import * as YQ from "react/jsx-runtime";
import { jsx as K, Fragment as ln, jsxs as $t } from "react/jsx-runtime";
import * as D from "react";
import kt, { useRef as Gr, useCallback as ci, useSyncExternalStore as XQ, useMemo as Or, useState as Wn, useLayoutEffect as Sb, useEffect as Qn, forwardRef as Mu, createElement as RT, useImperativeHandle as ZQ, createContext as Ko, useContext as Ta, useDebugValue as JQ, useId as QQ, Children as eee, isValidElement as tee, cloneElement as ree, useReducer as nee } from "react";
import * as _b from "react-dom";
import iee from "react-dom";
import { Head as aee } from "@inertiajs/react";
let th = class {
  _value;
  listeners = [];
  constructor(t) {
    this._value = t;
  }
  get value() {
    return this._value;
  }
  update(t) {
    this._value = t, this.listeners.forEach((r) => r(t)), window.postMessage("morph-refresh");
  }
  onUpdate(t) {
    this.listeners.push(t);
  }
};
const kze = (e) => Object.entries(e).reduce((t, [r, n]) => ({ ...t, [r]: new th(n) }), {}), SU = (e, t) => {
  const r = (n, a) => Object.fromEntries(
    Object.entries(n).map(([s, i]) => {
      const o = a ? `${a}.${s}` : s, l = t(o, i);
      return l.type === "continue" ? typeof i == "object" && i !== null ? [
        s,
        r(i, o)
      ] : [s, i] : l.type === "skip" ? [s, i] : [s, l.value];
    })
  );
  return r(e, "");
}, see = (e) => {
  const t = [];
  return SU(e ?? {}, (r, n) => n instanceof th ? (t.push(n), { type: "skip" }) : { type: "continue" }), t;
}, kb = (e) => SU(
  e,
  (t, r) => r instanceof th ? { type: "replace", value: r.value } : { type: "continue" }
);
class oee extends th {
  queryFn;
  loading = !0;
  beforeInitialRequest = !0;
  constructor(t) {
    super(void 0), this.queryFn = t;
  }
  get value() {
    return this.beforeInitialRequest && (this.beforeInitialRequest = !1, this.queryAndSet()), super.value;
  }
  async queryAndSet() {
    try {
      const t = await this.queryFn();
      this.loading = !1, this.update(t);
    } catch {
      this.loading = !1, this.update(void 0);
    }
  }
  refresh(t = !1) {
    this.loading = !0, t && this.update(void 0), this.queryAndSet();
  }
}
const Cze = (e, t, r) => {
  const n = async () => {
    const s = await fetch(`/cli/run/${e}/${t}`, {
      method: "POST",
      body: JSON.stringify({
        variables: kb(r ?? {})
      }),
      headers: {
        "content-type": "application/json"
      }
    });
    if (!s.ok)
      throw new Error(s.statusText);
    const i = await s.json();
    if (i.error)
      throw new Error(i.error.message);
    return i.data;
  }, a = new oee(n);
  return see(r ?? {}).forEach(
    (s) => s.onUpdate(() => {
      a.refresh();
    })
  ), a;
}, Aze = (e) => {
  const t = new th({}), r = (s) => JSON.stringify(s);
  return {
    run: async (s, i) => {
      const o = i ?? r(s);
      t.update({
        ...t.value,
        [o]: !0
      }), await fetch(`/cli/run/${e}`, {
        method: "POST",
        body: JSON.stringify({
          variables: s
        }),
        headers: {
          "content-type": "application/json"
        }
      }).finally(() => {
        t.update({
          ...t.value,
          [o]: !1
        });
      });
    },
    running: (s) => s ? t.value[s] : Object.values(t.value).some((i) => i)
  };
}, Tze = () => {
  window.location.reload();
};
let Qy = 0, T2 = [];
function lee() {
  return Qy += 1, () => {
    if (Qy -= 1, Qy === 0) {
      let e = T2;
      T2 = [];
      for (let t of e) t();
    }
  };
}
let IT = Symbol("clean"), Es = [], pl = 0;
const Kh = 4;
let ig = 0, Tl = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let s = pl + Kh; s < Es.length; )
          Es[s] === n ? Es.splice(s, Kh) : s += Kh;
        let a = t.indexOf(n);
        ~a && (t.splice(a, 1), --r.lc || r.off());
      };
    },
    notify(n, a) {
      ig++;
      let s = !Es.length;
      for (let i of t)
        Es.push(
          i,
          r.value,
          n,
          a
        );
      if (s) {
        for (pl = 0; pl < Es.length; pl += Kh)
          Es[pl](
            Es[pl + 1],
            Es[pl + 2],
            Es[pl + 3]
          );
        Es.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let a = r.value;
      a !== n && (r.value = n, r.notify(a));
    },
    subscribe(n) {
      let a = r.listen(n);
      return n(r.value), a;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[IT] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
const uee = 0, cee = 1, dee = 5, oc = 6, Yh = 10;
let vI = (e, t, r, n) => (e.events = e.events || {}, e.events[r + Yh] || (e.events[r + Yh] = n((a) => {
  e.events[r].reduceRight((s, i) => (i(s), s), {
    shared: {},
    ...a
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let a = e.events[r], s = a.indexOf(t);
  a.splice(s, 1), a.length || (delete e.events[r], e.events[r + Yh](), delete e.events[r + Yh]);
}), fee = (e, t) => vI(e, t, uee, (r) => {
  let n = e.listen;
  return e.listen = (a) => (!e.lc && !e.starting && (e.starting = !0, r(), delete e.starting), n(a)), () => {
    e.listen = n;
  };
}), R2 = (e, t) => vI(e, t, cee, (r) => {
  let n = e.off;
  return e.off = () => {
    r(), n();
  }, () => {
    e.off = n;
  };
}), pee = 1e3, hee = (e, t) => vI(e, (n) => {
  let a = t(n);
  a && e.events[oc].push(a);
}, dee, (n) => {
  let a = e.listen;
  e.listen = (...i) => (!e.lc && !e.active && (e.active = !0, n()), a(...i));
  let s = e.off;
  if (e.events[oc] = [], e.off = () => {
    s(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let i of e.events[oc]) i();
        e.events[oc] = [];
      }
    }, pee);
  }, process.env.NODE_ENV !== "production") {
    let i = e[IT];
    e[IT] = () => {
      for (let o of e.events[oc]) o();
      e.events[oc] = [], e.active = !1, i();
    };
  }
  return () => {
    e.listen = a, e.off = s;
  };
}), mee = (e, t, r) => {
  Array.isArray(e) || (e = [e]);
  let n, a, s = () => {
    if (a === ig) return;
    a = ig;
    let c = e.map((d) => d.get());
    if (!n || c.some((d, p) => d !== n[p])) {
      n = c;
      let d = t(...c);
      d && d.then && d.t ? d.then((p) => {
        n === c && i.set(p);
      }) : (i.set(d), a = ig);
    }
  }, i = Tl(void 0), o = i.get;
  i.get = () => (s(), o());
  let l, u = () => {
    clearTimeout(l), l = setTimeout(s);
  };
  return hee(i, () => {
    let c = e.map((d) => d.listen(u));
    return s(), () => {
      for (let d of c) d();
    };
  }), i;
}, gee = (e, t) => mee(e, t);
function bee(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((a, s, i) => {
    n.has(i) && r(a, s, i);
  });
}
let I2 = (e = {}) => {
  let t = Tl(e);
  return t.setKey = function(r, n) {
    let a = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(a, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(a, r));
  }, t;
}, yee = () => ({
  emit(e, ...t) {
    for (let r = this.events[e] || [], n = 0, a = r.length; n < a; n++)
      r[n](...t);
  },
  events: {},
  on(e, t) {
    return (this.events[e] ||= []).push(t), () => {
      this.events[e] = this.events[e]?.filter((r) => t !== r);
    };
  }
});
function vee({ retryCount: e }) {
  return ~~((Math.random() + 0.5) * (1 << (e < 8 ? e : 8))) * 2e3;
}
const wee = ([
  e,
  t,
  r
]) => {
  const n = ({
    cache: b = /* @__PURE__ */ new Map(),
    fetcher: v,
    ...x
  } = {}) => {
    const _ = yee();
    let E = !0;
    t(() => {
      E = e(), E && _.emit(o);
    }), r(() => _.emit(l));
    const w = /* @__PURE__ */ new Map(), C = /* @__PURE__ */ new Map(), k = /* @__PURE__ */ new Map();
    let S = {};
    const B = (le) => {
      const W = b.get(le);
      return W ? (W.expires || 0) > f() ? [W.data, W.error] : [] : [];
    }, U = async ([le, W], X, G) => {
      if (!E)
        return;
      const P = (V) => {
        X.key === le && (X.set(V), _.emit(d, le, V, !0));
      }, he = (V) => {
        P({
          ...V === void 0 ? {} : { data: V },
          ...m,
          promise: k.get(le)
        });
      };
      let {
        dedupeTime: ye = 4e3,
        cacheLifetime: pe = 1 / 0,
        fetcher: $,
        onErrorRetry: F = vee
      } = {
        ...G,
        ...S
      };
      pe < ye && (pe = ye);
      const ge = f();
      if (k.has(le)) {
        X.value.loading || he(B(le)[0]);
        return;
      }
      let ce, ie;
      const re = b.get(le);
      if ((re?.data !== void 0 || re?.error) && ([ce, ie] = B(le), (re.created || 0) + ye > ge)) {
        (X.value.data != ce || X.value.error != ie) && P({ ...y, data: ce, error: ie });
        return;
      }
      const Te = lee();
      try {
        clearTimeout(C.get(le));
        const V = $(...W);
        k.set(le, V), he(ce);
        const Pe = await V;
        b.set(le, {
          data: Pe,
          created: f(),
          expires: f() + pe
        }), P({ data: Pe, ...y });
      } catch (V) {
        G.onError?.(V);
        const Pe = (b.get(le)?.retryCount || 0) + 1;
        if (b.set(le, {
          error: V,
          created: f(),
          expires: f() + pe,
          retryCount: Pe
        }), F) {
          const z = F({
            error: V,
            key: le,
            retryCount: Pe
          });
          z && C.set(
            le,
            setTimeout(() => {
              I(le), b.set(le, { retryCount: Pe });
            }, z)
          );
        }
        P({ data: X.value.data, error: V, ...y });
      } finally {
        Te(), k.delete(le);
      }
    }, N = (le, {
      fetcher: W = v,
      ...X
    } = {}) => {
      if (process.env.NODE_ENV !== "production" && !W)
        throw new Error(
          "You need to set up either global fetcher of fetcher in createFetcherStore"
        );
      const G = I2({
        ...y
      }), P = { ...x, ...X, fetcher: W };
      G._ = h, G.invalidate = () => {
        const { key: re } = G;
        re && I(re);
      }, G.revalidate = () => {
        const { key: re } = G;
        re && q(re);
      }, G.mutate = (re) => {
        const { key: Te } = G;
        Te && ae(Te, re);
      }, G.fetch = async () => {
        let re;
        const Te = new Promise((Pe) => re = Pe), V = G.listen(({ error: Pe, data: z }) => {
          Pe !== void 0 && re({ error: Pe }), z !== void 0 && re({ data: z });
        });
        return Te.finally(V);
      };
      let he, ye, pe, $, F, ge = [];
      fee(G, () => {
        const re = !he;
        [F, he] = s(le), $ = F.subscribe((H) => {
          if (H) {
            const [be, me] = H;
            G.key = be, U([be, me], G, P), ye = be, pe = me;
          } else
            G.key = ye = pe = void 0, G.set({ ...y });
        });
        const Te = F.get();
        Te && ([ye, pe] = Te, re && ce());
        const {
          revalidateInterval: V = 0,
          revalidateOnFocus: Pe,
          revalidateOnReconnect: z
        } = P, A = () => {
          ye && U([ye, pe], G, P);
        };
        V > 0 && w.set(
          le,
          setInterval(A, V)
        ), Pe && ge.push(_.on(o, A)), z && ge.push(_.on(l, A));
        const R = (H) => {
          ye && p(ye, H) && U([ye, pe], G, P);
        };
        ge.push(
          _.on(u, R),
          _.on(c, R),
          _.on(d, (H, be, me) => {
            ye && p(ye, H) && G.value !== be && G.value.data !== be && G.set(
              me ? be : { data: be, ...y }
            );
          })
        );
      });
      const ce = () => {
        ye && pe && U([ye, pe], G, P);
      }, ie = G.listen;
      return G.listen = (re) => {
        const Te = ie(re);
        return re(G.value), ce(), Te;
      }, R2(G, () => {
        G.value = { ...y }, he?.(), ge.forEach((re) => re()), ge = [], $?.(), clearInterval(w.get(le));
      }), G;
    }, O = (le, W) => {
      for (const X of b.keys())
        p(X, le) && W(X);
    }, I = (le) => {
      O(le, (W) => {
        b.delete(W);
      }), _.emit(u, le);
    }, q = (le) => {
      O(le, (W) => {
        const X = b.get(W);
        X && b.set(W, { ...X, created: -1 / 0 });
      }), _.emit(c, le);
    }, ae = (le, W) => {
      O(le, (X) => {
        W === void 0 ? b.delete(X) : b.set(X, {
          data: W,
          created: f(),
          expires: f() + (x.cacheLifetime ?? 8e3)
        });
      }), _.emit(d, le, W);
    };
    function Q(le, W) {
      const { throttleCalls: X, onError: G } = W ?? {
        throttleCalls: !0,
        onError: x?.onError
      }, P = async (ye) => {
        if (X && he.value?.loading)
          return;
        const pe = S.fetcher ?? le, $ = [], F = [], ge = (ce, ie) => {
          he.lc && he.setKey(ce, ie);
        };
        try {
          he.set({
            error: void 0,
            data: void 0,
            mutate: P,
            ...m
          });
          const ce = await pe({
            data: ye,
            invalidate: (ie) => {
              $.push(ie);
            },
            revalidate: (ie) => {
              F.push(ie);
            },
            getCacheUpdater: (ie, re = !0) => [
              (Te) => {
                ae(ie, Te), re && F.push(ie);
              },
              b.get(ie)?.data
            ]
          });
          return ge("data", ce), ce;
        } catch (ce) {
          G?.(ce), ge("error", ce), he.setKey("error", ce);
        } finally {
          ge("loading", !1), $.forEach(I), F.forEach(q);
        }
      }, he = I2({
        mutate: P,
        ...y
      });
      return R2(
        he,
        () => he.set({ mutate: P, ...y })
      ), he.mutate = P, he;
    }
    return [
      N,
      Q,
      { __unsafeOverruleSettings: (le) => {
        process.env.NODE_ENV !== "test" && console.warn(
          "You should only use __unsafeOverruleSettings in test environment"
        ), S = le;
      }, invalidateKeys: I, revalidateKeys: q, mutateCache: ae }
    ];
  };
  function a(b) {
    return typeof b == "string" || typeof b == "number" || b === !0;
  }
  const s = (b) => {
    if (a(b))
      return [
        Tl(["" + b, [b]]),
        () => {
        }
      ];
    const v = [], x = Tl(null), _ = /* @__PURE__ */ new Map(), E = () => {
      v.some((k) => k == null || k === !1) ? x.set(null) : x.set([v.join(""), v]);
    };
    for (let k = 0; k < b.length; k++) {
      const S = b[k];
      a(S) ? v.push(S) : (v.push(null), _.set(S, k));
    }
    const w = [..._.keys()], C = gee(w, (...k) => {
      for (let S = 0; S < k.length; S++) {
        const B = w[S], U = _.get(B);
        v[U] = B._ === h ? B.value && "data" in B.value ? B.key : null : k[S];
      }
      E();
    });
    return E(), [x, C.subscribe(i)];
  };
  function i() {
  }
  const o = 1, l = 2, u = 3, c = 4, d = 5, p = (b, v) => Array.isArray(v) ? v.includes(b) : typeof v == "function" ? v(b) : b === v, f = () => (/* @__PURE__ */ new Date()).getTime(), h = Symbol(), m = { loading: !0 }, y = { loading: !1 };
  return n;
}, N2 = (e, t) => {
  typeof window > "u" || addEventListener(e, t);
}, xee = [
  () => !document.hidden,
  (e) => N2("visibilitychange", e),
  (e) => N2("online", e)
], Eee = wee(xee), [_U, Rze] = Eee();
let ev = (e, t) => (r) => {
  e.current !== r && (e.current = r, t());
};
function _c(e, { keys: t, deps: r = [e, t] } = {}) {
  let n = Gr();
  n.current = e.get();
  let a = ci((i) => (ev(n, i)(e.value), t?.length > 0 ? bee(e, t, ev(n, i)) : e.listen(ev(n, i))), r), s = () => n.current;
  return XQ(a, s, s);
}
var hn;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function r(a) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (a) => {
    const s = {};
    for (const i of a)
      s[i] = i;
    return s;
  }, e.getValidEnumValues = (a) => {
    const s = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), i = {};
    for (const o of s)
      i[o] = a[o];
    return e.objectValues(i);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(s) {
    return a[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const s = [];
    for (const i in a)
      Object.prototype.hasOwnProperty.call(a, i) && s.push(i);
    return s;
  }, e.find = (a, s) => {
    for (const i of a)
      if (s(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function n(a, s = " | ") {
    return a.map((i) => typeof i == "string" ? `'${i}'` : i).join(s);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (a, s) => typeof s == "bigint" ? s.toString() : s;
})(hn || (hn = {}));
var NT;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(NT || (NT = {}));
const hr = hn.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Io = (e) => {
  switch (typeof e) {
    case "undefined":
      return hr.undefined;
    case "string":
      return hr.string;
    case "number":
      return isNaN(e) ? hr.nan : hr.number;
    case "boolean":
      return hr.boolean;
    case "function":
      return hr.function;
    case "bigint":
      return hr.bigint;
    case "symbol":
      return hr.symbol;
    case "object":
      return Array.isArray(e) ? hr.array : e === null ? hr.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? hr.promise : typeof Map < "u" && e instanceof Map ? hr.map : typeof Set < "u" && e instanceof Set ? hr.set : typeof Date < "u" && e instanceof Date ? hr.date : hr.object;
    default:
      return hr.unknown;
  }
}, Bt = hn.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), See = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ua extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, n = { _errors: [] }, a = (s) => {
      for (const i of s.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(a);
        else if (i.code === "invalid_return_type")
          a(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          a(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(r(i));
        else {
          let o = n, l = 0;
          for (; l < i.path.length; ) {
            const u = i.path[l];
            l === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], l++;
          }
        }
    };
    return a(this), n;
  }
  static assert(t) {
    if (!(t instanceof Ua))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, hn.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const a of this.issues)
      a.path.length > 0 ? (r[a.path[0]] = r[a.path[0]] || [], r[a.path[0]].push(t(a))) : n.push(t(a));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ua.create = (e) => new Ua(e);
const Qc = (e, t) => {
  let r;
  switch (e.code) {
    case Bt.invalid_type:
      e.received === hr.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Bt.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, hn.jsonStringifyReplacer)}`;
      break;
    case Bt.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${hn.joinValues(e.keys, ", ")}`;
      break;
    case Bt.invalid_union:
      r = "Invalid input";
      break;
    case Bt.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${hn.joinValues(e.options)}`;
      break;
    case Bt.invalid_enum_value:
      r = `Invalid enum value. Expected ${hn.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Bt.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Bt.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Bt.invalid_date:
      r = "Invalid date";
      break;
    case Bt.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : hn.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case Bt.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case Bt.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case Bt.custom:
      r = "Invalid input";
      break;
    case Bt.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Bt.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Bt.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, hn.assertNever(e);
  }
  return { message: r };
};
let kU = Qc;
function _ee(e) {
  kU = e;
}
function xg() {
  return kU;
}
const Eg = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: a } = e, s = [...r, ...a.path || []], i = {
    ...a,
    path: s
  };
  if (a.message !== void 0)
    return {
      ...a,
      path: s,
      message: a.message
    };
  let o = "";
  const l = n.filter((u) => !!u).slice().reverse();
  for (const u of l)
    o = u(i, { data: t, defaultError: o }).message;
  return {
    ...a,
    path: s,
    message: o
  };
}, kee = [];
function ar(e, t) {
  const r = xg(), n = Eg({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      r,
      // then global override map
      r === Qc ? void 0 : Qc
      // then global default map
    ].filter((a) => !!a)
  });
  e.common.issues.push(n);
}
class Vi {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const a of r) {
      if (a.status === "aborted")
        return $r;
      a.status === "dirty" && t.dirty(), n.push(a.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const a of r) {
      const s = await a.key, i = await a.value;
      n.push({
        key: s,
        value: i
      });
    }
    return Vi.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const a of r) {
      const { key: s, value: i } = a;
      if (s.status === "aborted" || i.status === "aborted")
        return $r;
      s.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), s.value !== "__proto__" && (typeof i.value < "u" || a.alwaysSet) && (n[s.value] = i.value);
    }
    return { status: t.value, value: n };
  }
}
const $r = Object.freeze({
  status: "aborted"
}), Dc = (e) => ({ status: "dirty", value: e }), ua = (e) => ({ status: "valid", value: e }), DT = (e) => e.status === "aborted", OT = (e) => e.status === "dirty", Eu = (e) => e.status === "valid", sp = (e) => typeof Promise < "u" && e instanceof Promise;
function Sg(e, t, r, n) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function CU(e, t, r, n, a) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, r), r;
}
var Ar;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(Ar || (Ar = {}));
var Df, Of;
class oo {
  constructor(t, r, n, a) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const D2 = (e, t) => {
  if (Eu(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Ua(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function Xr(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: a } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (i, o) => {
    var l, u;
    const { message: c } = e;
    return i.code === "invalid_enum_value" ? { message: c ?? o.defaultError } : typeof o.data > "u" ? { message: (l = c ?? n) !== null && l !== void 0 ? l : o.defaultError } : i.code !== "invalid_type" ? { message: o.defaultError } : { message: (u = c ?? r) !== null && u !== void 0 ? u : o.defaultError };
  }, description: a };
}
class rn {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Io(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: Io(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Vi(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Io(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (sp(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const a = {
      common: {
        issues: [],
        async: (n = r?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Io(t)
    }, s = this._parseSync({ data: t, path: a.path, parent: a });
    return D2(a, s);
  }
  "~validate"(t) {
    var r, n;
    const a = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Io(t)
    };
    if (!this["~standard"].async)
      try {
        const s = this._parseSync({ data: t, path: [], parent: a });
        return Eu(s) ? {
          value: s.value
        } : {
          issues: a.common.issues
        };
      } catch (s) {
        !((n = (r = s?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0), a.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: a }).then((s) => Eu(s) ? {
      value: s.value
    } : {
      issues: a.common.issues
    });
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Io(t)
    }, a = this._parse({ data: t, path: n.path, parent: n }), s = await (sp(a) ? a : Promise.resolve(a));
    return D2(n, s);
  }
  refine(t, r) {
    const n = (a) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(a) : r;
    return this._refinement((a, s) => {
      const i = t(a), o = () => s.addIssue({
        code: Bt.custom,
        ...n(a)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((l) => l ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, a) => t(n) ? !0 : (a.addIssue(typeof r == "function" ? r(n, a) : r), !1));
  }
  _refinement(t) {
    return new $s({
      schema: this,
      typeName: qt.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return Ls.create(this, this._def);
  }
  nullable() {
    return $l.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ps.create(this);
  }
  promise() {
    return td.create(this, this._def);
  }
  or(t) {
    return cp.create([this, t], this._def);
  }
  and(t) {
    return dp.create(this, t, this._def);
  }
  transform(t) {
    return new $s({
      ...Xr(this._def),
      schema: this,
      typeName: qt.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new gp({
      ...Xr(this._def),
      innerType: this,
      defaultValue: r,
      typeName: qt.ZodDefault
    });
  }
  brand() {
    return new wI({
      typeName: qt.ZodBranded,
      type: this,
      ...Xr(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new bp({
      ...Xr(this._def),
      innerType: this,
      catchValue: r,
      typeName: qt.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return rh.create(this, t);
  }
  readonly() {
    return yp.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Cee = /^c[^\s-]{8,}$/i, Aee = /^[0-9a-z]+$/, Tee = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Ree = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Iee = /^[a-z0-9_-]{21}$/i, Nee = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Dee = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Oee = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Pee = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let tv;
const Lee = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Mee = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Fee = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, $ee = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Bee = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Uee = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, AU = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", zee = new RegExp(`^${AU}$`);
function TU(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function qee(e) {
  return new RegExp(`^${TU(e)}$`);
}
function RU(e) {
  let t = `${AU}T${TU(e)}`;
  const r = [];
  return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function jee(e, t) {
  return !!((t === "v4" || !t) && Lee.test(e) || (t === "v6" || !t) && Fee.test(e));
}
function Hee(e, t) {
  if (!Nee.test(e))
    return !1;
  try {
    const [r] = e.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), a = JSON.parse(atob(n));
    return !(typeof a != "object" || a === null || !a.typ || !a.alg || t && a.alg !== t);
  } catch {
    return !1;
  }
}
function Vee(e, t) {
  return !!((t === "v4" || !t) && Mee.test(e) || (t === "v6" || !t) && $ee.test(e));
}
class Ds extends rn {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== hr.string) {
      const s = this._getOrReturnCtx(t);
      return ar(s, {
        code: Bt.invalid_type,
        expected: hr.string,
        received: s.parsedType
      }), $r;
    }
    const n = new Vi();
    let a;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (a = this._getOrReturnCtx(t, a), ar(a, {
          code: Bt.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (a = this._getOrReturnCtx(t, a), ar(a, {
          code: Bt.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const i = t.data.length > s.value, o = t.data.length < s.value;
        (i || o) && (a = this._getOrReturnCtx(t, a), i ? ar(a, {
          code: Bt.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && ar(a, {
          code: Bt.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        Oee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "email",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        tv || (tv = new RegExp(Pee, "u")), tv.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "emoji",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        Ree.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "uuid",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "nanoid")
        Iee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "nanoid",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        Cee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "cuid",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        Aee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "cuid2",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        Tee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
          validation: "ulid",
          code: Bt.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          a = this._getOrReturnCtx(t, a), ar(a, {
            validation: "url",
            code: Bt.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "regex",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: { includes: s.value, position: s.position },
        message: s.message
      }), n.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: { startsWith: s.value },
        message: s.message
      }), n.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: { endsWith: s.value },
        message: s.message
      }), n.dirty()) : s.kind === "datetime" ? RU(s).test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: "datetime",
        message: s.message
      }), n.dirty()) : s.kind === "date" ? zee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: "date",
        message: s.message
      }), n.dirty()) : s.kind === "time" ? qee(s).test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.invalid_string,
        validation: "time",
        message: s.message
      }), n.dirty()) : s.kind === "duration" ? Dee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "duration",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : s.kind === "ip" ? jee(t.data, s.version) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "ip",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : s.kind === "jwt" ? Hee(t.data, s.alg) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "jwt",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : s.kind === "cidr" ? Vee(t.data, s.version) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "cidr",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : s.kind === "base64" ? Bee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "base64",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : s.kind === "base64url" ? Uee.test(t.data) || (a = this._getOrReturnCtx(t, a), ar(a, {
        validation: "base64url",
        code: Bt.invalid_string,
        message: s.message
      }), n.dirty()) : hn.assertNever(s);
    return { status: n.value, value: t.data };
  }
  _regex(t, r, n) {
    return this.refinement((a) => t.test(a), {
      validation: r,
      code: Bt.invalid_string,
      ...Ar.errToObj(n)
    });
  }
  _addCheck(t) {
    return new Ds({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ar.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ar.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ar.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ar.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...Ar.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ar.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ar.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ar.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...Ar.errToObj(t) });
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...Ar.errToObj(t)
    });
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...Ar.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ar.errToObj(t) });
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...Ar.errToObj(t) });
  }
  datetime(t) {
    var r, n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: (r = t?.offset) !== null && r !== void 0 ? r : !1,
      local: (n = t?.local) !== null && n !== void 0 ? n : !1,
      ...Ar.errToObj(t?.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      ...Ar.errToObj(t?.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...Ar.errToObj(t) });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ar.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r?.position,
      ...Ar.errToObj(r?.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ar.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ar.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ar.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ar.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ar.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, Ar.errToObj(t));
  }
  trim() {
    return new Ds({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Ds({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Ds({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Ds.create = (e) => {
  var t;
  return new Ds({
    checks: [],
    typeName: qt.ZodString,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...Xr(e)
  });
};
function Gee(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, a = r > n ? r : n, s = parseInt(e.toFixed(a).replace(".", "")), i = parseInt(t.toFixed(a).replace(".", ""));
  return s % i / Math.pow(10, a);
}
class Ll extends rn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== hr.number) {
      const s = this._getOrReturnCtx(t);
      return ar(s, {
        code: Bt.invalid_type,
        expected: hr.number,
        received: s.parsedType
      }), $r;
    }
    let n;
    const a = new Vi();
    for (const s of this._def.checks)
      s.kind === "int" ? hn.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), a.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), a.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), a.dirty()) : s.kind === "multipleOf" ? Gee(t.data, s.value) !== 0 && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), a.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.not_finite,
        message: s.message
      }), a.dirty()) : hn.assertNever(s);
    return { status: a.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ar.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ar.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ar.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ar.toString(r));
  }
  setLimit(t, r, n, a) {
    return new Ll({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ar.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ll({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ar.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ar.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ar.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ar.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ar.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ar.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ar.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ar.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ar.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && hn.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
Ll.create = (e) => new Ll({
  checks: [],
  typeName: qt.ZodNumber,
  coerce: e?.coerce || !1,
  ...Xr(e)
});
class Ml extends rn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== hr.bigint)
      return this._getInvalidInput(t);
    let n;
    const a = new Vi();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), a.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), a.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), ar(n, {
        code: Bt.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), a.dirty()) : hn.assertNever(s);
    return { status: a.value, value: t.data };
  }
  _getInvalidInput(t) {
    const r = this._getOrReturnCtx(t);
    return ar(r, {
      code: Bt.invalid_type,
      expected: hr.bigint,
      received: r.parsedType
    }), $r;
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ar.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ar.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ar.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ar.toString(r));
  }
  setLimit(t, r, n, a) {
    return new Ml({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ar.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ml({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ar.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ar.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ar.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ar.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ar.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Ml.create = (e) => {
  var t;
  return new Ml({
    checks: [],
    typeName: qt.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...Xr(e)
  });
};
class op extends rn {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== hr.boolean) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.boolean,
        received: n.parsedType
      }), $r;
    }
    return ua(t.data);
  }
}
op.create = (e) => new op({
  typeName: qt.ZodBoolean,
  coerce: e?.coerce || !1,
  ...Xr(e)
});
class Su extends rn {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== hr.date) {
      const s = this._getOrReturnCtx(t);
      return ar(s, {
        code: Bt.invalid_type,
        expected: hr.date,
        received: s.parsedType
      }), $r;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return ar(s, {
        code: Bt.invalid_date
      }), $r;
    }
    const n = new Vi();
    let a;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (a = this._getOrReturnCtx(t, a), ar(a, {
        code: Bt.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : hn.assertNever(s);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Su({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ar.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ar.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Su.create = (e) => new Su({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: qt.ZodDate,
  ...Xr(e)
});
class _g extends rn {
  _parse(t) {
    if (this._getType(t) !== hr.symbol) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.symbol,
        received: n.parsedType
      }), $r;
    }
    return ua(t.data);
  }
}
_g.create = (e) => new _g({
  typeName: qt.ZodSymbol,
  ...Xr(e)
});
class lp extends rn {
  _parse(t) {
    if (this._getType(t) !== hr.undefined) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.undefined,
        received: n.parsedType
      }), $r;
    }
    return ua(t.data);
  }
}
lp.create = (e) => new lp({
  typeName: qt.ZodUndefined,
  ...Xr(e)
});
class up extends rn {
  _parse(t) {
    if (this._getType(t) !== hr.null) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.null,
        received: n.parsedType
      }), $r;
    }
    return ua(t.data);
  }
}
up.create = (e) => new up({
  typeName: qt.ZodNull,
  ...Xr(e)
});
class ed extends rn {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return ua(t.data);
  }
}
ed.create = (e) => new ed({
  typeName: qt.ZodAny,
  ...Xr(e)
});
class vu extends rn {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return ua(t.data);
  }
}
vu.create = (e) => new vu({
  typeName: qt.ZodUnknown,
  ...Xr(e)
});
class Uo extends rn {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return ar(r, {
      code: Bt.invalid_type,
      expected: hr.never,
      received: r.parsedType
    }), $r;
  }
}
Uo.create = (e) => new Uo({
  typeName: qt.ZodNever,
  ...Xr(e)
});
class kg extends rn {
  _parse(t) {
    if (this._getType(t) !== hr.undefined) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.void,
        received: n.parsedType
      }), $r;
    }
    return ua(t.data);
  }
}
kg.create = (e) => new kg({
  typeName: qt.ZodVoid,
  ...Xr(e)
});
class Ps extends rn {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), a = this._def;
    if (r.parsedType !== hr.array)
      return ar(r, {
        code: Bt.invalid_type,
        expected: hr.array,
        received: r.parsedType
      }), $r;
    if (a.exactLength !== null) {
      const i = r.data.length > a.exactLength.value, o = r.data.length < a.exactLength.value;
      (i || o) && (ar(r, {
        code: i ? Bt.too_big : Bt.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: i ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), n.dirty());
    }
    if (a.minLength !== null && r.data.length < a.minLength.value && (ar(r, {
      code: Bt.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), n.dirty()), a.maxLength !== null && r.data.length > a.maxLength.value && (ar(r, {
      code: Bt.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((i, o) => a.type._parseAsync(new oo(r, i, r.path, o)))).then((i) => Vi.mergeArray(n, i));
    const s = [...r.data].map((i, o) => a.type._parseSync(new oo(r, i, r.path, o)));
    return Vi.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Ps({
      ...this._def,
      minLength: { value: t, message: Ar.toString(r) }
    });
  }
  max(t, r) {
    return new Ps({
      ...this._def,
      maxLength: { value: t, message: Ar.toString(r) }
    });
  }
  length(t, r) {
    return new Ps({
      ...this._def,
      exactLength: { value: t, message: Ar.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ps.create = (e, t) => new Ps({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: qt.ZodArray,
  ...Xr(t)
});
function kc(e) {
  if (e instanceof ai) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Ls.create(kc(n));
    }
    return new ai({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Ps ? new Ps({
    ...e._def,
    type: kc(e.element)
  }) : e instanceof Ls ? Ls.create(kc(e.unwrap())) : e instanceof $l ? $l.create(kc(e.unwrap())) : e instanceof lo ? lo.create(e.items.map((t) => kc(t))) : e;
}
class ai extends rn {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = hn.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== hr.object) {
      const u = this._getOrReturnCtx(t);
      return ar(u, {
        code: Bt.invalid_type,
        expected: hr.object,
        received: u.parsedType
      }), $r;
    }
    const { status: n, ctx: a } = this._processInputParams(t), { shape: s, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Uo && this._def.unknownKeys === "strip"))
      for (const u in a.data)
        i.includes(u) || o.push(u);
    const l = [];
    for (const u of i) {
      const c = s[u], d = a.data[u];
      l.push({
        key: { status: "valid", value: u },
        value: c._parse(new oo(a, d, a.path, u)),
        alwaysSet: u in a.data
      });
    }
    if (this._def.catchall instanceof Uo) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const c of o)
          l.push({
            key: { status: "valid", value: c },
            value: { status: "valid", value: a.data[c] }
          });
      else if (u === "strict")
        o.length > 0 && (ar(a, {
          code: Bt.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const c of o) {
        const d = a.data[c];
        l.push({
          key: { status: "valid", value: c },
          value: u._parse(
            new oo(a, d, a.path, c)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: c in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const c of l) {
        const d = await c.key, p = await c.value;
        u.push({
          key: d,
          value: p,
          alwaysSet: c.alwaysSet
        });
      }
      return u;
    }).then((u) => Vi.mergeObjectSync(n, u)) : Vi.mergeObjectSync(n, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Ar.errToObj, new ai({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var a, s, i, o;
          const l = (i = (s = (a = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(a, r, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = Ar.errToObj(t).message) !== null && o !== void 0 ? o : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new ai({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ai({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new ai({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new ai({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: qt.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new ai({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return hn.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new ai({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return hn.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new ai({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return kc(this);
  }
  partial(t) {
    const r = {};
    return hn.objectKeys(this.shape).forEach((n) => {
      const a = this.shape[n];
      t && !t[n] ? r[n] = a : r[n] = a.optional();
    }), new ai({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return hn.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof Ls; )
          s = s._def.innerType;
        r[n] = s;
      }
    }), new ai({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return IU(hn.objectKeys(this.shape));
  }
}
ai.create = (e, t) => new ai({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Uo.create(),
  typeName: qt.ZodObject,
  ...Xr(t)
});
ai.strictCreate = (e, t) => new ai({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Uo.create(),
  typeName: qt.ZodObject,
  ...Xr(t)
});
ai.lazycreate = (e, t) => new ai({
  shape: e,
  unknownKeys: "strip",
  catchall: Uo.create(),
  typeName: qt.ZodObject,
  ...Xr(t)
});
class cp extends rn {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function a(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const i = s.map((o) => new Ua(o.ctx.common.issues));
      return ar(r, {
        code: Bt.invalid_union,
        unionErrors: i
      }), $r;
    }
    if (r.common.async)
      return Promise.all(n.map(async (s) => {
        const i = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: i
          }),
          ctx: i
        };
      })).then(a);
    {
      let s;
      const i = [];
      for (const l of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, c = l._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !s && (s = { result: c, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = i.map((l) => new Ua(l));
      return ar(r, {
        code: Bt.invalid_union,
        unionErrors: o
      }), $r;
    }
  }
  get options() {
    return this._def.options;
  }
}
cp.create = (e, t) => new cp({
  options: e,
  typeName: qt.ZodUnion,
  ...Xr(t)
});
const To = (e) => e instanceof pp ? To(e.schema) : e instanceof $s ? To(e.innerType()) : e instanceof hp ? [e.value] : e instanceof Fl ? e.options : e instanceof mp ? hn.objectValues(e.enum) : e instanceof gp ? To(e._def.innerType) : e instanceof lp ? [void 0] : e instanceof up ? [null] : e instanceof Ls ? [void 0, ...To(e.unwrap())] : e instanceof $l ? [null, ...To(e.unwrap())] : e instanceof wI || e instanceof yp ? To(e.unwrap()) : e instanceof bp ? To(e._def.innerType) : [];
class Cb extends rn {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== hr.object)
      return ar(r, {
        code: Bt.invalid_type,
        expected: hr.object,
        received: r.parsedType
      }), $r;
    const n = this.discriminator, a = r.data[n], s = this.optionsMap.get(a);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (ar(r, {
      code: Bt.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), $r);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const a = /* @__PURE__ */ new Map();
    for (const s of r) {
      const i = To(s.shape[t]);
      if (!i.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of i) {
        if (a.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        a.set(o, s);
      }
    }
    return new Cb({
      typeName: qt.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: a,
      ...Xr(n)
    });
  }
}
function PT(e, t) {
  const r = Io(e), n = Io(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === hr.object && n === hr.object) {
    const a = hn.objectKeys(t), s = hn.objectKeys(e).filter((o) => a.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of s) {
      const l = PT(e[o], t[o]);
      if (!l.valid)
        return { valid: !1 };
      i[o] = l.data;
    }
    return { valid: !0, data: i };
  } else if (r === hr.array && n === hr.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let s = 0; s < e.length; s++) {
      const i = e[s], o = t[s], l = PT(i, o);
      if (!l.valid)
        return { valid: !1 };
      a.push(l.data);
    }
    return { valid: !0, data: a };
  } else return r === hr.date && n === hr.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class dp extends rn {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), a = (s, i) => {
      if (DT(s) || DT(i))
        return $r;
      const o = PT(s.value, i.value);
      return o.valid ? ((OT(s) || OT(i)) && r.dirty(), { status: r.value, value: o.data }) : (ar(n, {
        code: Bt.invalid_intersection_types
      }), $r);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, i]) => a(s, i)) : a(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
dp.create = (e, t, r) => new dp({
  left: e,
  right: t,
  typeName: qt.ZodIntersection,
  ...Xr(r)
});
class lo extends rn {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== hr.array)
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.array,
        received: n.parsedType
      }), $r;
    if (n.data.length < this._def.items.length)
      return ar(n, {
        code: Bt.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), $r;
    !this._def.rest && n.data.length > this._def.items.length && (ar(n, {
      code: Bt.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const s = [...n.data].map((i, o) => {
      const l = this._def.items[o] || this._def.rest;
      return l ? l._parse(new oo(n, i, n.path, o)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(s).then((i) => Vi.mergeArray(r, i)) : Vi.mergeArray(r, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new lo({
      ...this._def,
      rest: t
    });
  }
}
lo.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new lo({
    items: e,
    typeName: qt.ZodTuple,
    rest: null,
    ...Xr(t)
  });
};
class fp extends rn {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== hr.object)
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.object,
        received: n.parsedType
      }), $r;
    const a = [], s = this._def.keyType, i = this._def.valueType;
    for (const o in n.data)
      a.push({
        key: s._parse(new oo(n, o, n.path, o)),
        value: i._parse(new oo(n, n.data[o], n.path, o)),
        alwaysSet: o in n.data
      });
    return n.common.async ? Vi.mergeObjectAsync(r, a) : Vi.mergeObjectSync(r, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof rn ? new fp({
      keyType: t,
      valueType: r,
      typeName: qt.ZodRecord,
      ...Xr(n)
    }) : new fp({
      keyType: Ds.create(),
      valueType: t,
      typeName: qt.ZodRecord,
      ...Xr(r)
    });
  }
}
class Cg extends rn {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== hr.map)
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.map,
        received: n.parsedType
      }), $r;
    const a = this._def.keyType, s = this._def.valueType, i = [...n.data.entries()].map(([o, l], u) => ({
      key: a._parse(new oo(n, o, n.path, [u, "key"])),
      value: s._parse(new oo(n, l, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of i) {
          const u = await l.key, c = await l.value;
          if (u.status === "aborted" || c.status === "aborted")
            return $r;
          (u.status === "dirty" || c.status === "dirty") && r.dirty(), o.set(u.value, c.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of i) {
        const u = l.key, c = l.value;
        if (u.status === "aborted" || c.status === "aborted")
          return $r;
        (u.status === "dirty" || c.status === "dirty") && r.dirty(), o.set(u.value, c.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Cg.create = (e, t, r) => new Cg({
  valueType: t,
  keyType: e,
  typeName: qt.ZodMap,
  ...Xr(r)
});
class _u extends rn {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== hr.set)
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.set,
        received: n.parsedType
      }), $r;
    const a = this._def;
    a.minSize !== null && n.data.size < a.minSize.value && (ar(n, {
      code: Bt.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), r.dirty()), a.maxSize !== null && n.data.size > a.maxSize.value && (ar(n, {
      code: Bt.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function i(l) {
      const u = /* @__PURE__ */ new Set();
      for (const c of l) {
        if (c.status === "aborted")
          return $r;
        c.status === "dirty" && r.dirty(), u.add(c.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((l, u) => s._parse(new oo(n, l, n.path, u)));
    return n.common.async ? Promise.all(o).then((l) => i(l)) : i(o);
  }
  min(t, r) {
    return new _u({
      ...this._def,
      minSize: { value: t, message: Ar.toString(r) }
    });
  }
  max(t, r) {
    return new _u({
      ...this._def,
      maxSize: { value: t, message: Ar.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
_u.create = (e, t) => new _u({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: qt.ZodSet,
  ...Xr(t)
});
class zc extends rn {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== hr.function)
      return ar(r, {
        code: Bt.invalid_type,
        expected: hr.function,
        received: r.parsedType
      }), $r;
    function n(o, l) {
      return Eg({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          xg(),
          Qc
        ].filter((u) => !!u),
        issueData: {
          code: Bt.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function a(o, l) {
      return Eg({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          xg(),
          Qc
        ].filter((u) => !!u),
        issueData: {
          code: Bt.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, i = r.data;
    if (this._def.returns instanceof td) {
      const o = this;
      return ua(async function(...l) {
        const u = new Ua([]), c = await o._def.args.parseAsync(l, s).catch((f) => {
          throw u.addIssue(n(l, f)), u;
        }), d = await Reflect.apply(i, this, c);
        return await o._def.returns._def.type.parseAsync(d, s).catch((f) => {
          throw u.addIssue(a(d, f)), u;
        });
      });
    } else {
      const o = this;
      return ua(function(...l) {
        const u = o._def.args.safeParse(l, s);
        if (!u.success)
          throw new Ua([n(l, u.error)]);
        const c = Reflect.apply(i, this, u.data), d = o._def.returns.safeParse(c, s);
        if (!d.success)
          throw new Ua([a(c, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new zc({
      ...this._def,
      args: lo.create(t).rest(vu.create())
    });
  }
  returns(t) {
    return new zc({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new zc({
      args: t || lo.create([]).rest(vu.create()),
      returns: r || vu.create(),
      typeName: qt.ZodFunction,
      ...Xr(n)
    });
  }
}
class pp extends rn {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
pp.create = (e, t) => new pp({
  getter: e,
  typeName: qt.ZodLazy,
  ...Xr(t)
});
class hp extends rn {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return ar(r, {
        received: r.data,
        code: Bt.invalid_literal,
        expected: this._def.value
      }), $r;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
hp.create = (e, t) => new hp({
  value: e,
  typeName: qt.ZodLiteral,
  ...Xr(t)
});
function IU(e, t) {
  return new Fl({
    values: e,
    typeName: qt.ZodEnum,
    ...Xr(t)
  });
}
class Fl extends rn {
  constructor() {
    super(...arguments), Df.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ar(r, {
        expected: hn.joinValues(n),
        received: r.parsedType,
        code: Bt.invalid_type
      }), $r;
    }
    if (Sg(this, Df) || CU(this, Df, new Set(this._def.values)), !Sg(this, Df).has(t.data)) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ar(r, {
        received: r.data,
        code: Bt.invalid_enum_value,
        options: n
      }), $r;
    }
    return ua(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t, r = this._def) {
    return Fl.create(t, {
      ...this._def,
      ...r
    });
  }
  exclude(t, r = this._def) {
    return Fl.create(this.options.filter((n) => !t.includes(n)), {
      ...this._def,
      ...r
    });
  }
}
Df = /* @__PURE__ */ new WeakMap();
Fl.create = IU;
class mp extends rn {
  constructor() {
    super(...arguments), Of.set(this, void 0);
  }
  _parse(t) {
    const r = hn.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== hr.string && n.parsedType !== hr.number) {
      const a = hn.objectValues(r);
      return ar(n, {
        expected: hn.joinValues(a),
        received: n.parsedType,
        code: Bt.invalid_type
      }), $r;
    }
    if (Sg(this, Of) || CU(this, Of, new Set(hn.getValidEnumValues(this._def.values))), !Sg(this, Of).has(t.data)) {
      const a = hn.objectValues(r);
      return ar(n, {
        received: n.data,
        code: Bt.invalid_enum_value,
        options: a
      }), $r;
    }
    return ua(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Of = /* @__PURE__ */ new WeakMap();
mp.create = (e, t) => new mp({
  values: e,
  typeName: qt.ZodNativeEnum,
  ...Xr(t)
});
class td extends rn {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== hr.promise && r.common.async === !1)
      return ar(r, {
        code: Bt.invalid_type,
        expected: hr.promise,
        received: r.parsedType
      }), $r;
    const n = r.parsedType === hr.promise ? r.data : Promise.resolve(r.data);
    return ua(n.then((a) => this._def.type.parseAsync(a, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
td.create = (e, t) => new td({
  type: e,
  typeName: qt.ZodPromise,
  ...Xr(t)
});
class $s extends rn {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === qt.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), a = this._def.effect || null, s = {
      addIssue: (i) => {
        ar(n, i), i.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), a.type === "preprocess") {
      const i = a.transform(n.data, s);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (r.value === "aborted")
            return $r;
          const l = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return l.status === "aborted" ? $r : l.status === "dirty" || r.value === "dirty" ? Dc(l.value) : l;
        });
      {
        if (r.value === "aborted")
          return $r;
        const o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? $r : o.status === "dirty" || r.value === "dirty" ? Dc(o.value) : o;
      }
    }
    if (a.type === "refinement") {
      const i = (o) => {
        const l = a.refinement(o, s);
        if (n.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? $r : (o.status === "dirty" && r.dirty(), i(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? $r : (o.status === "dirty" && r.dirty(), i(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Eu(i))
          return i;
        const o = a.transform(i.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => Eu(i) ? Promise.resolve(a.transform(i.value, s)).then((o) => ({ status: r.value, value: o })) : i);
    hn.assertNever(a);
  }
}
$s.create = (e, t, r) => new $s({
  schema: e,
  typeName: qt.ZodEffects,
  effect: t,
  ...Xr(r)
});
$s.createWithPreprocess = (e, t, r) => new $s({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: qt.ZodEffects,
  ...Xr(r)
});
class Ls extends rn {
  _parse(t) {
    return this._getType(t) === hr.undefined ? ua(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ls.create = (e, t) => new Ls({
  innerType: e,
  typeName: qt.ZodOptional,
  ...Xr(t)
});
class $l extends rn {
  _parse(t) {
    return this._getType(t) === hr.null ? ua(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
$l.create = (e, t) => new $l({
  innerType: e,
  typeName: qt.ZodNullable,
  ...Xr(t)
});
class gp extends rn {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === hr.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
gp.create = (e, t) => new gp({
  innerType: e,
  typeName: qt.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Xr(t)
});
class bp extends rn {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return sp(a) ? a.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ua(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Ua(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
bp.create = (e, t) => new bp({
  innerType: e,
  typeName: qt.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Xr(t)
});
class Ag extends rn {
  _parse(t) {
    if (this._getType(t) !== hr.nan) {
      const n = this._getOrReturnCtx(t);
      return ar(n, {
        code: Bt.invalid_type,
        expected: hr.nan,
        received: n.parsedType
      }), $r;
    }
    return { status: "valid", value: t.data };
  }
}
Ag.create = (e) => new Ag({
  typeName: qt.ZodNaN,
  ...Xr(e)
});
const Wee = Symbol("zod_brand");
class wI extends rn {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class rh extends rn {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? $r : s.status === "dirty" ? (r.dirty(), Dc(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return a.status === "aborted" ? $r : a.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new rh({
      in: t,
      out: r,
      typeName: qt.ZodPipeline
    });
  }
}
class yp extends rn {
  _parse(t) {
    const r = this._def.innerType._parse(t), n = (a) => (Eu(a) && (a.value = Object.freeze(a.value)), a);
    return sp(r) ? r.then((a) => n(a)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
yp.create = (e, t) => new yp({
  innerType: e,
  typeName: qt.ZodReadonly,
  ...Xr(t)
});
function NU(e, t = {}, r) {
  return e ? ed.create().superRefine((n, a) => {
    var s, i;
    if (!e(n)) {
      const o = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, l = (i = (s = o.fatal) !== null && s !== void 0 ? s : r) !== null && i !== void 0 ? i : !0, u = typeof o == "string" ? { message: o } : o;
      a.addIssue({ code: "custom", ...u, fatal: l });
    }
  }) : ed.create();
}
const Kee = {
  object: ai.lazycreate
};
var qt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(qt || (qt = {}));
const Yee = (e, t = {
  message: `Input not instance of ${e.name}`
}) => NU((r) => r instanceof e, t), DU = Ds.create, OU = Ll.create, Xee = Ag.create, Zee = Ml.create, PU = op.create, Jee = Su.create, Qee = _g.create, ete = lp.create, tte = up.create, rte = ed.create, nte = vu.create, ite = Uo.create, ate = kg.create, ste = Ps.create, ote = ai.create, lte = ai.strictCreate, ute = cp.create, cte = Cb.create, dte = dp.create, fte = lo.create, pte = fp.create, hte = Cg.create, mte = _u.create, gte = zc.create, bte = pp.create, yte = hp.create, vte = Fl.create, wte = mp.create, xte = td.create, O2 = $s.create, Ete = Ls.create, Ste = $l.create, _te = $s.createWithPreprocess, kte = rh.create, Cte = () => DU().optional(), Ate = () => OU().optional(), Tte = () => PU().optional(), Rte = {
  string: (e) => Ds.create({ ...e, coerce: !0 }),
  number: (e) => Ll.create({ ...e, coerce: !0 }),
  boolean: (e) => op.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Ml.create({ ...e, coerce: !0 }),
  date: (e) => Su.create({ ...e, coerce: !0 })
}, Ite = $r;
var _a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Qc,
  setErrorMap: _ee,
  getErrorMap: xg,
  makeIssue: Eg,
  EMPTY_PATH: kee,
  addIssueToContext: ar,
  ParseStatus: Vi,
  INVALID: $r,
  DIRTY: Dc,
  OK: ua,
  isAborted: DT,
  isDirty: OT,
  isValid: Eu,
  isAsync: sp,
  get util() {
    return hn;
  },
  get objectUtil() {
    return NT;
  },
  ZodParsedType: hr,
  getParsedType: Io,
  ZodType: rn,
  datetimeRegex: RU,
  ZodString: Ds,
  ZodNumber: Ll,
  ZodBigInt: Ml,
  ZodBoolean: op,
  ZodDate: Su,
  ZodSymbol: _g,
  ZodUndefined: lp,
  ZodNull: up,
  ZodAny: ed,
  ZodUnknown: vu,
  ZodNever: Uo,
  ZodVoid: kg,
  ZodArray: Ps,
  ZodObject: ai,
  ZodUnion: cp,
  ZodDiscriminatedUnion: Cb,
  ZodIntersection: dp,
  ZodTuple: lo,
  ZodRecord: fp,
  ZodMap: Cg,
  ZodSet: _u,
  ZodFunction: zc,
  ZodLazy: pp,
  ZodLiteral: hp,
  ZodEnum: Fl,
  ZodNativeEnum: mp,
  ZodPromise: td,
  ZodEffects: $s,
  ZodTransformer: $s,
  ZodOptional: Ls,
  ZodNullable: $l,
  ZodDefault: gp,
  ZodCatch: bp,
  ZodNaN: Ag,
  BRAND: Wee,
  ZodBranded: wI,
  ZodPipeline: rh,
  ZodReadonly: yp,
  custom: NU,
  Schema: rn,
  ZodSchema: rn,
  late: Kee,
  get ZodFirstPartyTypeKind() {
    return qt;
  },
  coerce: Rte,
  any: rte,
  array: ste,
  bigint: Zee,
  boolean: PU,
  date: Jee,
  discriminatedUnion: cte,
  effect: O2,
  enum: vte,
  function: gte,
  instanceof: Yee,
  intersection: dte,
  lazy: bte,
  literal: yte,
  map: hte,
  nan: Xee,
  nativeEnum: wte,
  never: ite,
  null: tte,
  nullable: Ste,
  number: OU,
  object: ote,
  oboolean: Tte,
  onumber: Ate,
  optional: Ete,
  ostring: Cte,
  pipeline: kte,
  preprocess: _te,
  promise: xte,
  record: pte,
  set: mte,
  strictObject: lte,
  string: DU,
  symbol: Qee,
  transformer: O2,
  tuple: fte,
  undefined: ete,
  union: ute,
  unknown: nte,
  void: ate,
  NEVER: Ite,
  ZodIssueCode: Bt,
  quotelessJson: See,
  ZodError: Ua
});
const Nte = _a.object({
  type: _a.literal("json"),
  data: _a.object({
    items: _a.array(_a.any()),
    count: _a.number().optional()
  })
}), Ab = (e) => {
  const { loadData: t, variables: r, loadDataUrl: n } = e, a = Gr(Tl(0)), s = _c(a.current), i = Gr(Tl([])), o = _c(i.current), l = Gr(Tl(!1)), u = _c(l.current), c = Gr(Tl()), d = _c(c.current), p = kb(r), f = Or(() => _U(
    [t, "json", JSON.stringify(p), s],
    {
      fetcher: async () => {
        const x = new URLSearchParams();
        x.append("skip", (s * 100).toString()), x.append("limit", "100");
        const E = await (await fetch(
          `${n(t)}?${x.toString()}`,
          {
            method: "POST",
            body: JSON.stringify({
              variables: p
            }),
            headers: {
              "content-type": "application/json"
            }
          }
        )).json(), w = Nte.safeParse(E);
        if (!w.success)
          throw new Error("Invalid response");
        return w.data.data.items && (s === 0 ? i.current.set(w.data.data.items) : i.current.set([...o, ...w.data.data.items])), w.data.data.count && c.current.set(w.data.data.count), l.current.set(!1), w.data;
      },
      cacheLifetime: 1e3 * 60 * 5
    }
  ), [t, JSON.stringify(p), s, o]), h = Or(() => d ? o.length < d : !1, [d, o]), m = ci(() => {
    l.current.set(!0), a.current.set(s + 1);
  }, [s]), { data: y, error: b } = _c(f), v = Or(() => o.length > 0 ? o : y ? y.data.items : [], [y, o]);
  return {
    data: y,
    items: v,
    count: d,
    isLoading: u,
    error: b,
    goNextPage: m,
    hasNext: h
  };
};
function LU(e = "This should not happen") {
  throw new Error(e);
}
function Fa(e, t = "Assertion failed") {
  if (!e)
    return LU(t);
}
function vp(e, t) {
  return LU(t ?? "Hell froze over");
}
function Dte(e, t) {
  try {
    return e();
  } catch {
    return t;
  }
}
const P2 = Object.prototype.hasOwnProperty;
function rd(e, t) {
  let r, n;
  if (e === t)
    return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date)
      return e.getTime() === t.getTime();
    if (r === RegExp)
      return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
        for (; n-- && rd(e[n], t[n]); )
          ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
        if (P2.call(e, r) && ++n && !P2.call(t, r) || !(r in t) || !rd(e[r], t[r]))
          return !1;
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
var is = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function da(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var rv, L2;
function Ote() {
  if (L2) return rv;
  L2 = 1;
  var e = Object.prototype, t = e.hasOwnProperty;
  function r(n, a) {
    return n != null && t.call(n, a);
  }
  return rv = r, rv;
}
var nv, M2;
function fo() {
  if (M2) return nv;
  M2 = 1;
  var e = Array.isArray;
  return nv = e, nv;
}
var iv, F2;
function MU() {
  if (F2) return iv;
  F2 = 1;
  var e = typeof is == "object" && is && is.Object === Object && is;
  return iv = e, iv;
}
var av, $2;
function po() {
  if ($2) return av;
  $2 = 1;
  var e = MU(), t = typeof self == "object" && self && self.Object === Object && self, r = e || t || Function("return this")();
  return av = r, av;
}
var sv, B2;
function nh() {
  if (B2) return sv;
  B2 = 1;
  var e = po(), t = e.Symbol;
  return sv = t, sv;
}
var ov, U2;
function Pte() {
  if (U2) return ov;
  U2 = 1;
  var e = nh(), t = Object.prototype, r = t.hasOwnProperty, n = t.toString, a = e ? e.toStringTag : void 0;
  function s(i) {
    var o = r.call(i, a), l = i[a];
    try {
      i[a] = void 0;
      var u = !0;
    } catch {
    }
    var c = n.call(i);
    return u && (o ? i[a] = l : delete i[a]), c;
  }
  return ov = s, ov;
}
var lv, z2;
function Lte() {
  if (z2) return lv;
  z2 = 1;
  var e = Object.prototype, t = e.toString;
  function r(n) {
    return t.call(n);
  }
  return lv = r, lv;
}
var uv, q2;
function ih() {
  if (q2) return uv;
  q2 = 1;
  var e = nh(), t = Pte(), r = Lte(), n = "[object Null]", a = "[object Undefined]", s = e ? e.toStringTag : void 0;
  function i(o) {
    return o == null ? o === void 0 ? a : n : s && s in Object(o) ? t(o) : r(o);
  }
  return uv = i, uv;
}
var cv, j2;
function ah() {
  if (j2) return cv;
  j2 = 1;
  function e(t) {
    return t != null && typeof t == "object";
  }
  return cv = e, cv;
}
var dv, H2;
function Tb() {
  if (H2) return dv;
  H2 = 1;
  var e = ih(), t = ah(), r = "[object Symbol]";
  function n(a) {
    return typeof a == "symbol" || t(a) && e(a) == r;
  }
  return dv = n, dv;
}
var fv, V2;
function xI() {
  if (V2) return fv;
  V2 = 1;
  var e = fo(), t = Tb(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function a(s, i) {
    if (e(s))
      return !1;
    var o = typeof s;
    return o == "number" || o == "symbol" || o == "boolean" || s == null || t(s) ? !0 : n.test(s) || !r.test(s) || i != null && s in Object(i);
  }
  return fv = a, fv;
}
var pv, G2;
function Fu() {
  if (G2) return pv;
  G2 = 1;
  function e(t) {
    var r = typeof t;
    return t != null && (r == "object" || r == "function");
  }
  return pv = e, pv;
}
var hv, W2;
function FU() {
  if (W2) return hv;
  W2 = 1;
  var e = ih(), t = Fu(), r = "[object AsyncFunction]", n = "[object Function]", a = "[object GeneratorFunction]", s = "[object Proxy]";
  function i(o) {
    if (!t(o))
      return !1;
    var l = e(o);
    return l == n || l == a || l == r || l == s;
  }
  return hv = i, hv;
}
var mv, K2;
function Mte() {
  if (K2) return mv;
  K2 = 1;
  var e = po(), t = e["__core-js_shared__"];
  return mv = t, mv;
}
var gv, Y2;
function Fte() {
  if (Y2) return gv;
  Y2 = 1;
  var e = Mte(), t = function() {
    var n = /[^.]+$/.exec(e && e.keys && e.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }();
  function r(n) {
    return !!t && t in n;
  }
  return gv = r, gv;
}
var bv, X2;
function $U() {
  if (X2) return bv;
  X2 = 1;
  var e = Function.prototype, t = e.toString;
  function r(n) {
    if (n != null) {
      try {
        return t.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return bv = r, bv;
}
var yv, Z2;
function $te() {
  if (Z2) return yv;
  Z2 = 1;
  var e = FU(), t = Fte(), r = Fu(), n = $U(), a = /[\\^$.*+?()[\]{}|]/g, s = /^\[object .+?Constructor\]$/, i = Function.prototype, o = Object.prototype, l = i.toString, u = o.hasOwnProperty, c = RegExp(
    "^" + l.call(u).replace(a, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function d(p) {
    if (!r(p) || t(p))
      return !1;
    var f = e(p) ? c : s;
    return f.test(n(p));
  }
  return yv = d, yv;
}
var vv, J2;
function Bte() {
  if (J2) return vv;
  J2 = 1;
  function e(t, r) {
    return t?.[r];
  }
  return vv = e, vv;
}
var wv, Q2;
function $u() {
  if (Q2) return wv;
  Q2 = 1;
  var e = $te(), t = Bte();
  function r(n, a) {
    var s = t(n, a);
    return e(s) ? s : void 0;
  }
  return wv = r, wv;
}
var xv, eO;
function Rb() {
  if (eO) return xv;
  eO = 1;
  var e = $u(), t = e(Object, "create");
  return xv = t, xv;
}
var Ev, tO;
function Ute() {
  if (tO) return Ev;
  tO = 1;
  var e = Rb();
  function t() {
    this.__data__ = e ? e(null) : {}, this.size = 0;
  }
  return Ev = t, Ev;
}
var Sv, rO;
function zte() {
  if (rO) return Sv;
  rO = 1;
  function e(t) {
    var r = this.has(t) && delete this.__data__[t];
    return this.size -= r ? 1 : 0, r;
  }
  return Sv = e, Sv;
}
var _v, nO;
function qte() {
  if (nO) return _v;
  nO = 1;
  var e = Rb(), t = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function a(s) {
    var i = this.__data__;
    if (e) {
      var o = i[s];
      return o === t ? void 0 : o;
    }
    return n.call(i, s) ? i[s] : void 0;
  }
  return _v = a, _v;
}
var kv, iO;
function jte() {
  if (iO) return kv;
  iO = 1;
  var e = Rb(), t = Object.prototype, r = t.hasOwnProperty;
  function n(a) {
    var s = this.__data__;
    return e ? s[a] !== void 0 : r.call(s, a);
  }
  return kv = n, kv;
}
var Cv, aO;
function Hte() {
  if (aO) return Cv;
  aO = 1;
  var e = Rb(), t = "__lodash_hash_undefined__";
  function r(n, a) {
    var s = this.__data__;
    return this.size += this.has(n) ? 0 : 1, s[n] = e && a === void 0 ? t : a, this;
  }
  return Cv = r, Cv;
}
var Av, sO;
function Vte() {
  if (sO) return Av;
  sO = 1;
  var e = Ute(), t = zte(), r = qte(), n = jte(), a = Hte();
  function s(i) {
    var o = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++o < l; ) {
      var u = i[o];
      this.set(u[0], u[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = a, Av = s, Av;
}
var Tv, oO;
function Gte() {
  if (oO) return Tv;
  oO = 1;
  function e() {
    this.__data__ = [], this.size = 0;
  }
  return Tv = e, Tv;
}
var Rv, lO;
function EI() {
  if (lO) return Rv;
  lO = 1;
  function e(t, r) {
    return t === r || t !== t && r !== r;
  }
  return Rv = e, Rv;
}
var Iv, uO;
function Ib() {
  if (uO) return Iv;
  uO = 1;
  var e = EI();
  function t(r, n) {
    for (var a = r.length; a--; )
      if (e(r[a][0], n))
        return a;
    return -1;
  }
  return Iv = t, Iv;
}
var Nv, cO;
function Wte() {
  if (cO) return Nv;
  cO = 1;
  var e = Ib(), t = Array.prototype, r = t.splice;
  function n(a) {
    var s = this.__data__, i = e(s, a);
    if (i < 0)
      return !1;
    var o = s.length - 1;
    return i == o ? s.pop() : r.call(s, i, 1), --this.size, !0;
  }
  return Nv = n, Nv;
}
var Dv, dO;
function Kte() {
  if (dO) return Dv;
  dO = 1;
  var e = Ib();
  function t(r) {
    var n = this.__data__, a = e(n, r);
    return a < 0 ? void 0 : n[a][1];
  }
  return Dv = t, Dv;
}
var Ov, fO;
function Yte() {
  if (fO) return Ov;
  fO = 1;
  var e = Ib();
  function t(r) {
    return e(this.__data__, r) > -1;
  }
  return Ov = t, Ov;
}
var Pv, pO;
function Xte() {
  if (pO) return Pv;
  pO = 1;
  var e = Ib();
  function t(r, n) {
    var a = this.__data__, s = e(a, r);
    return s < 0 ? (++this.size, a.push([r, n])) : a[s][1] = n, this;
  }
  return Pv = t, Pv;
}
var Lv, hO;
function Nb() {
  if (hO) return Lv;
  hO = 1;
  var e = Gte(), t = Wte(), r = Kte(), n = Yte(), a = Xte();
  function s(i) {
    var o = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++o < l; ) {
      var u = i[o];
      this.set(u[0], u[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = a, Lv = s, Lv;
}
var Mv, mO;
function SI() {
  if (mO) return Mv;
  mO = 1;
  var e = $u(), t = po(), r = e(t, "Map");
  return Mv = r, Mv;
}
var Fv, gO;
function Zte() {
  if (gO) return Fv;
  gO = 1;
  var e = Vte(), t = Nb(), r = SI();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new e(),
      map: new (r || t)(),
      string: new e()
    };
  }
  return Fv = n, Fv;
}
var $v, bO;
function Jte() {
  if (bO) return $v;
  bO = 1;
  function e(t) {
    var r = typeof t;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? t !== "__proto__" : t === null;
  }
  return $v = e, $v;
}
var Bv, yO;
function Db() {
  if (yO) return Bv;
  yO = 1;
  var e = Jte();
  function t(r, n) {
    var a = r.__data__;
    return e(n) ? a[typeof n == "string" ? "string" : "hash"] : a.map;
  }
  return Bv = t, Bv;
}
var Uv, vO;
function Qte() {
  if (vO) return Uv;
  vO = 1;
  var e = Db();
  function t(r) {
    var n = e(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return Uv = t, Uv;
}
var zv, wO;
function ere() {
  if (wO) return zv;
  wO = 1;
  var e = Db();
  function t(r) {
    return e(this, r).get(r);
  }
  return zv = t, zv;
}
var qv, xO;
function tre() {
  if (xO) return qv;
  xO = 1;
  var e = Db();
  function t(r) {
    return e(this, r).has(r);
  }
  return qv = t, qv;
}
var jv, EO;
function rre() {
  if (EO) return jv;
  EO = 1;
  var e = Db();
  function t(r, n) {
    var a = e(this, r), s = a.size;
    return a.set(r, n), this.size += a.size == s ? 0 : 1, this;
  }
  return jv = t, jv;
}
var Hv, SO;
function _I() {
  if (SO) return Hv;
  SO = 1;
  var e = Zte(), t = Qte(), r = ere(), n = tre(), a = rre();
  function s(i) {
    var o = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++o < l; ) {
      var u = i[o];
      this.set(u[0], u[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = a, Hv = s, Hv;
}
var Vv, _O;
function nre() {
  if (_O) return Vv;
  _O = 1;
  var e = _I(), t = "Expected a function";
  function r(n, a) {
    if (typeof n != "function" || a != null && typeof a != "function")
      throw new TypeError(t);
    var s = function() {
      var i = arguments, o = a ? a.apply(this, i) : i[0], l = s.cache;
      if (l.has(o))
        return l.get(o);
      var u = n.apply(this, i);
      return s.cache = l.set(o, u) || l, u;
    };
    return s.cache = new (r.Cache || e)(), s;
  }
  return r.Cache = e, Vv = r, Vv;
}
var Gv, kO;
function ire() {
  if (kO) return Gv;
  kO = 1;
  var e = nre(), t = 500;
  function r(n) {
    var a = e(n, function(i) {
      return s.size === t && s.clear(), i;
    }), s = a.cache;
    return a;
  }
  return Gv = r, Gv;
}
var Wv, CO;
function are() {
  if (CO) return Wv;
  CO = 1;
  var e = ire(), t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = e(function(a) {
    var s = [];
    return a.charCodeAt(0) === 46 && s.push(""), a.replace(t, function(i, o, l, u) {
      s.push(l ? u.replace(r, "$1") : o || i);
    }), s;
  });
  return Wv = n, Wv;
}
var Kv, AO;
function sre() {
  if (AO) return Kv;
  AO = 1;
  function e(t, r) {
    for (var n = -1, a = t == null ? 0 : t.length, s = Array(a); ++n < a; )
      s[n] = r(t[n], n, t);
    return s;
  }
  return Kv = e, Kv;
}
var Yv, TO;
function ore() {
  if (TO) return Yv;
  TO = 1;
  var e = nh(), t = sre(), r = fo(), n = Tb(), a = e ? e.prototype : void 0, s = a ? a.toString : void 0;
  function i(o) {
    if (typeof o == "string")
      return o;
    if (r(o))
      return t(o, i) + "";
    if (n(o))
      return s ? s.call(o) : "";
    var l = o + "";
    return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
  }
  return Yv = i, Yv;
}
var Xv, RO;
function lre() {
  if (RO) return Xv;
  RO = 1;
  var e = ore();
  function t(r) {
    return r == null ? "" : e(r);
  }
  return Xv = t, Xv;
}
var Zv, IO;
function BU() {
  if (IO) return Zv;
  IO = 1;
  var e = fo(), t = xI(), r = are(), n = lre();
  function a(s, i) {
    return e(s) ? s : t(s, i) ? [s] : r(n(s));
  }
  return Zv = a, Zv;
}
var Jv, NO;
function ure() {
  if (NO) return Jv;
  NO = 1;
  var e = ih(), t = ah(), r = "[object Arguments]";
  function n(a) {
    return t(a) && e(a) == r;
  }
  return Jv = n, Jv;
}
var Qv, DO;
function kI() {
  if (DO) return Qv;
  DO = 1;
  var e = ure(), t = ah(), r = Object.prototype, n = r.hasOwnProperty, a = r.propertyIsEnumerable, s = e(/* @__PURE__ */ function() {
    return arguments;
  }()) ? e : function(i) {
    return t(i) && n.call(i, "callee") && !a.call(i, "callee");
  };
  return Qv = s, Qv;
}
var e0, OO;
function CI() {
  if (OO) return e0;
  OO = 1;
  var e = 9007199254740991, t = /^(?:0|[1-9]\d*)$/;
  function r(n, a) {
    var s = typeof n;
    return a = a ?? e, !!a && (s == "number" || s != "symbol" && t.test(n)) && n > -1 && n % 1 == 0 && n < a;
  }
  return e0 = r, e0;
}
var t0, PO;
function AI() {
  if (PO) return t0;
  PO = 1;
  var e = 9007199254740991;
  function t(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= e;
  }
  return t0 = t, t0;
}
var r0, LO;
function Ob() {
  if (LO) return r0;
  LO = 1;
  var e = Tb();
  function t(r) {
    if (typeof r == "string" || e(r))
      return r;
    var n = r + "";
    return n == "0" && 1 / r == -1 / 0 ? "-0" : n;
  }
  return r0 = t, r0;
}
var n0, MO;
function UU() {
  if (MO) return n0;
  MO = 1;
  var e = BU(), t = kI(), r = fo(), n = CI(), a = AI(), s = Ob();
  function i(o, l, u) {
    l = e(l, o);
    for (var c = -1, d = l.length, p = !1; ++c < d; ) {
      var f = s(l[c]);
      if (!(p = o != null && u(o, f)))
        break;
      o = o[f];
    }
    return p || ++c != d ? p : (d = o == null ? 0 : o.length, !!d && a(d) && n(f, d) && (r(o) || t(o)));
  }
  return n0 = i, n0;
}
var i0, FO;
function cre() {
  if (FO) return i0;
  FO = 1;
  var e = Ote(), t = UU();
  function r(n, a) {
    return n != null && t(n, a, e);
  }
  return i0 = r, i0;
}
var dre = cre();
const fre = /* @__PURE__ */ da(dre), Tg = null, TI = void 0;
var Gt;
(function(e) {
  e.Uri = "uri", e.Text = "text", e.Image = "image", e.RowID = "row-id", e.Number = "number", e.Bubble = "bubble", e.Boolean = "boolean", e.Loading = "loading", e.Markdown = "markdown", e.Drilldown = "drilldown", e.Protected = "protected", e.Custom = "custom";
})(Gt || (Gt = {}));
var $O;
(function(e) {
  e.HeaderRowID = "headerRowID", e.HeaderCode = "headerCode", e.HeaderNumber = "headerNumber", e.HeaderString = "headerString", e.HeaderBoolean = "headerBoolean", e.HeaderAudioUri = "headerAudioUri", e.HeaderVideoUri = "headerVideoUri", e.HeaderEmoji = "headerEmoji", e.HeaderImage = "headerImage", e.HeaderUri = "headerUri", e.HeaderPhone = "headerPhone", e.HeaderMarkdown = "headerMarkdown", e.HeaderDate = "headerDate", e.HeaderTime = "headerTime", e.HeaderEmail = "headerEmail", e.HeaderReference = "headerReference", e.HeaderIfThenElse = "headerIfThenElse", e.HeaderSingleValue = "headerSingleValue", e.HeaderLookup = "headerLookup", e.HeaderTextTemplate = "headerTextTemplate", e.HeaderMath = "headerMath", e.HeaderRollup = "headerRollup", e.HeaderJoinStrings = "headerJoinStrings", e.HeaderSplitString = "headerSplitString", e.HeaderGeoDistance = "headerGeoDistance", e.HeaderArray = "headerArray", e.RowOwnerOverlay = "rowOwnerOverlay", e.ProtectedColumnOverlay = "protectedColumnOverlay";
})($O || ($O = {}));
var Rg;
(function(e) {
  e.Triangle = "triangle", e.Dots = "dots";
})(Rg || (Rg = {}));
function Xh(e) {
  return "width" in e && typeof e.width == "number";
}
async function BO(e) {
  return typeof e == "object" ? e : await e();
}
function Cc(e) {
  return !(e.kind === Gt.Loading || e.kind === Gt.Bubble || e.kind === Gt.RowID || e.kind === Gt.Protected || e.kind === Gt.Drilldown);
}
function Oc(e) {
  return e.kind === as.Marker || e.kind === as.NewRow;
}
function Pf(e) {
  if (!Cc(e) || e.kind === Gt.Image)
    return !1;
  if (e.kind === Gt.Text || e.kind === Gt.Number || e.kind === Gt.Markdown || e.kind === Gt.Uri || e.kind === Gt.Custom || e.kind === Gt.Boolean)
    return e.readonly !== !0;
  vp(e, "A cell was passed with an invalid kind");
}
function pre(e) {
  return fre(e, "editor");
}
function LT(e) {
  return !(e.readonly ?? !1);
}
var as;
(function(e) {
  e.NewRow = "new-row", e.Marker = "marker";
})(as || (as = {}));
function hre(e) {
  if (e.length === 0)
    return [];
  const t = [...e], r = [];
  t.sort(function(n, a) {
    return n[0] - a[0];
  }), r.push([...t[0]]);
  for (const n of t.slice(1)) {
    const a = r[r.length - 1];
    a[1] < n[0] ? r.push([...n]) : a[1] < n[1] && (a[1] = n[1]);
  }
  return r;
}
let UO;
class fn {
  items;
  constructor(t) {
    this.items = t;
  }
  static empty = () => UO ?? (UO = new fn([]));
  static fromSingleSelection = (t) => fn.empty().add(t);
  offset(t) {
    if (t === 0)
      return this;
    const r = this.items.map((n) => [n[0] + t, n[1] + t]);
    return new fn(r);
  }
  add(t) {
    const r = typeof t == "number" ? [t, t + 1] : t, n = hre([...this.items, r]);
    return new fn(n);
  }
  remove(t) {
    const r = [...this.items], n = typeof t == "number" ? t : t[0], a = typeof t == "number" ? t + 1 : t[1];
    for (const [s, i] of r.entries()) {
      const [o, l] = i;
      if (o <= a && n <= l) {
        const u = [];
        o < n && u.push([o, n]), a < l && u.push([a, l]), r.splice(s, 1, ...u);
      }
    }
    return new fn(r);
  }
  first() {
    if (this.items.length !== 0)
      return this.items[0][0];
  }
  last() {
    if (this.items.length !== 0)
      return this.items.slice(-1)[0][1] - 1;
  }
  hasIndex(t) {
    for (let r = 0; r < this.items.length; r++) {
      const [n, a] = this.items[r];
      if (t >= n && t < a)
        return !0;
    }
    return !1;
  }
  hasAll(t) {
    for (let r = t[0]; r < t[1]; r++)
      if (!this.hasIndex(r))
        return !1;
    return !0;
  }
  some(t) {
    for (const r of this)
      if (t(r))
        return !0;
    return !1;
  }
  equals(t) {
    if (t === this)
      return !0;
    if (t.items.length !== this.items.length)
      return !1;
    for (let r = 0; r < this.items.length; r++) {
      const n = t.items[r], a = this.items[r];
      if (n[0] !== a[0] || n[1] !== a[1])
        return !1;
    }
    return !0;
  }
  // Really old JS wont have access to the iterator and babel will stop people using it
  // when trying to support browsers so old we don't support them anyway. What goes on
  // between an engineer and their bundler in the privacy of their CI server is none of
  // my business anyway.
  toArray() {
    const t = [];
    for (const [r, n] of this.items)
      for (let a = r; a < n; a++)
        t.push(a);
    return t;
  }
  get length() {
    let t = 0;
    for (const [r, n] of this.items)
      t += n - r;
    return t;
  }
  *[Symbol.iterator]() {
    for (const [t, r] of this.items)
      for (let n = t; n < r; n++)
        yield n;
  }
}
function mre(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] === void 0 && (t[r] = e(r)), t[r];
  };
}
var gre = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, a0 = /* @__PURE__ */ mre(
  function(e) {
    return gre.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), bre = function() {
  const t = Array.prototype.slice.call(arguments).filter(Boolean), r = {}, n = [];
  t.forEach((s) => {
    (s ? s.split(" ") : []).forEach((o) => {
      if (o.startsWith("atm_")) {
        const [, l] = o.split("_");
        r[l] = o;
      } else
        n.push(o);
    });
  });
  const a = [];
  for (const s in r)
    Object.prototype.hasOwnProperty.call(r, s) && a.push(r[s]);
  return a.push(...n), a.join(" ");
}, zO = bre, yre = (e) => e.toUpperCase() === e, vre = (e) => (t) => e.indexOf(t) === -1, zU = (e, t) => {
  const r = {};
  return Object.keys(e).filter(vre(t)).forEach((n) => {
    r[n] = e[n];
  }), r;
};
function wre(e, t, r) {
  const n = zU(t, r);
  if (!e) {
    const a = typeof a0 == "function" ? { default: a0 } : a0;
    Object.keys(n).forEach((s) => {
      a.default(s) || delete n[s];
    });
  }
  return n;
}
var xre = (e, t) => {
  if (process.env.NODE_ENV !== "production") {
    if (typeof e == "string" || typeof e == "number" && isFinite(e))
      return;
    const r = typeof e == "object" ? JSON.stringify(e) : String(e);
    console.warn(
      `An interpolation evaluated to '${r}' in the component '${t}', which is probably a mistake. You should explicitly cast or transform the value to a string.`
    );
  }
}, Ere = 0;
function qO(e) {
  var t;
  let r = "";
  return process.env.NODE_ENV === "test" && (r += `mocked-styled-${Ere++}`, (t = e?.__linaria) != null && t.className && (r += ` ${e.__linaria.className}`)), (n) => {
    if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Array.isArray(n))
      throw new Error(
        'Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'
      );
    const a = (i, o) => {
      const { as: l = e, class: u = r } = i, c = n.propsAsIs === void 0 ? !(typeof l == "string" && l.indexOf("-") === -1 && !yre(l[0])) : n.propsAsIs, d = wre(c, i, [
        "as",
        "class"
      ]);
      d.ref = o, d.className = n.atomic ? zO(n.class, d.className || u) : zO(d.className || u, n.class);
      const { vars: p } = n;
      if (p) {
        const f = {};
        for (const y in p) {
          const b = p[y], v = b[0], x = b[1] || "", _ = typeof v == "function" ? v(i) : v;
          xre(_, n.name), f[`--${y}`] = `${_}${x}`;
        }
        const h = d.style || {}, m = Object.keys(h);
        m.length > 0 && m.forEach((y) => {
          f[y] = h[y];
        }), d.style = f;
      }
      return e.__linaria && e !== l ? (d.as = l, kt.createElement(e, d)) : kt.createElement(l, d);
    }, s = kt.forwardRef ? kt.forwardRef(a) : (i) => {
      const o = zU(i, ["innerRef"]);
      return a(o, i.innerRef);
    };
    return s.displayName = n.name, s.__linaria = {
      className: n.class || r,
      extends: e
    }, s;
  };
}
var Ga = process.env.NODE_ENV !== "production" ? new Proxy(qO, {
  get(e, t) {
    return e(t);
  }
}) : qO;
const Sre = /* @__PURE__ */ Ga("div")({
  name: "ImageOverlayEditorStyle",
  class: "gdg-i2iowwq",
  propsAsIs: !1
});
var s0 = {}, Qd = {}, Zh = {}, Jh = {}, Qh = { exports: {} }, em = { exports: {} }, In = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jO;
function _re() {
  if (jO) return In;
  jO = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, v = e ? Symbol.for("react.scope") : 60119;
  function x(E) {
    if (typeof E == "object" && E !== null) {
      var w = E.$$typeof;
      switch (w) {
        case t:
          switch (E = E.type, E) {
            case l:
            case u:
            case n:
            case s:
            case a:
            case d:
              return E;
            default:
              switch (E = E && E.$$typeof, E) {
                case o:
                case c:
                case h:
                case f:
                case i:
                  return E;
                default:
                  return w;
              }
          }
        case r:
          return w;
      }
    }
  }
  function _(E) {
    return x(E) === u;
  }
  return In.AsyncMode = l, In.ConcurrentMode = u, In.ContextConsumer = o, In.ContextProvider = i, In.Element = t, In.ForwardRef = c, In.Fragment = n, In.Lazy = h, In.Memo = f, In.Portal = r, In.Profiler = s, In.StrictMode = a, In.Suspense = d, In.isAsyncMode = function(E) {
    return _(E) || x(E) === l;
  }, In.isConcurrentMode = _, In.isContextConsumer = function(E) {
    return x(E) === o;
  }, In.isContextProvider = function(E) {
    return x(E) === i;
  }, In.isElement = function(E) {
    return typeof E == "object" && E !== null && E.$$typeof === t;
  }, In.isForwardRef = function(E) {
    return x(E) === c;
  }, In.isFragment = function(E) {
    return x(E) === n;
  }, In.isLazy = function(E) {
    return x(E) === h;
  }, In.isMemo = function(E) {
    return x(E) === f;
  }, In.isPortal = function(E) {
    return x(E) === r;
  }, In.isProfiler = function(E) {
    return x(E) === s;
  }, In.isStrictMode = function(E) {
    return x(E) === a;
  }, In.isSuspense = function(E) {
    return x(E) === d;
  }, In.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === n || E === u || E === s || E === a || E === d || E === p || typeof E == "object" && E !== null && (E.$$typeof === h || E.$$typeof === f || E.$$typeof === i || E.$$typeof === o || E.$$typeof === c || E.$$typeof === y || E.$$typeof === b || E.$$typeof === v || E.$$typeof === m);
  }, In.typeOf = x, In;
}
var Nn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HO;
function kre() {
  return HO || (HO = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, v = e ? Symbol.for("react.scope") : 60119;
    function x(re) {
      return typeof re == "string" || typeof re == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      re === n || re === u || re === s || re === a || re === d || re === p || typeof re == "object" && re !== null && (re.$$typeof === h || re.$$typeof === f || re.$$typeof === i || re.$$typeof === o || re.$$typeof === c || re.$$typeof === y || re.$$typeof === b || re.$$typeof === v || re.$$typeof === m);
    }
    function _(re) {
      if (typeof re == "object" && re !== null) {
        var Te = re.$$typeof;
        switch (Te) {
          case t:
            var V = re.type;
            switch (V) {
              case l:
              case u:
              case n:
              case s:
              case a:
              case d:
                return V;
              default:
                var Pe = V && V.$$typeof;
                switch (Pe) {
                  case o:
                  case c:
                  case h:
                  case f:
                  case i:
                    return Pe;
                  default:
                    return Te;
                }
            }
          case r:
            return Te;
        }
      }
    }
    var E = l, w = u, C = o, k = i, S = t, B = c, U = n, N = h, O = f, I = r, q = s, ae = a, Q = d, ne = !1;
    function le(re) {
      return ne || (ne = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), W(re) || _(re) === l;
    }
    function W(re) {
      return _(re) === u;
    }
    function X(re) {
      return _(re) === o;
    }
    function G(re) {
      return _(re) === i;
    }
    function P(re) {
      return typeof re == "object" && re !== null && re.$$typeof === t;
    }
    function he(re) {
      return _(re) === c;
    }
    function ye(re) {
      return _(re) === n;
    }
    function pe(re) {
      return _(re) === h;
    }
    function $(re) {
      return _(re) === f;
    }
    function F(re) {
      return _(re) === r;
    }
    function ge(re) {
      return _(re) === s;
    }
    function ce(re) {
      return _(re) === a;
    }
    function ie(re) {
      return _(re) === d;
    }
    Nn.AsyncMode = E, Nn.ConcurrentMode = w, Nn.ContextConsumer = C, Nn.ContextProvider = k, Nn.Element = S, Nn.ForwardRef = B, Nn.Fragment = U, Nn.Lazy = N, Nn.Memo = O, Nn.Portal = I, Nn.Profiler = q, Nn.StrictMode = ae, Nn.Suspense = Q, Nn.isAsyncMode = le, Nn.isConcurrentMode = W, Nn.isContextConsumer = X, Nn.isContextProvider = G, Nn.isElement = P, Nn.isForwardRef = he, Nn.isFragment = ye, Nn.isLazy = pe, Nn.isMemo = $, Nn.isPortal = F, Nn.isProfiler = ge, Nn.isStrictMode = ce, Nn.isSuspense = ie, Nn.isValidElementType = x, Nn.typeOf = _;
  }()), Nn;
}
var VO;
function qU() {
  return VO || (VO = 1, process.env.NODE_ENV === "production" ? em.exports = _re() : em.exports = kre()), em.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var o0, GO;
function Cre() {
  if (GO) return o0;
  GO = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function a() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var i = {}, o = 0; o < 10; o++)
        i["_" + String.fromCharCode(o)] = o;
      var l = Object.getOwnPropertyNames(i).map(function(c) {
        return i[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return o0 = a() ? Object.assign : function(s, i) {
    for (var o, l = n(s), u, c = 1; c < arguments.length; c++) {
      o = Object(arguments[c]);
      for (var d in o)
        t.call(o, d) && (l[d] = o[d]);
      if (e) {
        u = e(o);
        for (var p = 0; p < u.length; p++)
          r.call(o, u[p]) && (l[u[p]] = o[u[p]]);
      }
    }
    return l;
  }, o0;
}
var l0, WO;
function RI() {
  if (WO) return l0;
  WO = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return l0 = e, l0;
}
var u0, KO;
function jU() {
  return KO || (KO = 1, u0 = Function.call.bind(Object.prototype.hasOwnProperty)), u0;
}
var c0, YO;
function Are() {
  if (YO) return c0;
  YO = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ RI(), r = {}, n = /* @__PURE__ */ jU();
    e = function(s) {
      var i = "Warning: " + s;
      typeof console < "u" && console.error(i);
      try {
        throw new Error(i);
      } catch {
      }
    };
  }
  function a(s, i, o, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in s)
        if (n(s, c)) {
          var d;
          try {
            if (typeof s[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + o + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = s[c](i, c, l, o, null, t);
          } catch (h) {
            d = h;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + o + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in r)) {
            r[d.message] = !0;
            var f = u ? u() : "";
            e(
              "Failed " + o + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return a.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, c0 = a, c0;
}
var d0, XO;
function Tre() {
  if (XO) return d0;
  XO = 1;
  var e = qU(), t = Cre(), r = /* @__PURE__ */ RI(), n = /* @__PURE__ */ jU(), a = /* @__PURE__ */ Are(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(o) {
    var l = "Warning: " + o;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function i() {
    return null;
  }
  return d0 = function(o, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(W) {
      var X = W && (u && W[u] || W[c]);
      if (typeof X == "function")
        return X;
    }
    var p = "<<anonymous>>", f = {
      array: b("array"),
      bigint: b("bigint"),
      bool: b("boolean"),
      func: b("function"),
      number: b("number"),
      object: b("object"),
      string: b("string"),
      symbol: b("symbol"),
      any: v(),
      arrayOf: x,
      element: _(),
      elementType: E(),
      instanceOf: w,
      node: B(),
      objectOf: k,
      oneOf: C,
      oneOfType: S,
      shape: N,
      exact: O
    };
    function h(W, X) {
      return W === X ? W !== 0 || 1 / W === 1 / X : W !== W && X !== X;
    }
    function m(W, X) {
      this.message = W, this.data = X && typeof X == "object" ? X : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function y(W) {
      if (process.env.NODE_ENV !== "production")
        var X = {}, G = 0;
      function P(ye, pe, $, F, ge, ce, ie) {
        if (F = F || p, ce = ce || $, ie !== r) {
          if (l) {
            var re = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw re.name = "Invariant Violation", re;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Te = F + ":" + $;
            !X[Te] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + ce + "` prop on `" + F + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), X[Te] = !0, G++);
          }
        }
        return pe[$] == null ? ye ? pe[$] === null ? new m("The " + ge + " `" + ce + "` is marked as required " + ("in `" + F + "`, but its value is `null`.")) : new m("The " + ge + " `" + ce + "` is marked as required in " + ("`" + F + "`, but its value is `undefined`.")) : null : W(pe, $, F, ge, ce);
      }
      var he = P.bind(null, !1);
      return he.isRequired = P.bind(null, !0), he;
    }
    function b(W) {
      function X(G, P, he, ye, pe, $) {
        var F = G[P], ge = ae(F);
        if (ge !== W) {
          var ce = Q(F);
          return new m(
            "Invalid " + ye + " `" + pe + "` of type " + ("`" + ce + "` supplied to `" + he + "`, expected ") + ("`" + W + "`."),
            { expectedType: W }
          );
        }
        return null;
      }
      return y(X);
    }
    function v() {
      return y(i);
    }
    function x(W) {
      function X(G, P, he, ye, pe) {
        if (typeof W != "function")
          return new m("Property `" + pe + "` of component `" + he + "` has invalid PropType notation inside arrayOf.");
        var $ = G[P];
        if (!Array.isArray($)) {
          var F = ae($);
          return new m("Invalid " + ye + " `" + pe + "` of type " + ("`" + F + "` supplied to `" + he + "`, expected an array."));
        }
        for (var ge = 0; ge < $.length; ge++) {
          var ce = W($, ge, he, ye, pe + "[" + ge + "]", r);
          if (ce instanceof Error)
            return ce;
        }
        return null;
      }
      return y(X);
    }
    function _() {
      function W(X, G, P, he, ye) {
        var pe = X[G];
        if (!o(pe)) {
          var $ = ae(pe);
          return new m("Invalid " + he + " `" + ye + "` of type " + ("`" + $ + "` supplied to `" + P + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(W);
    }
    function E() {
      function W(X, G, P, he, ye) {
        var pe = X[G];
        if (!e.isValidElementType(pe)) {
          var $ = ae(pe);
          return new m("Invalid " + he + " `" + ye + "` of type " + ("`" + $ + "` supplied to `" + P + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(W);
    }
    function w(W) {
      function X(G, P, he, ye, pe) {
        if (!(G[P] instanceof W)) {
          var $ = W.name || p, F = le(G[P]);
          return new m("Invalid " + ye + " `" + pe + "` of type " + ("`" + F + "` supplied to `" + he + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return y(X);
    }
    function C(W) {
      if (!Array.isArray(W))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), i;
      function X(G, P, he, ye, pe) {
        for (var $ = G[P], F = 0; F < W.length; F++)
          if (h($, W[F]))
            return null;
        var ge = JSON.stringify(W, function(ie, re) {
          var Te = Q(re);
          return Te === "symbol" ? String(re) : re;
        });
        return new m("Invalid " + ye + " `" + pe + "` of value `" + String($) + "` " + ("supplied to `" + he + "`, expected one of " + ge + "."));
      }
      return y(X);
    }
    function k(W) {
      function X(G, P, he, ye, pe) {
        if (typeof W != "function")
          return new m("Property `" + pe + "` of component `" + he + "` has invalid PropType notation inside objectOf.");
        var $ = G[P], F = ae($);
        if (F !== "object")
          return new m("Invalid " + ye + " `" + pe + "` of type " + ("`" + F + "` supplied to `" + he + "`, expected an object."));
        for (var ge in $)
          if (n($, ge)) {
            var ce = W($, ge, he, ye, pe + "." + ge, r);
            if (ce instanceof Error)
              return ce;
          }
        return null;
      }
      return y(X);
    }
    function S(W) {
      if (!Array.isArray(W))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), i;
      for (var X = 0; X < W.length; X++) {
        var G = W[X];
        if (typeof G != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ne(G) + " at index " + X + "."
          ), i;
      }
      function P(he, ye, pe, $, F) {
        for (var ge = [], ce = 0; ce < W.length; ce++) {
          var ie = W[ce], re = ie(he, ye, pe, $, F, r);
          if (re == null)
            return null;
          re.data && n(re.data, "expectedType") && ge.push(re.data.expectedType);
        }
        var Te = ge.length > 0 ? ", expected one of type [" + ge.join(", ") + "]" : "";
        return new m("Invalid " + $ + " `" + F + "` supplied to " + ("`" + pe + "`" + Te + "."));
      }
      return y(P);
    }
    function B() {
      function W(X, G, P, he, ye) {
        return I(X[G]) ? null : new m("Invalid " + he + " `" + ye + "` supplied to " + ("`" + P + "`, expected a ReactNode."));
      }
      return y(W);
    }
    function U(W, X, G, P, he) {
      return new m(
        (W || "React class") + ": " + X + " type `" + G + "." + P + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + he + "`."
      );
    }
    function N(W) {
      function X(G, P, he, ye, pe) {
        var $ = G[P], F = ae($);
        if (F !== "object")
          return new m("Invalid " + ye + " `" + pe + "` of type `" + F + "` " + ("supplied to `" + he + "`, expected `object`."));
        for (var ge in W) {
          var ce = W[ge];
          if (typeof ce != "function")
            return U(he, ye, pe, ge, Q(ce));
          var ie = ce($, ge, he, ye, pe + "." + ge, r);
          if (ie)
            return ie;
        }
        return null;
      }
      return y(X);
    }
    function O(W) {
      function X(G, P, he, ye, pe) {
        var $ = G[P], F = ae($);
        if (F !== "object")
          return new m("Invalid " + ye + " `" + pe + "` of type `" + F + "` " + ("supplied to `" + he + "`, expected `object`."));
        var ge = t({}, G[P], W);
        for (var ce in ge) {
          var ie = W[ce];
          if (n(W, ce) && typeof ie != "function")
            return U(he, ye, pe, ce, Q(ie));
          if (!ie)
            return new m(
              "Invalid " + ye + " `" + pe + "` key `" + ce + "` supplied to `" + he + "`.\nBad object: " + JSON.stringify(G[P], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(W), null, "  ")
            );
          var re = ie($, ce, he, ye, pe + "." + ce, r);
          if (re)
            return re;
        }
        return null;
      }
      return y(X);
    }
    function I(W) {
      switch (typeof W) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !W;
        case "object":
          if (Array.isArray(W))
            return W.every(I);
          if (W === null || o(W))
            return !0;
          var X = d(W);
          if (X) {
            var G = X.call(W), P;
            if (X !== W.entries) {
              for (; !(P = G.next()).done; )
                if (!I(P.value))
                  return !1;
            } else
              for (; !(P = G.next()).done; ) {
                var he = P.value;
                if (he && !I(he[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(W, X) {
      return W === "symbol" ? !0 : X ? X["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && X instanceof Symbol : !1;
    }
    function ae(W) {
      var X = typeof W;
      return Array.isArray(W) ? "array" : W instanceof RegExp ? "object" : q(X, W) ? "symbol" : X;
    }
    function Q(W) {
      if (typeof W > "u" || W === null)
        return "" + W;
      var X = ae(W);
      if (X === "object") {
        if (W instanceof Date)
          return "date";
        if (W instanceof RegExp)
          return "regexp";
      }
      return X;
    }
    function ne(W) {
      var X = Q(W);
      switch (X) {
        case "array":
        case "object":
          return "an " + X;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + X;
        default:
          return X;
      }
    }
    function le(W) {
      return !W.constructor || !W.constructor.name ? p : W.constructor.name;
    }
    return f.checkPropTypes = a, f.resetWarningCache = a.resetWarningCache, f.PropTypes = f, f;
  }, d0;
}
var f0, ZO;
function Rre() {
  if (ZO) return f0;
  ZO = 1;
  var e = /* @__PURE__ */ RI();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, f0 = function() {
    function n(i, o, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function a() {
      return n;
    }
    var s = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: a,
      element: n,
      elementType: n,
      instanceOf: a,
      node: n,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, f0;
}
var JO;
function Ire() {
  if (JO) return Qh.exports;
  if (JO = 1, process.env.NODE_ENV !== "production") {
    var e = qU(), t = !0;
    Qh.exports = /* @__PURE__ */ Tre()(e.isElement, t);
  } else
    Qh.exports = /* @__PURE__ */ Rre()();
  return Qh.exports;
}
var QO;
function Nre() {
  return QO || (QO = 1, function(e) {
    (function(t, r) {
      r(e, kt, /* @__PURE__ */ Ire());
    })(Jh, function(t, r, n) {
      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.setHasSupportToCaptureOption = h;
      var a = i(r), s = i(n);
      function i(v) {
        return v && v.__esModule ? v : {
          default: v
        };
      }
      var o = Object.assign || function(v) {
        for (var x = 1; x < arguments.length; x++) {
          var _ = arguments[x];
          for (var E in _)
            Object.prototype.hasOwnProperty.call(_, E) && (v[E] = _[E]);
        }
        return v;
      };
      function l(v, x) {
        var _ = {};
        for (var E in v)
          x.indexOf(E) >= 0 || Object.prototype.hasOwnProperty.call(v, E) && (_[E] = v[E]);
        return _;
      }
      function u(v, x) {
        if (!(v instanceof x))
          throw new TypeError("Cannot call a class as a function");
      }
      var c = /* @__PURE__ */ function() {
        function v(x, _) {
          for (var E = 0; E < _.length; E++) {
            var w = _[E];
            w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(x, w.key, w);
          }
        }
        return function(x, _, E) {
          return _ && v(x.prototype, _), E && v(x, E), x;
        };
      }();
      function d(v, x) {
        if (!v)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return x && (typeof x == "object" || typeof x == "function") ? x : v;
      }
      function p(v, x) {
        if (typeof x != "function" && x !== null)
          throw new TypeError("Super expression must either be null or a function, not " + typeof x);
        v.prototype = Object.create(x && x.prototype, {
          constructor: {
            value: v,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), x && (Object.setPrototypeOf ? Object.setPrototypeOf(v, x) : v.__proto__ = x);
      }
      var f = !1;
      function h(v) {
        f = v;
      }
      try {
        addEventListener("test", null, Object.defineProperty({}, "capture", { get: function() {
          h(!0);
        } }));
      } catch {
      }
      function m() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { capture: !0 };
        return f ? v : v.capture;
      }
      function y(v) {
        if ("touches" in v) {
          var x = v.touches[0], _ = x.pageX, E = x.pageY;
          return { x: _, y: E };
        }
        var w = v.screenX, C = v.screenY;
        return { x: w, y: C };
      }
      var b = function(v) {
        p(x, v);
        function x() {
          var _;
          u(this, x);
          for (var E = arguments.length, w = Array(E), C = 0; C < E; C++)
            w[C] = arguments[C];
          var k = d(this, (_ = x.__proto__ || Object.getPrototypeOf(x)).call.apply(_, [this].concat(w)));
          return k._handleSwipeStart = k._handleSwipeStart.bind(k), k._handleSwipeMove = k._handleSwipeMove.bind(k), k._handleSwipeEnd = k._handleSwipeEnd.bind(k), k._onMouseDown = k._onMouseDown.bind(k), k._onMouseMove = k._onMouseMove.bind(k), k._onMouseUp = k._onMouseUp.bind(k), k._setSwiperRef = k._setSwiperRef.bind(k), k;
        }
        return c(x, [{
          key: "componentDidMount",
          value: function() {
            this.swiper && this.swiper.addEventListener("touchmove", this._handleSwipeMove, m({
              capture: !0,
              passive: !1
            }));
          }
        }, {
          key: "componentWillUnmount",
          value: function() {
            this.swiper && this.swiper.removeEventListener("touchmove", this._handleSwipeMove, m({
              capture: !0,
              passive: !1
            }));
          }
        }, {
          key: "_onMouseDown",
          value: function(E) {
            this.props.allowMouseEvents && (this.mouseDown = !0, document.addEventListener("mouseup", this._onMouseUp), document.addEventListener("mousemove", this._onMouseMove), this._handleSwipeStart(E));
          }
        }, {
          key: "_onMouseMove",
          value: function(E) {
            this.mouseDown && this._handleSwipeMove(E);
          }
        }, {
          key: "_onMouseUp",
          value: function(E) {
            this.mouseDown = !1, document.removeEventListener("mouseup", this._onMouseUp), document.removeEventListener("mousemove", this._onMouseMove), this._handleSwipeEnd(E);
          }
        }, {
          key: "_handleSwipeStart",
          value: function(E) {
            var w = y(E), C = w.x, k = w.y;
            this.moveStart = { x: C, y: k }, this.props.onSwipeStart(E);
          }
        }, {
          key: "_handleSwipeMove",
          value: function(E) {
            if (this.moveStart) {
              var w = y(E), C = w.x, k = w.y, S = C - this.moveStart.x, B = k - this.moveStart.y;
              this.moving = !0;
              var U = this.props.onSwipeMove({
                x: S,
                y: B
              }, E);
              U && E.cancelable && E.preventDefault(), this.movePosition = { deltaX: S, deltaY: B };
            }
          }
        }, {
          key: "_handleSwipeEnd",
          value: function(E) {
            this.props.onSwipeEnd(E);
            var w = this.props.tolerance;
            this.moving && this.movePosition && (this.movePosition.deltaX < -w ? this.props.onSwipeLeft(1, E) : this.movePosition.deltaX > w && this.props.onSwipeRight(1, E), this.movePosition.deltaY < -w ? this.props.onSwipeUp(1, E) : this.movePosition.deltaY > w && this.props.onSwipeDown(1, E)), this.moveStart = null, this.moving = !1, this.movePosition = null;
          }
        }, {
          key: "_setSwiperRef",
          value: function(E) {
            this.swiper = E, this.props.innerRef(E);
          }
        }, {
          key: "render",
          value: function() {
            var E = this.props;
            E.tagName;
            var w = E.className, C = E.style, k = E.children;
            E.allowMouseEvents, E.onSwipeUp, E.onSwipeDown, E.onSwipeLeft, E.onSwipeRight, E.onSwipeStart, E.onSwipeMove, E.onSwipeEnd, E.innerRef, E.tolerance;
            var S = l(E, ["tagName", "className", "style", "children", "allowMouseEvents", "onSwipeUp", "onSwipeDown", "onSwipeLeft", "onSwipeRight", "onSwipeStart", "onSwipeMove", "onSwipeEnd", "innerRef", "tolerance"]);
            return a.default.createElement(
              this.props.tagName,
              o({
                ref: this._setSwiperRef,
                onMouseDown: this._onMouseDown,
                onTouchStart: this._handleSwipeStart,
                onTouchEnd: this._handleSwipeEnd,
                className: w,
                style: C
              }, S),
              k
            );
          }
        }]), x;
      }(r.Component);
      b.displayName = "ReactSwipe", b.propTypes = {
        tagName: s.default.string,
        className: s.default.string,
        style: s.default.object,
        children: s.default.node,
        allowMouseEvents: s.default.bool,
        onSwipeUp: s.default.func,
        onSwipeDown: s.default.func,
        onSwipeLeft: s.default.func,
        onSwipeRight: s.default.func,
        onSwipeStart: s.default.func,
        onSwipeMove: s.default.func,
        onSwipeEnd: s.default.func,
        innerRef: s.default.func,
        tolerance: s.default.number.isRequired
      }, b.defaultProps = {
        tagName: "div",
        allowMouseEvents: !1,
        onSwipeUp: function() {
        },
        onSwipeDown: function() {
        },
        onSwipeLeft: function() {
        },
        onSwipeRight: function() {
        },
        onSwipeStart: function() {
        },
        onSwipeMove: function() {
        },
        onSwipeEnd: function() {
        },
        innerRef: function() {
        },
        tolerance: 0
      }, t.default = b;
    });
  }(Jh)), Jh;
}
var e4;
function HU() {
  return e4 || (e4 = 1, function(e) {
    (function(t, r) {
      r(e, Nre());
    })(Zh, function(t, r) {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var n = a(r);
      function a(s) {
        return s && s.__esModule ? s : {
          default: s
        };
      }
      t.default = n.default;
    });
  }(Zh)), Zh;
}
var ef = {}, p0 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var t4;
function Dre() {
  return t4 || (t4 = 1, function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function r() {
        for (var s = "", i = 0; i < arguments.length; i++) {
          var o = arguments[i];
          o && (s = a(s, n(o)));
        }
        return s;
      }
      function n(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return r.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var i = "";
        for (var o in s)
          t.call(s, o) && s[o] && (i = a(i, o));
        return i;
      }
      function a(s, i) {
        return i ? s ? s + " " + i : s + i : s;
      }
      e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
    })();
  }(p0)), p0.exports;
}
var r4;
function VU() {
  if (r4) return ef;
  r4 = 1, Object.defineProperty(ef, "__esModule", {
    value: !0
  }), ef.default = void 0;
  var e = t(Dre());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function r(a, s, i) {
    return s in a ? Object.defineProperty(a, s, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : a[s] = i, a;
  }
  var n = {
    ROOT: function(s) {
      return (0, e.default)(r({
        "carousel-root": !0
      }, s || "", !!s));
    },
    CAROUSEL: function(s) {
      return (0, e.default)({
        carousel: !0,
        "carousel-slider": s
      });
    },
    WRAPPER: function(s, i) {
      return (0, e.default)({
        "thumbs-wrapper": !s,
        "slider-wrapper": s,
        "axis-horizontal": i === "horizontal",
        "axis-vertical": i !== "horizontal"
      });
    },
    SLIDER: function(s, i) {
      return (0, e.default)({
        thumbs: !s,
        slider: s,
        animated: !i
      });
    },
    ITEM: function(s, i, o) {
      return (0, e.default)({
        thumb: !s,
        slide: s,
        selected: i,
        previous: o
      });
    },
    ARROW_PREV: function(s) {
      return (0, e.default)({
        "control-arrow control-prev": !0,
        "control-disabled": s
      });
    },
    ARROW_NEXT: function(s) {
      return (0, e.default)({
        "control-arrow control-next": !0,
        "control-disabled": s
      });
    },
    DOT: function(s) {
      return (0, e.default)({
        dot: !0,
        selected: s
      });
    }
  };
  return ef.default = n, ef;
}
var tf = {}, rf = {}, n4;
function Ore() {
  if (n4) return rf;
  n4 = 1, Object.defineProperty(rf, "__esModule", {
    value: !0
  }), rf.outerWidth = void 0;
  var e = function(r) {
    var n = r.offsetWidth, a = getComputedStyle(r);
    return n += parseInt(a.marginLeft) + parseInt(a.marginRight), n;
  };
  return rf.outerWidth = e, rf;
}
var nf = {}, i4;
function II() {
  if (i4) return nf;
  i4 = 1, Object.defineProperty(nf, "__esModule", {
    value: !0
  }), nf.default = void 0;
  var e = function(r, n, a) {
    var s = r === 0 ? r : r + n, i = a === "horizontal" ? [s, 0, 0] : [0, s, 0], o = "translate3d", l = "(" + i.join(",") + ")";
    return o + l;
  };
  return nf.default = e, nf;
}
var af = {}, a4;
function GU() {
  if (a4) return af;
  a4 = 1, Object.defineProperty(af, "__esModule", {
    value: !0
  }), af.default = void 0;
  var e = function() {
    return window;
  };
  return af.default = e, af;
}
var s4;
function WU() {
  if (s4) return tf;
  s4 = 1, Object.defineProperty(tf, "__esModule", {
    value: !0
  }), tf.default = void 0;
  var e = l(kt), t = i(VU()), r = Ore(), n = i(II()), a = i(HU()), s = i(GU());
  function i(k) {
    return k && k.__esModule ? k : { default: k };
  }
  function o() {
    if (typeof WeakMap != "function") return null;
    var k = /* @__PURE__ */ new WeakMap();
    return o = function() {
      return k;
    }, k;
  }
  function l(k) {
    if (k && k.__esModule)
      return k;
    if (k === null || u(k) !== "object" && typeof k != "function")
      return { default: k };
    var S = o();
    if (S && S.has(k))
      return S.get(k);
    var B = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var N in k)
      if (Object.prototype.hasOwnProperty.call(k, N)) {
        var O = U ? Object.getOwnPropertyDescriptor(k, N) : null;
        O && (O.get || O.set) ? Object.defineProperty(B, N, O) : B[N] = k[N];
      }
    return B.default = k, S && S.set(k, B), B;
  }
  function u(k) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function(B) {
      return typeof B;
    } : u = function(B) {
      return B && typeof Symbol == "function" && B.constructor === Symbol && B !== Symbol.prototype ? "symbol" : typeof B;
    }, u(k);
  }
  function c() {
    return c = Object.assign || function(k) {
      for (var S = 1; S < arguments.length; S++) {
        var B = arguments[S];
        for (var U in B)
          Object.prototype.hasOwnProperty.call(B, U) && (k[U] = B[U]);
      }
      return k;
    }, c.apply(this, arguments);
  }
  function d(k, S) {
    if (!(k instanceof S))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(k, S) {
    for (var B = 0; B < S.length; B++) {
      var U = S[B];
      U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(k, U.key, U);
    }
  }
  function f(k, S, B) {
    return p(k.prototype, S), k;
  }
  function h(k, S) {
    if (typeof S != "function" && S !== null)
      throw new TypeError("Super expression must either be null or a function");
    k.prototype = Object.create(S && S.prototype, { constructor: { value: k, writable: !0, configurable: !0 } }), S && m(k, S);
  }
  function m(k, S) {
    return m = Object.setPrototypeOf || function(U, N) {
      return U.__proto__ = N, U;
    }, m(k, S);
  }
  function y(k) {
    var S = x();
    return function() {
      var U = _(k), N;
      if (S) {
        var O = _(this).constructor;
        N = Reflect.construct(U, arguments, O);
      } else
        N = U.apply(this, arguments);
      return b(this, N);
    };
  }
  function b(k, S) {
    return S && (u(S) === "object" || typeof S == "function") ? S : v(k);
  }
  function v(k) {
    if (k === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return k;
  }
  function x() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function _(k) {
    return _ = Object.setPrototypeOf ? Object.getPrototypeOf : function(B) {
      return B.__proto__ || Object.getPrototypeOf(B);
    }, _(k);
  }
  function E(k, S, B) {
    return S in k ? Object.defineProperty(k, S, { value: B, enumerable: !0, configurable: !0, writable: !0 }) : k[S] = B, k;
  }
  var w = function(S) {
    return S.hasOwnProperty("key");
  }, C = /* @__PURE__ */ function(k) {
    h(B, k);
    var S = y(B);
    function B(U) {
      var N;
      return d(this, B), N = S.call(this, U), E(v(N), "itemsWrapperRef", void 0), E(v(N), "itemsListRef", void 0), E(v(N), "thumbsRef", void 0), E(v(N), "setItemsWrapperRef", function(O) {
        N.itemsWrapperRef = O;
      }), E(v(N), "setItemsListRef", function(O) {
        N.itemsListRef = O;
      }), E(v(N), "setThumbsRef", function(O, I) {
        N.thumbsRef || (N.thumbsRef = []), N.thumbsRef[I] = O;
      }), E(v(N), "updateSizes", function() {
        if (!(!N.props.children || !N.itemsWrapperRef || !N.thumbsRef)) {
          var O = e.Children.count(N.props.children), I = N.itemsWrapperRef.clientWidth, q = N.props.thumbWidth ? N.props.thumbWidth : (0, r.outerWidth)(N.thumbsRef[0]), ae = Math.floor(I / q), Q = ae < O, ne = Q ? O - ae : 0;
          N.setState(function(le, W) {
            return {
              itemSize: q,
              visibleItems: ae,
              firstItem: Q ? N.getFirstItem(W.selectedItem) : 0,
              lastPosition: ne,
              showArrows: Q
            };
          });
        }
      }), E(v(N), "handleClickItem", function(O, I, q) {
        if (!w(q) || q.key === "Enter") {
          var ae = N.props.onSelectItem;
          typeof ae == "function" && ae(O, I);
        }
      }), E(v(N), "onSwipeStart", function() {
        N.setState({
          swiping: !0
        });
      }), E(v(N), "onSwipeEnd", function() {
        N.setState({
          swiping: !1
        });
      }), E(v(N), "onSwipeMove", function(O) {
        var I = O.x;
        if (!N.state.itemSize || !N.itemsWrapperRef || !N.state.visibleItems)
          return !1;
        var q = 0, ae = e.Children.count(N.props.children), Q = -(N.state.firstItem * 100) / N.state.visibleItems, ne = Math.max(ae - N.state.visibleItems, 0), le = -ne * 100 / N.state.visibleItems;
        Q === q && I > 0 && (I = 0), Q === le && I < 0 && (I = 0);
        var W = N.itemsWrapperRef.clientWidth, X = Q + 100 / (W / I);
        return N.itemsListRef && ["WebkitTransform", "MozTransform", "MsTransform", "OTransform", "transform", "msTransform"].forEach(function(G) {
          N.itemsListRef.style[G] = (0, n.default)(X, "%", N.props.axis);
        }), !0;
      }), E(v(N), "slideRight", function(O) {
        N.moveTo(N.state.firstItem - (typeof O == "number" ? O : 1));
      }), E(v(N), "slideLeft", function(O) {
        N.moveTo(N.state.firstItem + (typeof O == "number" ? O : 1));
      }), E(v(N), "moveTo", function(O) {
        O = O < 0 ? 0 : O, O = O >= N.state.lastPosition ? N.state.lastPosition : O, N.setState({
          firstItem: O
        });
      }), N.state = {
        selectedItem: U.selectedItem,
        swiping: !1,
        showArrows: !1,
        firstItem: 0,
        visibleItems: 0,
        lastPosition: 0
      }, N;
    }
    return f(B, [{
      key: "componentDidMount",
      value: function() {
        this.setupThumbs();
      }
    }, {
      key: "componentDidUpdate",
      value: function(N) {
        this.props.selectedItem !== this.state.selectedItem && this.setState({
          selectedItem: this.props.selectedItem,
          firstItem: this.getFirstItem(this.props.selectedItem)
        }), this.props.children !== N.children && this.updateSizes();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.destroyThumbs();
      }
    }, {
      key: "setupThumbs",
      value: function() {
        (0, s.default)().addEventListener("resize", this.updateSizes), (0, s.default)().addEventListener("DOMContentLoaded", this.updateSizes), this.updateSizes();
      }
    }, {
      key: "destroyThumbs",
      value: function() {
        (0, s.default)().removeEventListener("resize", this.updateSizes), (0, s.default)().removeEventListener("DOMContentLoaded", this.updateSizes);
      }
    }, {
      key: "getFirstItem",
      value: function(N) {
        var O = N;
        return N >= this.state.lastPosition && (O = this.state.lastPosition), N < this.state.firstItem + this.state.visibleItems && (O = this.state.firstItem), N < this.state.firstItem && (O = N), O;
      }
    }, {
      key: "renderItems",
      value: function() {
        var N = this;
        return this.props.children.map(function(O, I) {
          var q = t.default.ITEM(!1, I === N.state.selectedItem), ae = {
            key: I,
            ref: function(ne) {
              return N.setThumbsRef(ne, I);
            },
            className: q,
            onClick: N.handleClickItem.bind(N, I, N.props.children[I]),
            onKeyDown: N.handleClickItem.bind(N, I, N.props.children[I]),
            "aria-label": "".concat(N.props.labels.item, " ").concat(I + 1),
            style: {
              width: N.props.thumbWidth
            }
          };
          return /* @__PURE__ */ e.default.createElement("li", c({}, ae, {
            role: "button",
            tabIndex: 0
          }), O);
        });
      }
    }, {
      key: "render",
      value: function() {
        var N = this;
        if (!this.props.children)
          return null;
        var O = e.Children.count(this.props.children) > 1, I = this.state.showArrows && this.state.firstItem > 0, q = this.state.showArrows && this.state.firstItem < this.state.lastPosition, ae = {}, Q = -this.state.firstItem * (this.state.itemSize || 0), ne = (0, n.default)(Q, "px", this.props.axis), le = this.props.transitionTime + "ms";
        return ae = {
          WebkitTransform: ne,
          MozTransform: ne,
          MsTransform: ne,
          OTransform: ne,
          transform: ne,
          msTransform: ne,
          WebkitTransitionDuration: le,
          MozTransitionDuration: le,
          MsTransitionDuration: le,
          OTransitionDuration: le,
          transitionDuration: le,
          msTransitionDuration: le
        }, /* @__PURE__ */ e.default.createElement("div", {
          className: t.default.CAROUSEL(!1)
        }, /* @__PURE__ */ e.default.createElement("div", {
          className: t.default.WRAPPER(!1),
          ref: this.setItemsWrapperRef
        }, /* @__PURE__ */ e.default.createElement("button", {
          type: "button",
          className: t.default.ARROW_PREV(!I),
          onClick: function() {
            return N.slideRight();
          },
          "aria-label": this.props.labels.leftArrow
        }), O ? /* @__PURE__ */ e.default.createElement(a.default, {
          tagName: "ul",
          className: t.default.SLIDER(!1, this.state.swiping),
          onSwipeLeft: this.slideLeft,
          onSwipeRight: this.slideRight,
          onSwipeMove: this.onSwipeMove,
          onSwipeStart: this.onSwipeStart,
          onSwipeEnd: this.onSwipeEnd,
          style: ae,
          innerRef: this.setItemsListRef,
          allowMouseEvents: this.props.emulateTouch
        }, this.renderItems()) : /* @__PURE__ */ e.default.createElement("ul", {
          className: t.default.SLIDER(!1, this.state.swiping),
          ref: function(X) {
            return N.setItemsListRef(X);
          },
          style: ae
        }, this.renderItems()), /* @__PURE__ */ e.default.createElement("button", {
          type: "button",
          className: t.default.ARROW_NEXT(!q),
          onClick: function() {
            return N.slideLeft();
          },
          "aria-label": this.props.labels.rightArrow
        })));
      }
    }]), B;
  }(e.Component);
  return tf.default = C, E(C, "displayName", "Thumbs"), E(C, "defaultProps", {
    axis: "horizontal",
    labels: {
      leftArrow: "previous slide / item",
      rightArrow: "next slide / item",
      item: "slide item"
    },
    selectedItem: 0,
    thumbWidth: 80,
    transitionTime: 350
  }), tf;
}
var sf = {}, o4;
function Pre() {
  if (o4) return sf;
  o4 = 1, Object.defineProperty(sf, "__esModule", {
    value: !0
  }), sf.default = void 0;
  var e = function() {
    return document;
  };
  return sf.default = e, sf;
}
var Oa = {}, l4;
function KU() {
  if (l4) return Oa;
  l4 = 1, Object.defineProperty(Oa, "__esModule", {
    value: !0
  }), Oa.setPosition = Oa.getPosition = Oa.isKeyboardEvent = Oa.defaultStatusFormatter = Oa.noop = void 0;
  var e = kt, t = r(II());
  function r(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var n = function() {
  };
  Oa.noop = n;
  var a = function(u, c) {
    return "".concat(u, " of ").concat(c);
  };
  Oa.defaultStatusFormatter = a;
  var s = function(u) {
    return u ? u.hasOwnProperty("key") : !1;
  };
  Oa.isKeyboardEvent = s;
  var i = function(u, c) {
    if (c.infiniteLoop && ++u, u === 0)
      return 0;
    var d = e.Children.count(c.children);
    if (c.centerMode && c.axis === "horizontal") {
      var p = -u * c.centerSlidePercentage, f = d - 1;
      return u && (u !== f || c.infiniteLoop) ? p += (100 - c.centerSlidePercentage) / 2 : u === f && (p += 100 - c.centerSlidePercentage), p;
    }
    return -u * 100;
  };
  Oa.getPosition = i;
  var o = function(u, c) {
    var d = {};
    return ["WebkitTransform", "MozTransform", "MsTransform", "OTransform", "transform", "msTransform"].forEach(function(p) {
      d[p] = (0, t.default)(u, "%", c);
    }), d;
  };
  return Oa.setPosition = o, Oa;
}
var Ss = {}, u4;
function Lre() {
  if (u4) return Ss;
  u4 = 1, Object.defineProperty(Ss, "__esModule", {
    value: !0
  }), Ss.fadeAnimationHandler = Ss.slideStopSwipingHandler = Ss.slideSwipeAnimationHandler = Ss.slideAnimationHandler = void 0;
  var e = kt, t = n(II()), r = KU();
  function n(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function a(d, p) {
    var f = Object.keys(d);
    if (Object.getOwnPropertySymbols) {
      var h = Object.getOwnPropertySymbols(d);
      p && (h = h.filter(function(m) {
        return Object.getOwnPropertyDescriptor(d, m).enumerable;
      })), f.push.apply(f, h);
    }
    return f;
  }
  function s(d) {
    for (var p = 1; p < arguments.length; p++) {
      var f = arguments[p] != null ? arguments[p] : {};
      p % 2 ? a(Object(f), !0).forEach(function(h) {
        i(d, h, f[h]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(f)) : a(Object(f)).forEach(function(h) {
        Object.defineProperty(d, h, Object.getOwnPropertyDescriptor(f, h));
      });
    }
    return d;
  }
  function i(d, p, f) {
    return p in d ? Object.defineProperty(d, p, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : d[p] = f, d;
  }
  var o = function(p, f) {
    var h = {}, m = f.selectedItem, y = m, b = e.Children.count(p.children) - 1, v = p.infiniteLoop && (m < 0 || m > b);
    if (v)
      return y < 0 ? p.centerMode && p.centerSlidePercentage && p.axis === "horizontal" ? h.itemListStyle = (0, r.setPosition)(-(b + 2) * p.centerSlidePercentage - (100 - p.centerSlidePercentage) / 2, p.axis) : h.itemListStyle = (0, r.setPosition)(-(b + 2) * 100, p.axis) : y > b && (h.itemListStyle = (0, r.setPosition)(0, p.axis)), h;
    var x = (0, r.getPosition)(m, p), _ = (0, t.default)(x, "%", p.axis), E = p.transitionTime + "ms";
    return h.itemListStyle = {
      WebkitTransform: _,
      msTransform: _,
      OTransform: _,
      transform: _
    }, f.swiping || (h.itemListStyle = s(s({}, h.itemListStyle), {}, {
      WebkitTransitionDuration: E,
      MozTransitionDuration: E,
      OTransitionDuration: E,
      transitionDuration: E,
      msTransitionDuration: E
    })), h;
  };
  Ss.slideAnimationHandler = o;
  var l = function(p, f, h, m) {
    var y = {}, b = f.axis === "horizontal", v = e.Children.count(f.children), x = 0, _ = (0, r.getPosition)(h.selectedItem, f), E = f.infiniteLoop ? (0, r.getPosition)(v - 1, f) - 100 : (0, r.getPosition)(v - 1, f), w = b ? p.x : p.y, C = w;
    _ === x && w > 0 && (C = 0), _ === E && w < 0 && (C = 0);
    var k = _ + 100 / (h.itemSize / C), S = Math.abs(w) > f.swipeScrollTolerance;
    return f.infiniteLoop && S && (h.selectedItem === 0 && k > -100 ? k -= v * 100 : h.selectedItem === v - 1 && k < -v * 100 && (k += v * 100)), (!f.preventMovementUntilSwipeScrollTolerance || S || h.swipeMovementStarted) && (h.swipeMovementStarted || m({
      swipeMovementStarted: !0
    }), y.itemListStyle = (0, r.setPosition)(k, f.axis)), S && !h.cancelClick && m({
      cancelClick: !0
    }), y;
  };
  Ss.slideSwipeAnimationHandler = l;
  var u = function(p, f) {
    var h = (0, r.getPosition)(f.selectedItem, p), m = (0, r.setPosition)(h, p.axis);
    return {
      itemListStyle: m
    };
  };
  Ss.slideStopSwipingHandler = u;
  var c = function(p, f) {
    var h = p.transitionTime + "ms", m = "ease-in-out", y = {
      position: "absolute",
      display: "block",
      zIndex: -2,
      minHeight: "100%",
      opacity: 0,
      top: 0,
      right: 0,
      left: 0,
      bottom: 0,
      transitionTimingFunction: m,
      msTransitionTimingFunction: m,
      MozTransitionTimingFunction: m,
      WebkitTransitionTimingFunction: m,
      OTransitionTimingFunction: m
    };
    return f.swiping || (y = s(s({}, y), {}, {
      WebkitTransitionDuration: h,
      MozTransitionDuration: h,
      OTransitionDuration: h,
      transitionDuration: h,
      msTransitionDuration: h
    })), {
      slideStyle: y,
      selectedStyle: s(s({}, y), {}, {
        opacity: 1,
        position: "relative"
      }),
      prevStyle: s({}, y)
    };
  };
  return Ss.fadeAnimationHandler = c, Ss;
}
var c4;
function Mre() {
  if (c4) return Qd;
  c4 = 1, Object.defineProperty(Qd, "__esModule", {
    value: !0
  }), Qd.default = void 0;
  var e = c(kt), t = l(HU()), r = l(VU()), n = l(WU()), a = l(Pre()), s = l(GU()), i = KU(), o = Lre();
  function l(U) {
    return U && U.__esModule ? U : { default: U };
  }
  function u() {
    if (typeof WeakMap != "function") return null;
    var U = /* @__PURE__ */ new WeakMap();
    return u = function() {
      return U;
    }, U;
  }
  function c(U) {
    if (U && U.__esModule)
      return U;
    if (U === null || d(U) !== "object" && typeof U != "function")
      return { default: U };
    var N = u();
    if (N && N.has(U))
      return N.get(U);
    var O = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var q in U)
      if (Object.prototype.hasOwnProperty.call(U, q)) {
        var ae = I ? Object.getOwnPropertyDescriptor(U, q) : null;
        ae && (ae.get || ae.set) ? Object.defineProperty(O, q, ae) : O[q] = U[q];
      }
    return O.default = U, N && N.set(U, O), O;
  }
  function d(U) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(O) {
      return typeof O;
    } : d = function(O) {
      return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
    }, d(U);
  }
  function p() {
    return p = Object.assign || function(U) {
      for (var N = 1; N < arguments.length; N++) {
        var O = arguments[N];
        for (var I in O)
          Object.prototype.hasOwnProperty.call(O, I) && (U[I] = O[I]);
      }
      return U;
    }, p.apply(this, arguments);
  }
  function f(U, N) {
    var O = Object.keys(U);
    if (Object.getOwnPropertySymbols) {
      var I = Object.getOwnPropertySymbols(U);
      N && (I = I.filter(function(q) {
        return Object.getOwnPropertyDescriptor(U, q).enumerable;
      })), O.push.apply(O, I);
    }
    return O;
  }
  function h(U) {
    for (var N = 1; N < arguments.length; N++) {
      var O = arguments[N] != null ? arguments[N] : {};
      N % 2 ? f(Object(O), !0).forEach(function(I) {
        S(U, I, O[I]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(U, Object.getOwnPropertyDescriptors(O)) : f(Object(O)).forEach(function(I) {
        Object.defineProperty(U, I, Object.getOwnPropertyDescriptor(O, I));
      });
    }
    return U;
  }
  function m(U, N) {
    if (!(U instanceof N))
      throw new TypeError("Cannot call a class as a function");
  }
  function y(U, N) {
    for (var O = 0; O < N.length; O++) {
      var I = N[O];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(U, I.key, I);
    }
  }
  function b(U, N, O) {
    return y(U.prototype, N), U;
  }
  function v(U, N) {
    if (typeof N != "function" && N !== null)
      throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(N && N.prototype, { constructor: { value: U, writable: !0, configurable: !0 } }), N && x(U, N);
  }
  function x(U, N) {
    return x = Object.setPrototypeOf || function(I, q) {
      return I.__proto__ = q, I;
    }, x(U, N);
  }
  function _(U) {
    var N = C();
    return function() {
      var I = k(U), q;
      if (N) {
        var ae = k(this).constructor;
        q = Reflect.construct(I, arguments, ae);
      } else
        q = I.apply(this, arguments);
      return E(this, q);
    };
  }
  function E(U, N) {
    return N && (d(N) === "object" || typeof N == "function") ? N : w(U);
  }
  function w(U) {
    if (U === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function C() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function k(U) {
    return k = Object.setPrototypeOf ? Object.getPrototypeOf : function(O) {
      return O.__proto__ || Object.getPrototypeOf(O);
    }, k(U);
  }
  function S(U, N, O) {
    return N in U ? Object.defineProperty(U, N, { value: O, enumerable: !0, configurable: !0, writable: !0 }) : U[N] = O, U;
  }
  var B = /* @__PURE__ */ function(U) {
    v(O, U);
    var N = _(O);
    function O(I) {
      var q;
      m(this, O), q = N.call(this, I), S(w(q), "thumbsRef", void 0), S(w(q), "carouselWrapperRef", void 0), S(w(q), "listRef", void 0), S(w(q), "itemsRef", void 0), S(w(q), "timer", void 0), S(w(q), "animationHandler", void 0), S(w(q), "setThumbsRef", function(Q) {
        q.thumbsRef = Q;
      }), S(w(q), "setCarouselWrapperRef", function(Q) {
        q.carouselWrapperRef = Q;
      }), S(w(q), "setListRef", function(Q) {
        q.listRef = Q;
      }), S(w(q), "setItemsRef", function(Q, ne) {
        q.itemsRef || (q.itemsRef = []), q.itemsRef[ne] = Q;
      }), S(w(q), "autoPlay", function() {
        e.Children.count(q.props.children) <= 1 || (q.clearAutoPlay(), q.props.autoPlay && (q.timer = setTimeout(function() {
          q.increment();
        }, q.props.interval)));
      }), S(w(q), "clearAutoPlay", function() {
        q.timer && clearTimeout(q.timer);
      }), S(w(q), "resetAutoPlay", function() {
        q.clearAutoPlay(), q.autoPlay();
      }), S(w(q), "stopOnHover", function() {
        q.setState({
          isMouseEntered: !0
        }, q.clearAutoPlay);
      }), S(w(q), "startOnLeave", function() {
        q.setState({
          isMouseEntered: !1
        }, q.autoPlay);
      }), S(w(q), "isFocusWithinTheCarousel", function() {
        return q.carouselWrapperRef ? !!((0, a.default)().activeElement === q.carouselWrapperRef || q.carouselWrapperRef.contains((0, a.default)().activeElement)) : !1;
      }), S(w(q), "navigateWithKeyboard", function(Q) {
        if (q.isFocusWithinTheCarousel()) {
          var ne = q.props.axis, le = ne === "horizontal", W = {
            ArrowUp: 38,
            ArrowRight: 39,
            ArrowDown: 40,
            ArrowLeft: 37
          }, X = le ? W.ArrowRight : W.ArrowDown, G = le ? W.ArrowLeft : W.ArrowUp;
          X === Q.keyCode ? q.increment() : G === Q.keyCode && q.decrement();
        }
      }), S(w(q), "updateSizes", function() {
        if (!(!q.state.initialized || !q.itemsRef || q.itemsRef.length === 0)) {
          var Q = q.props.axis === "horizontal", ne = q.itemsRef[0];
          if (ne) {
            var le = Q ? ne.clientWidth : ne.clientHeight;
            q.setState({
              itemSize: le
            }), q.thumbsRef && q.thumbsRef.updateSizes();
          }
        }
      }), S(w(q), "setMountState", function() {
        q.setState({
          hasMount: !0
        }), q.updateSizes();
      }), S(w(q), "handleClickItem", function(Q, ne) {
        if (e.Children.count(q.props.children) !== 0) {
          if (q.state.cancelClick) {
            q.setState({
              cancelClick: !1
            });
            return;
          }
          q.props.onClickItem(Q, ne), Q !== q.state.selectedItem && q.setState({
            selectedItem: Q
          });
        }
      }), S(w(q), "handleOnChange", function(Q, ne) {
        e.Children.count(q.props.children) <= 1 || q.props.onChange(Q, ne);
      }), S(w(q), "handleClickThumb", function(Q, ne) {
        q.props.onClickThumb(Q, ne), q.moveTo(Q);
      }), S(w(q), "onSwipeStart", function(Q) {
        q.setState({
          swiping: !0
        }), q.props.onSwipeStart(Q);
      }), S(w(q), "onSwipeEnd", function(Q) {
        q.setState({
          swiping: !1,
          cancelClick: !1,
          swipeMovementStarted: !1
        }), q.props.onSwipeEnd(Q), q.clearAutoPlay(), q.state.autoPlay && q.autoPlay();
      }), S(w(q), "onSwipeMove", function(Q, ne) {
        q.props.onSwipeMove(ne);
        var le = q.props.swipeAnimationHandler(Q, q.props, q.state, q.setState.bind(w(q)));
        return q.setState(h({}, le)), !!Object.keys(le).length;
      }), S(w(q), "decrement", function() {
        var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        q.moveTo(q.state.selectedItem - (typeof Q == "number" ? Q : 1));
      }), S(w(q), "increment", function() {
        var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        q.moveTo(q.state.selectedItem + (typeof Q == "number" ? Q : 1));
      }), S(w(q), "moveTo", function(Q) {
        if (typeof Q == "number") {
          var ne = e.Children.count(q.props.children) - 1;
          Q < 0 && (Q = q.props.infiniteLoop ? ne : 0), Q > ne && (Q = q.props.infiniteLoop ? 0 : ne), q.selectItem({
            // if it's not a slider, we don't need to set position here
            selectedItem: Q
          }), q.state.autoPlay && q.state.isMouseEntered === !1 && q.resetAutoPlay();
        }
      }), S(w(q), "onClickNext", function() {
        q.increment(1);
      }), S(w(q), "onClickPrev", function() {
        q.decrement(1);
      }), S(w(q), "onSwipeForward", function() {
        q.increment(1), q.props.emulateTouch && q.setState({
          cancelClick: !0
        });
      }), S(w(q), "onSwipeBackwards", function() {
        q.decrement(1), q.props.emulateTouch && q.setState({
          cancelClick: !0
        });
      }), S(w(q), "changeItem", function(Q) {
        return function(ne) {
          (!(0, i.isKeyboardEvent)(ne) || ne.key === "Enter") && q.moveTo(Q);
        };
      }), S(w(q), "selectItem", function(Q) {
        q.setState(h({
          previousItem: q.state.selectedItem
        }, Q), function() {
          q.setState(q.animationHandler(q.props, q.state));
        }), q.handleOnChange(Q.selectedItem, e.Children.toArray(q.props.children)[Q.selectedItem]);
      }), S(w(q), "getInitialImage", function() {
        var Q = q.props.selectedItem, ne = q.itemsRef && q.itemsRef[Q], le = ne && ne.getElementsByTagName("img") || [];
        return le[0];
      }), S(w(q), "getVariableItemHeight", function(Q) {
        var ne = q.itemsRef && q.itemsRef[Q];
        if (q.state.hasMount && ne && ne.children.length) {
          var le = ne.children[0].getElementsByTagName("img") || [];
          if (le.length > 0) {
            var W = le[0];
            if (!W.complete) {
              var X = function he() {
                q.forceUpdate(), W.removeEventListener("load", he);
              };
              W.addEventListener("load", X);
            }
          }
          var G = le[0] || ne.children[0], P = G.clientHeight;
          return P > 0 ? P : null;
        }
        return null;
      });
      var ae = {
        initialized: !1,
        previousItem: I.selectedItem,
        selectedItem: I.selectedItem,
        hasMount: !1,
        isMouseEntered: !1,
        autoPlay: I.autoPlay,
        swiping: !1,
        swipeMovementStarted: !1,
        cancelClick: !1,
        itemSize: 1,
        itemListStyle: {},
        slideStyle: {},
        selectedStyle: {},
        prevStyle: {}
      };
      return q.animationHandler = typeof I.animationHandler == "function" && I.animationHandler || I.animationHandler === "fade" && o.fadeAnimationHandler || o.slideAnimationHandler, q.state = h(h({}, ae), q.animationHandler(I, ae)), q;
    }
    return b(O, [{
      key: "componentDidMount",
      value: function() {
        this.props.children && this.setupCarousel();
      }
    }, {
      key: "componentDidUpdate",
      value: function(q, ae) {
        !q.children && this.props.children && !this.state.initialized && this.setupCarousel(), !q.autoFocus && this.props.autoFocus && this.forceFocus(), ae.swiping && !this.state.swiping && this.setState(h({}, this.props.stopSwipingHandler(this.props, this.state))), (q.selectedItem !== this.props.selectedItem || q.centerMode !== this.props.centerMode) && (this.updateSizes(), this.moveTo(this.props.selectedItem)), q.autoPlay !== this.props.autoPlay && (this.props.autoPlay ? this.setupAutoPlay() : this.destroyAutoPlay(), this.setState({
          autoPlay: this.props.autoPlay
        }));
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.destroyCarousel();
      }
    }, {
      key: "setupCarousel",
      value: function() {
        var q = this;
        this.bindEvents(), this.state.autoPlay && e.Children.count(this.props.children) > 1 && this.setupAutoPlay(), this.props.autoFocus && this.forceFocus(), this.setState({
          initialized: !0
        }, function() {
          var ae = q.getInitialImage();
          ae && !ae.complete ? ae.addEventListener("load", q.setMountState) : q.setMountState();
        });
      }
    }, {
      key: "destroyCarousel",
      value: function() {
        this.state.initialized && (this.unbindEvents(), this.destroyAutoPlay());
      }
    }, {
      key: "setupAutoPlay",
      value: function() {
        this.autoPlay();
        var q = this.carouselWrapperRef;
        this.props.stopOnHover && q && (q.addEventListener("mouseenter", this.stopOnHover), q.addEventListener("mouseleave", this.startOnLeave));
      }
    }, {
      key: "destroyAutoPlay",
      value: function() {
        this.clearAutoPlay();
        var q = this.carouselWrapperRef;
        this.props.stopOnHover && q && (q.removeEventListener("mouseenter", this.stopOnHover), q.removeEventListener("mouseleave", this.startOnLeave));
      }
    }, {
      key: "bindEvents",
      value: function() {
        (0, s.default)().addEventListener("resize", this.updateSizes), (0, s.default)().addEventListener("DOMContentLoaded", this.updateSizes), this.props.useKeyboardArrows && (0, a.default)().addEventListener("keydown", this.navigateWithKeyboard);
      }
    }, {
      key: "unbindEvents",
      value: function() {
        (0, s.default)().removeEventListener("resize", this.updateSizes), (0, s.default)().removeEventListener("DOMContentLoaded", this.updateSizes);
        var q = this.getInitialImage();
        q && q.removeEventListener("load", this.setMountState), this.props.useKeyboardArrows && (0, a.default)().removeEventListener("keydown", this.navigateWithKeyboard);
      }
    }, {
      key: "forceFocus",
      value: function() {
        var q;
        (q = this.carouselWrapperRef) === null || q === void 0 || q.focus();
      }
    }, {
      key: "renderItems",
      value: function(q) {
        var ae = this;
        return this.props.children ? e.Children.map(this.props.children, function(Q, ne) {
          var le = ne === ae.state.selectedItem, W = ne === ae.state.previousItem, X = le && ae.state.selectedStyle || W && ae.state.prevStyle || ae.state.slideStyle || {};
          ae.props.centerMode && ae.props.axis === "horizontal" && (X = h(h({}, X), {}, {
            minWidth: ae.props.centerSlidePercentage + "%"
          })), ae.state.swiping && ae.state.swipeMovementStarted && (X = h(h({}, X), {}, {
            pointerEvents: "none"
          }));
          var G = {
            ref: function(he) {
              return ae.setItemsRef(he, ne);
            },
            key: "itemKey" + ne + (q ? "clone" : ""),
            className: r.default.ITEM(!0, ne === ae.state.selectedItem, ne === ae.state.previousItem),
            onClick: ae.handleClickItem.bind(ae, ne, Q),
            style: X
          };
          return /* @__PURE__ */ e.default.createElement("li", G, ae.props.renderItem(Q, {
            isSelected: ne === ae.state.selectedItem,
            isPrevious: ne === ae.state.previousItem
          }));
        }) : [];
      }
    }, {
      key: "renderControls",
      value: function() {
        var q = this, ae = this.props, Q = ae.showIndicators, ne = ae.labels, le = ae.renderIndicator, W = ae.children;
        return Q ? /* @__PURE__ */ e.default.createElement("ul", {
          className: "control-dots"
        }, e.Children.map(W, function(X, G) {
          return le && le(q.changeItem(G), G === q.state.selectedItem, G, ne.item);
        })) : null;
      }
    }, {
      key: "renderStatus",
      value: function() {
        return this.props.showStatus ? /* @__PURE__ */ e.default.createElement("p", {
          className: "carousel-status"
        }, this.props.statusFormatter(this.state.selectedItem + 1, e.Children.count(this.props.children))) : null;
      }
    }, {
      key: "renderThumbs",
      value: function() {
        return !this.props.showThumbs || !this.props.children || e.Children.count(this.props.children) === 0 ? null : /* @__PURE__ */ e.default.createElement(n.default, {
          ref: this.setThumbsRef,
          onSelectItem: this.handleClickThumb,
          selectedItem: this.state.selectedItem,
          transitionTime: this.props.transitionTime,
          thumbWidth: this.props.thumbWidth,
          labels: this.props.labels,
          emulateTouch: this.props.emulateTouch
        }, this.props.renderThumbs(this.props.children));
      }
    }, {
      key: "render",
      value: function() {
        var q = this;
        if (!this.props.children || e.Children.count(this.props.children) === 0)
          return null;
        var ae = this.props.swipeable && e.Children.count(this.props.children) > 1, Q = this.props.axis === "horizontal", ne = this.props.showArrows && e.Children.count(this.props.children) > 1, le = ne && (this.state.selectedItem > 0 || this.props.infiniteLoop) || !1, W = ne && (this.state.selectedItem < e.Children.count(this.props.children) - 1 || this.props.infiniteLoop) || !1, X = this.renderItems(!0), G = X.shift(), P = X.pop(), he = {
          className: r.default.SLIDER(!0, this.state.swiping),
          onSwipeMove: this.onSwipeMove,
          onSwipeStart: this.onSwipeStart,
          onSwipeEnd: this.onSwipeEnd,
          style: this.state.itemListStyle,
          tolerance: this.props.swipeScrollTolerance
        }, ye = {};
        if (Q) {
          if (he.onSwipeLeft = this.onSwipeForward, he.onSwipeRight = this.onSwipeBackwards, this.props.dynamicHeight) {
            var pe = this.getVariableItemHeight(this.state.selectedItem);
            ye.height = pe || "auto";
          }
        } else
          he.onSwipeUp = this.props.verticalSwipe === "natural" ? this.onSwipeBackwards : this.onSwipeForward, he.onSwipeDown = this.props.verticalSwipe === "natural" ? this.onSwipeForward : this.onSwipeBackwards, he.style = h(h({}, he.style), {}, {
            height: this.state.itemSize
          }), ye.height = this.state.itemSize;
        return /* @__PURE__ */ e.default.createElement("div", {
          "aria-label": this.props.ariaLabel,
          className: r.default.ROOT(this.props.className),
          ref: this.setCarouselWrapperRef,
          tabIndex: this.props.useKeyboardArrows ? 0 : void 0
        }, /* @__PURE__ */ e.default.createElement("div", {
          className: r.default.CAROUSEL(!0),
          style: {
            width: this.props.width
          }
        }, this.renderControls(), this.props.renderArrowPrev(this.onClickPrev, le, this.props.labels.leftArrow), /* @__PURE__ */ e.default.createElement("div", {
          className: r.default.WRAPPER(!0, this.props.axis),
          style: ye
        }, ae ? /* @__PURE__ */ e.default.createElement(t.default, p({
          tagName: "ul",
          innerRef: this.setListRef
        }, he, {
          allowMouseEvents: this.props.emulateTouch
        }), this.props.infiniteLoop && P, this.renderItems(), this.props.infiniteLoop && G) : /* @__PURE__ */ e.default.createElement("ul", {
          className: r.default.SLIDER(!0, this.state.swiping),
          ref: function(F) {
            return q.setListRef(F);
          },
          style: this.state.itemListStyle || {}
        }, this.props.infiniteLoop && P, this.renderItems(), this.props.infiniteLoop && G)), this.props.renderArrowNext(this.onClickNext, W, this.props.labels.rightArrow), this.renderStatus()), this.renderThumbs());
      }
    }]), O;
  }(e.default.Component);
  return Qd.default = B, S(B, "displayName", "Carousel"), S(B, "defaultProps", {
    ariaLabel: void 0,
    axis: "horizontal",
    centerSlidePercentage: 80,
    interval: 3e3,
    labels: {
      leftArrow: "previous slide / item",
      rightArrow: "next slide / item",
      item: "slide item"
    },
    onClickItem: i.noop,
    onClickThumb: i.noop,
    onChange: i.noop,
    onSwipeStart: function() {
    },
    onSwipeEnd: function() {
    },
    onSwipeMove: function() {
      return !1;
    },
    preventMovementUntilSwipeScrollTolerance: !1,
    renderArrowPrev: function(N, O, I) {
      return /* @__PURE__ */ e.default.createElement("button", {
        type: "button",
        "aria-label": I,
        className: r.default.ARROW_PREV(!O),
        onClick: N
      });
    },
    renderArrowNext: function(N, O, I) {
      return /* @__PURE__ */ e.default.createElement("button", {
        type: "button",
        "aria-label": I,
        className: r.default.ARROW_NEXT(!O),
        onClick: N
      });
    },
    renderIndicator: function(N, O, I, q) {
      return /* @__PURE__ */ e.default.createElement("li", {
        className: r.default.DOT(O),
        onClick: N,
        onKeyDown: N,
        value: I,
        key: I,
        role: "button",
        tabIndex: 0,
        "aria-label": "".concat(q, " ").concat(I + 1)
      });
    },
    renderItem: function(N) {
      return N;
    },
    renderThumbs: function(N) {
      var O = e.Children.map(N, function(I) {
        var q = I;
        if (I.type !== "img" && (q = e.Children.toArray(I.props.children).find(function(ae) {
          return ae.type === "img";
        })), !!q)
          return q;
      });
      return O.filter(function(I) {
        return I;
      }).length === 0 ? (console.warn("No images found! Can't build the thumb list without images. If you don't need thumbs, set showThumbs={false} in the Carousel. Note that it's not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md"), []) : O;
    },
    statusFormatter: i.defaultStatusFormatter,
    selectedItem: 0,
    showArrows: !0,
    showIndicators: !0,
    showStatus: !0,
    showThumbs: !0,
    stopOnHover: !0,
    swipeScrollTolerance: 5,
    swipeable: !0,
    transitionTime: 350,
    verticalSwipe: "standard",
    width: "100%",
    animationHandler: "slide",
    swipeAnimationHandler: o.slideSwipeAnimationHandler,
    stopSwipingHandler: o.slideStopSwipingHandler
  }), Qd;
}
var d4 = {}, f4;
function Fre() {
  return f4 || (f4 = 1), d4;
}
var p4;
function $re() {
  return p4 || (p4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "Carousel", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "CarouselProps", {
      enumerable: !0,
      get: function() {
        return r.CarouselProps;
      }
    }), Object.defineProperty(e, "Thumbs", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    });
    var t = a(Mre()), r = Fre(), n = a(WU());
    function a(s) {
      return s && s.__esModule ? s : { default: s };
    }
  }(s0)), s0;
}
var Bre = $re(), h0, h4;
function Ure() {
  if (h4) return h0;
  h4 = 1;
  var e = po(), t = function() {
    return e.Date.now();
  };
  return h0 = t, h0;
}
var m0, m4;
function zre() {
  if (m4) return m0;
  m4 = 1;
  var e = /\s/;
  function t(r) {
    for (var n = r.length; n-- && e.test(r.charAt(n)); )
      ;
    return n;
  }
  return m0 = t, m0;
}
var g0, g4;
function qre() {
  if (g4) return g0;
  g4 = 1;
  var e = zre(), t = /^\s+/;
  function r(n) {
    return n && n.slice(0, e(n) + 1).replace(t, "");
  }
  return g0 = r, g0;
}
var b0, b4;
function NI() {
  if (b4) return b0;
  b4 = 1;
  var e = qre(), t = Fu(), r = Tb(), n = NaN, a = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, i = /^0o[0-7]+$/i, o = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (t(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = t(c) ? c + "" : c;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = e(u);
    var d = s.test(u);
    return d || i.test(u) ? o(u.slice(2), d ? 2 : 8) : a.test(u) ? n : +u;
  }
  return b0 = l, b0;
}
var y0, y4;
function YU() {
  if (y4) return y0;
  y4 = 1;
  var e = Fu(), t = Ure(), r = NI(), n = "Expected a function", a = Math.max, s = Math.min;
  function i(o, l, u) {
    var c, d, p, f, h, m, y = 0, b = !1, v = !1, x = !0;
    if (typeof o != "function")
      throw new TypeError(n);
    l = r(l) || 0, e(u) && (b = !!u.leading, v = "maxWait" in u, p = v ? a(r(u.maxWait) || 0, l) : p, x = "trailing" in u ? !!u.trailing : x);
    function _(O) {
      var I = c, q = d;
      return c = d = void 0, y = O, f = o.apply(q, I), f;
    }
    function E(O) {
      return y = O, h = setTimeout(k, l), b ? _(O) : f;
    }
    function w(O) {
      var I = O - m, q = O - y, ae = l - I;
      return v ? s(ae, p - q) : ae;
    }
    function C(O) {
      var I = O - m, q = O - y;
      return m === void 0 || I >= l || I < 0 || v && q >= p;
    }
    function k() {
      var O = t();
      if (C(O))
        return S(O);
      h = setTimeout(k, w(O));
    }
    function S(O) {
      return h = void 0, x && c ? _(O) : (c = d = void 0, f);
    }
    function B() {
      h !== void 0 && clearTimeout(h), y = 0, c = m = d = h = void 0;
    }
    function U() {
      return h === void 0 ? f : S(t());
    }
    function N() {
      var O = t(), I = C(O);
      if (c = arguments, d = this, m = O, I) {
        if (h === void 0)
          return E(m);
        if (v)
          return clearTimeout(h), h = setTimeout(k, l), _(m);
      }
      return h === void 0 && (h = setTimeout(k, l)), f;
    }
    return N.cancel = B, N.flush = U, N;
  }
  return y0 = i, y0;
}
var jre = YU();
const XU = /* @__PURE__ */ da(jre);
function Oi(e, t, r, n, a = !1) {
  const s = D.useRef();
  s.current = t, D.useEffect(
    () => {
      if (r === null || r.addEventListener === void 0)
        return;
      const i = r, o = (l) => {
        s.current?.call(i, l);
      };
      return i.addEventListener(e, o, { passive: n, capture: a }), () => {
        i.removeEventListener(e, o, { capture: a });
      };
    },
    [e, r, n, a]
    // Re-run if eventName or element changes
  );
}
function lc(e, t) {
  return e === void 0 ? void 0 : t;
}
const Hre = Math.PI;
function v4(e) {
  return e * Hre / 180;
}
const ZU = (e, t, r) => ({
  x1: e - r / 2,
  y1: t - r / 2,
  x2: e + r / 2,
  y2: t + r / 2
}), JU = (e, t, r, n, a) => {
  switch (e) {
    case "left":
      return Math.floor(t) + n + a / 2;
    case "center":
      return Math.floor(t + r / 2);
    case "right":
      return Math.floor(t + r) - n - a / 2;
  }
}, QU = (e, t, r) => Math.min(e, t - r * 2), ez = (e, t, r) => r.x1 <= e && e <= r.x2 && r.y1 <= t && t <= r.y2, DI = (e) => {
  const t = e.fgColor ?? "currentColor";
  return D.createElement(
    "svg",
    { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
    D.createElement("path", { d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929", stroke: t, strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", fill: "none", vectorEffect: "non-scaling-stroke" }),
    D.createElement("path", { d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z", stroke: t, strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", fill: "none", vectorEffect: "non-scaling-stroke" })
  );
}, Vre = (e) => {
  const t = e.fgColor ?? "currentColor";
  return D.createElement(
    "svg",
    { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
    D.createElement("path", { d: "M19 6L10.3802 17L5.34071 11.8758", vectorEffect: "non-scaling-stroke", stroke: t, strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
  );
};
function Gre(e, t, r) {
  const [n, a] = D.useState(e), s = D.useRef(!0);
  D.useEffect(() => () => {
    s.current = !1;
  }, []);
  const i = D.useRef(XU((o) => {
    s.current && a(o);
  }, r));
  return D.useLayoutEffect(() => {
    s.current && i.current(() => e());
  }, t), n;
}
const Wre = "֑-߿יִ-﷽ﹰ-ﻼ", Kre = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Yre = new RegExp("^[^" + Kre + "]*[" + Wre + "]");
function OI(e) {
  return Yre.test(e) ? "rtl" : "not-rtl";
}
let tm;
function MT() {
  if (typeof document > "u")
    return 0;
  if (tm !== void 0)
    return tm;
  const e = document.createElement("p");
  e.style.width = "100%", e.style.height = "200px";
  const t = document.createElement("div");
  t.id = "testScrollbar", t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.visibility = "hidden", t.style.width = "200px", t.style.height = "150px", t.style.overflow = "hidden", t.append(e), document.body.append(t);
  const r = e.offsetWidth;
  t.style.overflow = "scroll";
  let n = e.offsetWidth;
  return r === n && (n = t.clientWidth), t.remove(), tm = r - n, tm;
}
const ou = Symbol();
function Xre(e) {
  const t = D.useRef([ou, e]);
  t.current[1] !== e && (t.current[0] = e), t.current[1] = e;
  const [r, n] = D.useState(e), [, a] = D.useState(), s = D.useCallback((o) => {
    const l = t.current[0];
    l !== ou && (o = typeof o == "function" ? o(l) : o, o === l) || (l !== ou && a({}), n((u) => typeof o == "function" ? o(l === ou ? u : l) : o), t.current[0] = ou);
  }, []), i = D.useCallback(() => {
    t.current[0] = ou, a({});
  }, []);
  return [t.current[0] === ou ? r : t.current[0], s, i];
}
function tz(e) {
  if (e.length === 0)
    return "";
  let t = 0, r = 0;
  for (const n of e) {
    if (r += n.length, r > 1e4)
      break;
    t++;
  }
  return e.slice(0, t).join(", ");
}
function Zre(e) {
  const t = D.useRef(e);
  return rd(e, t.current) || (t.current = e), t.current;
}
const Jre = (e) => {
  const { urls: t, canWrite: r, onEditClick: n, renderImage: a } = e, s = t.filter((o) => o !== "");
  if (s.length === 0)
    return null;
  const i = s.length > 1;
  return D.createElement(
    Sre,
    { "data-testid": "GDG-default-image-overlay-editor" },
    D.createElement(Bre.Carousel, { showArrows: i, showThumbs: !1, swipeable: i, emulateTouch: i, infiniteLoop: i }, s.map((o) => {
      const l = a?.(o) ?? D.createElement("img", { draggable: !1, src: o });
      return D.createElement("div", { className: "gdg-centering-container", key: o }, l);
    })),
    r && n && D.createElement(
      "button",
      { className: "gdg-edit-icon", onClick: n },
      D.createElement(DI, null)
    )
  );
};
function rz() {
  return {
    async: !1,
    baseUrl: null,
    breaks: !1,
    extensions: null,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartypants: !1,
    tokenizer: null,
    walkTokens: null,
    xhtml: !1
  };
}
let Bu = rz();
function Qre(e) {
  Bu = e;
}
const nz = /[&<>"']/, ene = new RegExp(nz.source, "g"), iz = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, tne = new RegExp(iz.source, "g"), rne = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, w4 = (e) => rne[e];
function Bi(e, t) {
  if (t) {
    if (nz.test(e))
      return e.replace(ene, w4);
  } else if (iz.test(e))
    return e.replace(tne, w4);
  return e;
}
const nne = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function az(e) {
  return e.replace(nne, (t, r) => (r = r.toLowerCase(), r === "colon" ? ":" : r.charAt(0) === "#" ? r.charAt(1) === "x" ? String.fromCharCode(parseInt(r.substring(2), 16)) : String.fromCharCode(+r.substring(1)) : ""));
}
const ine = /(^|[^\[])\^/g;
function Un(e, t) {
  e = typeof e == "string" ? e : e.source, t = t || "";
  const r = {
    replace: (n, a) => (a = a.source || a, a = a.replace(ine, "$1"), e = e.replace(n, a), r),
    getRegex: () => new RegExp(e, t)
  };
  return r;
}
const ane = /[^\w:]/g, sne = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function x4(e, t, r) {
  if (e) {
    let n;
    try {
      n = decodeURIComponent(az(r)).replace(ane, "").toLowerCase();
    } catch {
      return null;
    }
    if (n.indexOf("javascript:") === 0 || n.indexOf("vbscript:") === 0 || n.indexOf("data:") === 0)
      return null;
  }
  t && !sne.test(r) && (r = cne(t, r));
  try {
    r = encodeURI(r).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return r;
}
const rm = {}, one = /^[^:]+:\/*[^/]*$/, lne = /^([^:]+:)[\s\S]*$/, une = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function cne(e, t) {
  rm[" " + e] || (one.test(e) ? rm[" " + e] = e + "/" : rm[" " + e] = ag(e, "/", !0)), e = rm[" " + e];
  const r = e.indexOf(":") === -1;
  return t.substring(0, 2) === "//" ? r ? t : e.replace(lne, "$1") + t : t.charAt(0) === "/" ? r ? t : e.replace(une, "$1") + t : e + t;
}
const Ig = { exec: function() {
} };
function E4(e, t) {
  const r = e.replace(/\|/g, (s, i, o) => {
    let l = !1, u = i;
    for (; --u >= 0 && o[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(/ \|/);
  let a = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), n.length > t)
    n.splice(t);
  else
    for (; n.length < t; ) n.push("");
  for (; a < n.length; a++)
    n[a] = n[a].trim().replace(/\\\|/g, "|");
  return n;
}
function ag(e, t, r) {
  const n = e.length;
  if (n === 0)
    return "";
  let a = 0;
  for (; a < n; ) {
    const s = e.charAt(n - a - 1);
    if (s === t && !r)
      a++;
    else if (s !== t && r)
      a++;
    else
      break;
  }
  return e.slice(0, n - a);
}
function dne(e, t) {
  if (e.indexOf(t[1]) === -1)
    return -1;
  const r = e.length;
  let n = 0, a = 0;
  for (; a < r; a++)
    if (e[a] === "\\")
      a++;
    else if (e[a] === t[0])
      n++;
    else if (e[a] === t[1] && (n--, n < 0))
      return a;
  return -1;
}
function fne(e) {
  e && e.sanitize && !e.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
}
function S4(e, t) {
  if (t < 1)
    return "";
  let r = "";
  for (; t > 1; )
    t & 1 && (r += e), t >>= 1, e += e;
  return r + e;
}
function _4(e, t, r, n) {
  const a = t.href, s = t.title ? Bi(t.title) : null, i = e[1].replace(/\\([\[\]])/g, "$1");
  if (e[0].charAt(0) !== "!") {
    n.state.inLink = !0;
    const o = {
      type: "link",
      raw: r,
      href: a,
      title: s,
      text: i,
      tokens: n.inlineTokens(i)
    };
    return n.state.inLink = !1, o;
  }
  return {
    type: "image",
    raw: r,
    href: a,
    title: s,
    text: Bi(i)
  };
}
function pne(e, t) {
  const r = e.match(/^(\s+)(?:```)/);
  if (r === null)
    return t;
  const n = r[1];
  return t.split(`
`).map((a) => {
    const s = a.match(/^\s+/);
    if (s === null)
      return a;
    const [i] = s;
    return i.length >= n.length ? a.slice(n.length) : a;
  }).join(`
`);
}
class PI {
  constructor(t) {
    this.options = t || Bu;
  }
  space(t) {
    const r = this.rules.block.newline.exec(t);
    if (r && r[0].length > 0)
      return {
        type: "space",
        raw: r[0]
      };
  }
  code(t) {
    const r = this.rules.block.code.exec(t);
    if (r) {
      const n = r[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: r[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? n : ag(n, `
`)
      };
    }
  }
  fences(t) {
    const r = this.rules.block.fences.exec(t);
    if (r) {
      const n = r[0], a = pne(n, r[3] || "");
      return {
        type: "code",
        raw: n,
        lang: r[2] ? r[2].trim().replace(this.rules.inline._escapes, "$1") : r[2],
        text: a
      };
    }
  }
  heading(t) {
    const r = this.rules.block.heading.exec(t);
    if (r) {
      let n = r[2].trim();
      if (/#$/.test(n)) {
        const a = ag(n, "#");
        (this.options.pedantic || !a || / $/.test(a)) && (n = a.trim());
      }
      return {
        type: "heading",
        raw: r[0],
        depth: r[1].length,
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  hr(t) {
    const r = this.rules.block.hr.exec(t);
    if (r)
      return {
        type: "hr",
        raw: r[0]
      };
  }
  blockquote(t) {
    const r = this.rules.block.blockquote.exec(t);
    if (r) {
      const n = r[0].replace(/^ *>[ \t]?/gm, ""), a = this.lexer.state.top;
      this.lexer.state.top = !0;
      const s = this.lexer.blockTokens(n);
      return this.lexer.state.top = a, {
        type: "blockquote",
        raw: r[0],
        tokens: s,
        text: n
      };
    }
  }
  list(t) {
    let r = this.rules.block.list.exec(t);
    if (r) {
      let n, a, s, i, o, l, u, c, d, p, f, h, m = r[1].trim();
      const y = m.length > 1, b = {
        type: "list",
        raw: "",
        ordered: y,
        start: y ? +m.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      m = y ? `\\d{1,9}\\${m.slice(-1)}` : `\\${m}`, this.options.pedantic && (m = y ? m : "[*+-]");
      const v = new RegExp(`^( {0,3}${m})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      for (; t && (h = !1, !(!(r = v.exec(t)) || this.rules.block.hr.test(t))); ) {
        if (n = r[0], t = t.substring(n.length), c = r[2].split(`
`, 1)[0].replace(/^\t+/, (_) => " ".repeat(3 * _.length)), d = t.split(`
`, 1)[0], this.options.pedantic ? (i = 2, f = c.trimLeft()) : (i = r[2].search(/[^ ]/), i = i > 4 ? 1 : i, f = c.slice(i), i += r[1].length), l = !1, !c && /^ *$/.test(d) && (n += d + `
`, t = t.substring(d.length + 1), h = !0), !h) {
          const _ = new RegExp(`^ {0,${Math.min(3, i - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), E = new RegExp(`^ {0,${Math.min(3, i - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), w = new RegExp(`^ {0,${Math.min(3, i - 1)}}(?:\`\`\`|~~~)`), C = new RegExp(`^ {0,${Math.min(3, i - 1)}}#`);
          for (; t && (p = t.split(`
`, 1)[0], d = p, this.options.pedantic && (d = d.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(w.test(d) || C.test(d) || _.test(d) || E.test(t))); ) {
            if (d.search(/[^ ]/) >= i || !d.trim())
              f += `
` + d.slice(i);
            else {
              if (l || c.search(/[^ ]/) >= 4 || w.test(c) || C.test(c) || E.test(c))
                break;
              f += `
` + d;
            }
            !l && !d.trim() && (l = !0), n += p + `
`, t = t.substring(p.length + 1), c = d.slice(i);
          }
        }
        b.loose || (u ? b.loose = !0 : /\n *\n *$/.test(n) && (u = !0)), this.options.gfm && (a = /^\[[ xX]\] /.exec(f), a && (s = a[0] !== "[ ] ", f = f.replace(/^\[[ xX]\] +/, ""))), b.items.push({
          type: "list_item",
          raw: n,
          task: !!a,
          checked: s,
          loose: !1,
          text: f
        }), b.raw += n;
      }
      b.items[b.items.length - 1].raw = n.trimRight(), b.items[b.items.length - 1].text = f.trimRight(), b.raw = b.raw.trimRight();
      const x = b.items.length;
      for (o = 0; o < x; o++)
        if (this.lexer.state.top = !1, b.items[o].tokens = this.lexer.blockTokens(b.items[o].text, []), !b.loose) {
          const _ = b.items[o].tokens.filter((w) => w.type === "space"), E = _.length > 0 && _.some((w) => /\n.*\n/.test(w.raw));
          b.loose = E;
        }
      if (b.loose)
        for (o = 0; o < x; o++)
          b.items[o].loose = !0;
      return b;
    }
  }
  html(t) {
    const r = this.rules.block.html.exec(t);
    if (r) {
      const n = {
        type: "html",
        raw: r[0],
        pre: !this.options.sanitizer && (r[1] === "pre" || r[1] === "script" || r[1] === "style"),
        text: r[0]
      };
      if (this.options.sanitize) {
        const a = this.options.sanitizer ? this.options.sanitizer(r[0]) : Bi(r[0]);
        n.type = "paragraph", n.text = a, n.tokens = this.lexer.inline(a);
      }
      return n;
    }
  }
  def(t) {
    const r = this.rules.block.def.exec(t);
    if (r) {
      const n = r[1].toLowerCase().replace(/\s+/g, " "), a = r[2] ? r[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", s = r[3] ? r[3].substring(1, r[3].length - 1).replace(this.rules.inline._escapes, "$1") : r[3];
      return {
        type: "def",
        tag: n,
        raw: r[0],
        href: a,
        title: s
      };
    }
  }
  table(t) {
    const r = this.rules.block.table.exec(t);
    if (r) {
      const n = {
        type: "table",
        header: E4(r[1]).map((a) => ({ text: a })),
        align: r[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: r[3] && r[3].trim() ? r[3].replace(/\n[ \t]*$/, "").split(`
`) : []
      };
      if (n.header.length === n.align.length) {
        n.raw = r[0];
        let a = n.align.length, s, i, o, l;
        for (s = 0; s < a; s++)
          /^ *-+: *$/.test(n.align[s]) ? n.align[s] = "right" : /^ *:-+: *$/.test(n.align[s]) ? n.align[s] = "center" : /^ *:-+ *$/.test(n.align[s]) ? n.align[s] = "left" : n.align[s] = null;
        for (a = n.rows.length, s = 0; s < a; s++)
          n.rows[s] = E4(n.rows[s], n.header.length).map((u) => ({ text: u }));
        for (a = n.header.length, i = 0; i < a; i++)
          n.header[i].tokens = this.lexer.inline(n.header[i].text);
        for (a = n.rows.length, i = 0; i < a; i++)
          for (l = n.rows[i], o = 0; o < l.length; o++)
            l[o].tokens = this.lexer.inline(l[o].text);
        return n;
      }
    }
  }
  lheading(t) {
    const r = this.rules.block.lheading.exec(t);
    if (r)
      return {
        type: "heading",
        raw: r[0],
        depth: r[2].charAt(0) === "=" ? 1 : 2,
        text: r[1],
        tokens: this.lexer.inline(r[1])
      };
  }
  paragraph(t) {
    const r = this.rules.block.paragraph.exec(t);
    if (r) {
      const n = r[1].charAt(r[1].length - 1) === `
` ? r[1].slice(0, -1) : r[1];
      return {
        type: "paragraph",
        raw: r[0],
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  text(t) {
    const r = this.rules.block.text.exec(t);
    if (r)
      return {
        type: "text",
        raw: r[0],
        text: r[0],
        tokens: this.lexer.inline(r[0])
      };
  }
  escape(t) {
    const r = this.rules.inline.escape.exec(t);
    if (r)
      return {
        type: "escape",
        raw: r[0],
        text: Bi(r[1])
      };
  }
  tag(t) {
    const r = this.rules.inline.tag.exec(t);
    if (r)
      return !this.lexer.state.inLink && /^<a /i.test(r[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(r[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(r[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(r[0]) && (this.lexer.state.inRawBlock = !1), {
        type: this.options.sanitize ? "text" : "html",
        raw: r[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r[0]) : Bi(r[0]) : r[0]
      };
  }
  link(t) {
    const r = this.rules.inline.link.exec(t);
    if (r) {
      const n = r[2].trim();
      if (!this.options.pedantic && /^</.test(n)) {
        if (!/>$/.test(n))
          return;
        const i = ag(n.slice(0, -1), "\\");
        if ((n.length - i.length) % 2 === 0)
          return;
      } else {
        const i = dne(r[2], "()");
        if (i > -1) {
          const l = (r[0].indexOf("!") === 0 ? 5 : 4) + r[1].length + i;
          r[2] = r[2].substring(0, i), r[0] = r[0].substring(0, l).trim(), r[3] = "";
        }
      }
      let a = r[2], s = "";
      if (this.options.pedantic) {
        const i = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(a);
        i && (a = i[1], s = i[3]);
      } else
        s = r[3] ? r[3].slice(1, -1) : "";
      return a = a.trim(), /^</.test(a) && (this.options.pedantic && !/>$/.test(n) ? a = a.slice(1) : a = a.slice(1, -1)), _4(r, {
        href: a && a.replace(this.rules.inline._escapes, "$1"),
        title: s && s.replace(this.rules.inline._escapes, "$1")
      }, r[0], this.lexer);
    }
  }
  reflink(t, r) {
    let n;
    if ((n = this.rules.inline.reflink.exec(t)) || (n = this.rules.inline.nolink.exec(t))) {
      let a = (n[2] || n[1]).replace(/\s+/g, " ");
      if (a = r[a.toLowerCase()], !a) {
        const s = n[0].charAt(0);
        return {
          type: "text",
          raw: s,
          text: s
        };
      }
      return _4(n, a, n[0], this.lexer);
    }
  }
  emStrong(t, r, n = "") {
    let a = this.rules.inline.emStrong.lDelim.exec(t);
    if (!a || a[3] && n.match(/[\p{L}\p{N}]/u)) return;
    const s = a[1] || a[2] || "";
    if (!s || s && (n === "" || this.rules.inline.punctuation.exec(n))) {
      const i = a[0].length - 1;
      let o, l, u = i, c = 0;
      const d = a[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      for (d.lastIndex = 0, r = r.slice(-1 * t.length + i); (a = d.exec(r)) != null; ) {
        if (o = a[1] || a[2] || a[3] || a[4] || a[5] || a[6], !o) continue;
        if (l = o.length, a[3] || a[4]) {
          u += l;
          continue;
        } else if ((a[5] || a[6]) && i % 3 && !((i + l) % 3)) {
          c += l;
          continue;
        }
        if (u -= l, u > 0) continue;
        l = Math.min(l, l + u + c);
        const p = t.slice(0, i + a.index + (a[0].length - o.length) + l);
        if (Math.min(i, l) % 2) {
          const h = p.slice(1, -1);
          return {
            type: "em",
            raw: p,
            text: h,
            tokens: this.lexer.inlineTokens(h)
          };
        }
        const f = p.slice(2, -2);
        return {
          type: "strong",
          raw: p,
          text: f,
          tokens: this.lexer.inlineTokens(f)
        };
      }
    }
  }
  codespan(t) {
    const r = this.rules.inline.code.exec(t);
    if (r) {
      let n = r[2].replace(/\n/g, " ");
      const a = /[^ ]/.test(n), s = /^ /.test(n) && / $/.test(n);
      return a && s && (n = n.substring(1, n.length - 1)), n = Bi(n, !0), {
        type: "codespan",
        raw: r[0],
        text: n
      };
    }
  }
  br(t) {
    const r = this.rules.inline.br.exec(t);
    if (r)
      return {
        type: "br",
        raw: r[0]
      };
  }
  del(t) {
    const r = this.rules.inline.del.exec(t);
    if (r)
      return {
        type: "del",
        raw: r[0],
        text: r[2],
        tokens: this.lexer.inlineTokens(r[2])
      };
  }
  autolink(t, r) {
    const n = this.rules.inline.autolink.exec(t);
    if (n) {
      let a, s;
      return n[2] === "@" ? (a = Bi(this.options.mangle ? r(n[1]) : n[1]), s = "mailto:" + a) : (a = Bi(n[1]), s = a), {
        type: "link",
        raw: n[0],
        text: a,
        href: s,
        tokens: [
          {
            type: "text",
            raw: a,
            text: a
          }
        ]
      };
    }
  }
  url(t, r) {
    let n;
    if (n = this.rules.inline.url.exec(t)) {
      let a, s;
      if (n[2] === "@")
        a = Bi(this.options.mangle ? r(n[0]) : n[0]), s = "mailto:" + a;
      else {
        let i;
        do
          i = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0];
        while (i !== n[0]);
        a = Bi(n[0]), n[1] === "www." ? s = "http://" + n[0] : s = n[0];
      }
      return {
        type: "link",
        raw: n[0],
        text: a,
        href: s,
        tokens: [
          {
            type: "text",
            raw: a,
            text: a
          }
        ]
      };
    }
  }
  inlineText(t, r) {
    const n = this.rules.inline.text.exec(t);
    if (n) {
      let a;
      return this.lexer.state.inRawBlock ? a = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : Bi(n[0]) : n[0] : a = Bi(this.options.smartypants ? r(n[0]) : n[0]), {
        type: "text",
        raw: n[0],
        text: a
      };
    }
  }
}
const Dr = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: Ig,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
Dr._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
Dr._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
Dr.def = Un(Dr.def).replace("label", Dr._label).replace("title", Dr._title).getRegex();
Dr.bullet = /(?:[*+-]|\d{1,9}[.)])/;
Dr.listItemStart = Un(/^( *)(bull) */).replace("bull", Dr.bullet).getRegex();
Dr.list = Un(Dr.list).replace(/bull/g, Dr.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Dr.def.source + ")").getRegex();
Dr._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
Dr._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
Dr.html = Un(Dr.html, "i").replace("comment", Dr._comment).replace("tag", Dr._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
Dr.paragraph = Un(Dr._paragraph).replace("hr", Dr.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Dr._tag).getRegex();
Dr.blockquote = Un(Dr.blockquote).replace("paragraph", Dr.paragraph).getRegex();
Dr.normal = { ...Dr };
Dr.gfm = {
  ...Dr.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
Dr.gfm.table = Un(Dr.gfm.table).replace("hr", Dr.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Dr._tag).getRegex();
Dr.gfm.paragraph = Un(Dr._paragraph).replace("hr", Dr.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Dr.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Dr._tag).getRegex();
Dr.pedantic = {
  ...Dr.normal,
  html: Un(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", Dr._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: Ig,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: Un(Dr.normal._paragraph).replace("hr", Dr.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Dr.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const wr = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: Ig,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: Ig,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
wr._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
wr.punctuation = Un(wr.punctuation).replace(/punctuation/g, wr._punctuation).getRegex();
wr.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
wr.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
wr._comment = Un(Dr._comment).replace("(?:-->|$)", "-->").getRegex();
wr.emStrong.lDelim = Un(wr.emStrong.lDelim).replace(/punct/g, wr._punctuation).getRegex();
wr.emStrong.rDelimAst = Un(wr.emStrong.rDelimAst, "g").replace(/punct/g, wr._punctuation).getRegex();
wr.emStrong.rDelimUnd = Un(wr.emStrong.rDelimUnd, "g").replace(/punct/g, wr._punctuation).getRegex();
wr._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
wr._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
wr._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
wr.autolink = Un(wr.autolink).replace("scheme", wr._scheme).replace("email", wr._email).getRegex();
wr._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
wr.tag = Un(wr.tag).replace("comment", wr._comment).replace("attribute", wr._attribute).getRegex();
wr._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
wr._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
wr._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
wr.link = Un(wr.link).replace("label", wr._label).replace("href", wr._href).replace("title", wr._title).getRegex();
wr.reflink = Un(wr.reflink).replace("label", wr._label).replace("ref", Dr._label).getRegex();
wr.nolink = Un(wr.nolink).replace("ref", Dr._label).getRegex();
wr.reflinkSearch = Un(wr.reflinkSearch, "g").replace("reflink", wr.reflink).replace("nolink", wr.nolink).getRegex();
wr.normal = { ...wr };
wr.pedantic = {
  ...wr.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: Un(/^!?\[(label)\]\((.*?)\)/).replace("label", wr._label).getRegex(),
  reflink: Un(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", wr._label).getRegex()
};
wr.gfm = {
  ...wr.normal,
  escape: Un(wr.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
wr.gfm.url = Un(wr.gfm.url, "i").replace("email", wr.gfm._extended_email).getRegex();
wr.breaks = {
  ...wr.gfm,
  br: Un(wr.br).replace("{2,}", "*").getRegex(),
  text: Un(wr.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function hne(e) {
  return e.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function k4(e) {
  let t = "", r, n;
  const a = e.length;
  for (r = 0; r < a; r++)
    n = e.charCodeAt(r), Math.random() > 0.5 && (n = "x" + n.toString(16)), t += "&#" + n + ";";
  return t;
}
class Bl {
  constructor(t) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = t || Bu, this.options.tokenizer = this.options.tokenizer || new PI(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const r = {
      block: Dr.normal,
      inline: wr.normal
    };
    this.options.pedantic ? (r.block = Dr.pedantic, r.inline = wr.pedantic) : this.options.gfm && (r.block = Dr.gfm, this.options.breaks ? r.inline = wr.breaks : r.inline = wr.gfm), this.tokenizer.rules = r;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Dr,
      inline: wr
    };
  }
  /**
   * Static Lex Method
   */
  static lex(t, r) {
    return new Bl(r).lex(t);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(t, r) {
    return new Bl(r).inlineTokens(t);
  }
  /**
   * Preprocessing
   */
  lex(t) {
    t = t.replace(/\r\n|\r/g, `
`), this.blockTokens(t, this.tokens);
    let r;
    for (; r = this.inlineQueue.shift(); )
      this.inlineTokens(r.src, r.tokens);
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(t, r = []) {
    this.options.pedantic ? t = t.replace(/\t/g, "    ").replace(/^ +$/gm, "") : t = t.replace(/^( *)(\t+)/gm, (o, l, u) => l + "    ".repeat(u.length));
    let n, a, s, i;
    for (; t; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((o) => (n = o.call({ lexer: this }, t, r)) ? (t = t.substring(n.raw.length), r.push(n), !0) : !1))) {
        if (n = this.tokenizer.space(t)) {
          t = t.substring(n.raw.length), n.raw.length === 1 && r.length > 0 ? r[r.length - 1].raw += `
` : r.push(n);
          continue;
        }
        if (n = this.tokenizer.code(t)) {
          t = t.substring(n.raw.length), a = r[r.length - 1], a && (a.type === "paragraph" || a.type === "text") ? (a.raw += `
` + n.raw, a.text += `
` + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = a.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.fences(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.heading(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.hr(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.blockquote(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.list(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.html(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.def(t)) {
          t = t.substring(n.raw.length), a = r[r.length - 1], a && (a.type === "paragraph" || a.type === "text") ? (a.raw += `
` + n.raw, a.text += `
` + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = a.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
            href: n.href,
            title: n.title
          });
          continue;
        }
        if (n = this.tokenizer.table(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.lheading(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (s = t, this.options.extensions && this.options.extensions.startBlock) {
          let o = 1 / 0;
          const l = t.slice(1);
          let u;
          this.options.extensions.startBlock.forEach(function(c) {
            u = c.call({ lexer: this }, l), typeof u == "number" && u >= 0 && (o = Math.min(o, u));
          }), o < 1 / 0 && o >= 0 && (s = t.substring(0, o + 1));
        }
        if (this.state.top && (n = this.tokenizer.paragraph(s))) {
          a = r[r.length - 1], i && a.type === "paragraph" ? (a.raw += `
` + n.raw, a.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = a.text) : r.push(n), i = s.length !== t.length, t = t.substring(n.raw.length);
          continue;
        }
        if (n = this.tokenizer.text(t)) {
          t = t.substring(n.raw.length), a = r[r.length - 1], a && a.type === "text" ? (a.raw += `
` + n.raw, a.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = a.text) : r.push(n);
          continue;
        }
        if (t) {
          const o = "Infinite loop on byte: " + t.charCodeAt(0);
          if (this.options.silent) {
            console.error(o);
            break;
          } else
            throw new Error(o);
        }
      }
    return this.state.top = !0, r;
  }
  inline(t, r = []) {
    return this.inlineQueue.push({ src: t, tokens: r }), r;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(t, r = []) {
    let n, a, s, i = t, o, l, u;
    if (this.tokens.links) {
      const c = Object.keys(this.tokens.links);
      if (c.length > 0)
        for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(i)) != null; )
          c.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (i = i.slice(0, o.index) + "[" + S4("a", o[0].length - 2) + "]" + i.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (o = this.tokenizer.rules.inline.blockSkip.exec(i)) != null; )
      i = i.slice(0, o.index) + "[" + S4("a", o[0].length - 2) + "]" + i.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (o = this.tokenizer.rules.inline.escapedEmSt.exec(i)) != null; )
      i = i.slice(0, o.index + o[0].length - 2) + "++" + i.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    for (; t; )
      if (l || (u = ""), l = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((c) => (n = c.call({ lexer: this }, t, r)) ? (t = t.substring(n.raw.length), r.push(n), !0) : !1))) {
        if (n = this.tokenizer.escape(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.tag(t)) {
          t = t.substring(n.raw.length), a = r[r.length - 1], a && n.type === "text" && a.type === "text" ? (a.raw += n.raw, a.text += n.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.link(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.reflink(t, this.tokens.links)) {
          t = t.substring(n.raw.length), a = r[r.length - 1], a && n.type === "text" && a.type === "text" ? (a.raw += n.raw, a.text += n.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.emStrong(t, i, u)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.codespan(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.br(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.del(t)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.autolink(t, k4)) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (!this.state.inLink && (n = this.tokenizer.url(t, k4))) {
          t = t.substring(n.raw.length), r.push(n);
          continue;
        }
        if (s = t, this.options.extensions && this.options.extensions.startInline) {
          let c = 1 / 0;
          const d = t.slice(1);
          let p;
          this.options.extensions.startInline.forEach(function(f) {
            p = f.call({ lexer: this }, d), typeof p == "number" && p >= 0 && (c = Math.min(c, p));
          }), c < 1 / 0 && c >= 0 && (s = t.substring(0, c + 1));
        }
        if (n = this.tokenizer.inlineText(s, hne)) {
          t = t.substring(n.raw.length), n.raw.slice(-1) !== "_" && (u = n.raw.slice(-1)), l = !0, a = r[r.length - 1], a && a.type === "text" ? (a.raw += n.raw, a.text += n.text) : r.push(n);
          continue;
        }
        if (t) {
          const c = "Infinite loop on byte: " + t.charCodeAt(0);
          if (this.options.silent) {
            console.error(c);
            break;
          } else
            throw new Error(c);
        }
      }
    return r;
  }
}
class LI {
  constructor(t) {
    this.options = t || Bu;
  }
  code(t, r, n) {
    const a = (r || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const s = this.options.highlight(t, a);
      s != null && s !== t && (n = !0, t = s);
    }
    return t = t.replace(/\n$/, "") + `
`, a ? '<pre><code class="' + this.options.langPrefix + Bi(a) + '">' + (n ? t : Bi(t, !0)) + `</code></pre>
` : "<pre><code>" + (n ? t : Bi(t, !0)) + `</code></pre>
`;
  }
  /**
   * @param {string} quote
   */
  blockquote(t) {
    return `<blockquote>
${t}</blockquote>
`;
  }
  html(t) {
    return t;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(t, r, n, a) {
    if (this.options.headerIds) {
      const s = this.options.headerPrefix + a.slug(n);
      return `<h${r} id="${s}">${t}</h${r}>
`;
    }
    return `<h${r}>${t}</h${r}>
`;
  }
  hr() {
    return this.options.xhtml ? `<hr/>
` : `<hr>
`;
  }
  list(t, r, n) {
    const a = r ? "ol" : "ul", s = r && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + a + s + `>
` + t + "</" + a + `>
`;
  }
  /**
   * @param {string} text
   */
  listitem(t) {
    return `<li>${t}</li>
`;
  }
  checkbox(t) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(t) {
    return `<p>${t}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(t, r) {
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  /**
   * @param {string} content
   */
  tablerow(t) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t, r) {
    const n = r.header ? "th" : "td";
    return (r.align ? `<${n} align="${r.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(t) {
    return `<strong>${t}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(t) {
    return `<em>${t}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(t) {
    return `<code>${t}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(t) {
    return `<del>${t}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(t, r, n) {
    if (t = x4(this.options.sanitize, this.options.baseUrl, t), t === null)
      return n;
    let a = '<a href="' + t + '"';
    return r && (a += ' title="' + r + '"'), a += ">" + n + "</a>", a;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(t, r, n) {
    if (t = x4(this.options.sanitize, this.options.baseUrl, t), t === null)
      return n;
    let a = `<img src="${t}" alt="${n}"`;
    return r && (a += ` title="${r}"`), a += this.options.xhtml ? "/>" : ">", a;
  }
  text(t) {
    return t;
  }
}
class sz {
  // no need for block level renderers
  strong(t) {
    return t;
  }
  em(t) {
    return t;
  }
  codespan(t) {
    return t;
  }
  del(t) {
    return t;
  }
  html(t) {
    return t;
  }
  text(t) {
    return t;
  }
  link(t, r, n) {
    return "" + n;
  }
  image(t, r, n) {
    return "" + n;
  }
  br() {
    return "";
  }
}
class oz {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(t) {
    return t.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(t, r) {
    let n = t, a = 0;
    if (this.seen.hasOwnProperty(n)) {
      a = this.seen[t];
      do
        a++, n = t + "-" + a;
      while (this.seen.hasOwnProperty(n));
    }
    return r || (this.seen[t] = a, this.seen[n] = 0), n;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(t, r = {}) {
    const n = this.serialize(t);
    return this.getNextSafeSlug(n, r.dryrun);
  }
}
let sh = class FT {
  constructor(t) {
    this.options = t || Bu, this.options.renderer = this.options.renderer || new LI(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new sz(), this.slugger = new oz();
  }
  /**
   * Static Parse Method
   */
  static parse(t, r) {
    return new FT(r).parse(t);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(t, r) {
    return new FT(r).parseInline(t);
  }
  /**
   * Parse Loop
   */
  parse(t, r = !0) {
    let n = "", a, s, i, o, l, u, c, d, p, f, h, m, y, b, v, x, _, E, w;
    const C = t.length;
    for (a = 0; a < C; a++) {
      if (f = t[a], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[f.type] && (w = this.options.extensions.renderers[f.type].call({ parser: this }, f), w !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(f.type))) {
        n += w || "";
        continue;
      }
      switch (f.type) {
        case "space":
          continue;
        case "hr": {
          n += this.renderer.hr();
          continue;
        }
        case "heading": {
          n += this.renderer.heading(
            this.parseInline(f.tokens),
            f.depth,
            az(this.parseInline(f.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          n += this.renderer.code(
            f.text,
            f.lang,
            f.escaped
          );
          continue;
        }
        case "table": {
          for (d = "", c = "", o = f.header.length, s = 0; s < o; s++)
            c += this.renderer.tablecell(
              this.parseInline(f.header[s].tokens),
              { header: !0, align: f.align[s] }
            );
          for (d += this.renderer.tablerow(c), p = "", o = f.rows.length, s = 0; s < o; s++) {
            for (u = f.rows[s], c = "", l = u.length, i = 0; i < l; i++)
              c += this.renderer.tablecell(
                this.parseInline(u[i].tokens),
                { header: !1, align: f.align[i] }
              );
            p += this.renderer.tablerow(c);
          }
          n += this.renderer.table(d, p);
          continue;
        }
        case "blockquote": {
          p = this.parse(f.tokens), n += this.renderer.blockquote(p);
          continue;
        }
        case "list": {
          for (h = f.ordered, m = f.start, y = f.loose, o = f.items.length, p = "", s = 0; s < o; s++)
            v = f.items[s], x = v.checked, _ = v.task, b = "", v.task && (E = this.renderer.checkbox(x), y ? v.tokens.length > 0 && v.tokens[0].type === "paragraph" ? (v.tokens[0].text = E + " " + v.tokens[0].text, v.tokens[0].tokens && v.tokens[0].tokens.length > 0 && v.tokens[0].tokens[0].type === "text" && (v.tokens[0].tokens[0].text = E + " " + v.tokens[0].tokens[0].text)) : v.tokens.unshift({
              type: "text",
              text: E
            }) : b += E), b += this.parse(v.tokens, y), p += this.renderer.listitem(b, _, x);
          n += this.renderer.list(p, h, m);
          continue;
        }
        case "html": {
          n += this.renderer.html(f.text);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(this.parseInline(f.tokens));
          continue;
        }
        case "text": {
          for (p = f.tokens ? this.parseInline(f.tokens) : f.text; a + 1 < C && t[a + 1].type === "text"; )
            f = t[++a], p += `
` + (f.tokens ? this.parseInline(f.tokens) : f.text);
          n += r ? this.renderer.paragraph(p) : p;
          continue;
        }
        default: {
          const k = 'Token with "' + f.type + '" type was not found.';
          if (this.options.silent) {
            console.error(k);
            return;
          } else
            throw new Error(k);
        }
      }
    }
    return n;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(t, r) {
    r = r || this.renderer;
    let n = "", a, s, i;
    const o = t.length;
    for (a = 0; a < o; a++) {
      if (s = t[a], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type] && (i = this.options.extensions.renderers[s.type].call({ parser: this }, s), i !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type))) {
        n += i || "";
        continue;
      }
      switch (s.type) {
        case "escape": {
          n += r.text(s.text);
          break;
        }
        case "html": {
          n += r.html(s.text);
          break;
        }
        case "link": {
          n += r.link(s.href, s.title, this.parseInline(s.tokens, r));
          break;
        }
        case "image": {
          n += r.image(s.href, s.title, s.text);
          break;
        }
        case "strong": {
          n += r.strong(this.parseInline(s.tokens, r));
          break;
        }
        case "em": {
          n += r.em(this.parseInline(s.tokens, r));
          break;
        }
        case "codespan": {
          n += r.codespan(s.text);
          break;
        }
        case "br": {
          n += r.br();
          break;
        }
        case "del": {
          n += r.del(this.parseInline(s.tokens, r));
          break;
        }
        case "text": {
          n += r.text(s.text);
          break;
        }
        default: {
          const l = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) {
            console.error(l);
            return;
          } else
            throw new Error(l);
        }
      }
    }
    return n;
  }
};
class $T {
  constructor(t) {
    this.options = t || Bu;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(t) {
    return t;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(t) {
    return t;
  }
}
function mne(e, t, r) {
  return (n) => {
    if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
      const a = "<p>An error occurred:</p><pre>" + Bi(n.message + "", !0) + "</pre>";
      if (t)
        return Promise.resolve(a);
      if (r) {
        r(null, a);
        return;
      }
      return a;
    }
    if (t)
      return Promise.reject(n);
    if (r) {
      r(n);
      return;
    }
    throw n;
  };
}
function lz(e, t) {
  return (r, n, a) => {
    typeof n == "function" && (a = n, n = null);
    const s = { ...n };
    n = { ...Pr.defaults, ...s };
    const i = mne(n.silent, n.async, a);
    if (typeof r > "u" || r === null)
      return i(new Error("marked(): input parameter is undefined or null"));
    if (typeof r != "string")
      return i(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
    if (fne(n), n.hooks && (n.hooks.options = n), a) {
      const o = n.highlight;
      let l;
      try {
        n.hooks && (r = n.hooks.preprocess(r)), l = e(r, n);
      } catch (d) {
        return i(d);
      }
      const u = function(d) {
        let p;
        if (!d)
          try {
            n.walkTokens && Pr.walkTokens(l, n.walkTokens), p = t(l, n), n.hooks && (p = n.hooks.postprocess(p));
          } catch (f) {
            d = f;
          }
        return n.highlight = o, d ? i(d) : a(null, p);
      };
      if (!o || o.length < 3 || (delete n.highlight, !l.length)) return u();
      let c = 0;
      Pr.walkTokens(l, function(d) {
        d.type === "code" && (c++, setTimeout(() => {
          o(d.text, d.lang, function(p, f) {
            if (p)
              return u(p);
            f != null && f !== d.text && (d.text = f, d.escaped = !0), c--, c === 0 && u();
          });
        }, 0));
      }), c === 0 && u();
      return;
    }
    if (n.async)
      return Promise.resolve(n.hooks ? n.hooks.preprocess(r) : r).then((o) => e(o, n)).then((o) => n.walkTokens ? Promise.all(Pr.walkTokens(o, n.walkTokens)).then(() => o) : o).then((o) => t(o, n)).then((o) => n.hooks ? n.hooks.postprocess(o) : o).catch(i);
    try {
      n.hooks && (r = n.hooks.preprocess(r));
      const o = e(r, n);
      n.walkTokens && Pr.walkTokens(o, n.walkTokens);
      let l = t(o, n);
      return n.hooks && (l = n.hooks.postprocess(l)), l;
    } catch (o) {
      return i(o);
    }
  };
}
function Pr(e, t, r) {
  return lz(Bl.lex, sh.parse)(e, t, r);
}
Pr.options = Pr.setOptions = function(e) {
  return Pr.defaults = { ...Pr.defaults, ...e }, Qre(Pr.defaults), Pr;
};
Pr.getDefaults = rz;
Pr.defaults = Bu;
Pr.use = function(...e) {
  const t = Pr.defaults.extensions || { renderers: {}, childTokens: {} };
  e.forEach((r) => {
    const n = { ...r };
    if (n.async = Pr.defaults.async || n.async || !1, r.extensions && (r.extensions.forEach((a) => {
      if (!a.name)
        throw new Error("extension name required");
      if (a.renderer) {
        const s = t.renderers[a.name];
        s ? t.renderers[a.name] = function(...i) {
          let o = a.renderer.apply(this, i);
          return o === !1 && (o = s.apply(this, i)), o;
        } : t.renderers[a.name] = a.renderer;
      }
      if (a.tokenizer) {
        if (!a.level || a.level !== "block" && a.level !== "inline")
          throw new Error("extension level must be 'block' or 'inline'");
        t[a.level] ? t[a.level].unshift(a.tokenizer) : t[a.level] = [a.tokenizer], a.start && (a.level === "block" ? t.startBlock ? t.startBlock.push(a.start) : t.startBlock = [a.start] : a.level === "inline" && (t.startInline ? t.startInline.push(a.start) : t.startInline = [a.start]));
      }
      a.childTokens && (t.childTokens[a.name] = a.childTokens);
    }), n.extensions = t), r.renderer) {
      const a = Pr.defaults.renderer || new LI();
      for (const s in r.renderer) {
        const i = a[s];
        a[s] = (...o) => {
          let l = r.renderer[s].apply(a, o);
          return l === !1 && (l = i.apply(a, o)), l;
        };
      }
      n.renderer = a;
    }
    if (r.tokenizer) {
      const a = Pr.defaults.tokenizer || new PI();
      for (const s in r.tokenizer) {
        const i = a[s];
        a[s] = (...o) => {
          let l = r.tokenizer[s].apply(a, o);
          return l === !1 && (l = i.apply(a, o)), l;
        };
      }
      n.tokenizer = a;
    }
    if (r.hooks) {
      const a = Pr.defaults.hooks || new $T();
      for (const s in r.hooks) {
        const i = a[s];
        $T.passThroughHooks.has(s) ? a[s] = (o) => {
          if (Pr.defaults.async)
            return Promise.resolve(r.hooks[s].call(a, o)).then((u) => i.call(a, u));
          const l = r.hooks[s].call(a, o);
          return i.call(a, l);
        } : a[s] = (...o) => {
          let l = r.hooks[s].apply(a, o);
          return l === !1 && (l = i.apply(a, o)), l;
        };
      }
      n.hooks = a;
    }
    if (r.walkTokens) {
      const a = Pr.defaults.walkTokens;
      n.walkTokens = function(s) {
        let i = [];
        return i.push(r.walkTokens.call(this, s)), a && (i = i.concat(a.call(this, s))), i;
      };
    }
    Pr.setOptions(n);
  });
};
Pr.walkTokens = function(e, t) {
  let r = [];
  for (const n of e)
    switch (r = r.concat(t.call(Pr, n)), n.type) {
      case "table": {
        for (const a of n.header)
          r = r.concat(Pr.walkTokens(a.tokens, t));
        for (const a of n.rows)
          for (const s of a)
            r = r.concat(Pr.walkTokens(s.tokens, t));
        break;
      }
      case "list": {
        r = r.concat(Pr.walkTokens(n.items, t));
        break;
      }
      default:
        Pr.defaults.extensions && Pr.defaults.extensions.childTokens && Pr.defaults.extensions.childTokens[n.type] ? Pr.defaults.extensions.childTokens[n.type].forEach(function(a) {
          r = r.concat(Pr.walkTokens(n[a], t));
        }) : n.tokens && (r = r.concat(Pr.walkTokens(n.tokens, t)));
    }
  return r;
};
Pr.parseInline = lz(Bl.lexInline, sh.parseInline);
Pr.Parser = sh;
Pr.parser = sh.parse;
Pr.Renderer = LI;
Pr.TextRenderer = sz;
Pr.Lexer = Bl;
Pr.lexer = Bl.lex;
Pr.Tokenizer = PI;
Pr.Slugger = oz;
Pr.Hooks = $T;
Pr.parse = Pr;
Pr.options;
Pr.setOptions;
Pr.use;
Pr.walkTokens;
Pr.parseInline;
sh.parse;
Bl.lex;
const gne = /* @__PURE__ */ Ga("div")({
  name: "MarkdownContainer",
  class: "gdg-mnuv029",
  propsAsIs: !1
});
class bne extends kt.PureComponent {
  targetElement = null;
  renderMarkdownIntoDiv() {
    const { targetElement: t, props: r } = this;
    if (t === null)
      return;
    const { contents: n, createNode: a } = r, s = Pr(n), i = document.createRange();
    i.selectNodeContents(t), i.deleteContents();
    let o = a?.(s);
    if (o === void 0) {
      const u = document.createElement("template");
      u.innerHTML = s, o = u.content;
    }
    t.append(o);
    const l = t.getElementsByTagName("a");
    for (const u of l)
      u.target = "_blank", u.rel = "noreferrer noopener";
  }
  containerRefHook = (t) => {
    this.targetElement = t, this.renderMarkdownIntoDiv();
  };
  render() {
    return this.renderMarkdownIntoDiv(), kt.createElement(gne, { ref: this.containerRefHook });
  }
}
const yne = /* @__PURE__ */ Ga("textarea")({
  name: "InputBox",
  class: "gdg-izpuzkl",
  propsAsIs: !1
}), vne = /* @__PURE__ */ Ga("div")({
  name: "ShadowBox",
  class: "gdg-s69h75o",
  propsAsIs: !1
}), wne = /* @__PURE__ */ Ga("div")({
  name: "GrowingEntryStyle",
  class: "gdg-g1y0xocz",
  propsAsIs: !1
});
let C4 = 0;
const Pb = (e) => {
  const { placeholder: t, value: r, onKeyDown: n, highlight: a, altNewline: s, validatedSelection: i, ...o } = e, { onChange: l, className: u } = o, c = D.useRef(null), d = r ?? "";
  Fa(l !== void 0, "GrowingEntry must be a controlled input area");
  const [p] = D.useState(() => "input-box-" + (C4 = (C4 + 1) % 1e7));
  D.useEffect(() => {
    const h = c.current;
    if (h === null || h.disabled)
      return;
    const m = d.toString().length;
    h.focus(), h.setSelectionRange(a ? 0 : m, m);
  }, []), D.useLayoutEffect(() => {
    if (i !== void 0) {
      const h = typeof i == "number" ? [i, null] : i;
      c.current?.setSelectionRange(h[0], h[1]);
    }
  }, [i]);
  const f = D.useCallback((h) => {
    h.key === "Enter" && h.shiftKey && s === !0 || n?.(h);
  }, [s, n]);
  return D.createElement(
    wne,
    { className: "gdg-growing-entry" },
    D.createElement(vne, { className: u }, d + `
`),
    D.createElement(yne, { ...o, className: (u ?? "") + " gdg-input", id: p, ref: c, onKeyDown: f, value: d, placeholder: t, dir: "auto" })
  );
}, v0 = {};
let hl = null;
function xne() {
  const e = document.createElement("div");
  return e.style.opacity = "0", e.style.pointerEvents = "none", e.style.position = "fixed", document.body.append(e), e;
}
function wp(e) {
  const t = e.toLowerCase().trim();
  if (v0[t] !== void 0)
    return v0[t];
  hl = hl || xne(), hl.style.color = "#000", hl.style.color = t;
  const r = getComputedStyle(hl).color;
  hl.style.color = "#fff", hl.style.color = t;
  const n = getComputedStyle(hl).color;
  if (n !== r)
    return [0, 0, 0, 1];
  let a = n.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);
  return a.length < 4 && a.push(1), a = a.map((s) => {
    const i = Number.isNaN(s);
    return process.env.NODE_ENV !== "production" && i && console.warn("Could not parse color", e), i ? 0 : s;
  }), v0[t] = a, a;
}
function ku(e, t) {
  const [r, n, a] = wp(e);
  return `rgba(${r}, ${n}, ${a}, ${t})`;
}
const A4 = /* @__PURE__ */ new Map();
function T4(e, t) {
  const r = `${e}-${t}`, n = A4.get(r);
  if (n !== void 0)
    return n;
  const a = $a(e, t);
  return A4.set(r, a), a;
}
function $a(e, t) {
  if (t === void 0)
    return e;
  const [r, n, a, s] = wp(e);
  if (s === 1)
    return e;
  const [i, o, l, u] = wp(t), c = s + u * (1 - s), d = (s * r + u * i * (1 - s)) / c, p = (s * n + u * o * (1 - s)) / c, f = (s * a + u * l * (1 - s)) / c;
  return `rgba(${d}, ${p}, ${f}, ${c})`;
}
function Ene(e, t, r) {
  if (r <= 0)
    return e;
  if (r >= 1)
    return t;
  const n = [...wp(e)];
  n[0] = n[0] * n[3], n[1] = n[1] * n[3], n[2] = n[2] * n[3];
  const a = [...wp(t)];
  a[0] = a[0] * a[3], a[1] = a[1] * a[3], a[2] = a[2] * a[3];
  const s = r, i = 1 - r, o = n[3] * i + a[3] * s, l = Math.floor((n[0] * i + a[0] * s) / o), u = Math.floor((n[1] * i + a[1] * s) / o), c = Math.floor((n[2] * i + a[2] * s) / o);
  return `rgba(${l}, ${u}, ${c}, ${o})`;
}
var Ac = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), BT = /* @__PURE__ */ new Map();
function Sne() {
  Ac.clear(), BT.clear(), Pc.clear();
}
function _ne(e, t, r, n, a) {
  var s, i, o;
  let l = 0, u = {};
  for (let d of e) l += (s = r.get(d)) != null ? s : a, u[d] = ((i = u[d]) != null ? i : 0) + 1;
  let c = t - l;
  for (let d of Object.keys(u)) {
    let p = u[d], f = (o = r.get(d)) != null ? o : a, h = f * p / l, m = c * h * n / p, y = f + m;
    r.set(d, y);
  }
}
function kne(e, t) {
  var r;
  let n = /* @__PURE__ */ new Map(), a = 0;
  for (let u of "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890,.-+=?") {
    let c = e.measureText(u).width;
    n.set(u, c), a += c;
  }
  let s = a / n.size, i = 3, o = (t / s + i) / (i + 1), l = n.keys();
  for (let u of l) n.set(u, ((r = n.get(u)) != null ? r : s) * o);
  return n;
}
function Kf(e, t, r, n) {
  var a, s;
  let i = Pc.get(r);
  if (n && i !== void 0 && i.count > 2e4) {
    let u = BT.get(r);
    if (u === void 0 && (u = kne(e, i.size), BT.set(r, u)), i.count > 5e5) {
      let d = 0;
      for (let p of t) d += (a = u.get(p)) != null ? a : i.size;
      return d * 1.01;
    }
    let c = e.measureText(t);
    return _ne(t, c.width, u, Math.max(0.05, 1 - i.count / 2e5), i.size), Pc.set(r, { count: i.count + t.length, size: i.size }), c.width;
  }
  let o = e.measureText(t), l = o.width / t.length;
  if (((s = i?.count) != null ? s : 0) > 2e4) return o.width;
  if (i === void 0) Pc.set(r, { count: t.length, size: l });
  else {
    let u = l - i.size, c = t.length / (i.count + t.length), d = i.size + u * c;
    Pc.set(r, { count: i.count + t.length, size: d });
  }
  return o.width;
}
function Cne(e, t, r, n, a, s, i, o) {
  if (t.length <= 1) return t.length;
  if (a < r) return -1;
  let l = Math.floor(r / a * s), u = Kf(e, t.slice(0, Math.max(0, l)), n, i);
  if (u !== r) if (u < r) {
    for (; u < r; ) l++, u = Kf(e, t.slice(0, Math.max(0, l)), n, i);
    l--;
  } else for (; u > r; ) {
    let c = t.lastIndexOf(" ", l - 1);
    c > 0 ? l = c : l--, u = Kf(e, t.slice(0, Math.max(0, l)), n, i);
  }
  if (t[l] !== " ") {
    let c = 0;
    c = t.lastIndexOf(" ", l), c > 0 && (l = c);
  }
  return l;
}
function Ane(e, t, r, n, a, s) {
  let i = `${t}_${r}_${n}px`, o = Ac.get(i);
  if (o !== void 0) return o;
  if (n <= 0) return [];
  let l = [], u = t.split(`
`), c = Pc.get(r), d = c === void 0 ? t.length : n / c.size * 1.5, p = a && c !== void 0 && c.count > 2e4;
  for (let f of u) {
    let h = Kf(e, f.slice(0, Math.max(0, d)), r, p), m = Math.min(f.length, d);
    if (h <= n) l.push(f);
    else {
      for (; h > n; ) {
        let y = Cne(e, f, n, r, h, m, p), b = f.slice(0, Math.max(0, y));
        f = f.slice(b.length), l.push(b), h = Kf(e, f.slice(0, Math.max(0, d)), r, p), m = Math.min(f.length, d);
      }
      h > 0 && l.push(f);
    }
  }
  return l = l.map((f, h) => h === 0 ? f.trimEnd() : f.trim()), Ac.set(i, l), Ac.size > 500 && Ac.delete(Ac.keys().next().value), l;
}
function Tne(e, t) {
  return kt.useMemo(() => e.map((r, n) => ({
    group: r.group,
    grow: r.grow,
    hasMenu: r.hasMenu,
    icon: r.icon,
    id: r.id,
    menuIcon: r.menuIcon,
    overlayIcon: r.overlayIcon,
    sourceIndex: n,
    sticky: n < t,
    style: r.style,
    themeOverride: r.themeOverride,
    title: r.title,
    trailingRowOptions: r.trailingRowOptions,
    width: r.width,
    growOffset: r.growOffset,
    rowMarker: r.rowMarker,
    rowMarkerChecked: r.rowMarkerChecked
  })), [e, t]);
}
function Rne(e, t) {
  const [r, n] = t;
  if (e.columns.hasIndex(r) || e.rows.hasIndex(n))
    return !0;
  if (e.current !== void 0) {
    if (Yf(e.current.cell, t))
      return !0;
    const a = [e.current.range, ...e.current.rangeStack];
    for (const s of a)
      if (r >= s.x && r < s.x + s.width && n >= s.y && n < s.y + s.height)
        return !0;
  }
  return !1;
}
function xp(e, t) {
  return (e ?? "") === (t ?? "");
}
function Ine(e, t, r) {
  return r.current === void 0 || e[1] !== r.current.cell[1] ? !1 : t.span === void 0 ? r.current.cell[0] === e[0] : r.current.cell[0] >= t.span[0] && r.current.cell[0] <= t.span[1];
}
function uz(e, t) {
  const [r, n] = e;
  return r >= t.x && r < t.x + t.width && n >= t.y && n < t.y + t.height;
}
function Yf(e, t) {
  return e?.[0] === t?.[0] && e?.[1] === t?.[1];
}
function cz(e) {
  return [e.x + e.width - 1, e.y + e.height - 1];
}
function R4(e, t, r) {
  const n = r.x, a = r.x + r.width - 1, s = r.y, i = r.y + r.height - 1, [o, l] = e;
  if (l < s || l > i)
    return !1;
  if (t.span === void 0)
    return o >= n && o <= a;
  const [u, c] = t.span;
  return u >= n && u <= a || c >= n && u <= a || u < n && c > a;
}
function Nne(e, t, r, n) {
  let a = 0;
  if (r.current === void 0)
    return a;
  const s = r.current.range;
  (n || s.height * s.width > 1) && R4(e, t, s) && a++;
  for (const i of r.current.rangeStack)
    R4(e, t, i) && a++;
  return a;
}
function dz(e, t) {
  let r = e;
  if (t !== void 0) {
    let n = [...e];
    const a = r[t.src];
    t.src > t.dest ? (n.splice(t.src, 1), n.splice(t.dest, 0, a)) : (n.splice(t.dest + 1, 0, a), n.splice(t.src, 1)), n = n.map((s, i) => ({
      ...s,
      sticky: e[i].sticky
    })), r = n;
  }
  return r;
}
function nd(e, t) {
  let r = 0;
  const n = dz(e, t);
  for (let a = 0; a < n.length; a++) {
    const s = n[a];
    if (s.sticky)
      r += s.width;
    else
      break;
  }
  return r;
}
function Uu(e, t, r) {
  if (typeof r == "number")
    return t * r;
  {
    let n = 0;
    for (let a = e - t; a < e; a++)
      n += r(a);
    return n;
  }
}
function UT(e, t, r, n, a) {
  const s = dz(e, n), i = [];
  for (const u of s)
    if (u.sticky)
      i.push(u);
    else
      break;
  if (i.length > 0)
    for (const u of i)
      r -= u.width;
  let o = t, l = a ?? 0;
  for (; l <= r && o < s.length; )
    l += s[o].width, o++;
  for (let u = t; u < o; u++) {
    const c = s[u];
    c.sticky || i.push(c);
  }
  return i;
}
function Dne(e, t, r) {
  let n = 0;
  for (const a of t) {
    const s = a.sticky ? n : n + (r ?? 0);
    if (e <= s + a.width)
      return a.sourceIndex;
    n += a.width;
  }
  return -1;
}
function One(e, t, r, n, a, s, i, o, l, u) {
  const c = n + a;
  if (r && e <= a)
    return -2;
  if (e <= c)
    return -1;
  let d = t;
  for (let h = 0; h < u; h++) {
    const m = s - 1 - h, y = typeof i == "number" ? i : i(m);
    if (d -= y, e >= d)
      return m;
  }
  const p = s - u, f = e - (l ?? 0);
  if (typeof i == "number") {
    const h = Math.floor((f - c) / i) + o;
    return h >= p ? void 0 : h;
  } else {
    let h = c;
    for (let m = o; m < p; m++) {
      const y = i(m);
      if (f <= h + y)
        return m;
      h += y;
    }
    return;
  }
}
let sg = 0, Xf = {};
const Pne = typeof window > "u";
async function Lne() {
  Pne || document?.fonts?.ready === void 0 || (await document.fonts.ready, sg = 0, Xf = {}, Sne());
}
Lne();
function fz(e, t, r, n) {
  return `${e}_${n ?? t?.font}_${r}`;
}
function oh(e, t, r, n = "middle") {
  const a = fz(e, t, n, r);
  let s = Xf[a];
  return s === void 0 && (s = t.measureText(e), Xf[a] = s, sg++), sg > 1e4 && (Xf = {}, sg = 0), s;
}
function Mne(e, t) {
  const r = fz(e, void 0, "middle", t);
  return Xf[r];
}
function Yo(e, t) {
  return typeof t != "string" && (t = t.baseFontFull), Fne(e, t);
}
function I4(e, t) {
  const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  e.save(), e.textBaseline = t;
  const n = e.measureText(r);
  return e.restore(), n;
}
const N4 = [];
function Fne(e, t) {
  for (const s of N4)
    if (s.key === t)
      return s.val;
  const r = I4(e, "alphabetic"), a = -(I4(e, "middle").actualBoundingBoxDescent - r.actualBoundingBoxDescent) + r.actualBoundingBoxAscent / 2;
  return N4.push({
    key: t,
    val: a
  }), a;
}
function $ne(e, t, r, n, a, s) {
  const { ctx: i, rect: o, theme: l } = e;
  let u = Number.MAX_SAFE_INTEGER;
  const c = 500;
  if (t !== void 0 && (u = r - t, u < c)) {
    const d = 1 - u / c;
    i.globalAlpha = d, i.fillStyle = l.bgSearchResult, i.fillRect(o.x + 1, o.y + 1, o.width - (a ? 2 : 1), o.height - (s ? 2 : 1)), i.globalAlpha = 1, n !== void 0 && (n.fillStyle = l.bgSearchResult);
  }
  return u < c;
}
function lh(e, t, r) {
  const { ctx: n, theme: a } = e, s = t ?? {}, i = r ?? a.textDark;
  return i !== s.fillStyle && (n.fillStyle = i, s.fillStyle = i), s;
}
function pz(e, t, r, n, a, s, i, o, l) {
  l === "right" ? e.fillText(t, r + a - (o.cellHorizontalPadding + 0.5), n + s / 2 + i) : l === "center" ? e.fillText(t, r + a / 2, n + s / 2 + i) : e.fillText(t, r + o.cellHorizontalPadding + 0.5, n + s / 2 + i);
}
function hz(e, t) {
  const r = oh("ABCi09jgqpy", e, t);
  return r.actualBoundingBoxAscent + r.actualBoundingBoxDescent;
}
function Bne(e, t) {
  e.includes(`
`) && (e = e.split(/\r?\n/, 1)[0]);
  const r = t / 4;
  return e.length > r && (e = e.slice(0, r)), e;
}
function Une(e, t, r, n, a, s, i, o, l, u) {
  const c = o.baseFontFull, d = Ane(e, t, c, a - o.cellHorizontalPadding * 2, u ?? !1), p = hz(e, c), f = o.lineHeight * p, h = p + f * (d.length - 1), m = h + o.cellVerticalPadding > s;
  m && (e.save(), e.rect(r, n, a, s), e.clip());
  const y = n + s / 2 - h / 2;
  let b = Math.max(n + o.cellVerticalPadding, y);
  for (const v of d)
    if (pz(e, v, r, b, a, p, i, o, l), b += f, b > n + s)
      break;
  m && e.restore();
}
function No(e, t, r, n, a) {
  const { ctx: s, rect: i, theme: o } = e, { x: l, y: u, width: c, height: d } = i;
  n = n ?? !1, n || (t = Bne(t, c));
  const p = Yo(s, o), f = OI(t) === "rtl";
  if (r === void 0 && f && (r = "right"), f && (s.direction = "rtl"), t.length > 0) {
    let h = !1;
    r === "right" ? (s.textAlign = "right", h = !0) : r !== void 0 && r !== "left" && (s.textAlign = r, h = !0), n ? Une(s, t, l, u, c, d, p, o, r, a) : pz(s, t, l, u, c, d, p, o, r), h && (s.textAlign = "start"), f && (s.direction = "inherit");
  }
}
function os(e, t, r, n, a, s) {
  typeof s == "number" && (s = { tl: s, tr: s, br: s, bl: s }), s = {
    tl: Math.max(0, Math.min(s.tl, a / 2, n / 2)),
    tr: Math.max(0, Math.min(s.tr, a / 2, n / 2)),
    bl: Math.max(0, Math.min(s.bl, a / 2, n / 2)),
    br: Math.max(0, Math.min(s.br, a / 2, n / 2))
  }, e.moveTo(t + s.tl, r), e.arcTo(t + n, r, t + n, r + s.tr, s.tr), e.arcTo(t + n, r + a, t + n - s.br, r + a, s.br), e.arcTo(t, r + a, t, r + a - s.bl, s.bl), e.arcTo(t, r, t + s.tl, r, s.tl);
}
function zne(e, t, r) {
  e.arc(t, r - 1.25 * 3.5, 1.25, 0, 2 * Math.PI, !1), e.arc(t, r, 1.25, 0, 2 * Math.PI, !1), e.arc(t, r + 1.25 * 3.5, 1.25, 0, 2 * Math.PI, !1);
}
function qne(e, t, r) {
  const n = function(o, l) {
    const u = l.x - o.x, c = l.y - o.y, d = Math.sqrt(u * u + c * c), p = u / d, f = c / d;
    return {
      x: u,
      y: l.y - o.y,
      len: d,
      nx: p,
      ny: f,
      ang: Math.atan2(f, p)
    };
  };
  let a;
  const s = t.length;
  let i = t[s - 1];
  for (let o = 0; o < s; o++) {
    let l = t[o % s];
    const u = t[(o + 1) % s], c = n(l, i), d = n(l, u), p = c.nx * d.ny - c.ny * d.nx, f = c.nx * d.nx - c.ny * -d.ny;
    let h = Math.asin(p < -1 ? -1 : p > 1 ? 1 : p), m = 1, y = !1;
    f < 0 ? h < 0 ? h = Math.PI + h : (h = Math.PI - h, m = -1, y = !0) : h > 0 && (m = -1, y = !0), a = l.radius !== void 0 ? l.radius : r;
    const b = h / 2;
    let v = Math.abs(Math.cos(b) * a / Math.sin(b)), x;
    v > Math.min(c.len / 2, d.len / 2) ? (v = Math.min(c.len / 2, d.len / 2), x = Math.abs(v * Math.sin(b) / Math.cos(b))) : x = a;
    let _ = l.x + d.nx * v, E = l.y + d.ny * v;
    _ += -d.ny * x * m, E += d.nx * x * m, e.arc(_, E, x, c.ang + Math.PI / 2 * m, d.ang - Math.PI / 2 * m, y), i = l, l = u;
  }
  e.closePath();
}
function zT(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h) {
  const m = {
    x: 0,
    y: s + u,
    width: 0,
    height: 0
  };
  if (e >= f.length || t >= c || t < -2 || e < 0)
    return m;
  const y = s - a;
  if (e >= d) {
    const b = i > e ? -1 : 1, v = nd(f);
    m.x += v + l;
    for (let x = i; x !== e; x += b)
      m.x += f[b === 1 ? x : x - 1].width * b;
  } else
    for (let b = 0; b < e; b++)
      m.x += f[b].width;
  if (m.width = f[e].width + 1, t === -1)
    m.y = a, m.height = y;
  else if (t === -2) {
    m.y = 0, m.height = a;
    let b = e;
    const v = f[e].group, x = f[e].sticky;
    for (; b > 0 && xp(f[b - 1].group, v) && f[b - 1].sticky === x; ) {
      const E = f[b - 1];
      m.x -= E.width, m.width += E.width, b--;
    }
    let _ = e;
    for (; _ + 1 < f.length && xp(f[_ + 1].group, v) && f[_ + 1].sticky === x; ) {
      const E = f[_ + 1];
      m.width += E.width, _++;
    }
    if (!x) {
      const E = nd(f), w = m.x - E;
      w < 0 && (m.x -= w, m.width += w), m.x + m.width > r && (m.width = r - m.x);
    }
  } else if (t >= c - p) {
    let b = c - t;
    for (m.y = n; b > 0; ) {
      const v = t + b - 1;
      m.height = typeof h == "number" ? h : h(v), m.y -= m.height, b--;
    }
    m.height += 1;
  } else {
    const b = o > t ? -1 : 1;
    if (typeof h == "number") {
      const v = t - o;
      m.y += v * h;
    } else
      for (let v = o; v !== t; v += b)
        m.y += h(v) * b;
    m.height = (typeof h == "number" ? h : h(t)) + 1;
  }
  return m;
}
const MI = 1 << 21;
function Ns(e, t) {
  return (t + 2) * MI + e;
}
function mz(e) {
  return e % MI;
}
function FI(e) {
  return Math.floor(e / MI) - 2;
}
function $I(e) {
  const t = mz(e), r = FI(e);
  return [t, r];
}
class gz {
  visibleWindow = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  freezeCols = 0;
  freezeRows = [];
  isInWindow = (t) => {
    const r = mz(t), n = FI(t), a = this.visibleWindow, s = r >= a.x && r <= a.x + a.width || r < this.freezeCols, i = n >= a.y && n <= a.y + a.height || this.freezeRows.includes(n);
    return s && i;
  };
  setWindow(t, r, n) {
    this.visibleWindow.x === t.x && this.visibleWindow.y === t.y && this.visibleWindow.width === t.width && this.visibleWindow.height === t.height && this.freezeCols === r && rd(this.freezeRows, n) || (this.visibleWindow = t, this.freezeCols = r, this.freezeRows = n, this.clearOutOfWindow());
  }
}
class jne extends gz {
  cache = /* @__PURE__ */ new Map();
  setValue = (t, r) => {
    this.cache.set(Ns(t[0], t[1]), r);
  };
  getValue = (t) => this.cache.get(Ns(t[0], t[1]));
  clearOutOfWindow = () => {
    for (const [t] of this.cache.entries())
      this.isInWindow(t) || this.cache.delete(t);
  };
}
class Zf {
  cells;
  constructor(t = []) {
    this.cells = new Set(t.map((r) => Ns(r[0], r[1])));
  }
  add(t) {
    this.cells.add(Ns(t[0], t[1]));
  }
  has(t) {
    return t === void 0 ? !1 : this.cells.has(Ns(t[0], t[1]));
  }
  remove(t) {
    this.cells.delete(Ns(t[0], t[1]));
  }
  clear() {
    this.cells.clear();
  }
  get size() {
    return this.cells.size;
  }
  hasHeader() {
    for (const t of this.cells)
      if (FI(t) < 0)
        return !0;
    return !1;
  }
  hasItemInRectangle(t) {
    for (let r = t.y; r < t.y + t.height; r++)
      for (let n = t.x; n < t.x + t.width; n++)
        if (this.cells.has(Ns(n, r)))
          return !0;
    return !1;
  }
  hasItemInRegion(t) {
    for (const r of t)
      if (this.hasItemInRectangle(r))
        return !0;
    return !1;
  }
  *values() {
    for (const t of this.cells)
      yield $I(t);
  }
}
function Hne(e) {
  return {
    "--gdg-accent-color": e.accentColor,
    "--gdg-accent-fg": e.accentFg,
    "--gdg-accent-light": e.accentLight,
    "--gdg-text-dark": e.textDark,
    "--gdg-text-medium": e.textMedium,
    "--gdg-text-light": e.textLight,
    "--gdg-text-bubble": e.textBubble,
    "--gdg-bg-icon-header": e.bgIconHeader,
    "--gdg-fg-icon-header": e.fgIconHeader,
    "--gdg-text-header": e.textHeader,
    "--gdg-text-group-header": e.textGroupHeader ?? e.textHeader,
    "--gdg-text-header-selected": e.textHeaderSelected,
    "--gdg-bg-cell": e.bgCell,
    "--gdg-bg-cell-medium": e.bgCellMedium,
    "--gdg-bg-header": e.bgHeader,
    "--gdg-bg-header-has-focus": e.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": e.bgHeaderHovered,
    "--gdg-bg-bubble": e.bgBubble,
    "--gdg-bg-bubble-selected": e.bgBubbleSelected,
    "--gdg-bg-search-result": e.bgSearchResult,
    "--gdg-border-color": e.borderColor,
    "--gdg-horizontal-border-color": e.horizontalBorderColor ?? e.borderColor,
    "--gdg-drilldown-border": e.drilldownBorder,
    "--gdg-link-color": e.linkColor,
    "--gdg-cell-horizontal-padding": `${e.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${e.cellVerticalPadding}px`,
    "--gdg-header-font-style": e.headerFontStyle,
    "--gdg-base-font-style": e.baseFontStyle,
    "--gdg-marker-font-style": e.markerFontStyle,
    "--gdg-font-family": e.fontFamily,
    "--gdg-editor-font-size": e.editorFontSize,
    ...e.resizeIndicatorColor === void 0 ? {} : { "--gdg-resize-indicator-color": e.resizeIndicatorColor },
    ...e.headerBottomBorderColor === void 0 ? {} : { "--gdg-header-bottom-border-color": e.headerBottomBorderColor },
    ...e.roundingRadius === void 0 ? {} : { "--gdg-rounding-radius": `${e.roundingRadius}px` }
  };
}
const bz = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#353fb5",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerIconSize: 18,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  markerFontStyle: "9px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
  //unitless scaler depends on your font
};
function yz() {
  return bz;
}
const Vne = kt.createContext(bz);
function Dl(e, ...t) {
  const r = { ...e };
  for (const n of t)
    if (n !== void 0)
      for (const a in n)
        n.hasOwnProperty(a) && (a === "bgCell" ? r[a] = $a(n[a], r[a]) : r[a] = n[a]);
  return (r.headerFontFull === void 0 || e.fontFamily !== r.fontFamily || e.headerFontStyle !== r.headerFontStyle) && (r.headerFontFull = `${r.headerFontStyle} ${r.fontFamily}`), (r.baseFontFull === void 0 || e.fontFamily !== r.fontFamily || e.baseFontStyle !== r.baseFontStyle) && (r.baseFontFull = `${r.baseFontStyle} ${r.fontFamily}`), (r.markerFontFull === void 0 || e.fontFamily !== r.fontFamily || e.markerFontStyle !== r.markerFontStyle) && (r.markerFontFull = `${r.markerFontStyle} ${r.fontFamily}`), r;
}
const qT = 150;
function Gne(e, t, r, n) {
  return n(t)?.measure?.(e, t, r) ?? qT;
}
function vz(e, t, r, n, a, s, i, o, l) {
  let u = 0;
  const c = a === void 0 ? [] : a.map((p) => {
    const f = Gne(e, p[n], t, l);
    return u = Math.max(u, f), f;
  });
  if (c.length > 5 && o) {
    u = 0;
    let p = 0;
    for (const h of c)
      p += h;
    const f = p / c.length;
    for (let h = 0; h < c.length; h++)
      c[h] >= f * 2 ? c[h] = 0 : u = Math.max(u, c[h]);
  }
  u = Math.max(u, e.measureText(r.title).width + 16 + (r.icon === void 0 ? 0 : 28));
  const d = Math.max(Math.ceil(s), Math.min(Math.floor(i), Math.ceil(u)));
  return {
    ...r,
    width: d
  };
}
function Wne(e, t, r, n, a, s, i, o, l) {
  const u = D.useRef(t), c = D.useRef(r), d = D.useRef(i);
  u.current = t, c.current = r, d.current = i;
  const [p, f] = D.useMemo(() => {
    if (typeof window > "u")
      return [null, null];
    const v = document.createElement("canvas");
    return v.style.display = "none", v.style.opacity = "0", v.style.position = "fixed", [v, v.getContext("2d", { alpha: !1 })];
  }, []);
  D.useLayoutEffect(() => (p && document.documentElement.append(p), () => {
    p?.remove();
  }), [p]);
  const h = D.useRef({}), m = D.useRef(), [y, b] = D.useState();
  return D.useLayoutEffect(() => {
    const v = c.current;
    if (v === void 0 || e.every(Xh))
      return;
    let x = Math.max(1, 10 - Math.floor(e.length / 1e4)), _ = 0;
    x < u.current && x > 1 && (x--, _ = 1);
    const E = {
      x: 0,
      y: 0,
      width: e.length,
      height: Math.min(u.current, x)
    }, w = {
      x: 0,
      y: u.current - 1,
      width: e.length,
      height: 1
    };
    (async () => {
      const k = v(E, l.signal), S = _ > 0 ? v(w, l.signal) : void 0;
      let B;
      typeof k == "object" ? B = k : B = await BO(k), S !== void 0 && (typeof S == "object" ? B = [...B, ...S] : B = [...B, ...await BO(S)]), m.current = e, b(B);
    })();
  }, [l.signal, e]), D.useMemo(() => {
    let x = e.every(Xh) ? e : f === null ? e.map((C) => Xh(C) ? C : {
      ...C,
      width: qT
    }) : (f.font = d.current.baseFontFull, e.map((C, k) => {
      if (Xh(C))
        return C;
      if (h.current[C.id] !== void 0)
        return {
          ...C,
          width: h.current[C.id]
        };
      if (y === void 0 || m.current !== e || C.id === void 0)
        return {
          ...C,
          width: qT
        };
      const S = vz(f, i, C, k, y, a, s, !0, o);
      return h.current[C.id] = S.width, S;
    })), _ = 0, E = 0;
    const w = [];
    for (const [C, k] of x.entries())
      _ += k.width, k.grow !== void 0 && k.grow > 0 && (E += k.grow, w.push(C));
    if (_ < n && w.length > 0) {
      const C = [...x], k = n - _;
      let S = k;
      for (let B = 0; B < w.length; B++) {
        const U = w[B], N = (x[U].grow ?? 0) / E, O = B === w.length - 1 ? S : Math.min(S, Math.floor(k * N));
        C[U] = {
          ...x[U],
          growOffset: O,
          width: x[U].width + O
        }, S -= O;
      }
      x = C;
    }
    return {
      sizedColumns: x,
      nonGrowWidth: _
    };
  }, [n, e, f, y, i, a, s, o]);
}
var w0, D4;
function Kne() {
  if (D4) return w0;
  D4 = 1;
  function e(t, r, n) {
    return t === t && (n !== void 0 && (t = t <= n ? t : n), r !== void 0 && (t = t >= r ? t : r)), t;
  }
  return w0 = e, w0;
}
var x0, O4;
function Yne() {
  if (O4) return x0;
  O4 = 1;
  var e = Kne(), t = NI();
  function r(n, a, s) {
    return s === void 0 && (s = a, a = void 0), s !== void 0 && (s = t(s), s = s === s ? s : 0), a !== void 0 && (a = t(a), a = a === a ? a : 0), e(t(n), a, s);
  }
  return x0 = r, x0;
}
var Xne = Yne();
const Rs = /* @__PURE__ */ da(Xne);
var E0, P4;
function Zne() {
  if (P4) return E0;
  P4 = 1;
  var e = "__lodash_hash_undefined__";
  function t(r) {
    return this.__data__.set(r, e), this;
  }
  return E0 = t, E0;
}
var S0, L4;
function Jne() {
  if (L4) return S0;
  L4 = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return S0 = e, S0;
}
var _0, M4;
function wz() {
  if (M4) return _0;
  M4 = 1;
  var e = _I(), t = Zne(), r = Jne();
  function n(a) {
    var s = -1, i = a == null ? 0 : a.length;
    for (this.__data__ = new e(); ++s < i; )
      this.add(a[s]);
  }
  return n.prototype.add = n.prototype.push = t, n.prototype.has = r, _0 = n, _0;
}
var k0, F4;
function Qne() {
  if (F4) return k0;
  F4 = 1;
  function e(t, r, n, a) {
    for (var s = t.length, i = n + (a ? 1 : -1); a ? i-- : ++i < s; )
      if (r(t[i], i, t))
        return i;
    return -1;
  }
  return k0 = e, k0;
}
var C0, $4;
function eie() {
  if ($4) return C0;
  $4 = 1;
  function e(t) {
    return t !== t;
  }
  return C0 = e, C0;
}
var A0, B4;
function tie() {
  if (B4) return A0;
  B4 = 1;
  function e(t, r, n) {
    for (var a = n - 1, s = t.length; ++a < s; )
      if (t[a] === r)
        return a;
    return -1;
  }
  return A0 = e, A0;
}
var T0, U4;
function rie() {
  if (U4) return T0;
  U4 = 1;
  var e = Qne(), t = eie(), r = tie();
  function n(a, s, i) {
    return s === s ? r(a, s, i) : e(a, t, i);
  }
  return T0 = n, T0;
}
var R0, z4;
function nie() {
  if (z4) return R0;
  z4 = 1;
  var e = rie();
  function t(r, n) {
    var a = r == null ? 0 : r.length;
    return !!a && e(r, n, 0) > -1;
  }
  return R0 = t, R0;
}
var I0, q4;
function iie() {
  if (q4) return I0;
  q4 = 1;
  function e(t, r, n) {
    for (var a = -1, s = t == null ? 0 : t.length; ++a < s; )
      if (n(r, t[a]))
        return !0;
    return !1;
  }
  return I0 = e, I0;
}
var N0, j4;
function xz() {
  if (j4) return N0;
  j4 = 1;
  function e(t, r) {
    return t.has(r);
  }
  return N0 = e, N0;
}
var D0, H4;
function Ez() {
  if (H4) return D0;
  H4 = 1;
  var e = $u(), t = po(), r = e(t, "Set");
  return D0 = r, D0;
}
var O0, V4;
function aie() {
  if (V4) return O0;
  V4 = 1;
  function e() {
  }
  return O0 = e, O0;
}
var P0, G4;
function BI() {
  if (G4) return P0;
  G4 = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(a) {
      n[++r] = a;
    }), n;
  }
  return P0 = e, P0;
}
var L0, W4;
function sie() {
  if (W4) return L0;
  W4 = 1;
  var e = Ez(), t = aie(), r = BI(), n = 1 / 0, a = e && 1 / r(new e([, -0]))[1] == n ? function(s) {
    return new e(s);
  } : t;
  return L0 = a, L0;
}
var M0, K4;
function oie() {
  if (K4) return M0;
  K4 = 1;
  var e = wz(), t = nie(), r = iie(), n = xz(), a = sie(), s = BI(), i = 200;
  function o(l, u, c) {
    var d = -1, p = t, f = l.length, h = !0, m = [], y = m;
    if (c)
      h = !1, p = r;
    else if (f >= i) {
      var b = u ? null : a(l);
      if (b)
        return s(b);
      h = !1, p = n, y = new e();
    } else
      y = u ? [] : m;
    e:
      for (; ++d < f; ) {
        var v = l[d], x = u ? u(v) : v;
        if (v = c || v !== 0 ? v : 0, h && x === x) {
          for (var _ = y.length; _--; )
            if (y[_] === x)
              continue e;
          u && y.push(x), m.push(v);
        } else p(y, x, c) || (y !== m && y.push(x), m.push(v));
      }
    return m;
  }
  return M0 = o, M0;
}
var F0, Y4;
function lie() {
  if (Y4) return F0;
  Y4 = 1;
  var e = oie();
  function t(r) {
    return r && r.length ? e(r) : [];
  }
  return F0 = t, F0;
}
var uie = lie();
const cie = /* @__PURE__ */ da(uie);
var $0, X4;
function Sz() {
  if (X4) return $0;
  X4 = 1;
  function e(t, r) {
    for (var n = -1, a = r.length, s = t.length; ++n < a; )
      t[s + n] = r[n];
    return t;
  }
  return $0 = e, $0;
}
var B0, Z4;
function die() {
  if (Z4) return B0;
  Z4 = 1;
  var e = nh(), t = kI(), r = fo(), n = e ? e.isConcatSpreadable : void 0;
  function a(s) {
    return r(s) || t(s) || !!(n && s && s[n]);
  }
  return B0 = a, B0;
}
var U0, J4;
function fie() {
  if (J4) return U0;
  J4 = 1;
  var e = Sz(), t = die();
  function r(n, a, s, i, o) {
    var l = -1, u = n.length;
    for (s || (s = t), o || (o = []); ++l < u; ) {
      var c = n[l];
      a > 0 && s(c) ? a > 1 ? r(c, a - 1, s, i, o) : e(o, c) : i || (o[o.length] = c);
    }
    return o;
  }
  return U0 = r, U0;
}
var z0, Q4;
function pie() {
  if (Q4) return z0;
  Q4 = 1;
  var e = fie();
  function t(r) {
    var n = r == null ? 0 : r.length;
    return n ? e(r, 1) : [];
  }
  return z0 = t, z0;
}
var hie = pie();
const e3 = /* @__PURE__ */ da(hie);
var q0, t3;
function mie() {
  if (t3) return q0;
  t3 = 1;
  var e = Math.ceil, t = Math.max;
  function r(n, a, s, i) {
    for (var o = -1, l = t(e((a - n) / (s || 1)), 0), u = Array(l); l--; )
      u[i ? l : ++o] = n, n += s;
    return u;
  }
  return q0 = r, q0;
}
var j0, r3;
function UI() {
  if (r3) return j0;
  r3 = 1;
  var e = FU(), t = AI();
  function r(n) {
    return n != null && t(n.length) && !e(n);
  }
  return j0 = r, j0;
}
var H0, n3;
function gie() {
  if (n3) return H0;
  n3 = 1;
  var e = EI(), t = UI(), r = CI(), n = Fu();
  function a(s, i, o) {
    if (!n(o))
      return !1;
    var l = typeof i;
    return (l == "number" ? t(o) && r(i, o.length) : l == "string" && i in o) ? e(o[i], s) : !1;
  }
  return H0 = a, H0;
}
var V0, i3;
function bie() {
  if (i3) return V0;
  i3 = 1;
  var e = NI(), t = 1 / 0, r = 17976931348623157e292;
  function n(a) {
    if (!a)
      return a === 0 ? a : 0;
    if (a = e(a), a === t || a === -1 / 0) {
      var s = a < 0 ? -1 : 1;
      return s * r;
    }
    return a === a ? a : 0;
  }
  return V0 = n, V0;
}
var G0, a3;
function yie() {
  if (a3) return G0;
  a3 = 1;
  var e = mie(), t = gie(), r = bie();
  function n(a) {
    return function(s, i, o) {
      return o && typeof o != "number" && t(s, i, o) && (i = o = void 0), s = r(s), i === void 0 ? (i = s, s = 0) : i = r(i), o = o === void 0 ? s < i ? 1 : -1 : r(o), e(s, i, o, a);
    };
  }
  return G0 = n, G0;
}
var W0, s3;
function vie() {
  if (s3) return W0;
  s3 = 1;
  var e = yie(), t = e();
  return W0 = t, W0;
}
var wie = vie();
const hu = /* @__PURE__ */ da(wie), Kn = '<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">', xie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}<rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${t}"/></svg>`;
}, Eie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}<rect x="2" y="2" width="16" height="16" rx="4" fill="${r}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${t}"/></svg>`;
}, Sie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${r}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${t}"/>
  </svg>`;
}, _ie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${t}"/>
</svg>`;
}, kie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${r}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${t}"
    />
</svg>`;
}, _z = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${t}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${t}"/>
</svg>
  `;
}, Cie = (e) => {
  const t = e.bgColor;
  return `${Kn}
    <path stroke="${t}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${t}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${t}"/>
  </svg>
`;
}, Aie = _z, Tie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${t}"/>
</svg>`;
}, Rie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${t}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${t}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${t}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${r}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${t}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${t}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${t}"/>
  </svg>`;
}, Iie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${t}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${t}"/>
</svg>`;
}, Nie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <path fill="${t}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${r}"/>
  </svg>`;
}, Die = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${r}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${t}"/>
  </svg>`;
}, Oie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${t}"/>
</svg>`;
}, Pie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${r}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${t}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${t}"/>
  </svg>`;
}, Lie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${t}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${t}"/>
</svg>`;
}, Mie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${r}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${r}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${t}"/>
  </svg>`;
}, Fie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path fill="${t}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${r}"/>
</svg>`;
}, $ie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${t}"/>
  </svg>`;
}, Bie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${t}"/>
  </svg>`;
}, Uie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${t}"/>
</svg>`;
}, zie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${t}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${t}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${t}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${t}"/>
</svg>`;
}, qie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${r}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${t}"/>
  </svg>`;
}, jie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${t}"/>
</svg>`;
}, Hie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `
    ${Kn}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${t}"/>
  </svg>`;
}, Vie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${r}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${t}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${t}"/>
</svg>`;
}, Gie = (e) => {
  const t = e.fgColor, r = e.bgColor;
  return `${Kn}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${r}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${t}"/>
</svg>`;
}, Wie = (e) => {
  const t = e.fgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${e.bgColor}" stroke="${t}" stroke-width="2"/>
  </svg>`;
}, Kie = (e) => {
  const t = e.fgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${e.bgColor}" stroke="${t}" stroke-width="2"/>
  </svg>
`;
}, Yie = {
  headerRowID: xie,
  headerNumber: Sie,
  headerCode: Eie,
  headerString: _ie,
  headerBoolean: kie,
  headerAudioUri: Aie,
  headerVideoUri: Tie,
  headerEmoji: Rie,
  headerImage: Iie,
  headerUri: _z,
  headerPhone: Nie,
  headerMarkdown: Die,
  headerDate: Oie,
  headerTime: Pie,
  headerEmail: Lie,
  headerReference: Mie,
  headerIfThenElse: Fie,
  headerSingleValue: $ie,
  headerLookup: Bie,
  headerTextTemplate: Uie,
  headerMath: zie,
  headerRollup: qie,
  headerJoinStrings: jie,
  headerSplitString: Hie,
  headerGeoDistance: Vie,
  headerArray: Gie,
  rowOwnerOverlay: Wie,
  protectedColumnOverlay: Kie,
  renameIcon: Cie
};
function Xie(e, t) {
  return e === "normal" ? [t.bgIconHeader, t.fgIconHeader] : e === "selected" ? ["white", t.accentColor] : [t.accentColor, t.bgHeader];
}
class Zie {
  onSettled;
  spriteMap = /* @__PURE__ */ new Map();
  headerIcons;
  inFlight = 0;
  constructor(t, r) {
    this.onSettled = r, this.headerIcons = t ?? {};
  }
  drawSprite(t, r, n, a, s, i, o, l = 1) {
    const [u, c] = Xie(r, o), d = i * Math.ceil(window.devicePixelRatio), p = `${u}_${c}_${d}_${t}`;
    let f = this.spriteMap.get(p);
    if (f === void 0) {
      const h = this.headerIcons[t];
      if (h === void 0)
        return;
      f = document.createElement("canvas");
      const m = f.getContext("2d");
      if (m === null)
        return;
      const y = new Image();
      y.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(h({ fgColor: c, bgColor: u }))}`, this.spriteMap.set(p, f);
      const b = y.decode();
      if (b === void 0)
        return;
      this.inFlight++, b.then(() => {
        m.drawImage(y, 0, 0, d, d);
      }).finally(() => {
        this.inFlight--, this.inFlight === 0 && this.onSettled();
      });
    } else
      l < 1 && (n.globalAlpha = l), n.drawImage(f, 0, 0, d, d, a, s, i, i), l < 1 && (n.globalAlpha = 1);
  }
}
function kz(e) {
  if (e.length === 0)
    return;
  let t;
  for (const r of e)
    t = Math.min(t ?? r.y, r.y);
}
function Lb(e, t, r, n, a, s, i, o, l) {
  o = o ?? t;
  let u = t, c = e;
  const d = n - s;
  let p = !1;
  for (; u < r && c < d; ) {
    const f = a(c);
    if (u + f > o && l(u, c, f, !1, i && c === n - 1) === !0) {
      p = !0;
      break;
    }
    u += f, c++;
  }
  if (!p) {
    u = r;
    for (let f = 0; f < s; f++) {
      c = n - 1 - f;
      const h = a(c);
      u -= h, l(u, c, h, !0, i && c === n - 1);
    }
  }
}
function Gl(e, t, r, n, a, s) {
  let i = 0, o = 0;
  const l = a + n;
  for (const u of e) {
    const c = u.sticky ? o : i + r;
    if (s(u, c, l, u.sticky ? 0 : o, t) === !0)
      break;
    i += u.width, o += u.sticky ? u.width : 0;
  }
}
function Cz(e, t, r, n, a) {
  let s = 0, i = 0;
  for (let o = 0; o < e.length; o++) {
    const l = e[o];
    let u = o + 1, c = l.width;
    for (l.sticky && (i += c); u < e.length && xp(e[u].group, l.group) && e[u].sticky === e[o].sticky; ) {
      const m = e[u];
      c += m.width, u++, o++, m.sticky && (i += m.width);
    }
    const d = l.sticky ? 0 : r, p = s + d, f = l.sticky ? 0 : Math.max(0, i - p), h = Math.min(c - f, t - (p + f));
    a([l.sourceIndex, e[u - 1].sourceIndex], l.group ?? "", p + f, 0, h, n), s += c;
  }
}
function Az(e, t, r, n, a, s, i) {
  const [o, l] = e;
  let u, c;
  const d = i.find((p) => !p.sticky)?.sourceIndex ?? 0;
  if (l > d) {
    const p = Math.max(o, d);
    let f = t, h = n;
    for (let m = s.sourceIndex - 1; m >= p; m--)
      f -= i[m].width, h += i[m].width;
    for (let m = s.sourceIndex + 1; m <= l; m++)
      h += i[m].width;
    c = {
      x: f,
      y: r,
      width: h,
      height: a
    };
  }
  if (d > o) {
    const p = Math.min(l, d - 1);
    let f = t, h = n;
    for (let m = s.sourceIndex - 1; m >= o; m--)
      f -= i[m].width, h += i[m].width;
    for (let m = s.sourceIndex + 1; m <= p; m++)
      h += i[m].width;
    u = {
      x: f,
      y: r,
      width: h,
      height: a
    };
  }
  return [u, c];
}
function Jie(e, t, r, n) {
  if (n === "any")
    return Tz(e, { x: t, y: r, width: 1, height: 1 });
  if (n === "vertical" && (t = e.x), n === "horizontal" && (r = e.y), uz([t, r], e))
    return;
  const a = t - e.x, s = e.x + e.width - t, i = r - e.y + 1, o = e.y + e.height - r, l = Math.min(n === "vertical" ? Number.MAX_SAFE_INTEGER : a, n === "vertical" ? Number.MAX_SAFE_INTEGER : s, n === "horizontal" ? Number.MAX_SAFE_INTEGER : i, n === "horizontal" ? Number.MAX_SAFE_INTEGER : o);
  return l === o ? { x: e.x, y: e.y + e.height, width: e.width, height: r - e.y - e.height + 1 } : l === i ? { x: e.x, y: r, width: e.width, height: e.y - r } : l === s ? { x: e.x + e.width, y: e.y, width: t - e.x - e.width + 1, height: e.height } : { x: t, y: e.y, width: e.x - t, height: e.height };
}
function Ng(e, t, r, n, a, s, i, o) {
  return e <= a + i && a <= e + r && t <= s + o && s <= t + n;
}
function Mb(e, t, r) {
  return t >= e.x && t <= e.x + e.width && r >= e.y && r <= e.y + e.height;
}
function Tz(e, t) {
  const r = Math.min(e.x, t.x), n = Math.min(e.y, t.y), a = Math.max(e.x + e.width, t.x + t.width) - r, s = Math.max(e.y + e.height, t.y + t.height) - n;
  return { x: r, y: n, width: a, height: s };
}
function Qie(e, t) {
  return e.x <= t.x && e.y <= t.y && e.x + e.width >= t.x + t.width && e.y + e.height >= t.y + t.height;
}
function eae(e, t, r, n) {
  if (e.x > t || e.y > r || e.x < 0 && e.y < 0 && e.x + e.width > t && e.y + e.height > r)
    return;
  if (e.x >= 0 && e.y >= 0 && e.x + e.width <= t && e.y + e.height <= r)
    return e;
  const a = -4, s = -4, i = t + 4, o = r + 4, l = a - e.x, u = e.x + e.width - i, c = s - e.y, d = e.y + e.height - o, p = l > 0 ? e.x + Math.floor(l / n) * n : e.x, f = u > 0 ? e.x + e.width - Math.floor(u / n) * n : e.x + e.width, h = c > 0 ? e.y + Math.floor(c / n) * n : e.y, m = d > 0 ? e.y + e.height - Math.floor(d / n) * n : e.y + e.height;
  return { x: p, y: h, width: f - p, height: m - h };
}
function tae(e, t, r, n, a) {
  const [s, i, o, l] = t, [u, c, d, p] = a, { x: f, y: h, width: m, height: y } = e, b = [];
  if (m <= 0 || y <= 0)
    return b;
  const v = f + m, x = h + y, _ = f < s, E = h < i, w = f + m > o, C = h + y > l, k = f >= s && f < o || v > s && v <= o || f < s && v > o, S = h >= i && h < l || x > i && x <= l || h < i && x > l;
  if (k && S) {
    const U = Math.max(f, s), N = Math.max(h, i), O = Math.min(v, o), I = Math.min(x, l);
    b.push({
      rect: { x: U, y: N, width: O - U, height: I - N },
      clip: {
        x: u,
        y: c,
        width: d - u + 1,
        height: p - c + 1
      }
    });
  }
  if (_ && E) {
    const U = f, N = h, O = Math.min(v, s), I = Math.min(x, i);
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: 0,
        y: 0,
        width: u + 1,
        height: c + 1
      }
    });
  }
  if (E && k) {
    const U = Math.max(f, s), N = h, O = Math.min(v, o), I = Math.min(x, i);
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: u,
        y: 0,
        width: d - u + 1,
        height: c + 1
      }
    });
  }
  if (E && w) {
    const U = Math.max(f, o), N = h, O = v, I = Math.min(x, i);
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: d,
        y: 0,
        width: r - d + 1,
        height: c + 1
      }
    });
  }
  if (_ && S) {
    const U = f, N = Math.max(h, i), O = Math.min(v, s), I = Math.min(x, l);
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: 0,
        y: c,
        width: u + 1,
        height: p - c + 1
      }
    });
  }
  if (w && S) {
    const U = Math.max(f, o), N = Math.max(h, i), O = v, I = Math.min(x, l);
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: d,
        y: c,
        width: r - d + 1,
        height: p - c + 1
      }
    });
  }
  if (_ && C) {
    const U = f, N = Math.max(h, l), O = Math.min(v, s), I = x;
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: 0,
        y: p,
        width: u + 1,
        height: n - p + 1
      }
    });
  }
  if (C && k) {
    const U = Math.max(f, s), N = Math.max(h, l), O = Math.min(v, o), I = x;
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: u,
        y: p,
        width: d - u + 1,
        height: n - p + 1
      }
    });
  }
  if (w && C) {
    const U = Math.max(f, o), N = Math.max(h, l), O = v, I = x;
    b.push({
      rect: {
        x: U,
        y: N,
        width: O - U,
        height: I - N
      },
      clip: {
        x: d,
        y: p,
        width: r - d + 1,
        height: n - p + 1
      }
    });
  }
  return b;
}
const rae = {
  kind: Gt.Loading,
  allowOverlay: !1
};
function o3(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v, x, _, E, w, C, k, S, B, U, N, O, I, q, ae, Q, ne) {
  let le = x?.size ?? Number.MAX_SAFE_INTEGER;
  const W = performance.now();
  let X = O.baseFontFull;
  e.font = X;
  const G = { ctx: e }, P = [0, 0], he = y > 0 ? Uu(l, y, u) : 0;
  let ye, pe;
  const $ = kz(v);
  return Gl(t, o, s, i, a, (F, ge, ce, ie, re) => {
    const Te = Math.max(0, ie - ge), V = ge + Te, Pe = a + 1, z = F.width - Te, A = n - a - 1;
    if (v.length > 0) {
      let xe = !1;
      for (let we = 0; we < v.length; we++) {
        const te = v[we];
        if (Ng(V, Pe, z, A, te.x, te.y, te.width, te.height)) {
          xe = !0;
          break;
        }
      }
      if (!xe)
        return;
    }
    const R = () => {
      e.save(), e.beginPath(), e.rect(V, Pe, z, A), e.clip();
    }, H = _.columns.hasIndex(F.sourceIndex), be = d(F.group ?? "").overrideTheme, me = F.themeOverride === void 0 && be === void 0 ? O : Dl(O, be, F.themeOverride), Ce = me.baseFontFull;
    Ce !== X && (X = Ce, e.font = Ce), R();
    let We;
    return Lb(re, ce, n, l, u, y, b, $, (xe, we, te, Fe, Y) => {
      if (we < 0 || (P[0] = F.sourceIndex, P[1] = we, x !== void 0 && !x.has(P)))
        return;
      if (v.length > 0) {
        let Nt = !1;
        for (let dr = 0; dr < v.length; dr++) {
          const $e = v[dr];
          if (Ng(ge, xe, F.width, te, $e.x, $e.y, $e.width, $e.height)) {
            Nt = !0;
            break;
          }
        }
        if (!Nt)
          return;
      }
      const Je = _.rows.hasIndex(we), xt = f.hasIndex(we), Ze = we < l ? c(P) : rae;
      let rt = ge, Mt = F.width, Qt = !1, kr = !1;
      if (Ze.span !== void 0) {
        const [Nt, dr] = Ze.span, $e = `${we},${Nt},${dr},${F.sticky}`;
        if (pe === void 0 && (pe = /* @__PURE__ */ new Set()), pe.has($e)) {
          le--;
          return;
        } else {
          const at = Az(Ze.span, ge, xe, F.width, te, F, r), Rt = F.sticky ? at[0] : at[1];
          if (!F.sticky && at[0] !== void 0 && (kr = !0), Rt !== void 0) {
            rt = Rt.x, Mt = Rt.width, pe.add($e), e.restore(), We = void 0, e.save(), e.beginPath();
            const sr = Math.max(0, ie - Rt.x);
            e.rect(Rt.x + sr, xe, Rt.width - sr, te), ye === void 0 && (ye = []), ye.push({
              x: Rt.x + sr,
              y: xe,
              width: Rt.width - sr,
              height: te
            }), e.clip(), Qt = !0;
          }
        }
      }
      const tr = p?.(we), Oe = Y && F.trailingRowOptions?.themeOverride !== void 0 ? F.trailingRowOptions?.themeOverride : void 0, Ie = Ze.themeOverride === void 0 && tr === void 0 && Oe === void 0 ? me : Dl(me, tr, Oe, Ze.themeOverride);
      e.beginPath();
      const Me = Ine(P, Ze, _);
      let je = Nne(P, Ze, _, m);
      const tt = Ze.span !== void 0 && _.columns.some(
        (Nt) => Ze.span !== void 0 && Nt >= Ze.span[0] && Nt <= Ze.span[1]
        //alloc
      );
      Me && !h && m ? je = 0 : Me && m && (je = Math.max(je, 1)), tt && je++, Me || (Je && je++, H && !Y && je++);
      const Ct = Ze.kind === Gt.Protected ? Ie.bgCellMedium : Ie.bgCell;
      let Kt;
      if ((Fe || Ct !== O.bgCell) && (Kt = $a(Ct, Kt)), je > 0 || xt) {
        xt && (Kt = $a(Ie.bgHeader, Kt));
        for (let Nt = 0; Nt < je; Nt++)
          Kt = $a(Ie.accentLight, Kt);
      } else if (E !== void 0) {
        for (const Nt of E)
          if (Nt[0] === F.sourceIndex && Nt[1] === we) {
            Kt = $a(Ie.bgSearchResult, Kt);
            break;
          }
      }
      if (w !== void 0)
        for (let Nt = 0; Nt < w.length; Nt++) {
          const dr = w[Nt], $e = dr.range;
          dr.style !== "solid-outline" && $e.x <= F.sourceIndex && F.sourceIndex < $e.x + $e.width && $e.y <= we && we < $e.y + $e.height && (Kt = $a(dr.color, Kt));
        }
      let ct = !1;
      if (x !== void 0) {
        const Nt = xe + 1, $e = (Fe ? Nt + te - 1 : Math.min(Nt + te - 1, n - he)) - Nt;
        ($e !== te - 1 || rt + 1 <= ie) && (ct = !0, e.save(), e.beginPath(), e.rect(rt + 1, Nt, Mt - 1, $e), e.clip()), Kt = Kt === void 0 ? Ie.bgCell : $a(Kt, Ie.bgCell);
      }
      const ir = F.sourceIndex === r.length - 1, xr = we === l - 1;
      Kt !== void 0 && (e.fillStyle = Kt, We !== void 0 && (We.fillStyle = Kt), x !== void 0 ? e.fillRect(rt + 1, xe + 1, Mt - (ir ? 2 : 1), te - (xr ? 2 : 1)) : e.fillRect(rt, xe, Mt, te)), Ze.style === "faded" && (e.globalAlpha = 0.6);
      let Rr;
      for (let Nt = 0; Nt < S.length; Nt++) {
        const dr = S[Nt];
        if (dr.item[0] === F.sourceIndex && dr.item[1] === we) {
          Rr = dr;
          break;
        }
      }
      if (Mt > ne && !kr) {
        const Nt = Ie.baseFontFull;
        Nt !== X && (e.font = Nt, X = Nt), We = Rz(e, Ze, F.sourceIndex, we, ir, xr, rt, xe, Mt, te, je > 0, Ie, Kt ?? Ie.bgCell, C, k, Rr?.hoverAmount ?? 0, B, N, W, U, We, I, q, ae, Q);
      }
      return ct && e.restore(), Ze.style === "faded" && (e.globalAlpha = 1), le--, Qt && (e.restore(), We?.deprep?.(G), We = void 0, R(), X = Ce, e.font = Ce), le <= 0;
    }), e.restore(), le <= 0;
  }), ye;
}
const of = [0, 0], lf = { x: 0, y: 0, width: 0, height: 0 }, K0 = [void 0, () => {
}];
let jT = !1;
function nae() {
  jT = !0;
}
function Rz(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v, x, _, E, w, C, k) {
  let S, B;
  y !== void 0 && y[0][0] === r && y[0][1] === n && (S = y[1][0], B = y[1][1]);
  let U;
  of[0] = r, of[1] = n, lf.x = i, lf.y = o, lf.width = l, lf.height = u, K0[0] = w.getValue(of), K0[1] = (q) => w.setValue(of, q), jT = !1;
  const N = {
    //alloc
    ctx: e,
    theme: d,
    col: r,
    row: n,
    cell: t,
    rect: lf,
    highlighted: c,
    cellFillColor: p,
    hoverAmount: m,
    frameTime: v,
    hoverX: S,
    drawState: K0,
    hoverY: B,
    imageLoader: f,
    spriteManager: h,
    hyperWrapping: b,
    overrideCursor: S !== void 0 ? k : void 0,
    requestAnimationFrame: nae
  }, O = $ne(N, t.lastUpdated, v, _, a, s), I = C(t);
  if (I !== void 0) {
    _?.renderer !== I && (_?.deprep?.(N), _ = void 0);
    const q = I.drawPrep?.(N, _);
    x !== void 0 && !Oc(N.cell) ? x(N, () => I.draw(N, t)) : I.draw(N, t), U = q === void 0 ? void 0 : {
      deprep: q?.deprep,
      fillStyle: q?.fillStyle,
      font: q?.font,
      renderer: I
    };
  }
  return (O || jT) && E?.(of), U;
}
function zI(e, t, r, n, a, s, i, o, l = -20, u = -20, c = 32, d = "center", p = "square") {
  const f = Math.floor(a + i / 2), h = p === "circle" ? 1e4 : t.roundingRadius ?? 4;
  let m = QU(c, i, t.cellVerticalPadding), y = m / 2;
  const b = JU(d, n, s, t.cellHorizontalPadding, m), v = ZU(b, f, m), x = ez(n + l, a + u, v);
  switch (r) {
    case !0: {
      e.beginPath(), os(e, b - m / 2, f - m / 2, m, m, h), p === "circle" && (y *= 0.8, m *= 0.8), e.fillStyle = o ? t.accentColor : t.textMedium, e.fill(), e.beginPath(), e.moveTo(b - y + m / 4.23, f - y + m / 1.97), e.lineTo(b - y + m / 2.42, f - y + m / 1.44), e.lineTo(b - y + m / 1.29, f - y + m / 3.25), e.strokeStyle = t.bgCell, e.lineJoin = "round", e.lineCap = "round", e.lineWidth = 1.9, e.stroke();
      break;
    }
    case Tg:
    case !1: {
      e.beginPath(), os(e, b - m / 2 + 0.5, f - m / 2 + 0.5, m - 1, m - 1, h), e.lineWidth = 1, e.strokeStyle = x ? t.textDark : t.textMedium, e.stroke();
      break;
    }
    case TI: {
      e.beginPath(), os(e, b - m / 2, f - m / 2, m, m, h), e.fillStyle = x ? t.textMedium : t.textLight, e.fill(), p === "circle" && (y *= 0.8, m *= 0.8), e.beginPath(), e.moveTo(b - m / 3, f), e.lineTo(b + m / 3, f), e.strokeStyle = t.bgCell, e.lineCap = "round", e.lineWidth = 1.9, e.stroke();
      break;
    }
    default:
      vp();
  }
}
function iae(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v) {
  const x = i + o;
  if (x <= 0)
    return;
  e.fillStyle = d.bgHeader, e.fillRect(0, 0, a, x);
  const [_, E] = n?.[0] ?? [], w = d.headerFontFull;
  e.font = w, Gl(t, 0, s, 0, x, (C, k, S, B) => {
    if (y !== void 0 && !y.has([C.sourceIndex, -1]))
      return;
    const U = Math.max(0, B - k);
    e.save(), e.beginPath(), e.rect(k + U, o, C.width - U, i), e.clip();
    const N = m(C.group ?? "").overrideTheme, O = C.themeOverride === void 0 && N === void 0 ? d : Dl(d, N, C.themeOverride);
    O.bgHeader !== d.bgHeader && (e.fillStyle = O.bgHeader, e.fill()), O !== d && (e.font = O.baseFontFull);
    const I = c.columns.hasIndex(C.sourceIndex), q = l !== void 0 || u, ae = !q && E === -1 && _ === C.sourceIndex, Q = q ? 0 : f.find((G) => G.item[0] === C.sourceIndex && G.item[1] === -1)?.hoverAmount ?? 0, ne = c?.current !== void 0 && c.current.cell[0] === C.sourceIndex, le = I ? O.accentColor : ne ? O.bgHeaderHasFocus : O.bgHeader, W = r ? o : 0, X = C.sourceIndex === 0 ? 0 : 1;
    I ? (e.fillStyle = le, e.fillRect(k + X, W, C.width - X, i)) : (ne || Q > 0) && (e.beginPath(), e.rect(k + X, W, C.width - X, i), ne && (e.fillStyle = O.bgHeaderHasFocus, e.fill()), Q > 0 && (e.globalAlpha = Q, e.fillStyle = O.bgHeaderHovered, e.fill(), e.globalAlpha = 1)), Dz(e, k, W, C.width, i, C, I, O, ae, ne, Q, p, b, v), e.restore();
  }), r && aae(e, t, a, s, o, n, d, p, f, h, m, y);
}
function aae(e, t, r, n, a, s, i, o, l, u, c, d) {
  const [f, h] = s?.[0] ?? [];
  let m = 0;
  Cz(t, r, n, a, (y, b, v, x, _, E) => {
    if (d !== void 0 && !d.hasItemInRectangle({
      x: y[0],
      y: -2,
      width: y[1] - y[0] + 1,
      height: 1
    }))
      return;
    e.save(), e.beginPath(), e.rect(v, x, _, E), e.clip();
    const w = c(b), C = w?.overrideTheme === void 0 ? i : Dl(i, w.overrideTheme), k = h === -2 && f !== void 0 && f >= y[0] && f <= y[1], S = k ? C.bgHeaderHovered : C.bgHeader;
    if (S !== i.bgHeader && (e.fillStyle = S, e.fill()), e.fillStyle = C.textGroupHeader ?? C.textHeader, w !== void 0) {
      let B = v;
      if (w.icon !== void 0 && (o.drawSprite(w.icon, "normal", e, B + 8, (a - 20) / 2, 20, C), B += 26), e.fillText(w.name, B + 8, a / 2 + Yo(e, i.headerFontFull)), w.actions !== void 0 && k) {
        const U = Nz({ x: v, y: x, width: _, height: E }, w.actions);
        e.beginPath();
        const N = U[0].x - 10, O = v + _ - N;
        e.rect(N, 0, O, a);
        const I = e.createLinearGradient(N, 0, N + O, 0), q = ku(S, 0);
        I.addColorStop(0, q), I.addColorStop(10 / O, S), I.addColorStop(1, S), e.fillStyle = I, e.fill(), e.globalAlpha = 0.6;
        const [ae, Q] = s?.[1] ?? [-1, -1];
        for (let ne = 0; ne < w.actions.length; ne++) {
          const le = w.actions[ne], W = U[ne], X = Mb(W, ae + v, Q);
          X && (e.globalAlpha = 1), o.drawSprite(le.icon, "normal", e, W.x + W.width / 2 - 10, W.y + W.height / 2 - 10, 20, C), X && (e.globalAlpha = 0.6);
        }
        e.globalAlpha = 1;
      }
    }
    v !== 0 && u(y[0]) && (e.beginPath(), e.moveTo(v + 0.5, 0), e.lineTo(v + 0.5, a), e.strokeStyle = i.borderColor, e.lineWidth = 1, e.stroke()), e.restore(), m = v + _;
  }), e.beginPath(), e.moveTo(m + 0.5, 0), e.lineTo(m + 0.5, a), e.moveTo(0, a + 0.5), e.lineTo(r, a + 0.5), e.strokeStyle = i.borderColor, e.lineWidth = 1, e.stroke();
}
const uc = 30;
function Iz(e, t, r, n, a) {
  return a ? { x: e, y: t, width: uc, height: Math.min(uc, n) } : {
    x: e + r - uc,
    y: Math.max(t, t + n / 2 - uc / 2),
    width: uc,
    height: Math.min(uc, n)
  };
}
function Nz(e, t) {
  const r = [];
  let n = e.x + e.width - 26 * t.length;
  const a = e.y + e.height / 2 - 13, s = 26, i = 26;
  for (let o = 0; o < t.length; o++)
    r.push({
      x: n,
      y: a,
      width: i,
      height: s
    }), n += 26;
  return r;
}
function l3(e, t, r, n, a, s, i, o, l, u, c, d, p, f) {
  if (s.rowMarker !== void 0) {
    const x = s.rowMarkerChecked;
    x !== !0 && (e.globalAlpha = u), zI(e, o, x, t, r, n, a, !1, void 0, void 0, 18, "center", s.rowMarker), x !== !0 && (e.globalAlpha = 1);
    return;
  }
  const h = o.cellHorizontalPadding, m = i ? o.textHeaderSelected : o.textHeader, y = s.hasMenu === !0 && (l || d && i), b = p ? -1 : 1;
  let v = p ? t + n - h : t + h;
  if (s.icon !== void 0) {
    let x = i ? "selected" : "normal";
    s.style === "highlight" && (x = i ? "selected" : "special");
    const _ = o.headerIconSize;
    c.drawSprite(s.icon, x, e, p ? v - _ : v, r + (a - _) / 2, _, o), s.overlayIcon !== void 0 && c.drawSprite(s.overlayIcon, i ? "selected" : "special", e, p ? v - _ + 9 : v + 9, r + ((a - 18) / 2 + 6), 18, o), v += Math.ceil(_ * 1.3) * b;
  }
  if (y && s.hasMenu === !0 && n > 35) {
    const _ = p ? 35 : n - 35, E = p ? 35 * 0.7 : n - 35 * 0.7, w = _ / n, C = E / n, k = e.createLinearGradient(t, 0, t + n, 0), S = ku(m, 0);
    k.addColorStop(p ? 1 : 0, m), k.addColorStop(w, m), k.addColorStop(C, S), k.addColorStop(p ? 0 : 1, S), e.fillStyle = k;
  } else
    e.fillStyle = m;
  if (p && (e.textAlign = "right"), e.fillText(s.title, v, r + a / 2 + Yo(e, o.headerFontFull)), p && (e.textAlign = "left"), y && s.hasMenu === !0)
    if (s.menuIcon === void 0 || s.menuIcon === Rg.Triangle) {
      e.beginPath();
      const x = f.x + f.width / 2 - 5.5, _ = f.y + f.height / 2 - 3;
      qne(e, [
        {
          x,
          y: _
        },
        {
          x: x + 11,
          y: _
        },
        {
          x: x + 5.5,
          y: _ + 6
        }
      ], 1), e.fillStyle = m, e.fill();
    } else if (s.menuIcon === Rg.Dots) {
      e.beginPath();
      const x = f.x + f.width / 2, _ = f.y + f.height / 2;
      zne(e, x, _), e.fillStyle = m, e.fill();
    } else {
      const x = f.x + (f.width - o.headerIconSize) / 2, _ = f.y + (f.height - o.headerIconSize) / 2;
      c.drawSprite(s.menuIcon, "normal", e, x, _, o.headerIconSize, o);
    }
}
function Dz(e, t, r, n, a, s, i, o, l, u, c, d, p, f) {
  const h = OI(s.title) === "rtl", m = Iz(t, r, n, a, h);
  p !== void 0 ? p({
    ctx: e,
    theme: o,
    rect: { x: t, y: r, width: n, height: a },
    column: s,
    columnIndex: s.sourceIndex,
    isSelected: i,
    hoverAmount: c,
    isHovered: l,
    hasSelectedCell: u,
    spriteManager: d,
    menuBounds: m
  }, () => l3(e, t, r, n, a, s, i, o, l, c, d, f, h, m)) : l3(e, t, r, n, a, s, i, o, l, c, d, f, h, m);
}
var Y0, u3;
function sae() {
  if (u3) return Y0;
  u3 = 1;
  var e = $u(), t = function() {
    try {
      var r = e(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  }();
  return Y0 = t, Y0;
}
var X0, c3;
function oae() {
  if (c3) return X0;
  c3 = 1;
  var e = sae();
  function t(r, n, a) {
    n == "__proto__" && e ? e(r, n, {
      configurable: !0,
      enumerable: !0,
      value: a,
      writable: !0
    }) : r[n] = a;
  }
  return X0 = t, X0;
}
var Z0, d3;
function lae() {
  if (d3) return Z0;
  d3 = 1;
  function e(t, r, n, a) {
    for (var s = -1, i = t == null ? 0 : t.length; ++s < i; ) {
      var o = t[s];
      r(a, o, n(o), t);
    }
    return a;
  }
  return Z0 = e, Z0;
}
var J0, f3;
function uae() {
  if (f3) return J0;
  f3 = 1;
  function e(t) {
    return function(r, n, a) {
      for (var s = -1, i = Object(r), o = a(r), l = o.length; l--; ) {
        var u = o[t ? l : ++s];
        if (n(i[u], u, i) === !1)
          break;
      }
      return r;
    };
  }
  return J0 = e, J0;
}
var Q0, p3;
function cae() {
  if (p3) return Q0;
  p3 = 1;
  var e = uae(), t = e();
  return Q0 = t, Q0;
}
var ew, h3;
function dae() {
  if (h3) return ew;
  h3 = 1;
  function e(t, r) {
    for (var n = -1, a = Array(t); ++n < t; )
      a[n] = r(n);
    return a;
  }
  return ew = e, ew;
}
var Lf = { exports: {} }, tw, m3;
function fae() {
  if (m3) return tw;
  m3 = 1;
  function e() {
    return !1;
  }
  return tw = e, tw;
}
Lf.exports;
var g3;
function Oz() {
  return g3 || (g3 = 1, function(e, t) {
    var r = po(), n = fae(), a = t && !t.nodeType && t, s = a && !0 && e && !e.nodeType && e, i = s && s.exports === a, o = i ? r.Buffer : void 0, l = o ? o.isBuffer : void 0, u = l || n;
    e.exports = u;
  }(Lf, Lf.exports)), Lf.exports;
}
var rw, b3;
function pae() {
  if (b3) return rw;
  b3 = 1;
  var e = ih(), t = AI(), r = ah(), n = "[object Arguments]", a = "[object Array]", s = "[object Boolean]", i = "[object Date]", o = "[object Error]", l = "[object Function]", u = "[object Map]", c = "[object Number]", d = "[object Object]", p = "[object RegExp]", f = "[object Set]", h = "[object String]", m = "[object WeakMap]", y = "[object ArrayBuffer]", b = "[object DataView]", v = "[object Float32Array]", x = "[object Float64Array]", _ = "[object Int8Array]", E = "[object Int16Array]", w = "[object Int32Array]", C = "[object Uint8Array]", k = "[object Uint8ClampedArray]", S = "[object Uint16Array]", B = "[object Uint32Array]", U = {};
  U[v] = U[x] = U[_] = U[E] = U[w] = U[C] = U[k] = U[S] = U[B] = !0, U[n] = U[a] = U[y] = U[s] = U[b] = U[i] = U[o] = U[l] = U[u] = U[c] = U[d] = U[p] = U[f] = U[h] = U[m] = !1;
  function N(O) {
    return r(O) && t(O.length) && !!U[e(O)];
  }
  return rw = N, rw;
}
var nw, y3;
function hae() {
  if (y3) return nw;
  y3 = 1;
  function e(t) {
    return function(r) {
      return t(r);
    };
  }
  return nw = e, nw;
}
var Mf = { exports: {} };
Mf.exports;
var v3;
function mae() {
  return v3 || (v3 = 1, function(e, t) {
    var r = MU(), n = t && !t.nodeType && t, a = n && !0 && e && !e.nodeType && e, s = a && a.exports === n, i = s && r.process, o = function() {
      try {
        var l = a && a.require && a.require("util").types;
        return l || i && i.binding && i.binding("util");
      } catch {
      }
    }();
    e.exports = o;
  }(Mf, Mf.exports)), Mf.exports;
}
var iw, w3;
function Pz() {
  if (w3) return iw;
  w3 = 1;
  var e = pae(), t = hae(), r = mae(), n = r && r.isTypedArray, a = n ? t(n) : e;
  return iw = a, iw;
}
var aw, x3;
function gae() {
  if (x3) return aw;
  x3 = 1;
  var e = dae(), t = kI(), r = fo(), n = Oz(), a = CI(), s = Pz(), i = Object.prototype, o = i.hasOwnProperty;
  function l(u, c) {
    var d = r(u), p = !d && t(u), f = !d && !p && n(u), h = !d && !p && !f && s(u), m = d || p || f || h, y = m ? e(u.length, String) : [], b = y.length;
    for (var v in u)
      (c || o.call(u, v)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
      (v == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      f && (v == "offset" || v == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      h && (v == "buffer" || v == "byteLength" || v == "byteOffset") || // Skip index properties.
      a(v, b))) && y.push(v);
    return y;
  }
  return aw = l, aw;
}
var sw, E3;
function bae() {
  if (E3) return sw;
  E3 = 1;
  var e = Object.prototype;
  function t(r) {
    var n = r && r.constructor, a = typeof n == "function" && n.prototype || e;
    return r === a;
  }
  return sw = t, sw;
}
var ow, S3;
function yae() {
  if (S3) return ow;
  S3 = 1;
  function e(t, r) {
    return function(n) {
      return t(r(n));
    };
  }
  return ow = e, ow;
}
var lw, _3;
function vae() {
  if (_3) return lw;
  _3 = 1;
  var e = yae(), t = e(Object.keys, Object);
  return lw = t, lw;
}
var uw, k3;
function wae() {
  if (k3) return uw;
  k3 = 1;
  var e = bae(), t = vae(), r = Object.prototype, n = r.hasOwnProperty;
  function a(s) {
    if (!e(s))
      return t(s);
    var i = [];
    for (var o in Object(s))
      n.call(s, o) && o != "constructor" && i.push(o);
    return i;
  }
  return uw = a, uw;
}
var cw, C3;
function qI() {
  if (C3) return cw;
  C3 = 1;
  var e = gae(), t = wae(), r = UI();
  function n(a) {
    return r(a) ? e(a) : t(a);
  }
  return cw = n, cw;
}
var dw, A3;
function xae() {
  if (A3) return dw;
  A3 = 1;
  var e = cae(), t = qI();
  function r(n, a) {
    return n && e(n, a, t);
  }
  return dw = r, dw;
}
var fw, T3;
function Eae() {
  if (T3) return fw;
  T3 = 1;
  var e = UI();
  function t(r, n) {
    return function(a, s) {
      if (a == null)
        return a;
      if (!e(a))
        return r(a, s);
      for (var i = a.length, o = n ? i : -1, l = Object(a); (n ? o-- : ++o < i) && s(l[o], o, l) !== !1; )
        ;
      return a;
    };
  }
  return fw = t, fw;
}
var pw, R3;
function Sae() {
  if (R3) return pw;
  R3 = 1;
  var e = xae(), t = Eae(), r = t(e);
  return pw = r, pw;
}
var hw, I3;
function _ae() {
  if (I3) return hw;
  I3 = 1;
  var e = Sae();
  function t(r, n, a, s) {
    return e(r, function(i, o, l) {
      n(s, i, a(i), l);
    }), s;
  }
  return hw = t, hw;
}
var mw, N3;
function kae() {
  if (N3) return mw;
  N3 = 1;
  var e = Nb();
  function t() {
    this.__data__ = new e(), this.size = 0;
  }
  return mw = t, mw;
}
var gw, D3;
function Cae() {
  if (D3) return gw;
  D3 = 1;
  function e(t) {
    var r = this.__data__, n = r.delete(t);
    return this.size = r.size, n;
  }
  return gw = e, gw;
}
var bw, O3;
function Aae() {
  if (O3) return bw;
  O3 = 1;
  function e(t) {
    return this.__data__.get(t);
  }
  return bw = e, bw;
}
var yw, P3;
function Tae() {
  if (P3) return yw;
  P3 = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return yw = e, yw;
}
var vw, L3;
function Rae() {
  if (L3) return vw;
  L3 = 1;
  var e = Nb(), t = SI(), r = _I(), n = 200;
  function a(s, i) {
    var o = this.__data__;
    if (o instanceof e) {
      var l = o.__data__;
      if (!t || l.length < n - 1)
        return l.push([s, i]), this.size = ++o.size, this;
      o = this.__data__ = new r(l);
    }
    return o.set(s, i), this.size = o.size, this;
  }
  return vw = a, vw;
}
var ww, M3;
function Lz() {
  if (M3) return ww;
  M3 = 1;
  var e = Nb(), t = kae(), r = Cae(), n = Aae(), a = Tae(), s = Rae();
  function i(o) {
    var l = this.__data__ = new e(o);
    this.size = l.size;
  }
  return i.prototype.clear = t, i.prototype.delete = r, i.prototype.get = n, i.prototype.has = a, i.prototype.set = s, ww = i, ww;
}
var xw, F3;
function Iae() {
  if (F3) return xw;
  F3 = 1;
  function e(t, r) {
    for (var n = -1, a = t == null ? 0 : t.length; ++n < a; )
      if (r(t[n], n, t))
        return !0;
    return !1;
  }
  return xw = e, xw;
}
var Ew, $3;
function Mz() {
  if ($3) return Ew;
  $3 = 1;
  var e = wz(), t = Iae(), r = xz(), n = 1, a = 2;
  function s(i, o, l, u, c, d) {
    var p = l & n, f = i.length, h = o.length;
    if (f != h && !(p && h > f))
      return !1;
    var m = d.get(i), y = d.get(o);
    if (m && y)
      return m == o && y == i;
    var b = -1, v = !0, x = l & a ? new e() : void 0;
    for (d.set(i, o), d.set(o, i); ++b < f; ) {
      var _ = i[b], E = o[b];
      if (u)
        var w = p ? u(E, _, b, o, i, d) : u(_, E, b, i, o, d);
      if (w !== void 0) {
        if (w)
          continue;
        v = !1;
        break;
      }
      if (x) {
        if (!t(o, function(C, k) {
          if (!r(x, k) && (_ === C || c(_, C, l, u, d)))
            return x.push(k);
        })) {
          v = !1;
          break;
        }
      } else if (!(_ === E || c(_, E, l, u, d))) {
        v = !1;
        break;
      }
    }
    return d.delete(i), d.delete(o), v;
  }
  return Ew = s, Ew;
}
var Sw, B3;
function Nae() {
  if (B3) return Sw;
  B3 = 1;
  var e = po(), t = e.Uint8Array;
  return Sw = t, Sw;
}
var _w, U3;
function Dae() {
  if (U3) return _w;
  U3 = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(a, s) {
      n[++r] = [s, a];
    }), n;
  }
  return _w = e, _w;
}
var kw, z3;
function Oae() {
  if (z3) return kw;
  z3 = 1;
  var e = nh(), t = Nae(), r = EI(), n = Mz(), a = Dae(), s = BI(), i = 1, o = 2, l = "[object Boolean]", u = "[object Date]", c = "[object Error]", d = "[object Map]", p = "[object Number]", f = "[object RegExp]", h = "[object Set]", m = "[object String]", y = "[object Symbol]", b = "[object ArrayBuffer]", v = "[object DataView]", x = e ? e.prototype : void 0, _ = x ? x.valueOf : void 0;
  function E(w, C, k, S, B, U, N) {
    switch (k) {
      case v:
        if (w.byteLength != C.byteLength || w.byteOffset != C.byteOffset)
          return !1;
        w = w.buffer, C = C.buffer;
      case b:
        return !(w.byteLength != C.byteLength || !U(new t(w), new t(C)));
      case l:
      case u:
      case p:
        return r(+w, +C);
      case c:
        return w.name == C.name && w.message == C.message;
      case f:
      case m:
        return w == C + "";
      case d:
        var O = a;
      case h:
        var I = S & i;
        if (O || (O = s), w.size != C.size && !I)
          return !1;
        var q = N.get(w);
        if (q)
          return q == C;
        S |= o, N.set(w, C);
        var ae = n(O(w), O(C), S, B, U, N);
        return N.delete(w), ae;
      case y:
        if (_)
          return _.call(w) == _.call(C);
    }
    return !1;
  }
  return kw = E, kw;
}
var Cw, q3;
function Pae() {
  if (q3) return Cw;
  q3 = 1;
  var e = Sz(), t = fo();
  function r(n, a, s) {
    var i = a(n);
    return t(n) ? i : e(i, s(n));
  }
  return Cw = r, Cw;
}
var Aw, j3;
function Lae() {
  if (j3) return Aw;
  j3 = 1;
  function e(t, r) {
    for (var n = -1, a = t == null ? 0 : t.length, s = 0, i = []; ++n < a; ) {
      var o = t[n];
      r(o, n, t) && (i[s++] = o);
    }
    return i;
  }
  return Aw = e, Aw;
}
var Tw, H3;
function Mae() {
  if (H3) return Tw;
  H3 = 1;
  function e() {
    return [];
  }
  return Tw = e, Tw;
}
var Rw, V3;
function Fae() {
  if (V3) return Rw;
  V3 = 1;
  var e = Lae(), t = Mae(), r = Object.prototype, n = r.propertyIsEnumerable, a = Object.getOwnPropertySymbols, s = a ? function(i) {
    return i == null ? [] : (i = Object(i), e(a(i), function(o) {
      return n.call(i, o);
    }));
  } : t;
  return Rw = s, Rw;
}
var Iw, G3;
function $ae() {
  if (G3) return Iw;
  G3 = 1;
  var e = Pae(), t = Fae(), r = qI();
  function n(a) {
    return e(a, r, t);
  }
  return Iw = n, Iw;
}
var Nw, W3;
function Bae() {
  if (W3) return Nw;
  W3 = 1;
  var e = $ae(), t = 1, r = Object.prototype, n = r.hasOwnProperty;
  function a(s, i, o, l, u, c) {
    var d = o & t, p = e(s), f = p.length, h = e(i), m = h.length;
    if (f != m && !d)
      return !1;
    for (var y = f; y--; ) {
      var b = p[y];
      if (!(d ? b in i : n.call(i, b)))
        return !1;
    }
    var v = c.get(s), x = c.get(i);
    if (v && x)
      return v == i && x == s;
    var _ = !0;
    c.set(s, i), c.set(i, s);
    for (var E = d; ++y < f; ) {
      b = p[y];
      var w = s[b], C = i[b];
      if (l)
        var k = d ? l(C, w, b, i, s, c) : l(w, C, b, s, i, c);
      if (!(k === void 0 ? w === C || u(w, C, o, l, c) : k)) {
        _ = !1;
        break;
      }
      E || (E = b == "constructor");
    }
    if (_ && !E) {
      var S = s.constructor, B = i.constructor;
      S != B && "constructor" in s && "constructor" in i && !(typeof S == "function" && S instanceof S && typeof B == "function" && B instanceof B) && (_ = !1);
    }
    return c.delete(s), c.delete(i), _;
  }
  return Nw = a, Nw;
}
var Dw, K3;
function Uae() {
  if (K3) return Dw;
  K3 = 1;
  var e = $u(), t = po(), r = e(t, "DataView");
  return Dw = r, Dw;
}
var Ow, Y3;
function zae() {
  if (Y3) return Ow;
  Y3 = 1;
  var e = $u(), t = po(), r = e(t, "Promise");
  return Ow = r, Ow;
}
var Pw, X3;
function qae() {
  if (X3) return Pw;
  X3 = 1;
  var e = $u(), t = po(), r = e(t, "WeakMap");
  return Pw = r, Pw;
}
var Lw, Z3;
function jae() {
  if (Z3) return Lw;
  Z3 = 1;
  var e = Uae(), t = SI(), r = zae(), n = Ez(), a = qae(), s = ih(), i = $U(), o = "[object Map]", l = "[object Object]", u = "[object Promise]", c = "[object Set]", d = "[object WeakMap]", p = "[object DataView]", f = i(e), h = i(t), m = i(r), y = i(n), b = i(a), v = s;
  return (e && v(new e(new ArrayBuffer(1))) != p || t && v(new t()) != o || r && v(r.resolve()) != u || n && v(new n()) != c || a && v(new a()) != d) && (v = function(x) {
    var _ = s(x), E = _ == l ? x.constructor : void 0, w = E ? i(E) : "";
    if (w)
      switch (w) {
        case f:
          return p;
        case h:
          return o;
        case m:
          return u;
        case y:
          return c;
        case b:
          return d;
      }
    return _;
  }), Lw = v, Lw;
}
var Mw, J3;
function Hae() {
  if (J3) return Mw;
  J3 = 1;
  var e = Lz(), t = Mz(), r = Oae(), n = Bae(), a = jae(), s = fo(), i = Oz(), o = Pz(), l = 1, u = "[object Arguments]", c = "[object Array]", d = "[object Object]", p = Object.prototype, f = p.hasOwnProperty;
  function h(m, y, b, v, x, _) {
    var E = s(m), w = s(y), C = E ? c : a(m), k = w ? c : a(y);
    C = C == u ? d : C, k = k == u ? d : k;
    var S = C == d, B = k == d, U = C == k;
    if (U && i(m)) {
      if (!i(y))
        return !1;
      E = !0, S = !1;
    }
    if (U && !S)
      return _ || (_ = new e()), E || o(m) ? t(m, y, b, v, x, _) : r(m, y, C, b, v, x, _);
    if (!(b & l)) {
      var N = S && f.call(m, "__wrapped__"), O = B && f.call(y, "__wrapped__");
      if (N || O) {
        var I = N ? m.value() : m, q = O ? y.value() : y;
        return _ || (_ = new e()), x(I, q, b, v, _);
      }
    }
    return U ? (_ || (_ = new e()), n(m, y, b, v, x, _)) : !1;
  }
  return Mw = h, Mw;
}
var Fw, Q3;
function Fz() {
  if (Q3) return Fw;
  Q3 = 1;
  var e = Hae(), t = ah();
  function r(n, a, s, i, o) {
    return n === a ? !0 : n == null || a == null || !t(n) && !t(a) ? n !== n && a !== a : e(n, a, s, i, r, o);
  }
  return Fw = r, Fw;
}
var $w, eP;
function Vae() {
  if (eP) return $w;
  eP = 1;
  var e = Lz(), t = Fz(), r = 1, n = 2;
  function a(s, i, o, l) {
    var u = o.length, c = u, d = !l;
    if (s == null)
      return !c;
    for (s = Object(s); u--; ) {
      var p = o[u];
      if (d && p[2] ? p[1] !== s[p[0]] : !(p[0] in s))
        return !1;
    }
    for (; ++u < c; ) {
      p = o[u];
      var f = p[0], h = s[f], m = p[1];
      if (d && p[2]) {
        if (h === void 0 && !(f in s))
          return !1;
      } else {
        var y = new e();
        if (l)
          var b = l(h, m, f, s, i, y);
        if (!(b === void 0 ? t(m, h, r | n, l, y) : b))
          return !1;
      }
    }
    return !0;
  }
  return $w = a, $w;
}
var Bw, tP;
function $z() {
  if (tP) return Bw;
  tP = 1;
  var e = Fu();
  function t(r) {
    return r === r && !e(r);
  }
  return Bw = t, Bw;
}
var Uw, rP;
function Gae() {
  if (rP) return Uw;
  rP = 1;
  var e = $z(), t = qI();
  function r(n) {
    for (var a = t(n), s = a.length; s--; ) {
      var i = a[s], o = n[i];
      a[s] = [i, o, e(o)];
    }
    return a;
  }
  return Uw = r, Uw;
}
var zw, nP;
function Bz() {
  if (nP) return zw;
  nP = 1;
  function e(t, r) {
    return function(n) {
      return n == null ? !1 : n[t] === r && (r !== void 0 || t in Object(n));
    };
  }
  return zw = e, zw;
}
var qw, iP;
function Wae() {
  if (iP) return qw;
  iP = 1;
  var e = Vae(), t = Gae(), r = Bz();
  function n(a) {
    var s = t(a);
    return s.length == 1 && s[0][2] ? r(s[0][0], s[0][1]) : function(i) {
      return i === a || e(i, a, s);
    };
  }
  return qw = n, qw;
}
var jw, aP;
function Uz() {
  if (aP) return jw;
  aP = 1;
  var e = BU(), t = Ob();
  function r(n, a) {
    a = e(a, n);
    for (var s = 0, i = a.length; n != null && s < i; )
      n = n[t(a[s++])];
    return s && s == i ? n : void 0;
  }
  return jw = r, jw;
}
var Hw, sP;
function Kae() {
  if (sP) return Hw;
  sP = 1;
  var e = Uz();
  function t(r, n, a) {
    var s = r == null ? void 0 : e(r, n);
    return s === void 0 ? a : s;
  }
  return Hw = t, Hw;
}
var Vw, oP;
function Yae() {
  if (oP) return Vw;
  oP = 1;
  function e(t, r) {
    return t != null && r in Object(t);
  }
  return Vw = e, Vw;
}
var Gw, lP;
function Xae() {
  if (lP) return Gw;
  lP = 1;
  var e = Yae(), t = UU();
  function r(n, a) {
    return n != null && t(n, a, e);
  }
  return Gw = r, Gw;
}
var Ww, uP;
function Zae() {
  if (uP) return Ww;
  uP = 1;
  var e = Fz(), t = Kae(), r = Xae(), n = xI(), a = $z(), s = Bz(), i = Ob(), o = 1, l = 2;
  function u(c, d) {
    return n(c) && a(d) ? s(i(c), d) : function(p) {
      var f = t(p, c);
      return f === void 0 && f === d ? r(p, c) : e(d, f, o | l);
    };
  }
  return Ww = u, Ww;
}
var Kw, cP;
function Jae() {
  if (cP) return Kw;
  cP = 1;
  function e(t) {
    return t;
  }
  return Kw = e, Kw;
}
var Yw, dP;
function Qae() {
  if (dP) return Yw;
  dP = 1;
  function e(t) {
    return function(r) {
      return r?.[t];
    };
  }
  return Yw = e, Yw;
}
var Xw, fP;
function ese() {
  if (fP) return Xw;
  fP = 1;
  var e = Uz();
  function t(r) {
    return function(n) {
      return e(n, r);
    };
  }
  return Xw = t, Xw;
}
var Zw, pP;
function tse() {
  if (pP) return Zw;
  pP = 1;
  var e = Qae(), t = ese(), r = xI(), n = Ob();
  function a(s) {
    return r(s) ? e(n(s)) : t(s);
  }
  return Zw = a, Zw;
}
var Jw, hP;
function rse() {
  if (hP) return Jw;
  hP = 1;
  var e = Wae(), t = Zae(), r = Jae(), n = fo(), a = tse();
  function s(i) {
    return typeof i == "function" ? i : i == null ? r : typeof i == "object" ? n(i) ? t(i[0], i[1]) : e(i) : a(i);
  }
  return Jw = s, Jw;
}
var Qw, mP;
function nse() {
  if (mP) return Qw;
  mP = 1;
  var e = lae(), t = _ae(), r = rse(), n = fo();
  function a(s, i) {
    return function(o, l) {
      var u = n(o) ? e : t, c = i ? i() : {};
      return u(o, s, r(l, 2), c);
    };
  }
  return Qw = a, Qw;
}
var e1, gP;
function ise() {
  if (gP) return e1;
  gP = 1;
  var e = oae(), t = nse(), r = Object.prototype, n = r.hasOwnProperty, a = t(function(s, i, o) {
    n.call(s, o) ? s[o].push(i) : e(s, o, [i]);
  });
  return e1 = a, e1;
}
var ase = ise();
const sse = /* @__PURE__ */ da(ase);
function ose(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v) {
  if (b !== void 0 || t[t.length - 1] !== r[t.length - 1])
    return;
  const x = kz(y);
  Gl(t, l, i, o, s, (_, E, w, C, k) => {
    if (_ !== t[t.length - 1])
      return;
    E += _.width;
    const S = Math.max(E, C);
    S > n || (e.save(), e.beginPath(), e.rect(S, s + 1, 1e4, a - s - 1), e.clip(), Lb(k, w, a, u, c, h, m, x, (B, U, N, O) => {
      if (!O && y.length > 0 && !y.some((ne) => Ng(E, B, 1e4, N, ne.x, ne.y, ne.width, ne.height)))
        return;
      const I = p.hasIndex(U), q = f.hasIndex(U);
      e.beginPath();
      const ae = d?.(U), Q = ae === void 0 ? v : Dl(v, ae);
      Q.bgCell !== v.bgCell && (e.fillStyle = Q.bgCell, e.fillRect(E, B, 1e4, N)), q && (e.fillStyle = Q.bgHeader, e.fillRect(E, B, 1e4, N)), I && (e.fillStyle = Q.accentLight, e.fillRect(E, B, 1e4, N));
    }), e.restore());
  });
}
function lse(e, t, r, n, a, s, i, o, l) {
  let u = !1;
  for (const h of t)
    if (!h.sticky) {
      u = i(h.sourceIndex);
      break;
    }
  const c = l.horizontalBorderColor ?? l.borderColor, d = l.borderColor, p = u ? nd(t) : 0;
  let f;
  if (p !== 0 && (f = T4(d, l.bgCell), e.beginPath(), e.moveTo(p + 0.5, 0), e.lineTo(p + 0.5, n), e.strokeStyle = f, e.stroke()), a > 0) {
    const h = d === c && f !== void 0 ? f : T4(c, l.bgCell), m = Uu(s, a, o);
    e.beginPath(), e.moveTo(0, n - m + 0.5), e.lineTo(r, n - m + 0.5), e.strokeStyle = h, e.stroke();
  }
}
const zz = (e, t, r) => {
  let n = 0, a = t, s = 0, i = r;
  if (e !== void 0 && e.length > 0) {
    n = Number.MAX_SAFE_INTEGER, s = Number.MAX_SAFE_INTEGER, a = Number.MIN_SAFE_INTEGER, i = Number.MIN_SAFE_INTEGER;
    for (const o of e)
      n = Math.min(n, o.x - 1), a = Math.max(a, o.x + o.width + 1), s = Math.min(s, o.y - 1), i = Math.max(i, o.y + o.height + 1);
  }
  return { minX: n, maxX: a, minY: s, maxY: i };
};
function use(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h) {
  const m = h.bgCell, { minX: y, maxX: b, minY: v, maxY: x } = zz(o, s, i), _ = [], E = i - Uu(f, p, u);
  let w = l, C = r, k = 0;
  for (; w + a < E; ) {
    const N = w + a, O = u(C);
    if (N >= v && N <= x - 1) {
      const q = c?.(C)?.bgCell;
      q !== void 0 && q !== m && C >= f - p && _.push({
        x: y,
        y: N,
        w: b - y,
        h: O,
        color: q
      });
    }
    w += O, C < f - p && (k = w), C++;
  }
  let S = 0;
  const B = Math.min(E, x) - k;
  if (B > 0)
    for (let N = 0; N < t.length; N++) {
      const O = t[N];
      if (O.width === 0)
        continue;
      const I = O.sticky ? S : S + n, q = O.themeOverride?.bgCell;
      q !== void 0 && q !== m && I >= y && I <= b && d(N + 1) && _.push({
        x: I,
        y: k,
        w: O.width,
        h: B,
        color: q
      }), S += O.width;
    }
  if (_.length === 0)
    return;
  let U;
  e.beginPath();
  for (let N = _.length - 1; N >= 0; N--) {
    const O = _[N];
    U === void 0 ? U = O.color : O.color !== U && (e.fillStyle = U, e.fill(), e.beginPath(), U = O.color), e.rect(O.x, O.y, O.w, O.h);
  }
  U !== void 0 && (e.fillStyle = U, e.fill()), e.beginPath();
}
function bP(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b = !1) {
  if (l !== void 0) {
    e.beginPath(), e.save(), e.rect(0, 0, s, i);
    for (const N of l)
      e.rect(N.x + 1, N.y + 1, N.width - 1, N.height - 1);
    e.clip("evenodd");
  }
  const v = y.horizontalBorderColor ?? y.borderColor, x = y.borderColor, { minX: _, maxX: E, minY: w, maxY: C } = zz(o, s, i), k = [];
  e.beginPath();
  let S = 0.5;
  for (let N = 0; N < t.length; N++) {
    const O = t[N];
    if (O.width === 0)
      continue;
    S += O.width;
    const I = O.sticky ? S : S + n;
    I >= _ && I <= E && f(N + 1) && k.push({
      x1: I,
      y1: Math.max(u, w),
      x2: I,
      y2: Math.min(i, C),
      color: x
    });
  }
  let B = i + 0.5;
  for (let N = m - h; N < m; N++) {
    const O = d(N);
    B -= O, k.push({ x1: _, y1: B, x2: E, y2: B, color: v });
  }
  if (b !== !0) {
    let N = c + 0.5, O = r;
    const I = B;
    for (; N + a < I; ) {
      const q = N + a;
      if (q >= w && q <= C - 1) {
        const ae = p?.(O);
        k.push({
          x1: _,
          y1: q,
          x2: E,
          y2: q,
          color: ae?.horizontalBorderColor ?? ae?.borderColor ?? v
        });
      }
      N += d(O), O++;
    }
  }
  const U = sse(k, (N) => N.color);
  for (const N of Object.keys(U)) {
    e.strokeStyle = N;
    for (const O of U[N])
      e.moveTo(O.x1, O.y1), e.lineTo(O.x2, O.y2);
    e.stroke(), e.beginPath();
  }
  l !== void 0 && e.restore();
}
function cse(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v) {
  const x = [];
  e.imageSmoothingEnabled = !1;
  const _ = Math.min(a.cellYOffset, i), E = Math.max(a.cellYOffset, i);
  let w = 0;
  if (typeof b == "number")
    w += (E - _) * b;
  else
    for (let I = _; I < E; I++)
      w += b(I);
  i > a.cellYOffset && (w = -w), w += l - a.translateY;
  const C = Math.min(a.cellXOffset, s), k = Math.max(a.cellXOffset, s);
  let S = 0;
  for (let I = C; I < k; I++)
    S += m[I].width;
  s > a.cellXOffset && (S = -S), S += o - a.translateX;
  const B = nd(y);
  if (S !== 0 && w !== 0)
    return {
      regions: []
    };
  const U = u > 0 ? Uu(p, u, b) : 0, N = c - B - Math.abs(S), O = d - f - U - Math.abs(w) - 1;
  if (N > 150 && O > 150) {
    const I = {
      sx: 0,
      sy: 0,
      sw: c * h,
      sh: d * h,
      dx: 0,
      dy: 0,
      dw: c * h,
      dh: d * h
    };
    if (w > 0 ? (I.sy = (f + 1) * h, I.sh = O * h, I.dy = (w + f + 1) * h, I.dh = O * h, x.push({
      x: 0,
      y: f,
      width: c,
      height: w + 1
    })) : w < 0 && (I.sy = (-w + f + 1) * h, I.sh = O * h, I.dy = (f + 1) * h, I.dh = O * h, x.push({
      x: 0,
      y: d + w - U,
      width: c,
      height: -w + U
    })), S > 0 ? (I.sx = B * h, I.sw = N * h, I.dx = (S + B) * h, I.dw = N * h, x.push({
      x: B - 1,
      y: 0,
      width: S + 2,
      height: d
    })) : S < 0 && (I.sx = (B - S) * h, I.sw = N * h, I.dx = B * h, I.dw = N * h, x.push({
      x: c + S,
      y: 0,
      width: -S,
      height: d
    })), e.setTransform(1, 0, 0, 1, 0, 0), v) {
      if (B > 0 && S !== 0 && w === 0 && (n === void 0 || r?.[1] !== !1)) {
        const q = B * h, ae = d * h;
        e.drawImage(t, 0, 0, q, ae, 0, 0, q, ae);
      }
      if (U > 0 && S === 0 && w !== 0 && (n === void 0 || r?.[0] !== !1)) {
        const q = (d - U) * h, ae = c * h, Q = U * h;
        e.drawImage(t, 0, q, ae, Q, 0, q, ae, Q);
      }
    }
    e.drawImage(t, I.sx, I.sy, I.sw, I.sh, I.dx, I.dy, I.dw, I.dh), e.scale(h, h);
  }
  return e.imageSmoothingEnabled = !0, {
    regions: x
  };
}
function dse(e, t, r, n, a, s, i, o, l, u) {
  const c = [];
  return t !== e.cellXOffset || r !== e.cellYOffset || n !== e.translateX || a !== e.translateY || Gl(l, r, n, a, o, (d, p, f, h) => {
    if (d.sourceIndex === u) {
      const m = Math.max(p, h) + 1;
      return c.push({
        x: m,
        y: 0,
        width: s - m,
        height: i
      }), !0;
    }
  }), c;
}
function fse(e, t) {
  if (t === void 0 || e.width !== t.width || e.height !== t.height || e.theme !== t.theme || e.headerHeight !== t.headerHeight || e.rowHeight !== t.rowHeight || e.rows !== t.rows || e.freezeColumns !== t.freezeColumns || e.getRowThemeOverride !== t.getRowThemeOverride || e.isFocused !== t.isFocused || e.isResizing !== t.isResizing || e.verticalBorder !== t.verticalBorder || e.getCellContent !== t.getCellContent || e.highlightRegions !== t.highlightRegions || e.selection !== t.selection || e.dragAndDropState !== t.dragAndDropState || e.prelightCells !== t.prelightCells || e.touchMode !== t.touchMode || e.maxScaleFactor !== t.maxScaleFactor)
    return !1;
  if (e.mappedColumns !== t.mappedColumns) {
    if (e.mappedColumns.length > 100 || e.mappedColumns.length !== t.mappedColumns.length)
      return !1;
    let r;
    for (let n = 0; n < e.mappedColumns.length; n++) {
      const a = e.mappedColumns[n], s = t.mappedColumns[n];
      if (rd(a, s))
        continue;
      if (r !== void 0 || a.width === s.width)
        return !1;
      const { width: i, ...o } = a, { width: l, ...u } = s;
      if (!rd(o, u))
        return !1;
      r = n;
    }
    return r === void 0 ? !0 : r;
  }
  return !0;
}
function yP(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m) {
  const y = h?.filter((C) => C.style !== "no-outline");
  if (y === void 0 || y.length === 0)
    return;
  const b = nd(o), v = Uu(f, p, d), x = [l, 0, o.length, f - p], _ = [b, 0, t, r - v], E = y.map((C) => {
    const k = C.range, S = C.style ?? "dashed";
    return tae(k, x, t, r, _).map((B) => {
      const U = B.rect, N = zT(U.x, U.y, t, r, c, u + c, n, a, s, i, f, l, p, o, d), O = U.width === 1 && U.height === 1 ? N : zT(U.x + U.width - 1, U.y + U.height - 1, t, r, c, u + c, n, a, s, i, f, l, p, o, d);
      return U.x + U.width >= o.length && (O.width -= 1), U.y + U.height >= f && (O.height -= 1), {
        color: C.color,
        style: S,
        clip: B.clip,
        rect: eae({
          x: N.x,
          y: N.y,
          width: O.x + O.width - N.x,
          height: O.y + O.height - N.y
        }, t, r, 8)
      };
    });
  }), w = () => {
    e.lineWidth = 1;
    let C = !1;
    for (const k of E)
      for (const S of k)
        if (S?.rect !== void 0 && Ng(0, 0, t, r, S.rect.x, S.rect.y, S.rect.width, S.rect.height)) {
          const B = C, U = !Qie(S.clip, S.rect);
          U && (e.save(), e.rect(S.clip.x, S.clip.y, S.clip.width, S.clip.height), e.clip()), S.style === "dashed" && !C ? (e.setLineDash([5, 3]), C = !0) : (S.style === "solid" || S.style === "solid-outline") && C && (e.setLineDash([]), C = !1), e.strokeStyle = S.style === "solid-outline" ? $a($a(S.color, m.borderColor), m.bgCell) : ku(S.color, 1), e.strokeRect(S.rect.x + 0.5, S.rect.y + 0.5, S.rect.width - 1, S.rect.height - 1), U && (e.restore(), C = B);
        }
    C && e.setLineDash([]);
  };
  return w(), w;
}
function vP(e, t, r, n, a) {
  e.beginPath(), e.moveTo(t, r), e.lineTo(t, n), e.lineWidth = 2, e.strokeStyle = a, e.stroke(), e.globalAlpha = 1;
}
function t1(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y) {
  if (c.current === void 0)
    return;
  const b = c.current.range, v = c.current.cell, x = [b.x + b.width - 1, b.y + b.height - 1];
  if (v[1] >= y && x[1] >= y || !i.some((I) => I.sourceIndex === v[0] || I.sourceIndex === x[0]))
    return;
  const [E, w] = c.current.cell, C = p(c.current.cell), k = C.span ?? [E, E], S = w >= y - f, B = f > 0 && !S ? Uu(y, f, d) - 1 : 0, U = x[1];
  let N;
  if (Gl(i, n, a, s, u, (I, q, ae, Q, ne) => {
    if (I.sticky && E > I.sourceIndex)
      return;
    const le = I.sourceIndex < k[0], W = I.sourceIndex > k[1], X = I.sourceIndex === x[0];
    if (!(!X && (le || W)))
      return Lb(ne, ae, r, y, d, f, h, void 0, (G, P, he) => {
        if (P !== w && P !== U)
          return;
        let ye = q, pe = I.width;
        if (C.span !== void 0) {
          const F = Az(C.span, q, G, I.width, he, I, o), ge = I.sticky ? F[0] : F[1];
          ge !== void 0 && (ye = ge.x, pe = ge.width);
        }
        return P === U && X && m && (N = () => {
          Q > ye && !I.sticky && (e.beginPath(), e.rect(Q, 0, t - Q, r), e.clip()), e.beginPath(), e.rect(ye + pe - 4, G + he - 4, 4, 4), e.fillStyle = I.themeOverride?.accentColor ?? l.accentColor, e.fill();
        }), N !== void 0;
      }), N !== void 0;
  }), N === void 0)
    return;
  const O = () => {
    e.save(), e.beginPath(), e.rect(0, u, t, r - u - B), e.clip(), N?.(), e.restore();
  };
  return O(), O;
}
function pse(e, t, r, n, a, s, i, o, l) {
  l === void 0 || l.size === 0 || (e.beginPath(), Cz(t, r, s, n, (u, c, d, p, f, h) => {
    l.hasItemInRectangle({
      x: u[0],
      y: -2,
      width: u[1] - u[0] + 1,
      height: 1
    }) && e.rect(d, p, f, h);
  }), Gl(t, o, s, i, a, (u, c, d, p) => {
    const f = Math.max(0, p - c), h = c + f + 1, m = u.width - f - 1;
    l.has([u.sourceIndex, -1]) && e.rect(h, n, m, a - n);
  }), e.clip());
}
function hse(e, t, r, n, a, s, i, o, l, u) {
  let c = 0;
  return Gl(e, s, n, a, r, (d, p, f, h, m) => (Lb(m, f, t, i, o, l, u, void 0, (y, b, v, x) => {
    x || (c = Math.max(b, c));
  }), !0)), c;
}
function wP(e, t) {
  const { canvasCtx: r, headerCanvasCtx: n, width: a, height: s, cellXOffset: i, cellYOffset: o, translateX: l, translateY: u, mappedColumns: c, enableGroups: d, freezeColumns: p, dragAndDropState: f, theme: h, drawFocus: m, headerHeight: y, groupHeaderHeight: b, disabledRows: v, rowHeight: x, verticalBorder: _, overrideCursor: E, isResizing: w, selection: C, fillHandle: k, freezeTrailingRows: S, rows: B, getCellContent: U, getGroupDetails: N, getRowThemeOverride: O, isFocused: I, drawHeaderCallback: q, prelightCells: ae, drawCellCallback: Q, highlightRegions: ne, resizeCol: le, imageLoader: W, lastBlitData: X, hoverValues: G, hyperWrapping: P, hoverInfo: he, spriteManager: ye, maxScaleFactor: pe, hasAppendRow: $, touchMode: F, enqueue: ge, renderStateProvider: ce, getCellRenderer: ie, renderStrategy: re, bufferACtx: Te, bufferBCtx: V, damage: Pe, minimumCellWidth: z } = e;
  if (a === 0 || s === 0)
    return;
  const A = re === "double-buffer", R = Math.min(pe, Math.ceil(window.devicePixelRatio ?? 1)), H = re !== "direct" && fse(e, t), be = r.canvas;
  (be.width !== a * R || be.height !== s * R) && (be.width = a * R, be.height = s * R, be.style.width = a + "px", be.style.height = s + "px");
  const me = n.canvas, Ce = d ? b + y : y, We = Ce + 1;
  (me.width !== a * R || me.height !== We * R) && (me.width = a * R, me.height = We * R, me.style.width = a + "px", me.style.height = We + "px");
  const xe = Te.canvas, we = V.canvas;
  A && (xe.width !== a * R || xe.height !== s * R) && (xe.width = a * R, xe.height = s * R, X.current !== void 0 && (X.current.aBufferScroll = void 0)), A && (we.width !== a * R || we.height !== s * R) && (we.width = a * R, we.height = s * R, X.current !== void 0 && (X.current.bBufferScroll = void 0));
  const te = X.current;
  if (H === !0 && i === te?.cellXOffset && o === te?.cellYOffset && l === te?.translateX && u === te?.translateY)
    return;
  let Fe = null;
  A && (Fe = r);
  const Y = n;
  let Je;
  A ? Pe !== void 0 ? Je = te?.lastBuffer === "b" ? V : Te : Je = te?.lastBuffer === "b" ? Te : V : Je = r;
  const xt = Je.canvas, Ze = A ? xt === xe ? we : xe : be, rt = typeof x == "number" ? () => x : x;
  Y.save(), Je.save(), Y.beginPath(), Je.beginPath(), Y.textBaseline = "middle", Je.textBaseline = "middle", R !== 1 && (Y.scale(R, R), Je.scale(R, R));
  const Mt = UT(c, i, a, f, l);
  let Qt = [];
  const kr = m && C.current?.cell[1] === o && u === 0;
  let tr = !1;
  if (ne !== void 0) {
    for (const ct of ne)
      if (ct.style !== "no-outline" && ct.range.y === o && u === 0) {
        tr = !0;
        break;
      }
  }
  const Oe = () => {
    iae(Y, Mt, d, he, a, l, y, b, f, w, C, h, ye, G, _, N, Pe, q, F), bP(Y, Mt, o, l, u, a, s, void 0, void 0, b, Ce, rt, O, _, S, B, h, !0), Y.beginPath(), Y.moveTo(0, We - 0.5), Y.lineTo(a, We - 0.5), Y.strokeStyle = $a(h.headerBottomBorderColor ?? h.horizontalBorderColor ?? h.borderColor, h.bgHeader), Y.stroke(), tr && yP(Y, a, s, i, o, l, u, c, p, y, b, x, S, B, ne, h), kr && t1(Y, a, s, o, l, u, Mt, c, h, Ce, C, rt, U, S, $, k, B);
  };
  if (Pe !== void 0) {
    const ct = Mt[Mt.length - 1].sourceIndex + 1, ir = Pe.hasItemInRegion([
      {
        x: i,
        y: -2,
        width: ct,
        height: 2
      },
      {
        x: i,
        y: o,
        width: ct,
        height: 300
      },
      {
        x: 0,
        y: o,
        width: p,
        height: 300
      },
      {
        x: 0,
        y: -2,
        width: p,
        height: 2
      },
      {
        x: i,
        y: B - S,
        width: ct,
        height: S,
        when: S > 0
      }
    ]), xr = (Rr) => {
      o3(Rr, Mt, c, s, Ce, l, u, o, B, rt, U, N, O, v, I, m, S, $, Qt, Pe, C, ae, ne, W, ye, G, he, Q, P, h, ge, ce, ie, E, z);
      const Nt = C.current;
      k && m && Nt !== void 0 && Pe.has(cz(Nt.range)) && t1(Rr, a, s, o, l, u, Mt, c, h, Ce, C, rt, U, S, $, k, B);
    };
    ir && (xr(Je), Fe !== null && (Fe.save(), Fe.scale(R, R), Fe.textBaseline = "middle", xr(Fe), Fe.restore()), Pe.hasHeader() && (pse(Y, Mt, a, b, Ce, l, u, o, Pe), Oe())), Je.restore(), Y.restore();
    return;
  }
  if ((H !== !0 || i !== te?.cellXOffset || l !== te?.translateX || kr !== te?.mustDrawFocusOnHeader || tr !== te?.mustDrawHighlightRingsOnHeader) && Oe(), H === !0) {
    Fa(Ze !== void 0 && te !== void 0);
    const { regions: ct } = cse(Je, Ze, Ze === xe ? te.aBufferScroll : te.bBufferScroll, Ze === xe ? te.bBufferScroll : te.aBufferScroll, te, i, o, l, u, S, a, s, B, Ce, R, c, Mt, x, A);
    Qt = ct;
  } else H !== !1 && (Fa(te !== void 0), Qt = dse(te, i, o, l, u, a, s, Ce, Mt, H));
  lse(Je, Mt, a, s, S, B, _, rt, h);
  const Ie = yP(Je, a, s, i, o, l, u, c, p, y, b, x, S, B, ne, h), Me = m ? t1(Je, a, s, o, l, u, Mt, c, h, Ce, C, rt, U, S, $, k, B) : void 0;
  if (Je.fillStyle = h.bgCell, Qt.length > 0) {
    Je.beginPath();
    for (const ct of Qt)
      Je.rect(ct.x, ct.y, ct.width, ct.height);
    Je.clip(), Je.fill(), Je.beginPath();
  } else
    Je.fillRect(0, 0, a, s);
  const je = o3(Je, Mt, c, s, Ce, l, u, o, B, rt, U, N, O, v, I, m, S, $, Qt, Pe, C, ae, ne, W, ye, G, he, Q, P, h, ge, ce, ie, E, z);
  ose(Je, Mt, c, a, s, Ce, l, u, o, B, rt, O, C.rows, v, S, $, Qt, Pe, h), use(Je, Mt, o, l, u, a, s, Qt, Ce, rt, O, _, S, B, h), bP(Je, Mt, o, l, u, a, s, Qt, je, b, Ce, rt, O, _, S, B, h), Ie?.(), Me?.(), w && Gl(Mt, 0, l, 0, Ce, (ct, ir) => ct.sourceIndex === le ? (vP(Y, ir + ct.width, 0, Ce + 1, $a(h.resizeIndicatorColor ?? h.accentLight, h.bgHeader)), vP(Je, ir + ct.width, Ce, s, $a(h.resizeIndicatorColor ?? h.accentLight, h.bgCell)), !0) : !1), Fe !== null && (Fe.fillStyle = h.bgCell, Fe.fillRect(0, 0, a, s), Fe.drawImage(Je.canvas, 0, 0));
  const tt = hse(Mt, s, Ce, l, u, o, B, rt, S, $);
  W?.setWindow({
    x: i,
    y: o,
    width: Mt.length,
    height: tt - o
  }, p, Array.from({ length: S }, (ct, ir) => B - 1 - ir));
  const Ct = te !== void 0 && (i !== te.cellXOffset || l !== te.translateX), Kt = te !== void 0 && (o !== te.cellYOffset || u !== te.translateY);
  X.current = {
    cellXOffset: i,
    cellYOffset: o,
    translateX: l,
    translateY: u,
    mustDrawFocusOnHeader: kr,
    mustDrawHighlightRingsOnHeader: tr,
    lastBuffer: A ? xt === xe ? "a" : "b" : void 0,
    aBufferScroll: xt === xe ? [Ct, Kt] : te?.aBufferScroll,
    bBufferScroll: xt === we ? [Ct, Kt] : te?.bBufferScroll
  }, Je.restore(), Y.restore();
}
const mse = 80;
function gse(e) {
  const t = e - 1;
  return t * t * t + 1;
}
class bse {
  callback;
  constructor(t) {
    this.callback = t;
  }
  currentHoveredItem = void 0;
  leavingItems = [];
  lastAnimationTime;
  addToLeavingItems = (t) => {
    this.leavingItems.some((n) => Yf(n.item, t.item)) || this.leavingItems.push(t);
  };
  /**
   * @returns the hover amount of the item, if it was leaving (0 if not).
   */
  removeFromLeavingItems = (t) => {
    const r = this.leavingItems.find((n) => Yf(n.item, t));
    return this.leavingItems = this.leavingItems.filter((n) => n !== r), r?.hoverAmount ?? 0;
  };
  cleanUpLeavingElements = () => {
    this.leavingItems = this.leavingItems.filter((t) => t.hoverAmount > 0);
  };
  shouldStep = () => {
    const t = this.leavingItems.length > 0, r = this.currentHoveredItem !== void 0 && this.currentHoveredItem.hoverAmount < 1;
    return t || r;
  };
  getAnimatingItems = () => this.currentHoveredItem !== void 0 ? [...this.leavingItems, this.currentHoveredItem] : this.leavingItems.map((t) => ({ ...t, hoverAmount: gse(t.hoverAmount) }));
  step = (t) => {
    if (this.lastAnimationTime === void 0)
      this.lastAnimationTime = t;
    else {
      const n = (t - this.lastAnimationTime) / mse;
      for (const s of this.leavingItems)
        s.hoverAmount = Rs(s.hoverAmount - n, 0, 1);
      this.currentHoveredItem !== void 0 && (this.currentHoveredItem.hoverAmount = Rs(this.currentHoveredItem.hoverAmount + n, 0, 1));
      const a = this.getAnimatingItems();
      this.callback(a), this.cleanUpLeavingElements();
    }
    this.shouldStep() ? (this.lastAnimationTime = t, window.requestAnimationFrame(this.step)) : this.lastAnimationTime = void 0;
  };
  setHovered = (t) => {
    if (!Yf(this.currentHoveredItem?.item, t)) {
      if (this.currentHoveredItem !== void 0 && this.addToLeavingItems(this.currentHoveredItem), t !== void 0) {
        const r = this.removeFromLeavingItems(t);
        this.currentHoveredItem = {
          item: t,
          hoverAmount: r
        };
      } else
        this.currentHoveredItem = void 0;
      this.lastAnimationTime === void 0 && window.requestAnimationFrame(this.step);
    }
  };
}
class yse {
  fn;
  val;
  constructor(t) {
    this.fn = t;
  }
  get value() {
    return this.val ?? (this.val = this.fn());
  }
}
function jI(e) {
  return new yse(e);
}
const vse = jI(() => window.navigator.userAgent.includes("Firefox")), Dg = jI(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome")), Og = jI(() => window.navigator.platform.toLowerCase().startsWith("mac"));
function wse(e) {
  const t = D.useRef([]), r = D.useRef(0), n = D.useRef(e);
  n.current = e;
  const a = D.useCallback(() => {
    const s = () => window.requestAnimationFrame(i), i = () => {
      const o = t.current.map($I);
      t.current = [], n.current(new Zf(o)), t.current.length > 0 ? r.current++ : r.current = 0;
    };
    window.requestAnimationFrame(r.current > 600 ? s : i);
  }, []);
  return D.useCallback((s) => {
    t.current.length === 0 && a();
    const i = Ns(s[0], s[1]);
    t.current.includes(i) || t.current.push(i);
  }, [a]);
}
const El = "header", Ma = "group-header", Pg = "out-of-bounds";
var Lc;
(function(e) {
  e[e.Start = -2] = "Start", e[e.StartPadding = -1] = "StartPadding", e[e.Center = 0] = "Center", e[e.EndPadding = 1] = "EndPadding", e[e.End = 2] = "End";
})(Lc || (Lc = {}));
function qz(e, t) {
  return e === t ? !0 : e?.kind === "out-of-bounds" ? e?.kind === t?.kind && e?.location[0] === t?.location[0] && e?.location[1] === t?.location[1] && e?.region[0] === t?.region[0] && e?.region[1] === t?.region[1] : e?.kind === t?.kind && e?.location[0] === t?.location[0] && e?.location[1] === t?.location[1];
}
const xP = 6, xse = (e, t) => e.kind === Gt.Custom ? e.copyData : t?.(e)?.getAccessibilityString(e) ?? "", Ese = (e, t) => {
  const { width: r, height: n, accessibilityHeight: a, columns: s, cellXOffset: i, cellYOffset: o, headerHeight: l, fillHandle: u = !1, groupHeaderHeight: c, rowHeight: d, rows: p, getCellContent: f, getRowThemeOverride: h, onHeaderMenuClick: m, enableGroups: y, isFilling: b, onCanvasFocused: v, onCanvasBlur: x, isFocused: _, selection: E, freezeColumns: w, onContextMenu: C, freezeTrailingRows: k, fixedShadowX: S = !0, fixedShadowY: B = !0, drawFocusRing: U, onMouseDown: N, onMouseUp: O, onMouseMoveRaw: I, onMouseMove: q, onItemHovered: ae, dragAndDropState: Q, firstColAccessible: ne, onKeyDown: le, onKeyUp: W, highlightRegions: X, canvasRef: G, onDragStart: P, onDragEnd: he, eventTargetRef: ye, isResizing: pe, resizeColumn: $, isDragging: F, isDraggable: ge = !1, allowResize: ce, disabledRows: ie, hasAppendRow: re, getGroupDetails: Te, theme: V, prelightCells: Pe, headerIcons: z, verticalBorder: A, drawCell: R, drawHeader: H, onCellFocused: be, onDragOverCell: me, onDrop: Ce, onDragLeave: We, imageWindowLoader: xe, smoothScrollX: we = !1, smoothScrollY: te = !1, experimental: Fe, getCellRenderer: Y } = e, Je = e.translateX ?? 0, xt = e.translateY ?? 0, Ze = Math.max(w, Math.min(s.length - 1, i)), rt = D.useRef(null), Mt = xe, Qt = D.useRef(), [kr, tr] = D.useState(!1), Oe = D.useRef([]), Ie = D.useRef(), [Me, je] = D.useState(), [tt, Ct] = D.useState(), Kt = D.useRef(null), [ct, ir] = D.useState(), [xr, Rr] = D.useState(!1), Nt = D.useRef(xr);
  Nt.current = xr;
  const dr = D.useMemo(() => new Zie(z, () => {
    He.current = void 0, qn.current();
  }), [z]), $e = y ? c + l : l, at = D.useRef(-1), Rt = (Fe?.enableFirefoxRescaling ?? !1) && vse.value, sr = (Fe?.enableSafariRescaling ?? !1) && Dg.value;
  D.useLayoutEffect(() => {
    window.devicePixelRatio === 1 || !Rt && !sr || (at.current !== -1 && tr(!0), window.clearTimeout(at.current), at.current = window.setTimeout(() => {
      tr(!1), at.current = -1;
    }, 200));
  }, [o, Ze, Je, xt, Rt, sr]);
  const bt = Tne(s, w), Ur = S ? nd(bt, Q) : 0, or = D.useCallback((it, Tt, rr) => {
    const Xt = it.getBoundingClientRect();
    if (Tt >= bt.length || rr >= p)
      return;
    const Dt = Xt.width / r, ur = zT(Tt, rr, r, n, c, $e, Ze, o, Je, xt, p, w, k, bt, d);
    return Dt !== 1 && (ur.x *= Dt, ur.y *= Dt, ur.width *= Dt, ur.height *= Dt), ur.x += Xt.x, ur.y += Xt.y, ur;
  }, [
    r,
    n,
    c,
    $e,
    Ze,
    o,
    Je,
    xt,
    p,
    w,
    k,
    bt,
    d
  ]), Ae = D.useCallback((it, Tt, rr, Xt) => {
    const Dt = it.getBoundingClientRect(), ur = Dt.width / r, Lr = (Tt - Dt.left) / ur, pr = (rr - Dt.top) / ur, Sr = 5, zr = UT(bt, Ze, r, void 0, Je);
    let Yn = 0, Xn = 0;
    Xt instanceof MouseEvent && (Yn = Xt.button, Xn = Xt.buttons);
    const _n = Dne(Lr, zr, Je), nn = One(pr, n, y, l, c, p, d, o, xt, k), Hn = Xt?.shiftKey === !0, Hr = Xt?.ctrlKey === !0, Bn = Xt?.metaKey === !0, wo = Xt !== void 0 && !(Xt instanceof MouseEvent) || Xt?.pointerType === "touch", ni = [
      Lr < 0 ? -1 : r < Lr ? 1 : 0,
      pr < $e ? -1 : n < pr ? 1 : 0
    ];
    let xo;
    if (_n === -1 || pr < 0 || Lr < 0 || nn === void 0 || Lr > r || pr > n) {
      const bn = Lr > r ? 1 : Lr < 0 ? -1 : 0, li = pr > n ? 1 : pr < 0 ? -1 : 0;
      let Ji = bn * 2, Wa = li * 2;
      bn === 0 && (Ji = _n === -1 ? Lc.EndPadding : Lc.Center), li === 0 && (Wa = nn === void 0 ? Lc.EndPadding : Lc.Center);
      let Na = !1;
      if (_n === -1 && nn === -1) {
        const Hs = or(it, bt.length - 1, -1);
        Fa(Hs !== void 0), Na = Tt < Hs.x + Hs.width + Sr;
      }
      const nl = Lr > r && Lr < r + MT() || pr > n && pr < n + MT();
      xo = {
        kind: Pg,
        location: [_n !== -1 ? _n : Lr < 0 ? 0 : bt.length - 1, nn ?? p - 1],
        region: [Ji, Wa],
        shiftKey: Hn,
        ctrlKey: Hr,
        metaKey: Bn,
        isEdge: Na,
        isTouch: wo,
        button: Yn,
        buttons: Xn,
        scrollEdge: ni,
        isMaybeScrollbar: nl
      };
    } else if (nn <= -1) {
      let bn = or(it, _n, nn);
      Fa(bn !== void 0);
      let li = bn !== void 0 && bn.x + bn.width - Tt <= Sr;
      const Ji = _n - 1;
      Tt - bn.x <= Sr && Ji >= 0 ? (li = !0, bn = or(it, Ji, nn), Fa(bn !== void 0), xo = {
        kind: y && nn === -2 ? Ma : El,
        location: [Ji, nn],
        bounds: bn,
        group: bt[Ji].group ?? "",
        isEdge: li,
        shiftKey: Hn,
        ctrlKey: Hr,
        metaKey: Bn,
        isTouch: wo,
        localEventX: Tt - bn.x,
        localEventY: rr - bn.y,
        button: Yn,
        buttons: Xn,
        scrollEdge: ni
      }) : xo = {
        kind: y && nn === -2 ? Ma : El,
        group: bt[_n].group ?? "",
        location: [_n, nn],
        bounds: bn,
        isEdge: li,
        shiftKey: Hn,
        ctrlKey: Hr,
        metaKey: Bn,
        isTouch: wo,
        localEventX: Tt - bn.x,
        localEventY: rr - bn.y,
        button: Yn,
        buttons: Xn,
        scrollEdge: ni
      };
    } else {
      const bn = or(it, _n, nn);
      Fa(bn !== void 0);
      const li = bn !== void 0 && bn.x + bn.width - Tt < Sr;
      let Ji = !1;
      if (u && E.current !== void 0) {
        const Wa = cz(E.current.range), Na = or(it, Wa[0], Wa[1]);
        if (Na !== void 0) {
          const nl = Na.x + Na.width - 2, Hs = Na.y + Na.height - 2;
          Ji = Math.abs(nl - Tt) < xP && Math.abs(Hs - rr) < xP;
        }
      }
      xo = {
        kind: "cell",
        location: [_n, nn],
        bounds: bn,
        isEdge: li,
        shiftKey: Hn,
        ctrlKey: Hr,
        isFillHandle: Ji,
        metaKey: Bn,
        isTouch: wo,
        localEventX: Tt - bn.x,
        localEventY: rr - bn.y,
        button: Yn,
        buttons: Xn,
        scrollEdge: ni
      };
    }
    return xo;
  }, [
    r,
    bt,
    Ze,
    Je,
    n,
    y,
    l,
    c,
    p,
    d,
    o,
    xt,
    k,
    or,
    u,
    E,
    $e
  ]), [Ve] = Me ?? [], Ge = D.useRef(() => {
  }), lr = D.useRef(Me);
  lr.current = Me;
  const [br, Ut] = D.useMemo(() => {
    const it = document.createElement("canvas"), Tt = document.createElement("canvas");
    return it.style.display = "none", it.style.opacity = "0", it.style.position = "fixed", Tt.style.display = "none", Tt.style.opacity = "0", Tt.style.position = "fixed", [it.getContext("2d", { alpha: !1 }), Tt.getContext("2d", { alpha: !1 })];
  }, []);
  D.useLayoutEffect(() => {
    if (!(br === null || Ut === null))
      return document.documentElement.append(br.canvas), document.documentElement.append(Ut.canvas), () => {
        br.canvas.remove(), Ut.canvas.remove();
      };
  }, [br, Ut]);
  const cn = D.useMemo(() => new jne(), []), Re = Rt && kr ? 1 : sr && kr ? 2 : 5, J = Fe?.disableMinimumCellWidth === !0 ? 1 : 10, He = D.useRef(), fr = D.useRef(null), Mr = D.useRef(null), ut = D.useCallback(() => {
    const it = rt.current, Tt = Kt.current;
    if (it === null || Tt === null || (fr.current === null && (fr.current = it.getContext("2d", { alpha: !1 }), it.width = 0, it.height = 0), Mr.current === null && (Mr.current = Tt.getContext("2d", { alpha: !1 }), Tt.width = 0, Tt.height = 0), fr.current === null || Mr.current === null || br === null || Ut === null))
      return;
    let rr = !1;
    const Xt = (Lr) => {
      rr = !0, ir(Lr);
    }, Dt = He.current, ur = {
      headerCanvasCtx: Mr.current,
      canvasCtx: fr.current,
      bufferACtx: br,
      bufferBCtx: Ut,
      width: r,
      height: n,
      cellXOffset: Ze,
      cellYOffset: o,
      translateX: Math.round(Je),
      translateY: Math.round(xt),
      mappedColumns: bt,
      enableGroups: y,
      freezeColumns: w,
      dragAndDropState: Q,
      theme: V,
      headerHeight: l,
      groupHeaderHeight: c,
      disabledRows: ie ?? fn.empty(),
      rowHeight: d,
      verticalBorder: A,
      isResizing: pe,
      resizeCol: $,
      isFocused: _,
      selection: E,
      fillHandle: u,
      drawCellCallback: R,
      hasAppendRow: re,
      overrideCursor: Xt,
      maxScaleFactor: Re,
      freezeTrailingRows: k,
      rows: p,
      drawFocus: U,
      getCellContent: f,
      getGroupDetails: Te ?? ((Lr) => ({ name: Lr })),
      getRowThemeOverride: h,
      drawHeaderCallback: H,
      prelightCells: Pe,
      highlightRegions: X,
      imageLoader: Mt,
      lastBlitData: Ie,
      damage: Qt.current,
      hoverValues: Oe.current,
      hoverInfo: lr.current,
      spriteManager: dr,
      scrolling: kr,
      hyperWrapping: Fe?.hyperWrapping ?? !1,
      touchMode: xr,
      enqueue: Ge.current,
      renderStateProvider: cn,
      renderStrategy: Fe?.renderStrategy ?? (Dg.value ? "double-buffer" : "single-buffer"),
      getCellRenderer: Y,
      minimumCellWidth: J
    };
    ur.damage === void 0 ? (He.current = ur, wP(ur, Dt)) : wP(ur, void 0), !rr && (ur.damage === void 0 || ur.damage.has(lr?.current?.[0])) && ir(void 0);
  }, [
    br,
    Ut,
    r,
    n,
    Ze,
    o,
    Je,
    xt,
    bt,
    y,
    w,
    Q,
    V,
    l,
    c,
    ie,
    d,
    A,
    pe,
    re,
    $,
    _,
    E,
    u,
    k,
    p,
    U,
    Re,
    f,
    Te,
    h,
    R,
    H,
    Pe,
    X,
    Mt,
    dr,
    kr,
    Fe?.hyperWrapping,
    Fe?.renderStrategy,
    xr,
    cn,
    Y,
    J
  ]), qn = D.useRef(ut);
  D.useLayoutEffect(() => {
    ut(), qn.current = ut;
  }, [ut]), D.useLayoutEffect(() => {
    (async () => {
      document?.fonts?.ready !== void 0 && (await document.fonts.ready, He.current = void 0, qn.current());
    })();
  }, []);
  const En = D.useCallback((it) => {
    Qt.current = it, qn.current(), Qt.current = void 0;
  }, []), yi = wse(En);
  Ge.current = yi;
  const Yi = D.useCallback((it) => {
    En(new Zf(it.map((Tt) => Tt.cell)));
  }, [En]);
  Mt.setCallback(En);
  const [Xi, mn] = D.useState(!1), [Ri, Ht] = Ve ?? [], jt = Ri !== void 0 && Ht === -1, jn = Ri !== void 0 && Ht === -2;
  let Ii = !1, ti = !1, Dn = ct;
  if (Dn === void 0 && Ri !== void 0 && Ht !== void 0 && Ht > -1 && Ht < p) {
    const it = f([Ri, Ht], !0);
    Ii = it.kind === as.NewRow || it.kind === as.Marker && it.markerKind !== "number", ti = it.kind === Gt.Boolean && LT(it), Dn = it.cursor;
  }
  const Ue = F ? "grabbing" : (tt ?? !1) || pe ? "col-resize" : Xi || b ? "crosshair" : Dn !== void 0 ? Dn : jt || Ii || ti || jn ? "pointer" : "default", ze = D.useMemo(() => ({
    // width,
    // height,
    contain: "strict",
    display: "block",
    cursor: Ue
  }), [Ue]), At = D.useRef("default"), yt = ye?.current;
  yt != null && At.current !== ze.cursor && (yt.style.cursor = At.current = ze.cursor);
  const wt = D.useCallback((it, Tt, rr, Xt) => {
    if (Te === void 0)
      return;
    const Dt = Te(it);
    if (Dt.actions !== void 0) {
      const ur = Nz(Tt, Dt.actions);
      for (const [Lr, pr] of ur.entries())
        if (Mb(pr, rr + Tt.x, Xt + pr.y))
          return Dt.actions[Lr];
    }
  }, [Te]), Se = D.useCallback((it, Tt, rr, Xt) => {
    const Dt = s[Tt];
    if (!F && !pe && Dt.hasMenu === !0 && !(tt ?? !1)) {
      const ur = or(it, Tt, -1);
      Fa(ur !== void 0);
      const Lr = Iz(ur.x, ur.y, ur.width, ur.height, OI(Dt.title) === "rtl");
      if (rr > Lr.x && rr < Lr.x + Lr.width && Xt > Lr.y && Xt < Lr.y + Lr.height)
        return ur;
    }
  }, [s, or, tt, F, pe]), qe = D.useRef(0), lt = D.useRef(), St = D.useRef(!1), Yt = D.useCallback((it) => {
    const Tt = rt.current, rr = ye?.current;
    if (Tt === null || it.target !== Tt && it.target !== rr)
      return;
    St.current = !0;
    let Xt, Dt;
    if (it instanceof MouseEvent ? (Xt = it.clientX, Dt = it.clientY) : (Xt = it.touches[0].clientX, Dt = it.touches[0].clientY), it.target === rr && rr !== null) {
      const Lr = rr.getBoundingClientRect();
      if (Xt > Lr.right || Dt > Lr.bottom)
        return;
    }
    const ur = Ae(Tt, Xt, Dt, it);
    lt.current = ur.location, ur.isTouch && (qe.current = Date.now()), Nt.current !== ur.isTouch && Rr(ur.isTouch), !(ur.kind === El && Se(Tt, ur.location[0], Xt, Dt) !== void 0) && (ur.kind === Ma && wt(ur.group, ur.bounds, ur.localEventX, ur.localEventY) !== void 0 || (N?.(ur), !ur.isTouch && ge !== !0 && ge !== ur.kind && ur.button < 3 && ur.button !== 1 && it.preventDefault()));
  }, [ye, ge, Ae, wt, Se, N]);
  Oi("touchstart", Yt, window, !1), Oi("mousedown", Yt, window, !1);
  const Vr = D.useRef(0), gn = D.useCallback((it) => {
    const Tt = Vr.current;
    Vr.current = Date.now();
    const rr = rt.current;
    if (St.current = !1, O === void 0 || rr === null)
      return;
    const Xt = ye?.current, Dt = it.target !== rr && it.target !== Xt;
    let ur, Lr, pr = !0;
    if (it instanceof MouseEvent) {
      if (ur = it.clientX, Lr = it.clientY, pr = it.button < 3, it.pointerType === "touch")
        return;
    } else
      ur = it.changedTouches[0].clientX, Lr = it.changedTouches[0].clientY;
    let Sr = Ae(rr, ur, Lr, it);
    Sr.isTouch && qe.current !== 0 && Date.now() - qe.current > 500 && (Sr = {
      ...Sr,
      isLongTouch: !0
    }), Tt !== 0 && Date.now() - Tt < (Sr.isTouch ? 1e3 : 500) && (Sr = {
      ...Sr,
      isDoubleClick: !0
    }), Nt.current !== Sr.isTouch && Rr(Sr.isTouch), !Dt && it.cancelable && pr && it.preventDefault();
    const [zr] = Sr.location, Yn = Se(rr, zr, ur, Lr);
    if (Sr.kind === El && Yn !== void 0) {
      (Sr.button !== 0 || lt.current?.[0] !== zr || lt.current?.[1] !== -1) && O(Sr, !0);
      return;
    } else if (Sr.kind === Ma) {
      const Xn = wt(Sr.group, Sr.bounds, Sr.localEventX, Sr.localEventY);
      if (Xn !== void 0) {
        Sr.button === 0 && Xn.onClick(Sr);
        return;
      }
    }
    O(Sr, Dt);
  }, [O, ye, Ae, Se, wt]);
  Oi("mouseup", gn, window, !1), Oi("touchend", gn, window, !1);
  const On = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null)
      return;
    const rr = ye?.current, Xt = it.target !== Tt && it.target !== rr;
    let Dt, ur, Lr = !0;
    it instanceof MouseEvent ? (Dt = it.clientX, ur = it.clientY, Lr = it.button < 3) : (Dt = it.changedTouches[0].clientX, ur = it.changedTouches[0].clientY);
    const pr = Ae(Tt, Dt, ur, it);
    Nt.current !== pr.isTouch && Rr(pr.isTouch), !Xt && it.cancelable && Lr && it.preventDefault();
    const [Sr] = pr.location, zr = Se(Tt, Sr, Dt, ur);
    if (pr.kind === El && zr !== void 0)
      pr.button === 0 && lt.current?.[0] === Sr && lt.current?.[1] === -1 && m?.(Sr, zr);
    else if (pr.kind === Ma) {
      const Yn = wt(pr.group, pr.bounds, pr.localEventX, pr.localEventY);
      Yn !== void 0 && pr.button === 0 && Yn.onClick(pr);
    }
  }, [ye, Ae, Se, m, wt]);
  Oi("click", On, window, !1);
  const bs = D.useCallback((it) => {
    const Tt = rt.current, rr = ye?.current;
    if (Tt === null || it.target !== Tt && it.target !== rr || C === void 0)
      return;
    const Xt = Ae(Tt, it.clientX, it.clientY, it);
    C(Xt, () => {
      it.cancelable && it.preventDefault();
    });
  }, [ye, Ae, C]);
  Oi("contextmenu", bs, ye?.current ?? null, !1);
  const ys = D.useCallback((it) => {
    Qt.current = new Zf(it.map((Tt) => Tt.item)), Oe.current = it, qn.current(), Qt.current = void 0;
  }, []), _i = D.useMemo(() => new bse(ys), [ys]), ri = D.useRef(_i);
  ri.current = _i, D.useLayoutEffect(() => {
    const it = ri.current;
    if (Ve === void 0 || Ve[1] < 0) {
      it.setHovered(Ve);
      return;
    }
    const Tt = f(Ve, !0), rr = Y(Tt), Xt = rr === void 0 && Tt.kind === Gt.Custom || rr?.needsHover !== void 0 && (typeof rr.needsHover == "boolean" ? rr.needsHover : rr.needsHover(Tt));
    it.setHovered(Xt ? Ve : void 0);
  }, [f, Y, Ve]);
  const Ir = D.useRef(), dt = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null)
      return;
    const rr = ye?.current, Xt = it.target !== Tt && it.target !== rr, Dt = Ae(Tt, it.clientX, it.clientY, it);
    if (Dt.kind !== "out-of-bounds" && Xt && !St.current && !Dt.isTouch)
      return;
    const ur = (pr, Sr) => {
      je((zr) => zr === pr || zr?.[0][0] === pr?.[0][0] && zr?.[0][1] === pr?.[0][1] && (zr?.[1][0] === pr?.[1][0] && zr?.[1][1] === pr?.[1][1] || !Sr) ? zr : pr);
    };
    if (!qz(Dt, Ir.current))
      ir(void 0), ae?.(Dt), ur(Dt.kind === Pg ? void 0 : [Dt.location, [Dt.localEventX, Dt.localEventY]], !0), Ir.current = Dt;
    else if (Dt.kind === "cell" || Dt.kind === El || Dt.kind === Ma) {
      let pr = !1, Sr = !0;
      if (Dt.kind === "cell") {
        const Yn = f(Dt.location);
        Sr = Y(Yn)?.needsHoverPosition ?? Yn.kind === Gt.Custom, pr = Sr;
      } else Dt.kind === Ma && (pr = !0);
      const zr = [Dt.location, [Dt.localEventX, Dt.localEventY]];
      ur(zr, Sr), lr.current = zr, pr && En(new Zf([Dt.location]));
    }
    const Lr = Dt.location[0] >= (ne ? 0 : 1);
    Ct(Dt.kind === El && Dt.isEdge && Lr && ce === !0), mn(Dt.kind === "cell" && Dt.isFillHandle), I?.(it), q(Dt);
  }, [
    ye,
    Ae,
    ne,
    ce,
    I,
    q,
    ae,
    f,
    Y,
    En
  ]);
  Oi("mousemove", dt, window, !0);
  const Sn = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null)
      return;
    let rr, Xt;
    E.current !== void 0 && (rr = or(Tt, E.current.cell[0], E.current.cell[1]), Xt = E.current.cell), le?.({
      bounds: rr,
      stopPropagation: () => it.stopPropagation(),
      preventDefault: () => it.preventDefault(),
      cancel: () => {
      },
      ctrlKey: it.ctrlKey,
      metaKey: it.metaKey,
      shiftKey: it.shiftKey,
      altKey: it.altKey,
      key: it.key,
      keyCode: it.keyCode,
      rawEvent: it,
      location: Xt
    });
  }, [le, E, or]), Mi = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null)
      return;
    let rr, Xt;
    E.current !== void 0 && (rr = or(Tt, E.current.cell[0], E.current.cell[1]), Xt = E.current.cell), W?.({
      bounds: rr,
      stopPropagation: () => it.stopPropagation(),
      preventDefault: () => it.preventDefault(),
      cancel: () => {
      },
      ctrlKey: it.ctrlKey,
      metaKey: it.metaKey,
      shiftKey: it.shiftKey,
      altKey: it.altKey,
      key: it.key,
      keyCode: it.keyCode,
      rawEvent: it,
      location: Xt
    });
  }, [W, E, or]), vs = D.useCallback((it) => {
    rt.current = it, G !== void 0 && (G.current = it);
  }, [G]), Zi = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null || ge === !1 || pe) {
      it.preventDefault();
      return;
    }
    let rr, Xt;
    const Dt = Ae(Tt, it.clientX, it.clientY);
    if (ge !== !0 && Dt.kind !== ge) {
      it.preventDefault();
      return;
    }
    const ur = (Xn, _n) => {
      rr = Xn, Xt = _n;
    };
    let Lr, pr, Sr;
    const zr = (Xn, _n, nn) => {
      Lr = Xn, pr = _n, Sr = nn;
    };
    let Yn = !1;
    if (P?.({
      ...Dt,
      setData: ur,
      setDragImage: zr,
      preventDefault: () => Yn = !0,
      defaultPrevented: () => Yn
    }), !Yn && rr !== void 0 && Xt !== void 0 && it.dataTransfer !== null)
      if (it.dataTransfer.setData(rr, Xt), it.dataTransfer.effectAllowed = "copyLink", Lr !== void 0 && pr !== void 0 && Sr !== void 0)
        it.dataTransfer.setDragImage(Lr, pr, Sr);
      else {
        const [Xn, _n] = Dt.location;
        if (_n !== void 0) {
          const nn = document.createElement("canvas"), Hn = or(Tt, Xn, _n);
          Fa(Hn !== void 0);
          const Hr = Math.ceil(window.devicePixelRatio ?? 1);
          nn.width = Hn.width * Hr, nn.height = Hn.height * Hr;
          const Bn = nn.getContext("2d");
          Bn !== null && (Bn.scale(Hr, Hr), Bn.textBaseline = "middle", _n === -1 ? (Bn.font = V.headerFontFull, Bn.fillStyle = V.bgHeader, Bn.fillRect(0, 0, nn.width, nn.height), Dz(Bn, 0, 0, Hn.width, Hn.height, bt[Xn], !1, V, !1, !1, 0, dr, H, !1)) : (Bn.font = V.baseFontFull, Bn.fillStyle = V.bgCell, Bn.fillRect(0, 0, nn.width, nn.height), Rz(Bn, f([Xn, _n]), 0, _n, !1, !1, 0, 0, Hn.width, Hn.height, !1, V, V.bgCell, Mt, dr, 1, void 0, !1, 0, void 0, void 0, void 0, cn, Y, () => {
          }))), nn.style.left = "-100%", nn.style.position = "absolute", nn.style.width = `${Hn.width}px`, nn.style.height = `${Hn.height}px`, document.body.append(nn), it.dataTransfer.setDragImage(nn, Hn.width / 2, Hn.height / 2), window.setTimeout(() => {
            nn.remove();
          }, 0);
        }
      }
    else
      it.preventDefault();
  }, [
    ge,
    pe,
    Ae,
    P,
    or,
    V,
    bt,
    dr,
    H,
    f,
    Mt,
    cn,
    Y
  ]);
  Oi("dragstart", Zi, ye?.current ?? null, !1, !1);
  const ws = D.useRef(), pa = D.useCallback((it) => {
    const Tt = rt.current;
    if (Ce !== void 0 && it.preventDefault(), Tt === null || me === void 0)
      return;
    const rr = Ae(Tt, it.clientX, it.clientY), [Xt, Dt] = rr.location, ur = Xt - (ne ? 0 : 1), [Lr, pr] = ws.current ?? [];
    (Lr !== ur || pr !== Dt) && (ws.current = [ur, Dt], me([ur, Dt], it.dataTransfer));
  }, [ne, Ae, me, Ce]);
  Oi("dragover", pa, ye?.current ?? null, !1, !1);
  const g = D.useCallback(() => {
    ws.current = void 0, he?.();
  }, [he]);
  Oi("dragend", g, ye?.current ?? null, !1, !1);
  const T = D.useCallback((it) => {
    const Tt = rt.current;
    if (Tt === null || Ce === void 0)
      return;
    it.preventDefault();
    const rr = Ae(Tt, it.clientX, it.clientY), [Xt, Dt] = rr.location, ur = Xt - (ne ? 0 : 1);
    Ce([ur, Dt], it.dataTransfer);
  }, [ne, Ae, Ce]);
  Oi("drop", T, ye?.current ?? null, !1, !1);
  const ee = D.useCallback(() => {
    We?.();
  }, [We]);
  Oi("dragleave", ee, ye?.current ?? null, !1, !1);
  const fe = D.useRef(E);
  fe.current = E;
  const j = D.useRef(null), de = D.useCallback((it) => {
    rt.current === null || !rt.current.contains(document.activeElement) || (it === null && fe.current.current !== void 0 ? G?.current?.focus({
      preventScroll: !0
    }) : it !== null && it.focus({
      preventScroll: !0
    }), j.current = it);
  }, [G]);
  D.useImperativeHandle(t, () => ({
    focus: () => {
      const it = j.current;
      it === null || !document.contains(it) ? G?.current?.focus({
        preventScroll: !0
      }) : it.focus({
        preventScroll: !0
      });
    },
    getBounds: (it, Tt) => {
      if (!(G === void 0 || G.current === null))
        return or(G.current, it ?? 0, Tt ?? -1);
    },
    damage: Yi
  }), [G, Yi, or]);
  const _e = D.useRef(), Le = Gre(() => {
    if (r < 50 || Fe?.disableAccessibilityTree === !0)
      return null;
    let it = UT(bt, Ze, r, Q, Je);
    const Tt = ne ? 0 : -1;
    !ne && it[0]?.sourceIndex === 0 && (it = it.slice(1));
    const [rr, Xt] = E.current?.cell ?? [], Dt = E.current?.range, ur = it.map((pr) => pr.sourceIndex), Lr = hu(o, Math.min(p, o + a));
    return rr !== void 0 && Xt !== void 0 && !(ur.includes(rr) && Lr.includes(Xt)) && de(null), D.createElement(
      "table",
      { key: "access-tree", role: "grid", "aria-rowcount": p + 1, "aria-multiselectable": "true", "aria-colcount": bt.length + Tt },
      D.createElement(
        "thead",
        { role: "rowgroup" },
        D.createElement("tr", { role: "row", "aria-rowindex": 1 }, it.map((pr) => D.createElement("th", { role: "columnheader", "aria-selected": E.columns.hasIndex(pr.sourceIndex), "aria-colindex": pr.sourceIndex + 1 + Tt, tabIndex: -1, onFocus: (Sr) => {
          if (Sr.target !== j.current)
            return be?.([pr.sourceIndex, -1]);
        }, key: pr.sourceIndex }, pr.title)))
      ),
      D.createElement("tbody", { role: "rowgroup" }, Lr.map((pr) => D.createElement("tr", { role: "row", "aria-selected": E.rows.hasIndex(pr), key: pr, "aria-rowindex": pr + 2 }, it.map((Sr) => {
        const zr = Sr.sourceIndex, Yn = Ns(zr, pr), Xn = rr === zr && Xt === pr, _n = Dt !== void 0 && zr >= Dt.x && zr < Dt.x + Dt.width && pr >= Dt.y && pr < Dt.y + Dt.height, nn = `glide-cell-${zr}-${pr}`, Hn = [zr, pr], Hr = f(Hn, !0);
        return D.createElement("td", { key: Yn, role: "gridcell", "aria-colindex": zr + 1 + Tt, "aria-selected": _n, "aria-readonly": Oc(Hr) || !Pf(Hr), id: nn, "data-testid": nn, onClick: () => {
          const Bn = G?.current;
          if (Bn != null)
            return le?.({
              bounds: or(Bn, zr, pr),
              cancel: () => {
              },
              preventDefault: () => {
              },
              stopPropagation: () => {
              },
              ctrlKey: !1,
              key: "Enter",
              keyCode: 13,
              metaKey: !1,
              shiftKey: !1,
              altKey: !1,
              rawEvent: void 0,
              location: Hn
            });
        }, onFocusCapture: (Bn) => {
          if (!(Bn.target === j.current || _e.current?.[0] === zr && _e.current?.[1] === pr))
            return _e.current = Hn, be?.(Hn);
        }, ref: Xn ? de : void 0, tabIndex: -1 }, xse(Hr, Y));
      }))))
    );
  }, [
    r,
    bt,
    Ze,
    Q,
    Je,
    p,
    o,
    a,
    E,
    de,
    f,
    G,
    le,
    or,
    be
  ], 200), et = w === 0 || !S ? 0 : Ze > w ? 1 : Rs(-Je / 100, 0, 1), vt = -o * 32 + xt, Wt = B ? Rs(-vt / 100, 0, 1) : 0, en = D.useMemo(() => {
    if (!et && !Wt)
      return null;
    const it = {
      position: "absolute",
      top: 0,
      left: Ur,
      width: r - Ur,
      height: n,
      opacity: et,
      pointerEvents: "none",
      transition: we ? void 0 : "opacity 0.2s",
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    }, Tt = {
      position: "absolute",
      top: $e,
      left: 0,
      width: r,
      height: n,
      opacity: Wt,
      pointerEvents: "none",
      transition: te ? void 0 : "opacity 0.2s",
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return D.createElement(
      D.Fragment,
      null,
      et > 0 && D.createElement("div", { id: "shadow-x", style: it }),
      Wt > 0 && D.createElement("div", { id: "shadow-y", style: Tt })
    );
  }, [et, Wt, Ur, r, we, $e, n, te]), pi = D.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return D.createElement(
    D.Fragment,
    null,
    D.createElement("canvas", { "data-testid": "data-grid-canvas", tabIndex: 0, onKeyDown: Sn, onKeyUp: Mi, onFocus: v, onBlur: x, ref: vs, style: ze }, Le),
    D.createElement("canvas", { ref: Kt, style: pi }),
    en
  );
}, Sse = D.memo(D.forwardRef(Ese));
function uf(e, t, r, n) {
  return Rs(Math.round(t - (e.growOffset ?? 0)), Math.ceil(r), Math.floor(n));
}
const _se = (e) => {
  const [t, r] = D.useState(), [n, a] = D.useState(), [s, i] = D.useState(), [o, l] = D.useState(), [u, c] = D.useState(!1), [d, p] = D.useState(), [f, h] = D.useState(), [m, y] = D.useState(), [b, v] = D.useState(!1), [x, _] = D.useState(), { onHeaderMenuClick: E, getCellContent: w, onColumnMoved: C, onColumnResize: k, onColumnResizeStart: S, onColumnResizeEnd: B, gridRef: U, maxColumnWidth: N, minColumnWidth: O, onRowMoved: I, lockColumns: q, onColumnProposeMove: ae, onMouseDown: Q, onMouseUp: ne, onItemHovered: le, onDragStart: W, canvasRef: X } = e, G = (k ?? B ?? S) !== void 0, { columns: P, selection: he } = e, ye = he.columns, pe = D.useCallback((A) => {
    const [R, H] = A.location;
    s !== void 0 && o !== R && R >= q ? (c(!0), l(R)) : f !== void 0 && H !== void 0 ? (v(!0), y(Math.max(0, H))) : n === void 0 && !u && !b && le?.(A);
  }, [s, f, o, le, q, n, u, b]), $ = C !== void 0, F = D.useCallback((A) => {
    if (A.button === 0) {
      const [R, H] = A.location;
      if (A.kind === "out-of-bounds" && A.isEdge && G) {
        const be = U?.current?.getBounds(P.length - 1, -1);
        be !== void 0 && (r(be.x), a(P.length - 1));
      } else if (A.kind === "header" && R >= q) {
        const be = X?.current;
        if (A.isEdge && G && be) {
          r(A.bounds.x), a(R);
          const Ce = be.getBoundingClientRect().width / be.offsetWidth, We = A.bounds.width / Ce;
          S?.(P[R], We, R, We + (P[R].growOffset ?? 0));
        } else A.kind === "header" && $ && (p(A.bounds.x), i(R));
      } else A.kind === "cell" && q > 0 && R === 0 && H !== void 0 && I !== void 0 && (_(A.bounds.y), h(H));
    }
    Q?.(A);
  }, [Q, G, q, I, U, P, $, S, X]), ge = D.useCallback((A, R) => {
    u || b || E?.(A, R);
  }, [u, b, E]), ce = D.useRef(-1), ie = D.useCallback(() => {
    ce.current = -1, h(void 0), y(void 0), _(void 0), v(!1), i(void 0), l(void 0), p(void 0), c(!1), a(void 0), r(void 0);
  }, []), re = D.useCallback((A, R) => {
    if (A.button === 0) {
      if (n !== void 0) {
        if (ye?.hasIndex(n) === !0)
          for (const be of ye) {
            if (be === n)
              continue;
            const me = P[be], Ce = uf(me, ce.current, O, N);
            k?.(me, Ce, be, Ce + (me.growOffset ?? 0));
          }
        const H = uf(P[n], ce.current, O, N);
        if (B?.(P[n], H, n, H + (P[n].growOffset ?? 0)), ye.hasIndex(n))
          for (const be of ye) {
            if (be === n)
              continue;
            const me = P[be], Ce = uf(me, ce.current, O, N);
            B?.(me, Ce, be, Ce + (me.growOffset ?? 0));
          }
      }
      ie(), s !== void 0 && o !== void 0 && C?.(s, o), f !== void 0 && m !== void 0 && I?.(f, m);
    }
    ne?.(A, R);
  }, [
    ne,
    n,
    s,
    o,
    f,
    m,
    ye,
    B,
    P,
    O,
    N,
    k,
    C,
    I,
    ie
  ]), Te = D.useMemo(() => {
    if (!(s === void 0 || o === void 0) && s !== o && ae?.(s, o) !== !1)
      return {
        src: s,
        dest: o
      };
  }, [s, o, ae]), V = D.useCallback((A) => {
    const R = X?.current;
    if (s !== void 0 && d !== void 0)
      Math.abs(A.clientX - d) > 20 && c(!0);
    else if (f !== void 0 && x !== void 0)
      Math.abs(A.clientY - x) > 20 && v(!0);
    else if (n !== void 0 && t !== void 0 && R) {
      const be = R.getBoundingClientRect().width / R.offsetWidth, me = (A.clientX - t) / be, Ce = P[n], We = uf(Ce, me, O, N);
      if (k?.(Ce, We, n, We + (Ce.growOffset ?? 0)), ce.current = me, ye?.first() === n)
        for (const xe of ye) {
          if (xe === n)
            continue;
          const we = P[xe], te = uf(we, ce.current, O, N);
          k?.(we, te, xe, te + (we.growOffset ?? 0));
        }
    }
  }, [
    s,
    d,
    f,
    x,
    n,
    t,
    P,
    O,
    N,
    k,
    ye,
    X
  ]), Pe = D.useCallback((A, R) => {
    if (f === void 0 || m === void 0)
      return w(A, R);
    let [H, be] = A;
    return be === m ? be = f : (be > m && (be -= 1), be >= f && (be += 1)), w([H, be], R);
  }, [f, m, w]), z = D.useCallback((A) => {
    W?.(A), A.defaultPrevented() || ie();
  }, [ie, W]);
  return D.createElement(Sse, { accessibilityHeight: e.accessibilityHeight, canvasRef: e.canvasRef, cellXOffset: e.cellXOffset, cellYOffset: e.cellYOffset, columns: e.columns, disabledRows: e.disabledRows, drawFocusRing: e.drawFocusRing, drawHeader: e.drawHeader, drawCell: e.drawCell, enableGroups: e.enableGroups, eventTargetRef: e.eventTargetRef, experimental: e.experimental, fillHandle: e.fillHandle, firstColAccessible: e.firstColAccessible, fixedShadowX: e.fixedShadowX, fixedShadowY: e.fixedShadowY, freezeColumns: e.freezeColumns, getCellRenderer: e.getCellRenderer, getGroupDetails: e.getGroupDetails, getRowThemeOverride: e.getRowThemeOverride, groupHeaderHeight: e.groupHeaderHeight, headerHeight: e.headerHeight, headerIcons: e.headerIcons, height: e.height, highlightRegions: e.highlightRegions, imageWindowLoader: e.imageWindowLoader, resizeColumn: n, isDraggable: e.isDraggable, isFilling: e.isFilling, isFocused: e.isFocused, onCanvasBlur: e.onCanvasBlur, onCanvasFocused: e.onCanvasFocused, onCellFocused: e.onCellFocused, onContextMenu: e.onContextMenu, onDragEnd: e.onDragEnd, onDragLeave: e.onDragLeave, onDragOverCell: e.onDragOverCell, onDrop: e.onDrop, onKeyDown: e.onKeyDown, onKeyUp: e.onKeyUp, onMouseMove: e.onMouseMove, prelightCells: e.prelightCells, rowHeight: e.rowHeight, rows: e.rows, selection: e.selection, smoothScrollX: e.smoothScrollX, smoothScrollY: e.smoothScrollY, theme: e.theme, freezeTrailingRows: e.freezeTrailingRows, hasAppendRow: e.hasAppendRow, translateX: e.translateX, translateY: e.translateY, verticalBorder: e.verticalBorder, width: e.width, getCellContent: Pe, isResizing: n !== void 0, onHeaderMenuClick: ge, isDragging: u, onItemHovered: pe, onDragStart: z, onMouseDown: F, allowResize: G, onMouseUp: re, dragAndDropState: Te, onMouseMoveRaw: V, ref: U });
};
function kse(e) {
  const t = Gr(null), [r, n] = Wn({
    width: e?.[0],
    height: e?.[1]
  });
  return Sb(() => {
    const a = (i) => {
      for (const o of i) {
        const { width: l, height: u } = o && o.contentRect || {};
        n((c) => c.width === l && c.height === u ? c : { width: l, height: u });
      }
    }, s = new window.ResizeObserver(a);
    return t.current && s.observe(t.current, void 0), () => {
      s.disconnect();
    };
  }, [t.current]), { ref: t, ...r };
}
const Cse = (e, t, r) => {
  const n = Gr(null), a = Gr(null), s = Gr(null), i = Gr(0), o = Gr(t);
  o.current = t;
  const l = r.current;
  Qn(() => {
    const u = () => {
      if (a.current === !1 && l !== null) {
        const p = [l.scrollLeft, l.scrollTop];
        if (s.current?.[0] === p[0] && s.current?.[1] === p[1])
          if (i.current > 10) {
            s.current = null, a.current = null;
            return;
          } else
            i.current++;
        else
          i.current = 0, o.current(p[0], p[1]), s.current = p;
        n.current = window.setTimeout(u, 8.333333333333334);
      }
    }, c = () => {
      a.current = !0, s.current = null, n.current !== null && (window.clearTimeout(n.current), n.current = null);
    }, d = (p) => {
      p.touches.length === 0 && (a.current = !1, i.current = 0, n.current = window.setTimeout(u, 8.333333333333334));
    };
    if (e && l !== null) {
      const p = l;
      return p.addEventListener("touchstart", c), p.addEventListener("touchend", d), () => {
        p.removeEventListener("touchstart", c), p.removeEventListener("touchend", d), n.current !== null && window.clearTimeout(n.current);
      };
    }
  }, [e, l]);
}, Ase = () => (e) => e.isSafari ? "scroll" : "auto", Tse = /* @__PURE__ */ Ga("div")({
  name: "ScrollRegionStyle",
  class: "gdg-s1dgczr6",
  propsAsIs: !1,
  vars: {
    "s1dgczr6-0": [Ase()]
  }
});
function Rse(e) {
  const [t, r] = D.useState(!1), n = typeof window > "u" ? null : window, a = D.useRef(0);
  return Oi("touchstart", D.useCallback(() => {
    window.clearTimeout(a.current), r(!0);
  }, []), n, !0, !1), Oi("touchend", D.useCallback((s) => {
    s.touches.length === 0 && (a.current = window.setTimeout(() => r(!1), e));
  }, [e]), n, !0, !1), t;
}
const Ise = (e) => {
  const {
    children: t,
    clientHeight: r,
    scrollHeight: n,
    scrollWidth: a,
    update: s,
    draggable: i,
    className: o,
    preventDiagonalScrolling: l = !1,
    paddingBottom: u = 0,
    paddingRight: c = 0,
    rightElement: d,
    rightElementProps: p,
    kineticScrollPerfHack: f = !1,
    scrollRef: h,
    initialSize: m
  } = e, y = [], b = p?.sticky ?? !1, v = p?.fill ?? !1, x = D.useRef(0), _ = D.useRef(0), E = D.useRef(null), w = typeof window > "u" ? 1 : window.devicePixelRatio, C = D.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: void 0
  }), k = D.useRef(null), S = Rse(200), [B, U] = D.useState(!0), N = D.useRef(0);
  D.useLayoutEffect(() => {
    if (!B || S || C.current.lockDirection === void 0) return;
    const P = E.current;
    if (P === null) return;
    const [he, ye] = C.current.lockDirection;
    he !== void 0 ? P.scrollLeft = he : ye !== void 0 && (P.scrollTop = ye), C.current.lockDirection = void 0;
  }, [S, B]);
  const O = D.useCallback((P, he) => {
    const ye = E.current;
    if (ye === null) return;
    he = he ?? ye.scrollTop, P = P ?? ye.scrollLeft;
    const pe = C.current.scrollTop, $ = C.current.scrollLeft, F = P - $, ge = he - pe;
    S && F !== 0 && ge !== 0 && (Math.abs(F) > 3 || Math.abs(ge) > 3) && l && C.current.lockDirection === void 0 && (C.current.lockDirection = Math.abs(F) < Math.abs(ge) ? [$, void 0] : [void 0, pe]);
    const ce = C.current.lockDirection;
    P = ce?.[0] ?? P, he = ce?.[1] ?? he, C.current.scrollLeft = P, C.current.scrollTop = he;
    const ie = ye.clientWidth, re = ye.clientHeight, Te = he, V = _.current - Te, Pe = ye.scrollHeight - re;
    if (_.current = Te, Pe > 0 && (Math.abs(V) > 2e3 || Te === 0 || Te === Pe) && n > ye.scrollHeight + 5) {
      const z = Te / Pe, A = (n - re) * z;
      x.current = A - Te;
    }
    ce !== void 0 && (window.clearTimeout(N.current), U(!1), N.current = window.setTimeout(() => U(!0), 200)), s({
      x: P,
      y: Te + x.current,
      width: ie - c,
      height: re - u,
      paddingRight: k.current?.clientWidth ?? 0
    });
  }, [u, c, n, s, l, S]);
  Cse(f && Dg.value, O, E);
  const I = D.useRef(O);
  I.current = O;
  const q = D.useRef(), ae = D.useRef(!1);
  D.useLayoutEffect(() => {
    ae.current ? O() : ae.current = !0;
  }, [O, u, c]);
  const Q = D.useCallback((P) => {
    E.current = P, h !== void 0 && (h.current = P);
  }, [h]);
  let ne = 0, le = 0;
  for (y.push(D.createElement("div", {
    key: ne++,
    style: {
      width: a,
      height: 0
    }
  })); le < n; ) {
    const P = Math.min(5e6, n - le);
    y.push(D.createElement("div", {
      key: ne++,
      style: {
        width: 0,
        height: P
      }
    })), le += P;
  }
  const {
    ref: W,
    width: X,
    height: G
  } = kse(m);
  return typeof window < "u" && (q.current?.height !== G || q.current?.width !== X) && (window.setTimeout(() => I.current(), 0), q.current = {
    width: X,
    height: G
  }), (X ?? 0) === 0 || (G ?? 0) === 0 ? D.createElement("div", {
    ref: W
  }) : D.createElement("div", {
    ref: W
  }, D.createElement(Tse, {
    isSafari: Dg.value
  }, D.createElement("div", {
    className: "dvn-underlay"
  }, t), D.createElement("div", {
    ref: Q,
    style: q.current,
    draggable: i,
    onDragStart: (P) => {
      i || (P.stopPropagation(), P.preventDefault());
    },
    className: "dvn-scroller " + (o ?? ""),
    onScroll: () => O()
  }, D.createElement("div", {
    className: "dvn-scroll-inner" + (d === void 0 ? " dvn-hidden" : "")
  }, D.createElement("div", {
    className: "dvn-stack"
  }, y), d !== void 0 && D.createElement(D.Fragment, null, !v && D.createElement("div", {
    className: "dvn-spacer"
  }), D.createElement("div", {
    ref: k,
    style: {
      height: G,
      maxHeight: r - Math.ceil(w % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: c,
      flexGrow: v ? 1 : void 0,
      right: b ? c ?? 0 : void 0,
      pointerEvents: "auto"
    }
  }, d))))));
}, Nse = (e) => {
  const { columns: t, rows: r, rowHeight: n, headerHeight: a, groupHeaderHeight: s, enableGroups: i, freezeColumns: o, experimental: l, nonGrowWidth: u, clientSize: c, className: d, onVisibleRegionChanged: p, scrollRef: f, preventDiagonalScrolling: h, rightElement: m, rightElementProps: y, overscrollX: b, overscrollY: v, initialSize: x, smoothScrollX: _ = !1, smoothScrollY: E = !1, isDraggable: w } = e, { paddingRight: C, paddingBottom: k } = l ?? {}, [S, B] = c, U = D.useRef(), N = D.useRef(), O = D.useRef(), I = D.useRef(), q = u + Math.max(0, b ?? 0);
  let ae = i ? a + s : a;
  if (typeof n == "number")
    ae += r * n;
  else
    for (let W = 0; W < r; W++)
      ae += n(W);
  v !== void 0 && (ae += v);
  const Q = D.useRef(), ne = D.useCallback(() => {
    if (Q.current === void 0)
      return;
    const W = { ...Q.current };
    let X = 0, G = W.x < 0 ? -W.x : 0, P = 0, he = 0;
    W.x = W.x < 0 ? 0 : W.x;
    let ye = 0;
    for (let ie = 0; ie < o; ie++)
      ye += t[ie].width;
    for (const ie of t) {
      const re = X - ye;
      if (W.x >= re + ie.width)
        X += ie.width, he++, P++;
      else if (W.x > re)
        X += ie.width, _ ? G += re - W.x : he++, P++;
      else if (W.x + W.width > re)
        X += ie.width, P++;
      else
        break;
    }
    let pe = 0, $ = 0, F = 0;
    if (typeof n == "number")
      E ? ($ = Math.floor(W.y / n), pe = $ * n - W.y) : $ = Math.ceil(W.y / n), F = Math.ceil(W.height / n) + $, pe < 0 && F++;
    else {
      let ie = 0;
      for (let re = 0; re < r; re++) {
        const Te = n(re), V = ie + (E ? 0 : Te / 2);
        if (W.y >= ie + Te)
          ie += Te, $++, F++;
        else if (W.y > V)
          ie += Te, E ? pe += V - W.y : $++, F++;
        else if (W.y + W.height > Te / 2 + ie)
          ie += Te, F++;
        else
          break;
      }
    }
    const ge = {
      x: he,
      y: $,
      width: P - he,
      height: F - $
    }, ce = U.current;
    (ce === void 0 || ce.y !== ge.y || ce.x !== ge.x || ce.height !== ge.height || ce.width !== ge.width || N.current !== G || O.current !== pe || W.width !== I.current?.[0] || W.height !== I.current?.[1]) && (p?.({
      x: he,
      y: $,
      width: P - he,
      height: F - $
    }, W.width, W.height, W.paddingRight ?? 0, G, pe), U.current = ge, N.current = G, O.current = pe, I.current = [W.width, W.height]);
  }, [t, n, r, p, o, _, E]), le = D.useCallback((W) => {
    Q.current = W, ne();
  }, [ne]);
  return D.useEffect(() => {
    ne();
  }, [ne]), D.createElement(
    Ise,
    { scrollRef: f, className: d, kineticScrollPerfHack: l?.kineticScrollPerfHack, preventDiagonalScrolling: h, draggable: w === !0 || typeof w == "string", scrollWidth: q + (C ?? 0), scrollHeight: ae + (k ?? 0), clientHeight: B, rightElement: m, paddingBottom: k, paddingRight: C, rightElementProps: y, update: le, initialSize: x },
    D.createElement(_se, { eventTargetRef: f, width: S, height: B, accessibilityHeight: e.accessibilityHeight, canvasRef: e.canvasRef, cellXOffset: e.cellXOffset, cellYOffset: e.cellYOffset, columns: e.columns, disabledRows: e.disabledRows, enableGroups: e.enableGroups, fillHandle: e.fillHandle, firstColAccessible: e.firstColAccessible, fixedShadowX: e.fixedShadowX, fixedShadowY: e.fixedShadowY, freezeColumns: e.freezeColumns, getCellContent: e.getCellContent, getCellRenderer: e.getCellRenderer, getGroupDetails: e.getGroupDetails, getRowThemeOverride: e.getRowThemeOverride, groupHeaderHeight: e.groupHeaderHeight, headerHeight: e.headerHeight, highlightRegions: e.highlightRegions, imageWindowLoader: e.imageWindowLoader, isFilling: e.isFilling, isFocused: e.isFocused, lockColumns: e.lockColumns, maxColumnWidth: e.maxColumnWidth, minColumnWidth: e.minColumnWidth, onHeaderMenuClick: e.onHeaderMenuClick, onMouseMove: e.onMouseMove, prelightCells: e.prelightCells, rowHeight: e.rowHeight, rows: e.rows, selection: e.selection, theme: e.theme, freezeTrailingRows: e.freezeTrailingRows, hasAppendRow: e.hasAppendRow, translateX: e.translateX, translateY: e.translateY, onColumnProposeMove: e.onColumnProposeMove, verticalBorder: e.verticalBorder, drawFocusRing: e.drawFocusRing, drawHeader: e.drawHeader, drawCell: e.drawCell, experimental: e.experimental, gridRef: e.gridRef, headerIcons: e.headerIcons, isDraggable: e.isDraggable, onCanvasBlur: e.onCanvasBlur, onCanvasFocused: e.onCanvasFocused, onCellFocused: e.onCellFocused, onColumnMoved: e.onColumnMoved, onColumnResize: e.onColumnResize, onColumnResizeEnd: e.onColumnResizeEnd, onColumnResizeStart: e.onColumnResizeStart, onContextMenu: e.onContextMenu, onDragEnd: e.onDragEnd, onDragLeave: e.onDragLeave, onDragOverCell: e.onDragOverCell, onDragStart: e.onDragStart, onDrop: e.onDrop, onItemHovered: e.onItemHovered, onKeyDown: e.onKeyDown, onKeyUp: e.onKeyUp, onMouseDown: e.onMouseDown, onMouseUp: e.onMouseUp, onRowMoved: e.onRowMoved, smoothScrollX: e.smoothScrollX, smoothScrollY: e.smoothScrollY })
  );
}, Dse = /* @__PURE__ */ Ga("div")({
  name: "SearchWrapper",
  class: "gdg-seveqep",
  propsAsIs: !1
}), Ose = D.createElement(
  "svg",
  { className: "button-icon", viewBox: "0 0 512 512" },
  D.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "48", d: "M112 244l144-144 144 144M256 120v292" })
), Pse = D.createElement(
  "svg",
  { className: "button-icon", viewBox: "0 0 512 512" },
  D.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "48", d: "M112 268l144 144 144-144M256 392V100" })
), Lse = D.createElement(
  "svg",
  { className: "button-icon", viewBox: "0 0 512 512" },
  D.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M368 368L144 144M368 144L144 368" })
), Mse = 10, Fse = (e) => {
  const { canvasRef: t, cellYOffset: r, rows: n, columns: a, searchInputRef: s, searchValue: i, searchResults: o, onSearchValueChange: l, getCellsForSelection: u, onSearchResultsChanged: c, showSearch: d = !1, onSearchClose: p } = e, [f] = D.useState(() => "search-box-" + Math.round(Math.random() * 1e3)), [h, m] = D.useState(""), y = i ?? h, b = D.useCallback((X) => {
    m(X), l?.(X);
  }, [l]), [v, x] = D.useState(), _ = D.useRef(v);
  _.current = v, D.useEffect(() => {
    o !== void 0 && (o.length > 0 ? x((X) => ({
      rowsSearched: n,
      results: o.length,
      selectedIndex: X?.selectedIndex ?? -1
    })) : x(void 0));
  }, [n, o]);
  const E = D.useRef();
  E.current === void 0 && (E.current = new AbortController());
  const w = D.useRef(), [C, k] = D.useState([]), S = o ?? C, B = D.useCallback(() => {
    w.current !== void 0 && (window.cancelAnimationFrame(w.current), w.current = void 0, E.current.abort());
  }, []), U = D.useRef(r);
  U.current = r;
  const N = D.useCallback((X) => {
    const G = new RegExp(X.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let P = U.current, he = Math.min(10, n), ye = 0;
    x(void 0), k([]);
    const pe = [], $ = async () => {
      if (u === void 0)
        return;
      const F = performance.now(), ge = n - ye;
      let ce = u({
        x: 0,
        y: P,
        width: a.length,
        height: Math.min(he, ge, n - P)
      }, E.current.signal);
      typeof ce == "function" && (ce = await ce());
      let ie = !1;
      for (const [A, R] of ce.entries())
        for (const [H, be] of R.entries()) {
          let me;
          switch (be.kind) {
            case Gt.Text:
            case Gt.Number:
              me = be.displayData;
              break;
            case Gt.Uri:
            case Gt.Markdown:
              me = be.data;
              break;
            case Gt.Boolean:
              me = typeof be.data == "boolean" ? be.data.toString() : void 0;
              break;
            case Gt.Image:
            case Gt.Bubble:
              me = be.data.join("🐳");
              break;
            case Gt.Custom:
              me = be.copyData;
              break;
          }
          me !== void 0 && G.test(me) && (pe.push([H, A + P]), ie = !0);
        }
      const re = performance.now();
      ie && k([...pe]), ye += ce.length, Fa(ye <= n);
      const Te = _.current?.selectedIndex ?? -1;
      x({
        results: pe.length,
        rowsSearched: ye,
        selectedIndex: Te
      }), c?.(pe, Te), P + he >= n ? P = 0 : P += he;
      const V = re - F, Pe = Math.max(V, 1), z = Mse / Pe;
      he = Math.ceil(he * z), ye < n && pe.length < 1e3 && (w.current = window.requestAnimationFrame($));
    };
    B(), w.current = window.requestAnimationFrame($);
  }, [B, a.length, u, c, n]), O = D.useCallback(() => {
    p?.(), x(void 0), k([]), c?.([], -1), B(), t?.current?.focus();
  }, [B, t, p, c]), I = D.useCallback((X) => {
    b(X.target.value), o === void 0 && (X.target.value === "" ? (x(void 0), k([]), B()) : N(X.target.value));
  }, [N, B, b, o]);
  D.useEffect(() => {
    d && s.current !== null && (b(""), s.current.focus({ preventScroll: !0 }));
  }, [d, s, b]);
  const q = D.useCallback((X) => {
    if (X?.stopPropagation?.(), v === void 0)
      return;
    const G = (v.selectedIndex + 1) % v.results;
    x({
      ...v,
      selectedIndex: G
    }), c?.(S, G);
  }, [v, c, S]), ae = D.useCallback((X) => {
    if (X?.stopPropagation?.(), v === void 0)
      return;
    let G = (v.selectedIndex - 1) % v.results;
    G < 0 && (G += v.results), x({
      ...v,
      selectedIndex: G
    }), c?.(S, G);
  }, [c, S, v]), Q = D.useCallback((X) => {
    (X.ctrlKey || X.metaKey) && X.nativeEvent.code === "KeyF" || X.key === "Escape" ? (O(), X.stopPropagation(), X.preventDefault()) : X.key === "Enter" && (X.shiftKey ? ae() : q());
  }, [O, q, ae]);
  D.useEffect(() => () => {
    B();
  }, [B]);
  const [ne, le] = D.useState(!1);
  D.useEffect(() => {
    if (d)
      le(!0);
    else {
      const X = setTimeout(() => le(!1), 150);
      return () => clearTimeout(X);
    }
  }, [d]);
  const W = D.useMemo(() => {
    if (!d && !ne)
      return null;
    let X;
    v !== void 0 && (X = v.results >= 1e3 ? "over 1000" : `${v.results} result${v.results !== 1 ? "s" : ""}`, v.selectedIndex >= 0 && (X = `${v.selectedIndex + 1} of ${X}`));
    const G = (ye) => {
      ye.stopPropagation();
    }, he = {
      width: `${Math.floor((v?.rowsSearched ?? 0) / n * 100)}%`
    };
    return D.createElement(
      Dse,
      { className: d ? "" : "out", onMouseDown: G, onMouseMove: G, onMouseUp: G, onClick: G },
      D.createElement(
        "div",
        { className: "gdg-search-bar-inner" },
        D.createElement("input", { id: f, "aria-hidden": !d, "data-testid": "search-input", ref: s, onChange: I, value: y, tabIndex: d ? void 0 : -1, onKeyDownCapture: Q }),
        D.createElement("button", { "aria-label": "Previous Result", "aria-hidden": !d, tabIndex: d ? void 0 : -1, onClick: ae, disabled: (v?.results ?? 0) === 0 }, Ose),
        D.createElement("button", { "aria-label": "Next Result", "aria-hidden": !d, tabIndex: d ? void 0 : -1, onClick: q, disabled: (v?.results ?? 0) === 0 }, Pse),
        p !== void 0 && D.createElement("button", { "aria-label": "Close Search", "aria-hidden": !d, "data-testid": "search-close-button", tabIndex: d ? void 0 : -1, onClick: O }, Lse)
      ),
      v !== void 0 ? D.createElement(
        D.Fragment,
        null,
        D.createElement(
          "div",
          { className: "gdg-search-status" },
          D.createElement("div", { "data-testid": "search-result-area" }, X)
        ),
        D.createElement("div", { className: "gdg-search-progress", style: he })
      ) : D.createElement(
        "div",
        { className: "gdg-search-status" },
        D.createElement("label", { htmlFor: f }, "Type to search")
      )
    );
  }, [
    d,
    ne,
    v,
    n,
    f,
    s,
    I,
    y,
    Q,
    ae,
    q,
    p,
    O
  ]);
  return D.createElement(
    D.Fragment,
    null,
    D.createElement(Nse, { prelightCells: S, accessibilityHeight: e.accessibilityHeight, canvasRef: e.canvasRef, cellXOffset: e.cellXOffset, cellYOffset: e.cellYOffset, className: e.className, clientSize: e.clientSize, columns: e.columns, disabledRows: e.disabledRows, enableGroups: e.enableGroups, fillHandle: e.fillHandle, firstColAccessible: e.firstColAccessible, nonGrowWidth: e.nonGrowWidth, fixedShadowX: e.fixedShadowX, fixedShadowY: e.fixedShadowY, freezeColumns: e.freezeColumns, getCellContent: e.getCellContent, getCellRenderer: e.getCellRenderer, getGroupDetails: e.getGroupDetails, getRowThemeOverride: e.getRowThemeOverride, groupHeaderHeight: e.groupHeaderHeight, headerHeight: e.headerHeight, highlightRegions: e.highlightRegions, imageWindowLoader: e.imageWindowLoader, initialSize: e.initialSize, isFilling: e.isFilling, isFocused: e.isFocused, lockColumns: e.lockColumns, maxColumnWidth: e.maxColumnWidth, minColumnWidth: e.minColumnWidth, onHeaderMenuClick: e.onHeaderMenuClick, onMouseMove: e.onMouseMove, onVisibleRegionChanged: e.onVisibleRegionChanged, overscrollX: e.overscrollX, overscrollY: e.overscrollY, preventDiagonalScrolling: e.preventDiagonalScrolling, rightElement: e.rightElement, rightElementProps: e.rightElementProps, rowHeight: e.rowHeight, rows: e.rows, scrollRef: e.scrollRef, selection: e.selection, theme: e.theme, freezeTrailingRows: e.freezeTrailingRows, hasAppendRow: e.hasAppendRow, translateX: e.translateX, translateY: e.translateY, verticalBorder: e.verticalBorder, onColumnProposeMove: e.onColumnProposeMove, drawFocusRing: e.drawFocusRing, drawCell: e.drawCell, drawHeader: e.drawHeader, experimental: e.experimental, gridRef: e.gridRef, headerIcons: e.headerIcons, isDraggable: e.isDraggable, onCanvasBlur: e.onCanvasBlur, onCanvasFocused: e.onCanvasFocused, onCellFocused: e.onCellFocused, onColumnMoved: e.onColumnMoved, onColumnResize: e.onColumnResize, onColumnResizeEnd: e.onColumnResizeEnd, onColumnResizeStart: e.onColumnResizeStart, onContextMenu: e.onContextMenu, onDragEnd: e.onDragEnd, onDragLeave: e.onDragLeave, onDragOverCell: e.onDragOverCell, onDragStart: e.onDragStart, onDrop: e.onDrop, onItemHovered: e.onItemHovered, onKeyDown: e.onKeyDown, onKeyUp: e.onKeyUp, onMouseDown: e.onMouseDown, onMouseUp: e.onMouseUp, onRowMoved: e.onRowMoved, smoothScrollX: e.smoothScrollX, smoothScrollY: e.smoothScrollY }),
    W
  );
};
class $se extends D.PureComponent {
  wrapperRef = D.createRef();
  componentDidMount() {
    document.addEventListener("touchend", this.clickOutside, !0), document.addEventListener("mousedown", this.clickOutside, !0), document.addEventListener("contextmenu", this.clickOutside, !0);
  }
  componentWillUnmount() {
    document.removeEventListener("touchend", this.clickOutside, !0), document.removeEventListener("mousedown", this.clickOutside, !0), document.removeEventListener("contextmenu", this.clickOutside, !0);
  }
  clickOutside = (t) => {
    if (!(this.props.isOutsideClick && !this.props.isOutsideClick(t)) && this.wrapperRef.current !== null && !this.wrapperRef.current.contains(t.target)) {
      let r = t.target;
      for (; r !== null; ) {
        if (r.classList.contains("click-outside-ignore"))
          return;
        r = r.parentElement;
      }
      this.props.onClickOutside();
    }
  };
  render() {
    const { onClickOutside: t, isOutsideClick: r, ...n } = this.props;
    return D.createElement("div", { ...n, ref: this.wrapperRef }, this.props.children);
  }
}
const Bse = () => (e) => Math.max(16, e.targetHeight - 10), Use = /* @__PURE__ */ Ga("input")({
  name: "RenameInput",
  class: "gdg-r17m35ur",
  propsAsIs: !1,
  vars: {
    "r17m35ur-0": [Bse(), "px"]
  }
}), zse = (e) => {
  const {
    bounds: t,
    group: r,
    onClose: n,
    canvasBounds: a,
    onFinish: s
  } = e, [i, o] = kt.useState(r);
  return kt.createElement($se, {
    style: {
      position: "absolute",
      left: t.x - a.left + 1,
      top: t.y - a.top,
      width: t.width - 2,
      height: t.height
    },
    className: "gdg-c1tqibwd",
    onClickOutside: n
  }, kt.createElement(Use, {
    targetHeight: t.height,
    "data-testid": "group-rename-input",
    value: i,
    onBlur: n,
    onFocus: (l) => l.target.setSelectionRange(0, i.length),
    onChange: (l) => o(l.target.value),
    onKeyDown: (l) => {
      l.key === "Enter" ? s(i) : l.key === "Escape" && n();
    },
    autoFocus: !0
  }));
};
function qse(e, t) {
  return e === void 0 ? !1 : e.length > 1 && e.startsWith("_") ? Number.parseInt(e.slice(1)) === t.keyCode : e.length === 1 && e >= "a" && e <= "z" ? e.toUpperCase().codePointAt(0) === t.keyCode : e === t.key;
}
function Zr(e, t, r) {
  const n = jz(e, t);
  return n && (r.didMatch = !0), n;
}
function jz(e, t) {
  if (e.length === 0)
    return !1;
  if (e.includes("|")) {
    const l = e.split("|");
    for (const u of l)
      if (jz(u, t))
        return !0;
    return !1;
  }
  let r = !1, n = !1, a = !1, s = !1;
  const i = e.split("+"), o = i.pop();
  if (!qse(o, t))
    return !1;
  if (i[0] === "any")
    return !0;
  for (const l of i)
    switch (l) {
      case "ctrl":
        r = !0;
        break;
      case "shift":
        n = !0;
        break;
      case "alt":
        a = !0;
        break;
      case "meta":
        s = !0;
        break;
      case "primary":
        Og.value ? s = !0 : r = !0;
        break;
    }
  return t.altKey === a && t.ctrlKey === r && t.shiftKey === n && t.metaKey === s;
}
function jse(e, t, r, n, a, s) {
  const i = kt.useCallback((u, c, d, p) => {
    (s === "cell" || s === "multi-cell") && u !== void 0 && (u = {
      ...u,
      range: {
        x: u.cell[0],
        y: u.cell[1],
        width: 1,
        height: 1
      }
    });
    const f = r === "mixed" && (d || p === "drag"), h = n === "mixed" && f, m = a === "mixed" && f;
    let y = {
      current: u === void 0 ? void 0 : {
        ...u,
        rangeStack: p === "drag" ? e.current?.rangeStack ?? [] : []
      },
      columns: h ? e.columns : fn.empty(),
      rows: m ? e.rows : fn.empty()
    };
    d && (s === "multi-rect" || s === "multi-cell") && y.current !== void 0 && e.current !== void 0 && (y = {
      ...y,
      current: {
        ...y.current,
        rangeStack: [...e.current.rangeStack, e.current.range]
      }
    }), t(y, c);
  }, [n, e, r, s, a, t]), o = kt.useCallback((u, c, d) => {
    u = u ?? e.rows, c !== void 0 && (u = u.add(c));
    let p;
    if (a === "exclusive" && u.length > 0)
      p = {
        current: void 0,
        columns: fn.empty(),
        rows: u
      };
    else {
      const f = d && r === "mixed", h = d && n === "mixed";
      p = {
        current: f ? e.current : void 0,
        columns: h ? e.columns : fn.empty(),
        rows: u
      };
    }
    t(p, !1);
  }, [n, e, r, a, t]), l = kt.useCallback((u, c, d) => {
    u = u ?? e.columns, c !== void 0 && (u = u.add(c));
    let p;
    if (n === "exclusive" && u.length > 0)
      p = {
        current: void 0,
        rows: fn.empty(),
        columns: u
      };
    else {
      const f = d && r === "mixed", h = d && a === "mixed";
      p = {
        current: f ? e.current : void 0,
        rows: h ? e.rows : fn.empty(),
        columns: u
      };
    }
    t(p, !1);
  }, [n, e, r, a, t]);
  return [i, o, l];
}
function Hse(e, t, r, n, a) {
  const s = D.useCallback((u) => {
    if (e === !0) {
      const c = [];
      for (let d = u.y; d < u.y + u.height; d++) {
        const p = [];
        for (let f = u.x; f < u.x + u.width; f++)
          f < 0 || d >= a ? p.push({
            kind: Gt.Loading,
            allowOverlay: !1
          }) : p.push(t([f, d]));
        c.push(p);
      }
      return c;
    }
    return e?.(u, n.signal) ?? [];
  }, [n.signal, t, e, a]), i = e !== void 0 ? s : void 0, o = D.useCallback((u) => {
    if (i === void 0)
      return [];
    const c = {
      ...u,
      x: u.x - r
    };
    if (c.x < 0) {
      c.x = 0, c.width--;
      const d = i(c, n.signal);
      return typeof d == "function" ? async () => (
        // eslint-disable-next-line unicorn/no-await-expression-member
        (await d()).map((p) => [
          { kind: Gt.Loading, allowOverlay: !1 },
          ...p
        ])
      ) : d.map((p) => [{ kind: Gt.Loading, allowOverlay: !1 }, ...p]);
    }
    return i(c, n.signal);
  }, [n.signal, i, r]);
  return [e !== void 0 ? o : void 0, i];
}
function Vse(e) {
  if (e.copyData !== void 0)
    return {
      formatted: e.copyData,
      rawValue: e.copyData,
      format: "string"
    };
  switch (e.kind) {
    case Gt.Boolean:
      return {
        formatted: e.data === !0 ? "TRUE" : e.data === !1 ? "FALSE" : e.data === TI ? "INDETERMINATE" : "",
        rawValue: e.data,
        format: "boolean"
      };
    case Gt.Custom:
      return {
        formatted: e.copyData,
        rawValue: e.copyData,
        format: "string"
      };
    case Gt.Image:
    case Gt.Bubble:
      return {
        formatted: e.data,
        rawValue: e.data,
        format: "string-array"
      };
    case Gt.Drilldown:
      return {
        formatted: e.data.map((t) => t.text),
        rawValue: e.data.map((t) => t.text),
        format: "string-array"
      };
    case Gt.Text:
      return {
        formatted: e.displayData ?? e.data,
        rawValue: e.data,
        format: "string"
      };
    case Gt.Uri:
      return {
        formatted: e.displayData ?? e.data,
        rawValue: e.data,
        format: "url"
      };
    case Gt.Markdown:
    case Gt.RowID:
      return {
        formatted: e.data,
        rawValue: e.data,
        format: "string"
      };
    case Gt.Number:
      return {
        formatted: e.displayData,
        rawValue: e.data,
        format: "number"
      };
    case Gt.Loading:
      return {
        formatted: "#LOADING",
        rawValue: "",
        format: "string"
      };
    case Gt.Protected:
      return {
        formatted: "************",
        rawValue: "",
        format: "string"
      };
    default:
      vp();
  }
}
function Gse(e, t) {
  return e.map((n, a) => {
    const s = t[a];
    return n.map((i) => i.span !== void 0 && i.span[0] !== s ? {
      formatted: "",
      rawValue: "",
      format: "string"
    } : Vse(i));
  });
}
function EP(e, t) {
  return (t ? /[\t\n",]/ : /[\t\n"]/).test(e) && (e = `"${e.replace(/"/g, '""')}"`), e;
}
function Wse(e) {
  const t = [];
  for (const r of e) {
    const n = [];
    for (const a of r)
      a.format === "url" ? n.push(a.rawValue?.toString() ?? "") : a.format === "string-array" ? n.push(a.formatted.map((s) => EP(s, !0)).join(",")) : n.push(EP(a.formatted, !1));
    t.push(n.join("	"));
  }
  return t.join(`
`);
}
function r1(e) {
  return e.replace(/\t/g, "    ").replace(/ {2,}/g, (t) => "<span> </span>".repeat(t.length));
}
function SP(e) {
  return '"' + e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + '"';
}
function Kse(e) {
  return e.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
}
function Yse(e) {
  const t = [];
  t.push('<style type="text/css"><!--br {mso-data-placement:same-cell;}--></style>', "<table><tbody>");
  for (const r of e) {
    t.push("<tr>");
    for (const n of r) {
      const a = `gdg-format="${n.format}"`;
      n.format === "url" ? t.push(`<td ${a}><a href="${n.rawValue}">${r1(n.formatted)}</a></td>`) : n.format === "string-array" ? t.push(`<td ${a}><ol>${n.formatted.map((s, i) => `<li gdg-raw-value=${SP(n.rawValue[i])}>` + r1(s) + "</li>").join("")}</ol></td>`) : t.push(`<td gdg-raw-value=${SP(n.rawValue?.toString() ?? "")} ${a}>${r1(n.formatted)}</td>`);
    }
    t.push("</tr>");
  }
  return t.push("</tbody></table>"), t.join("");
}
function Xse(e, t) {
  const r = Gse(e, t), n = Wse(r), a = Yse(r);
  return {
    textPlain: n,
    textHtml: a
  };
}
function _P(e) {
  const t = document.createElement("html");
  t.innerHTML = e.replace(/&nbsp;/g, " ");
  const r = t.querySelector("table");
  if (r === null)
    return;
  const n = [r], a = [];
  let s;
  for (; n.length > 0; ) {
    const i = n.pop();
    if (i === void 0)
      break;
    if (i instanceof HTMLTableElement || i.nodeName === "TBODY")
      n.push(...[...i.children].reverse());
    else if (i instanceof HTMLTableRowElement)
      s !== void 0 && a.push(s), s = [], n.push(...[...i.children].reverse());
    else if (i instanceof HTMLTableCellElement) {
      const o = i.cloneNode(!0), u = o.children.length === 1 && o.children[0].nodeName === "P" ? o.children[0] : null, c = u?.children.length === 1 && u.children[0].nodeName === "FONT", d = o.querySelectorAll("br");
      for (const h of d)
        h.replaceWith(`
`);
      const p = o.getAttribute("gdg-raw-value"), f = o.getAttribute("gdg-format") ?? "string";
      if (o.querySelector("a") !== null)
        s?.push({
          // raw value is the href
          rawValue: o.querySelector("a")?.getAttribute("href") ?? "",
          formatted: o.textContent ?? "",
          format: f
        });
      else if (o.querySelector("ol") !== null) {
        const h = o.querySelectorAll("li");
        s?.push({
          rawValue: [...h].map((m) => m.getAttribute("gdg-raw-value") ?? ""),
          formatted: [...h].map((m) => m.textContent ?? ""),
          format: "string-array"
        });
      } else if (p !== null)
        s?.push({
          rawValue: Kse(p),
          formatted: o.textContent ?? "",
          format: f
        });
      else {
        let h = o.textContent ?? "";
        c && (h = h.replace(/\n(?!\n)/g, "")), s?.push({
          rawValue: h ?? "",
          formatted: h ?? "",
          format: f
        });
      }
    }
  }
  return s !== void 0 && a.push(s), a;
}
function Zse(e, t, r, n, a) {
  const s = e;
  if (n === "allowPartial" || e.current === void 0 || t === void 0)
    return e;
  let i = !1;
  do {
    if (e?.current === void 0)
      break;
    const o = e.current?.range, l = [];
    if (o.width > 2) {
      const d = t({
        x: o.x,
        y: o.y,
        width: 1,
        height: o.height
      }, a.signal);
      if (typeof d == "function")
        return s;
      l.push(...d);
      const p = t({
        x: o.x + o.width - 1,
        y: o.y,
        width: 1,
        height: o.height
      }, a.signal);
      if (typeof p == "function")
        return s;
      l.push(...p);
    } else {
      const d = t({
        x: o.x,
        y: o.y,
        width: o.width,
        height: o.height
      }, a.signal);
      if (typeof d == "function")
        return s;
      l.push(...d);
    }
    let u = o.x - r, c = o.x + o.width - 1 - r;
    for (const d of l)
      for (const p of d)
        p.span !== void 0 && (u = Math.min(p.span[0], u), c = Math.max(p.span[1], c));
    u === o.x - r && c === o.x + o.width - 1 - r ? i = !0 : e = {
      current: {
        cell: e.current.cell ?? [0, 0],
        range: {
          x: u + r,
          y: o.y,
          width: c - u + 1,
          height: o.height
        },
        rangeStack: e.current.rangeStack
      },
      columns: e.columns,
      rows: e.rows
    };
  } while (!i);
  return e;
}
function kP(e) {
  return e.startsWith('"') && e.endsWith('"') && (e = e.slice(1, -1).replace(/""/g, '"')), e;
}
function Jse(e) {
  let t;
  (function(o) {
    o[o.None = 0] = "None", o[o.inString = 1] = "inString", o[o.inStringPostQuote = 2] = "inStringPostQuote";
  })(t || (t = {}));
  const r = [];
  let n = [], a = 0, s = t.None;
  e = e.replace(/\r\n/g, `
`);
  let i = 0;
  for (const o of e) {
    switch (s) {
      case t.None:
        o === "	" || o === `
` ? (n.push(e.slice(a, i)), a = i + 1, o === `
` && (r.push(n), n = [])) : o === '"' && (s = t.inString);
        break;
      case t.inString:
        o === '"' && (s = t.inStringPostQuote);
        break;
      case t.inStringPostQuote:
        o === '"' ? s = t.inString : ((o === "	" || o === `
`) && (n.push(kP(e.slice(a, i))), a = i + 1, o === `
` && (r.push(n), n = [])), s = t.None);
        break;
    }
    i++;
  }
  return a < e.length && n.push(kP(e.slice(a, e.length))), r.push(n), r.map((o) => o.map((l) => ({ rawValue: l, formatted: l, format: "string" })));
}
function CP(e, t, r) {
  const n = Xse(e, t), a = (o) => {
    window.navigator.clipboard?.writeText(o);
  }, s = (o, l) => window.navigator.clipboard?.write === void 0 ? !1 : (window.navigator.clipboard.write([
    new ClipboardItem({
      // eslint-disable-next-line sonarjs/no-duplicate-string
      "text/plain": new Blob([o], { type: "text/plain" }),
      "text/html": new Blob([l], {
        type: "text/html"
      })
    })
  ]), !0), i = (o, l) => {
    try {
      if (r === void 0 || r.clipboardData === null)
        throw new Error("No clipboard data");
      r?.clipboardData?.setData("text/plain", o), r?.clipboardData?.setData("text/html", l);
    } catch {
      s(o, l) || a(o);
    }
  };
  window.navigator.clipboard?.write !== void 0 || r?.clipboardData !== void 0 ? i(n.textPlain, n.textHtml) : a(n.textPlain), r?.preventDefault();
}
function Hz(e) {
  return e !== !0;
}
function AP(e) {
  return typeof e == "string" ? e : `${e}px`;
}
const Qse = () => (e) => e.innerWidth, eoe = () => (e) => e.innerHeight, toe = /* @__PURE__ */ Ga("div")({
  name: "Wrapper",
  class: "gdg-wmyidgi",
  propsAsIs: !1,
  vars: {
    "wmyidgi-0": [Qse()],
    "wmyidgi-1": [eoe()]
  }
}), roe = (e) => {
  const {
    inWidth: t,
    inHeight: r,
    children: n,
    ...a
  } = e;
  return D.createElement(toe, {
    innerHeight: AP(r),
    innerWidth: AP(t),
    ...a
  }, n);
}, noe = 2, ioe = 1300;
function aoe(e, t, r) {
  const n = kt.useRef(0), [a, s] = e ?? [0, 0];
  kt.useEffect(() => {
    if (a === 0 && s === 0) {
      n.current = 0;
      return;
    }
    let i = !1, o = 0;
    const l = (u) => {
      if (!i) {
        if (o === 0)
          o = u;
        else {
          const c = u - o;
          n.current = Math.min(1, n.current + c / ioe);
          const d = n.current ** 1.618 * c * noe;
          t.current?.scrollBy(a * d, s * d), o = u, r?.();
        }
        window.requestAnimationFrame(l);
      }
    };
    return window.requestAnimationFrame(l), () => {
      i = !0;
    };
  }, [t, a, s, r]);
}
function soe({ rowHeight: e, headerHeight: t, groupHeaderHeight: r, theme: n, overscrollX: a, overscrollY: s, scaleToRem: i, remSize: o }) {
  const [l, u, c, d, p, f] = kt.useMemo(() => {
    if (!i || o === 16)
      return [e, t, r, n, a, s];
    const h = o / 16, m = e, y = yz();
    return [
      typeof m == "number" ? m * h : (b) => Math.ceil(m(b) * h),
      Math.ceil(t * h),
      Math.ceil(r * h),
      {
        ...n,
        headerIconSize: (n?.headerIconSize ?? y.headerIconSize) * h,
        cellHorizontalPadding: (n?.cellHorizontalPadding ?? y.cellHorizontalPadding) * h,
        cellVerticalPadding: (n?.cellVerticalPadding ?? y.cellVerticalPadding) * h
      },
      Math.ceil((a ?? 0) * h),
      Math.ceil((s ?? 0) * h)
    ];
  }, [r, t, a, s, o, e, i, n]);
  return { rowHeight: l, headerHeight: u, groupHeaderHeight: c, theme: d, overscrollX: p, overscrollY: f };
}
const ml = {
  downFill: !1,
  rightFill: !1,
  clear: !0,
  closeOverlay: !0,
  acceptOverlayDown: !0,
  acceptOverlayUp: !0,
  acceptOverlayLeft: !0,
  acceptOverlayRight: !0,
  copy: !0,
  paste: !0,
  cut: !0,
  search: !1,
  delete: !0,
  activateCell: !0,
  scrollToSelectedCell: !0,
  goToFirstCell: !0,
  goToFirstColumn: !0,
  goToFirstRow: !0,
  goToLastCell: !0,
  goToLastColumn: !0,
  goToLastRow: !0,
  goToNextPage: !0,
  goToPreviousPage: !0,
  selectToFirstCell: !0,
  selectToFirstColumn: !0,
  selectToFirstRow: !0,
  selectToLastCell: !0,
  selectToLastColumn: !0,
  selectToLastRow: !0,
  selectAll: !0,
  selectRow: !0,
  selectColumn: !0,
  goUpCell: !0,
  goRightCell: !0,
  goDownCell: !0,
  goLeftCell: !0,
  goUpCellRetainSelection: !0,
  goRightCellRetainSelection: !0,
  goDownCellRetainSelection: !0,
  goLeftCellRetainSelection: !0,
  selectGrowUp: !0,
  selectGrowRight: !0,
  selectGrowDown: !0,
  selectGrowLeft: !0
};
function Jr(e, t) {
  return e === !0 ? t : e === !1 ? "" : e;
}
function TP(e) {
  const t = Og.value;
  return {
    activateCell: Jr(e.activateCell, " |Enter|shift+Enter"),
    clear: Jr(e.clear, "any+Escape"),
    closeOverlay: Jr(e.closeOverlay, "any+Escape"),
    acceptOverlayDown: Jr(e.acceptOverlayDown, "Enter"),
    acceptOverlayUp: Jr(e.acceptOverlayUp, "shift+Enter"),
    acceptOverlayLeft: Jr(e.acceptOverlayLeft, "shift+Tab"),
    acceptOverlayRight: Jr(e.acceptOverlayRight, "Tab"),
    copy: e.copy,
    cut: e.cut,
    delete: Jr(e.delete, t ? "Backspace|Delete" : "Delete"),
    downFill: Jr(e.downFill, "primary+_68"),
    scrollToSelectedCell: Jr(e.scrollToSelectedCell, "primary+Enter"),
    goDownCell: Jr(e.goDownCell, "ArrowDown"),
    goDownCellRetainSelection: Jr(e.goDownCellRetainSelection, "alt+ArrowDown"),
    goLeftCell: Jr(e.goLeftCell, "ArrowLeft|shift+Tab"),
    goLeftCellRetainSelection: Jr(e.goLeftCellRetainSelection, "alt+ArrowLeft"),
    goRightCell: Jr(e.goRightCell, "ArrowRight|Tab"),
    goRightCellRetainSelection: Jr(e.goRightCellRetainSelection, "alt+ArrowRight"),
    goUpCell: Jr(e.goUpCell, "ArrowUp"),
    goUpCellRetainSelection: Jr(e.goUpCellRetainSelection, "alt+ArrowUp"),
    goToFirstCell: Jr(e.goToFirstCell, "primary+Home"),
    goToFirstColumn: Jr(e.goToFirstColumn, "Home|primary+ArrowLeft"),
    goToFirstRow: Jr(e.goToFirstRow, "primary+ArrowUp"),
    goToLastCell: Jr(e.goToLastCell, "primary+End"),
    goToLastColumn: Jr(e.goToLastColumn, "End|primary+ArrowRight"),
    goToLastRow: Jr(e.goToLastRow, "primary+ArrowDown"),
    goToNextPage: Jr(e.goToNextPage, "PageDown"),
    goToPreviousPage: Jr(e.goToPreviousPage, "PageUp"),
    paste: e.paste,
    rightFill: Jr(e.rightFill, "primary+_82"),
    search: Jr(e.search, "primary+f"),
    selectAll: Jr(e.selectAll, "primary+a"),
    selectColumn: Jr(e.selectColumn, "ctrl+ "),
    selectGrowDown: Jr(e.selectGrowDown, "shift+ArrowDown"),
    selectGrowLeft: Jr(e.selectGrowLeft, "shift+ArrowLeft"),
    selectGrowRight: Jr(e.selectGrowRight, "shift+ArrowRight"),
    selectGrowUp: Jr(e.selectGrowUp, "shift+ArrowUp"),
    selectRow: Jr(e.selectRow, "shift+ "),
    selectToFirstCell: Jr(e.selectToFirstCell, "primary+shift+Home"),
    selectToFirstColumn: Jr(e.selectToFirstColumn, "primary+shift+ArrowLeft"),
    selectToFirstRow: Jr(e.selectToFirstRow, "primary+shift+ArrowUp"),
    selectToLastCell: Jr(e.selectToLastCell, "primary+shift+End"),
    selectToLastColumn: Jr(e.selectToLastColumn, "primary+shift+ArrowRight"),
    selectToLastRow: Jr(e.selectToLastRow, "primary+shift+ArrowDown")
  };
}
function ooe(e) {
  const t = Zre(e);
  return kt.useMemo(() => {
    if (t === void 0)
      return TP(ml);
    const r = {
      ...t,
      goToNextPage: t?.goToNextPage ?? t?.pageDown ?? ml.goToNextPage,
      goToPreviousPage: t?.goToPreviousPage ?? t?.pageUp ?? ml.goToPreviousPage,
      goToFirstCell: t?.goToFirstCell ?? t?.first ?? ml.goToFirstCell,
      goToLastCell: t?.goToLastCell ?? t?.last ?? ml.goToLastCell,
      selectToFirstCell: t?.selectToFirstCell ?? t?.first ?? ml.selectToFirstCell,
      selectToLastCell: t?.selectToLastCell ?? t?.last ?? ml.selectToLastCell
    };
    return TP({
      ...ml,
      ...r
    });
  }, [t]);
}
const loe = D.lazy(async () => await import("./data-grid-overlay-editor-C-SPnIU9.js"));
let uoe = 0;
function coe(e) {
  return cie(e3(e3(e).filter((t) => t.span !== void 0).map((t) => hu((t.span?.[0] ?? 0) + 1, (t.span?.[1] ?? 0) + 1))));
}
function nm(e, t) {
  return e === void 0 || t === 0 || e.columns.length === 0 && e.current === void 0 ? e : {
    current: e.current === void 0 ? void 0 : {
      cell: [e.current.cell[0] + t, e.current.cell[1]],
      range: {
        ...e.current.range,
        x: e.current.range.x + t
      },
      rangeStack: e.current.rangeStack.map((r) => ({
        ...r,
        x: r.x + t
      }))
    },
    rows: e.rows,
    columns: e.columns.offset(t)
  };
}
const n1 = {
  kind: Gt.Loading,
  allowOverlay: !1
}, im = {
  columns: fn.empty(),
  rows: fn.empty(),
  current: void 0
}, doe = (e, t) => {
  const [r, n] = D.useState(im), [a, s] = D.useState(), i = D.useRef(null), o = D.useRef(null), [l, u] = D.useState(), c = D.useRef(null), d = D.useRef(), p = typeof window > "u" ? null : window, { imageEditorOverride: f, getRowThemeOverride: h, markdownDivCreateNode: m, width: y, height: b, columns: v, rows: x, getCellContent: _, onCellClicked: E, onCellActivated: w, onFillPattern: C, onFinishedEditing: k, coercePasteValue: S, drawHeader: B, drawCell: U, editorBloom: N, onHeaderClicked: O, onColumnProposeMove: I, spanRangeBehavior: q = "default", onGroupHeaderClicked: ae, onCellContextMenu: Q, className: ne, onHeaderContextMenu: le, getCellsForSelection: W, onGroupHeaderContextMenu: X, onGroupHeaderRenamed: G, onCellEdited: P, onCellsEdited: he, onSearchResultsChanged: ye, searchResults: pe, onSearchValueChange: $, searchValue: F, onKeyDown: ge, onKeyUp: ce, keybindings: ie, editOnType: re = !0, onRowAppended: Te, onColumnMoved: V, validateCell: Pe, highlightRegions: z, rangeSelect: A = "rect", columnSelect: R = "multi", rowSelect: H = "multi", rangeSelectionBlending: be = "exclusive", columnSelectionBlending: me = "exclusive", rowSelectionBlending: Ce = "exclusive", onDelete: We, onDragStart: xe, onMouseMove: we, onPaste: te, copyHeaders: Fe = !1, freezeColumns: Y = 0, cellActivationBehavior: Je = "second-click", rowSelectionMode: xt = "auto", onHeaderMenuClick: Ze, getGroupDetails: rt, onSearchClose: Mt, onItemHovered: Qt, onSelectionCleared: kr, showSearch: tr, onVisibleRegionChanged: Oe, gridSelection: Ie, onGridSelectionChange: Me, minColumnWidth: je = 50, maxColumnWidth: tt = 500, maxColumnAutoWidth: Ct, provideEditor: Kt, trailingRowOptions: ct, freezeTrailingRows: ir = 0, allowedFillDirections: xr = "orthogonal", scrollOffsetX: Rr, scrollOffsetY: Nt, verticalBorder: dr, onDragOverCell: $e, onDrop: at, onColumnResize: Rt, onColumnResizeEnd: sr, onColumnResizeStart: bt, customRenderers: Ur, fillHandle: or, drawFocusRing: Ae = !0, experimental: Ve, fixedShadowX: Ge, fixedShadowY: lr, headerIcons: br, imageWindowLoader: Ut, initialSize: cn, isDraggable: Re, onDragLeave: J, onRowMoved: He, overscrollX: fr, overscrollY: Mr, preventDiagonalScrolling: ut, rightElement: qn, rightElementProps: En, trapFocus: yi = !1, smoothScrollX: Yi, smoothScrollY: Xi, scaleToRem: mn = !1, rowHeight: Ri = 34, headerHeight: Ht = 36, groupHeaderHeight: jt = Ht, theme: jn, isOutsideClick: Ii, renderers: ti } = e, Dn = typeof e.rowMarkers == "string" ? void 0 : e.rowMarkers, ue = Dn?.kind ?? e.rowMarkers ?? "none", Ue = Dn?.width ?? e.rowMarkerWidth, ze = Dn?.startIndex ?? e.rowMarkerStartIndex ?? 1, At = Dn?.theme ?? e.rowMarkerTheme, yt = Dn?.checkboxStyle ?? "square", wt = Math.max(je, 20), Se = Math.max(tt, wt), qe = Math.max(Ct ?? Se, wt), lt = D.useMemo(() => typeof window > "u" ? { fontSize: "16px" } : window.getComputedStyle(document.documentElement), []), St = D.useMemo(() => Number.parseFloat(lt.fontSize), [lt]), { rowHeight: Yt, headerHeight: Vr, groupHeaderHeight: gn, theme: On, overscrollX: bs, overscrollY: ys } = soe({
    groupHeaderHeight: jt,
    headerHeight: Ht,
    overscrollX: fr,
    overscrollY: Mr,
    remSize: St,
    rowHeight: Ri,
    scaleToRem: mn,
    theme: jn
  }), _i = ooe(ie), ri = Ue ?? (x > 1e4 ? 48 : x > 1e3 ? 44 : x > 100 ? 36 : 32), Ir = ue !== "none", dt = Ir ? 1 : 0, Sn = Te !== void 0, Mi = ct?.sticky === !0, [vs, Zi] = D.useState(!1), ws = tr ?? vs, pa = D.useCallback(() => {
    Mt !== void 0 ? Mt() : Zi(!1);
  }, [Mt]), T = D.useMemo(() => Ie === void 0 ? void 0 : nm(Ie, dt), [Ie, dt]) ?? r, ee = D.useRef();
  ee.current === void 0 && (ee.current = new AbortController()), D.useEffect(() => () => ee?.current.abort(), []);
  const [fe, j] = Hse(W, _, dt, ee.current, x), de = D.useCallback((Ee, Ye, Xe) => {
    if (Pe === void 0)
      return !0;
    const ht = [Ee[0] - dt, Ee[1]];
    return Pe?.(ht, Ye, Xe);
  }, [dt, Pe]), _e = D.useRef(Ie), Le = D.useCallback((Ee, Ye) => {
    Ye && (Ee = Zse(Ee, fe, dt, q, ee.current)), Me !== void 0 ? (_e.current = nm(Ee, -dt), Me(_e.current)) : n(Ee);
  }, [Me, fe, dt, q]), et = lc(Rt, D.useCallback((Ee, Ye, Xe, ht) => {
    Rt?.(v[Xe - dt], Ye, Xe - dt, ht);
  }, [Rt, dt, v])), vt = lc(sr, D.useCallback((Ee, Ye, Xe, ht) => {
    sr?.(v[Xe - dt], Ye, Xe - dt, ht);
  }, [sr, dt, v])), Wt = lc(bt, D.useCallback((Ee, Ye, Xe, ht) => {
    bt?.(v[Xe - dt], Ye, Xe - dt, ht);
  }, [bt, dt, v])), en = lc(B, D.useCallback((Ee, Ye) => B?.({ ...Ee, columnIndex: Ee.columnIndex - dt }, Ye) ?? !1, [B, dt])), pi = lc(U, D.useCallback((Ee, Ye) => U?.({ ...Ee, col: Ee.col - dt }, Ye) ?? !1, [U, dt])), it = D.useCallback((Ee) => {
    if (We !== void 0) {
      const Ye = We(nm(Ee, -dt));
      return typeof Ye == "boolean" ? Ye : nm(Ye, dt);
    }
    return !0;
  }, [We, dt]), [Tt, rr, Xt] = jse(T, Le, be, me, Ce, A), Dt = D.useMemo(() => Dl(yz(), On), [On]), [ur, Lr] = D.useState([0, 0, 0]), pr = D.useMemo(() => {
    if (ti === void 0)
      return {};
    const Ee = {};
    for (const Ye of ti)
      Ee[Ye.kind] = Ye;
    return Ee;
  }, [ti]), Sr = D.useCallback((Ee) => Ee.kind !== Gt.Custom ? pr[Ee.kind] : Ur?.find((Ye) => Ye.isMatch(Ee)), [Ur, pr]);
  let { sizedColumns: zr, nonGrowWidth: Yn } = Wne(v, x, j, ur[0] - (dt === 0 ? 0 : ri) - ur[2], wt, qe, Dt, Sr, ee.current);
  ue !== "none" && (Yn += ri);
  const Xn = D.useMemo(() => zr.some((Ee) => Ee.group !== void 0), [zr]), _n = Xn ? Vr + gn : Vr, nn = T.rows.length, Hn = ue === "none" ? void 0 : nn === 0 ? !1 : nn === x ? !0 : void 0, Hr = D.useMemo(() => ue === "none" ? zr : [
    {
      title: "",
      width: ri,
      icon: void 0,
      hasMenu: !1,
      style: "normal",
      themeOverride: At,
      rowMarker: yt,
      rowMarkerChecked: Hn
    },
    ...zr
  ], [ue, zr, ri, At, yt, Hn]), [Bn, wo] = D.useMemo(() => [
    Nt !== void 0 && typeof Yt == "number" ? Math.floor(Nt / Yt) : 0,
    Nt !== void 0 && typeof Yt == "number" ? -(Nt % Yt) : 0
  ], [Nt, Yt]), ni = D.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  }), xo = D.useMemo(() => ({
    x: ni.current.x,
    y: Bn,
    width: ni.current.width ?? 1,
    height: ni.current.height ?? 1,
    // tx: 'TODO',
    ty: wo
  }), [wo, Bn]), bn = D.useRef(!1), [li, Ji, Wa] = Xre(xo);
  ni.current = li;
  const Na = (li.height ?? 1) > 1;
  D.useLayoutEffect(() => {
    if (Nt !== void 0 && c.current !== null && Na) {
      if (c.current.scrollTop === Nt)
        return;
      c.current.scrollTop = Nt, c.current.scrollTop !== Nt && Wa(), bn.current = !0;
    }
  }, [Nt, Na, Wa]);
  const nl = (li.width ?? 1) > 1;
  D.useLayoutEffect(() => {
    if (Rr !== void 0 && c.current !== null && nl) {
      if (c.current.scrollLeft === Rr)
        return;
      c.current.scrollLeft = Rr, c.current.scrollLeft !== Rr && Wa(), bn.current = !0;
    }
  }, [Rr, nl, Wa]);
  const Hs = li.x + dt, Yu = li.y, Fi = D.useRef(null), ki = D.useCallback((Ee) => {
    Ee === !0 ? Fi.current?.focus() : window.requestAnimationFrame(() => {
      Fi.current?.focus();
    });
  }, []), vi = Sn ? x + 1 : x, ha = D.useCallback((Ee) => {
    const Ye = dt === 0 ? Ee : Ee.map((ht) => ({
      ...ht,
      location: [ht.location[0] - dt, ht.location[1]]
    })), Xe = he?.(Ye);
    if (Xe !== !0)
      for (const ht of Ye)
        P?.(ht.location, ht.value);
    return Xe;
  }, [P, he, dt]), [Vs, Xu] = D.useState(), Zu = T.current !== void 0 && T.current.range.width * T.current.range.height > 1 ? T.current.range : void 0, Fh = Ae ? T.current?.cell : void 0, Ju = Fh?.[0], Qu = Fh?.[1], Hy = D.useMemo(() => {
    if ((z === void 0 || z.length === 0) && (Zu ?? Ju ?? Qu ?? Vs) === void 0)
      return;
    const Ee = [];
    if (z !== void 0)
      for (const Ye of z) {
        const Xe = Hr.length - Ye.range.x - dt;
        Xe > 0 && Ee.push({
          color: Ye.color,
          range: {
            ...Ye.range,
            x: Ye.range.x + dt,
            width: Math.min(Xe, Ye.range.width)
          },
          style: Ye.style
        });
      }
    return Vs !== void 0 && Ee.push({
      color: ku(Dt.accentColor, 0),
      range: Vs,
      style: "dashed"
    }), Zu !== void 0 && Ee.push({
      color: ku(Dt.accentColor, 0.5),
      range: Zu,
      style: "solid-outline"
    }), Ju !== void 0 && Qu !== void 0 && Ee.push({
      color: Dt.accentColor,
      range: {
        x: Ju,
        y: Qu,
        width: 1,
        height: 1
      },
      style: "solid-outline"
    }), Ee.length > 0 ? Ee : void 0;
  }, [
    Vs,
    Zu,
    Ju,
    Qu,
    z,
    Hr.length,
    Dt.accentColor,
    dt
  ]), $h = D.useRef(Hr);
  $h.current = Hr;
  const Qi = D.useCallback(([Ee, Ye], Xe = !1) => {
    const ht = Sn && Ye === vi - 1;
    if (Ee === 0 && Ir)
      return ht ? n1 : {
        kind: as.Marker,
        allowOverlay: !1,
        checkboxStyle: yt,
        checked: T?.rows.hasIndex(Ye) === !0,
        markerKind: ue === "clickable-number" ? "number" : ue,
        row: ze + Ye,
        drawHandle: He !== void 0,
        cursor: ue === "clickable-number" ? "pointer" : void 0
      };
    if (ht) {
      const ot = Ee === dt ? ct?.hint ?? "" : "", pt = $h.current[Ee];
      if (pt?.trailingRowOptions?.disabled === !0)
        return n1;
      {
        const Ft = pt?.trailingRowOptions?.hint ?? ot, Zt = pt?.trailingRowOptions?.addIcon ?? ct?.addIcon;
        return {
          kind: as.NewRow,
          hint: Ft,
          allowOverlay: !1,
          icon: Zt
        };
      }
    } else {
      const _t = Ee - dt;
      if (Xe || Ve?.strict === !0) {
        const pt = ni.current, Ft = pt.x > _t || _t > pt.x + pt.width || pt.y > Ye || Ye > pt.y + pt.height || Ye >= tc.current, Zt = _t === pt.extras?.selected?.[0] && Ye === pt.extras?.selected[1];
        let mr = !1;
        if (pt.extras?.freezeRegions !== void 0) {
          for (const Vt of pt.extras.freezeRegions)
            if (Mb(Vt, _t, Ye)) {
              mr = !0;
              break;
            }
        }
        if (Ft && !Zt && !mr)
          return n1;
      }
      let ot = _([_t, Ye]);
      return dt !== 0 && ot.span !== void 0 && (ot = {
        ...ot,
        span: [ot.span[0] + dt, ot.span[1] + dt]
      }), ot;
    }
  }, [
    Sn,
    vi,
    Ir,
    yt,
    T?.rows,
    ue,
    ze,
    He,
    dt,
    ct?.hint,
    ct?.addIcon,
    Ve?.strict,
    _
  ]), qd = D.useCallback((Ee) => {
    let Ye = rt?.(Ee) ?? { name: Ee };
    return G !== void 0 && Ee !== "" && (Ye = {
      // FIXME: Mutate
      icon: Ye.icon,
      name: Ye.name,
      overrideTheme: Ye.overrideTheme,
      actions: [
        ...Ye.actions ?? [],
        {
          title: "Rename",
          icon: "renameIcon",
          onClick: (Xe) => jd({
            group: Ye.name,
            bounds: Xe.bounds
          })
        }
      ]
    }), Ye;
  }, [rt, G]), ec = D.useCallback((Ee) => {
    const [Ye, Xe] = Ee.cell, ht = Hr[Ye], mt = ht?.group !== void 0 ? qd(ht.group)?.overrideTheme : void 0, _t = ht?.themeOverride, ot = h?.(Xe);
    s({
      ...Ee,
      theme: Dl(Dt, mt, _t, ot, Ee.content.themeOverride)
    });
  }, [h, Hr, qd, Dt]), il = D.useCallback((Ee, Ye, Xe) => {
    if (T.current === void 0)
      return;
    const [ht, mt] = T.current.cell, _t = Qi([ht, mt]);
    if (_t.kind !== Gt.Boolean && _t.allowOverlay) {
      let ot = _t;
      if (Xe !== void 0)
        switch (ot.kind) {
          case Gt.Number: {
            const pt = Dte(() => Xe === "-" ? -0 : Number.parseFloat(Xe), 0);
            ot = {
              ...ot,
              data: Number.isNaN(pt) ? 0 : pt
            };
            break;
          }
          case Gt.Text:
          case Gt.Markdown:
          case Gt.Uri:
            ot = {
              ...ot,
              data: Xe
            };
            break;
        }
      ec({
        target: Ee,
        content: ot,
        initialValue: Xe,
        cell: [ht, mt],
        highlight: Xe === void 0,
        forceEditMode: Xe !== void 0
      });
    } else _t.kind === Gt.Boolean && Ye && _t.readonly !== !0 && (ha([
      {
        location: T.current.cell,
        value: {
          ..._t,
          data: Hz(_t.data)
        }
      }
    ]), Fi.current?.damage([{ cell: T.current.cell }]));
  }, [Qi, T, ha, ec]), Bh = D.useCallback((Ee, Ye) => {
    const Xe = Fi.current?.getBounds(Ee, Ye);
    if (Xe === void 0 || c.current === null)
      return;
    const ht = Qi([Ee, Ye]);
    ht.allowOverlay && ec({
      target: Xe,
      content: ht,
      initialValue: void 0,
      highlight: !0,
      cell: [Ee, Ye],
      forceEditMode: !0
    });
  }, [Qi, ec]), ii = D.useCallback((Ee, Ye, Xe = "both", ht = 0, mt = 0, _t = void 0) => {
    if (c.current !== null) {
      const ot = Fi.current, pt = o.current, Ft = typeof Ee != "number" ? Ee.unit === "cell" ? Ee.amount : void 0 : Ee, Zt = typeof Ye != "number" ? Ye.unit === "cell" ? Ye.amount : void 0 : Ye, mr = typeof Ee != "number" && Ee.unit === "px" ? Ee.amount : void 0, Vt = typeof Ye != "number" && Ye.unit === "px" ? Ye.amount : void 0;
      if (ot !== null && pt !== null) {
        let L = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, Z = 0, ve = 0;
        if ((Ft !== void 0 || Zt !== void 0) && (L = ot.getBounds((Ft ?? 0) + dt, Zt ?? 0) ?? L, L.width === 0 || L.height === 0))
          return;
        const oe = pt.getBoundingClientRect(), De = oe.width / pt.offsetWidth;
        if (mr !== void 0 && (L = {
          ...L,
          x: mr - oe.left - c.current.scrollLeft,
          width: 1
        }), Vt !== void 0 && (L = {
          ...L,
          y: Vt + oe.top - c.current.scrollTop,
          height: 1
        }), L !== void 0) {
          const Ne = {
            x: L.x - ht,
            y: L.y - mt,
            width: L.width + 2 * ht,
            height: L.height + 2 * mt
          };
          let Qe = 0;
          for (let sc = 0; sc < Y; sc++)
            Qe += zr[sc].width;
          let Ke = 0;
          const Jt = ir + (Mi ? 1 : 0);
          Jt > 0 && (Ke = Uu(vi, Jt, Yt));
          let gt = Qe * De + oe.left + dt * ri * De, yr = oe.right, Cr = oe.top + _n * De, Br = oe.bottom - Ke * De;
          const xi = L.width + ht * 2;
          switch (_t?.hAlign) {
            case "start":
              yr = gt + xi;
              break;
            case "end":
              gt = yr - xi;
              break;
            case "center":
              gt = Math.floor((gt + yr) / 2) - xi / 2, yr = gt + xi;
              break;
          }
          const Zn = L.height + mt * 2;
          switch (_t?.vAlign) {
            case "start":
              Br = Cr + Zn;
              break;
            case "end":
              Cr = Br - Zn;
              break;
            case "center":
              Cr = Math.floor((Cr + Br) / 2) - Zn / 2, Br = Cr + Zn;
              break;
          }
          gt > Ne.x ? Z = Ne.x - gt : yr < Ne.x + Ne.width && (Z = Ne.x + Ne.width - yr), Cr > Ne.y ? ve = Ne.y - Cr : Br < Ne.y + Ne.height && (ve = Ne.y + Ne.height - Br), Xe === "vertical" || typeof Ee == "number" && Ee < Y ? Z = 0 : (Xe === "horizontal" || typeof Ye == "number" && Ye >= vi - Jt) && (ve = 0), (Z !== 0 || ve !== 0) && (De !== 1 && (Z /= De, ve /= De), c.current.scrollTo(Z + c.current.scrollLeft, ve + c.current.scrollTop));
        }
      }
    }
  }, [
    dt,
    ir,
    ri,
    _n,
    Y,
    zr,
    vi,
    Mi,
    Yt
  ]), Uh = D.useRef(Bh), zh = D.useRef(_), tc = D.useRef(x);
  Uh.current = Bh, zh.current = _, tc.current = x;
  const al = D.useCallback(async (Ee, Ye = !0) => {
    if (Hr[Ee]?.trailingRowOptions?.disabled === !0)
      return;
    const ht = Te?.();
    let mt, _t = !0;
    ht !== void 0 && (mt = await ht, mt === "top" && (_t = !1), typeof mt == "number" && (_t = !1));
    let ot = 0;
    const pt = () => {
      if (tc.current <= x) {
        ot < 500 && window.setTimeout(pt, ot), ot = 50 + ot * 2;
        return;
      }
      const Ft = typeof mt == "number" ? mt : _t ? x : 0;
      fl.current(Ee - dt, Ft), Tt({
        cell: [Ee, Ft],
        range: {
          x: Ee,
          y: Ft,
          width: 1,
          height: 1
        }
      }, !1, !1, "edit");
      const Zt = zh.current([Ee - dt, Ft]);
      Zt.allowOverlay && Pf(Zt) && Zt.readonly !== !0 && Ye && window.setTimeout(() => {
        Uh.current(Ee, Ft);
      }, 0);
    };
    pt();
  }, [Hr, Te, dt, x, Tt]), nu = D.useCallback((Ee) => {
    const Ye = zr[Ee]?.trailingRowOptions?.targetColumn ?? ct?.targetColumn;
    if (typeof Ye == "number")
      return Ye + (Ir ? 1 : 0);
    if (typeof Ye == "object") {
      const Xe = v.indexOf(Ye);
      if (Xe >= 0)
        return Xe + (Ir ? 1 : 0);
    }
  }, [zr, v, Ir, ct?.targetColumn]), Gs = D.useRef(), sl = D.useRef(), M = D.useCallback((Ee, Ye) => {
    const [Xe, ht] = Ye;
    return Dl(Dt, Hr[Xe]?.themeOverride, h?.(ht), Ee.themeOverride);
  }, [h, Hr, Dt]), Lt = D.useCallback((Ee) => {
    const Ye = Og.value ? Ee.metaKey : Ee.ctrlKey, Xe = Ye && H === "multi", ht = Ye && R === "multi", [mt, _t] = Ee.location, ot = T.columns, pt = T.rows, [Ft, Zt] = T.current?.cell ?? [];
    if (Ee.kind === "cell") {
      if (sl.current = void 0, Ci.current = [mt, _t], mt === 0 && Ir) {
        if (Sn === !0 && _t === x || ue === "number" || H === "none")
          return;
        const mr = Qi(Ee.location);
        if (mr.kind !== as.Marker)
          return;
        if (He !== void 0) {
          const Z = Sr(mr);
          Fa(Z?.kind === as.Marker);
          const ve = Z?.onClick?.({
            ...Ee,
            cell: mr,
            posX: Ee.localEventX,
            posY: Ee.localEventY,
            bounds: Ee.bounds,
            theme: M(mr, Ee.location),
            preventDefault: () => {
            }
          });
          if (ve === void 0 || ve.checked === mr.checked)
            return;
        }
        s(void 0), ki();
        const Vt = pt.hasIndex(_t), L = Gs.current;
        if (H === "multi" && (Ee.shiftKey || Ee.isLongTouch === !0) && L !== void 0 && pt.hasIndex(L)) {
          const Z = [Math.min(L, _t), Math.max(L, _t) + 1];
          Xe || xt === "multi" ? rr(void 0, Z, !0) : rr(fn.fromSingleSelection(Z), void 0, Xe);
        } else Xe || Ee.isTouch || xt === "multi" ? Vt ? rr(pt.remove(_t), void 0, !0) : (rr(void 0, _t, !0), Gs.current = _t) : Vt && pt.length === 1 ? rr(fn.empty(), void 0, Ye) : (rr(fn.fromSingleSelection(_t), void 0, Ye), Gs.current = _t);
      } else if (mt >= dt && Sn && _t === x) {
        const mr = nu(mt);
        al(mr ?? mt);
      } else if (Ft !== mt || Zt !== _t) {
        const mr = Qi(Ee.location), Vt = Sr(mr);
        if (Vt?.onSelect !== void 0) {
          let ve = !1;
          if (Vt.onSelect({
            ...Ee,
            cell: mr,
            posX: Ee.localEventX,
            posY: Ee.localEventY,
            bounds: Ee.bounds,
            preventDefault: () => ve = !0,
            theme: M(mr, Ee.location)
          }), ve)
            return;
        }
        const L = Mi && _t === x, Z = Mi && T !== void 0 && T.current?.cell[1] === x;
        if ((Ee.shiftKey || Ee.isLongTouch === !0) && Ft !== void 0 && Zt !== void 0 && T.current !== void 0 && !Z) {
          if (L)
            return;
          const ve = Math.min(mt, Ft), oe = Math.max(mt, Ft), De = Math.min(_t, Zt), Ne = Math.max(_t, Zt);
          Tt({
            ...T.current,
            range: {
              x: ve,
              y: De,
              width: oe - ve + 1,
              height: Ne - De + 1
            }
          }, !0, Ye, "click"), Gs.current = void 0, ki();
        } else
          Tt({
            cell: [mt, _t],
            range: { x: mt, y: _t, width: 1, height: 1 }
          }, !0, Ye, "click"), Gs.current = void 0, s(void 0), ki();
      }
    } else if (Ee.kind === "header")
      if (Ci.current = [mt, _t], s(void 0), Ir && mt === 0)
        Gs.current = void 0, sl.current = void 0, H === "multi" && (pt.length !== x ? rr(fn.fromSingleSelection([0, x]), void 0, Ye) : rr(fn.empty(), void 0, Ye), ki());
      else {
        const mr = sl.current;
        if (R === "multi" && (Ee.shiftKey || Ee.isLongTouch === !0) && mr !== void 0 && ot.hasIndex(mr)) {
          const Vt = [Math.min(mr, mt), Math.max(mr, mt) + 1];
          ht ? Xt(void 0, Vt, Ye) : Xt(fn.fromSingleSelection(Vt), void 0, Ye);
        } else ht ? (ot.hasIndex(mt) ? Xt(ot.remove(mt), void 0, Ye) : Xt(void 0, mt, Ye), sl.current = mt) : R !== "none" && (Xt(fn.fromSingleSelection(mt), void 0, Ye), sl.current = mt);
        Gs.current = void 0, ki();
      }
    else Ee.kind === Ma ? Ci.current = [mt, _t] : Ee.kind === Pg && !Ee.isMaybeScrollbar && (Le(im, !1), s(void 0), ki(), kr?.(), Gs.current = void 0, sl.current = void 0);
  }, [
    al,
    R,
    ki,
    Sr,
    nu,
    Qi,
    T,
    Ir,
    Mi,
    kr,
    He,
    dt,
    ue,
    H,
    xt,
    x,
    Tt,
    Le,
    Xt,
    rr,
    Sn,
    M
  ]), Ws = D.useRef(!1), Ci = D.useRef(), rc = D.useRef(li), Be = D.useRef(), It = D.useCallback((Ee) => {
    if (Nr.current = !1, rc.current = ni.current, Ee.button !== 0 && Ee.button !== 1) {
      Be.current = void 0;
      return;
    }
    const Ye = performance.now();
    Be.current = {
      button: Ee.button,
      time: Ye,
      location: Ee.location
    }, Ee?.kind === "header" && (Ws.current = !0);
    const Xe = Ee.kind === "cell" && Ee.isFillHandle;
    !Xe && Ee.kind !== "cell" && Ee.isEdge || (u({
      previousSelection: T,
      fillHandle: Xe
    }), Ci.current = void 0, !Ee.isTouch && Ee.button === 0 && !Xe ? Lt(Ee) : !Ee.isTouch && Ee.button === 1 && (Ci.current = Ee.location));
  }, [T, Lt]), [ol, jd] = D.useState(), Hd = D.useCallback((Ee) => {
    if (Ee.kind !== Ma || R !== "multi")
      return;
    const Ye = Og.value ? Ee.metaKey : Ee.ctrlKey, [Xe] = Ee.location, ht = T.columns;
    if (Xe < dt)
      return;
    const mt = Hr[Xe];
    let _t = Xe, ot = Xe;
    for (let pt = Xe - 1; pt >= dt && xp(mt.group, Hr[pt].group); pt--)
      _t--;
    for (let pt = Xe + 1; pt < Hr.length && xp(mt.group, Hr[pt].group); pt++)
      ot++;
    if (ki(), Ye)
      if (ht.hasAll([_t, ot + 1])) {
        let pt = ht;
        for (let Ft = _t; Ft <= ot; Ft++)
          pt = pt.remove(Ft);
        Xt(pt, void 0, Ye);
      } else
        Xt(void 0, [_t, ot + 1], Ye);
    else
      Xt(fn.fromSingleSelection([_t, ot + 1]), void 0, Ye);
  }, [R, ki, T.columns, Hr, dt, Xt]), Nr = D.useRef(!1), Ks = D.useCallback(async (Ee) => {
    if (fe !== void 0 && et !== void 0) {
      const Ye = ni.current.y, Xe = ni.current.height;
      let ht = fe({
        x: Ee,
        y: Ye,
        width: 1,
        height: Math.min(Xe, x - Ye)
      }, ee.current.signal);
      typeof ht != "object" && (ht = await ht());
      const mt = zr[Ee - dt], ot = document.createElement("canvas").getContext("2d", { alpha: !1 });
      if (ot !== null) {
        ot.font = Dt.baseFontFull;
        const pt = vz(ot, Dt, mt, 0, ht, wt, Se, !1, Sr);
        et?.(mt, pt.width, Ee, pt.width);
      }
    }
  }, [
    zr,
    fe,
    Se,
    Dt,
    wt,
    et,
    dt,
    x,
    Sr
  ]), [Vy, Vd] = D.useState(), An = D.useCallback(async (Ee, Ye) => {
    const Xe = Ee.current?.range;
    if (Xe === void 0 || fe === void 0 || Ye.current === void 0)
      return;
    const ht = Ye.current.range;
    if (C !== void 0) {
      let pt = !1;
      if (C({
        fillDestination: { ...ht, x: ht.x - dt },
        patternSource: { ...Xe, x: Xe.x - dt },
        preventDefault: () => pt = !0
      }), pt)
        return;
    }
    let mt = fe(Xe, ee.current.signal);
    typeof mt != "object" && (mt = await mt());
    const _t = mt, ot = [];
    for (let pt = 0; pt < ht.width; pt++)
      for (let Ft = 0; Ft < ht.height; Ft++) {
        const Zt = [ht.x + pt, ht.y + Ft];
        if (uz(Zt, Xe))
          continue;
        const mr = _t[Ft % Xe.height][pt % Xe.width];
        Oc(mr) || !Pf(mr) || ot.push({
          location: Zt,
          value: { ...mr }
        });
      }
    ha(ot), Fi.current?.damage(ot.map((pt) => ({
      cell: pt.location
    })));
  }, [fe, ha, C, dt]), Gd = D.useCallback(() => {
    if (T.current === void 0 || T.current.range.width <= 1)
      return;
    const Ee = {
      ...T,
      current: {
        ...T.current,
        range: {
          ...T.current.range,
          width: 1
        }
      }
    };
    An(Ee, T);
  }, [An, T]), nc = D.useCallback(() => {
    if (T.current === void 0 || T.current.range.height <= 1)
      return;
    const Ee = {
      ...T,
      current: {
        ...T.current,
        range: {
          ...T.current.range,
          height: 1
        }
      }
    };
    An(Ee, T);
  }, [An, T]), Et = D.useCallback((Ee, Ye) => {
    const Xe = l;
    if (u(void 0), Xu(void 0), Vd(void 0), Ws.current = !1, Ye)
      return;
    if (Xe?.fillHandle === !0 && T.current !== void 0 && Xe.previousSelection?.current !== void 0) {
      if (Vs === void 0)
        return;
      const mr = {
        ...T,
        current: {
          ...T.current,
          range: Tz(Xe.previousSelection.current.range, Vs)
        }
      };
      An(Xe.previousSelection, mr), Le(mr, !0);
      return;
    }
    const [ht, mt] = Ee.location, [_t, ot] = Ci.current ?? [], pt = () => {
      Nr.current = !0;
    }, Ft = (mr) => {
      const Vt = mr.isTouch || _t === ht && ot === mt;
      if (Vt && E?.([ht - dt, mt], {
        ...mr,
        preventDefault: pt
      }), mr.button === 1)
        return !Nr.current;
      if (!Nr.current) {
        const L = Qi(Ee.location), Z = Sr(L);
        if (Z !== void 0 && Z.onClick !== void 0 && Vt) {
          const oe = Z.onClick({
            ...mr,
            cell: L,
            posX: mr.localEventX,
            posY: mr.localEventY,
            bounds: mr.bounds,
            theme: M(L, Ee.location),
            preventDefault: pt
          });
          oe !== void 0 && !Oc(oe) && Cc(oe) && (ha([{ location: mr.location, value: oe }]), Fi.current?.damage([
            {
              cell: mr.location
            }
          ]));
        }
        if (Nr.current || T.current === void 0)
          return !1;
        let ve = !1;
        switch (L.activationBehaviorOverride ?? Je) {
          case "double-click":
          case "second-click": {
            if (Xe?.previousSelection?.current?.cell === void 0)
              break;
            const [oe, De] = T.current.cell, [Ne, Qe] = Xe.previousSelection.current.cell;
            ve = ht === oe && ht === Ne && mt === De && mt === Qe && (mr.isDoubleClick === !0 || Je === "second-click");
            break;
          }
          case "single-click": {
            ve = !0;
            break;
          }
        }
        if (ve)
          return w?.([ht - dt, mt]), il(mr.bounds, !1), !0;
      }
      return !1;
    }, Zt = Ee.location[0] - dt;
    if (Ee.isTouch) {
      const mr = ni.current, Vt = rc.current;
      if (mr.x !== Vt.x || mr.y !== Vt.y)
        return;
      if (Ee.isLongTouch === !0) {
        if (Ee.kind === "cell" && Yf(T.current?.cell, Ee.location)) {
          Q?.([Zt, Ee.location[1]], {
            ...Ee,
            preventDefault: pt
          });
          return;
        } else if (Ee.kind === "header" && T.columns.hasIndex(ht)) {
          le?.(Zt, { ...Ee, preventDefault: pt });
          return;
        } else if (Ee.kind === Ma) {
          if (Zt < 0)
            return;
          X?.(Zt, { ...Ee, preventDefault: pt });
          return;
        }
      }
      Ee.kind === "cell" ? Ft(Ee) || Lt(Ee) : Ee.kind === Ma ? ae?.(Zt, { ...Ee, preventDefault: pt }) : (Ee.kind === El && O?.(Zt, {
        ...Ee,
        preventDefault: pt
      }), Lt(Ee));
      return;
    }
    if (Ee.kind === "header") {
      if (Zt < 0)
        return;
      Ee.isEdge ? Ee.isDoubleClick === !0 && Ks(ht) : Ee.button === 0 && ht === _t && mt === ot && O?.(Zt, { ...Ee, preventDefault: pt });
    }
    if (Ee.kind === Ma) {
      if (Zt < 0)
        return;
      Ee.button === 0 && ht === _t && mt === ot && (ae?.(Zt, { ...Ee, preventDefault: pt }), Nr.current || Hd(Ee));
    }
    Ee.kind === "cell" && (Ee.button === 0 || Ee.button === 1) && Ft(Ee), Ci.current = void 0;
  }, [
    l,
    T,
    dt,
    Vs,
    An,
    Le,
    E,
    Qi,
    Sr,
    Je,
    M,
    ha,
    w,
    il,
    Q,
    le,
    X,
    Lt,
    ae,
    O,
    Ks,
    Hd
  ]), Gy = D.useCallback((Ee) => {
    const Ye = {
      ...Ee,
      location: [Ee.location[0] - dt, Ee.location[1]]
    };
    we?.(Ye), l !== void 0 && Ee.buttons === 0 && (u(void 0), Xu(void 0), Vd(void 0), Ws.current = !1), Vd((Xe) => Ws.current ? [Ee.scrollEdge[0], 0] : Ee.scrollEdge[0] === Xe?.[0] && Ee.scrollEdge[1] === Xe[1] ? Xe : l === void 0 || (Be.current?.location[0] ?? 0) < dt ? void 0 : Ee.scrollEdge);
  }, [l, we, dt]), qh = D.useCallback((Ee, Ye) => {
    Ze?.(Ee - dt, Ye);
  }, [Ze, dt]), ll = T?.current?.cell, Ka = D.useCallback((Ee, Ye, Xe, ht, mt, _t) => {
    bn.current = !1;
    let ot = ll;
    ot !== void 0 && (ot = [ot[0] - dt, ot[1]]);
    const pt = Y === 0 ? void 0 : {
      x: 0,
      y: Ee.y,
      width: Y,
      height: Ee.height
    }, Ft = [];
    pt !== void 0 && Ft.push(pt), ir > 0 && (Ft.push({
      x: Ee.x - dt,
      y: x - ir,
      width: Ee.width,
      height: ir
    }), Y > 0 && Ft.push({
      x: 0,
      y: x - ir,
      width: Y,
      height: ir
    }));
    const Zt = {
      x: Ee.x - dt,
      y: Ee.y,
      width: Ee.width,
      height: Sn && Ee.y + Ee.height >= x ? Ee.height - 1 : Ee.height,
      tx: mt,
      ty: _t,
      extras: {
        selected: ot,
        freezeRegion: pt,
        freezeRegions: Ft
      }
    };
    ni.current = Zt, Ji(Zt), Lr([Ye, Xe, ht]), Oe?.(Zt, Zt.tx, Zt.ty, Zt.extras);
  }, [
    ll,
    dt,
    Sn,
    x,
    Y,
    ir,
    Ji,
    Oe
  ]), jh = lc(V, D.useCallback((Ee, Ye) => {
    V?.(Ee - dt, Ye - dt), R !== "none" && Xt(fn.fromSingleSelection(Ye), void 0, !0);
  }, [R, V, dt, Xt])), $i = D.useRef(!1), Hh = D.useCallback((Ee) => {
    if (Ee.location[0] === 0 && dt > 0) {
      Ee.preventDefault();
      return;
    }
    xe?.({
      ...Ee,
      location: [Ee.location[0] - dt, Ee.location[1]]
    }), Ee.defaultPrevented() || ($i.current = !0), u(void 0);
  }, [xe, dt]), hi = D.useCallback(() => {
    $i.current = !1;
  }, []), Wd = D.useRef(), ic = D.useCallback((Ee) => {
    if (!qz(Ee, Wd.current) && (Wd.current = Ee, !(Be?.current?.button !== void 0 && Be.current.button >= 1))) {
      if (Ee.buttons !== 0 && l !== void 0 && Be.current?.location[0] === 0 && Ee.location[0] === 0 && dt === 1 && H === "multi" && l.previousSelection && !l.previousSelection.rows.hasIndex(Be.current.location[1]) && T.rows.hasIndex(Be.current.location[1])) {
        const Ye = Math.min(Be.current.location[1], Ee.location[1]), Xe = Math.max(Be.current.location[1], Ee.location[1]) + 1;
        rr(fn.fromSingleSelection([Ye, Xe]), void 0, !1);
      }
      if (Ee.buttons !== 0 && l !== void 0 && T.current !== void 0 && !$i.current && !Ws.current && (A === "rect" || A === "multi-rect")) {
        const [Ye, Xe] = T.current.cell;
        let [ht, mt] = Ee.location;
        if (mt < 0 && (mt = ni.current.y), l.fillHandle === !0 && l.previousSelection?.current !== void 0) {
          const _t = l.previousSelection.current.range;
          mt = Math.min(mt, Sn ? x - 1 : x);
          const ot = Jie(_t, ht, mt, xr);
          Xu(ot);
        } else {
          if (Sn && Xe === x)
            return;
          if (Sn && mt === x)
            if (Ee.kind === Pg)
              mt--;
            else
              return;
          ht = Math.max(ht, dt);
          const pt = ht - Ye, Ft = mt - Xe, Zt = {
            x: pt >= 0 ? Ye : ht,
            y: Ft >= 0 ? Xe : mt,
            width: Math.abs(pt) + 1,
            height: Math.abs(Ft) + 1
          };
          Tt({
            ...T.current,
            range: Zt
          }, !0, !1, "drag");
        }
      }
      Qt?.({ ...Ee, location: [Ee.location[0] - dt, Ee.location[1]] });
    }
  }, [
    xr,
    l,
    dt,
    H,
    T,
    A,
    Qt,
    rr,
    Sn,
    x,
    Tt
  ]), Kd = D.useCallback(() => {
    const Ee = Wd.current;
    if (Ee === void 0)
      return;
    const [Ye, Xe] = Ee.scrollEdge;
    let [ht, mt] = Ee.location;
    const _t = ni.current;
    Ye === -1 ? ht = _t.extras?.freezeRegion?.x ?? _t.x : Ye === 1 && (ht = _t.x + _t.width), Xe === -1 ? mt = Math.max(0, _t.y) : Xe === 1 && (mt = Math.min(x - 1, _t.y + _t.height)), ht = Rs(ht, 0, Hr.length - 1), mt = Rs(mt, 0, x - 1), ic({
      ...Ee,
      location: [ht, mt]
    });
  }, [Hr.length, ic, x]);
  aoe(Vy, c, Kd);
  const ma = D.useCallback((Ee) => {
    if (T.current === void 0)
      return;
    const [Ye, Xe] = Ee, [ht, mt] = T.current.cell, _t = T.current.range;
    let ot = _t.x, pt = _t.x + _t.width, Ft = _t.y, Zt = _t.y + _t.height;
    if (Xe !== 0)
      switch (Xe) {
        case 2: {
          Zt = x, Ft = mt, ii(0, Zt, "vertical");
          break;
        }
        case -2: {
          Ft = 0, Zt = mt + 1, ii(0, Ft, "vertical");
          break;
        }
        case 1: {
          Ft < mt ? (Ft++, ii(0, Ft, "vertical")) : (Zt = Math.min(x, Zt + 1), ii(0, Zt, "vertical"));
          break;
        }
        case -1: {
          Zt > mt + 1 ? (Zt--, ii(0, Zt, "vertical")) : (Ft = Math.max(0, Ft - 1), ii(0, Ft, "vertical"));
          break;
        }
        default:
          vp();
      }
    if (Ye !== 0)
      if (Ye === 2)
        pt = Hr.length, ot = ht, ii(pt - 1 - dt, 0, "horizontal");
      else if (Ye === -2)
        ot = dt, pt = ht + 1, ii(ot - dt, 0, "horizontal");
      else {
        let mr = [];
        if (fe !== void 0) {
          const Vt = fe({
            x: ot,
            y: Ft,
            width: pt - ot - dt,
            height: Zt - Ft
          }, ee.current.signal);
          typeof Vt == "object" && (mr = coe(Vt));
        }
        if (Ye === 1) {
          let Vt = !1;
          if (ot < ht) {
            if (mr.length > 0) {
              const L = hu(ot + 1, ht + 1).find((Z) => !mr.includes(Z - dt));
              L !== void 0 && (ot = L, Vt = !0);
            } else
              ot++, Vt = !0;
            Vt && ii(ot, 0, "horizontal");
          }
          Vt || (pt = Math.min(Hr.length, pt + 1), ii(pt - 1 - dt, 0, "horizontal"));
        } else if (Ye === -1) {
          let Vt = !1;
          if (pt > ht + 1) {
            if (mr.length > 0) {
              const L = hu(pt - 1, ht, -1).find((Z) => !mr.includes(Z - dt));
              L !== void 0 && (pt = L, Vt = !0);
            } else
              pt--, Vt = !0;
            Vt && ii(pt - dt, 0, "horizontal");
          }
          Vt || (ot = Math.max(dt, ot - 1), ii(ot - dt, 0, "horizontal"));
        } else
          vp();
      }
    Tt({
      cell: T.current.cell,
      range: {
        x: ot,
        y: Ft,
        width: pt - ot,
        height: Zt - Ft
      }
    }, !0, !1, "keyboard-select");
  }, [fe, T, Hr.length, dt, x, ii, Tt]), xs = D.useCallback((Ee, Ye, Xe, ht) => {
    const mt = vi - (Xe ? 0 : 1);
    if (Ee = Rs(Ee, dt, zr.length - 1 + dt), Ye = Rs(Ye, 0, mt), Ee === ll?.[0] && Ye === ll?.[1])
      return !1;
    if (ht && T.current !== void 0) {
      const _t = [...T.current.rangeStack];
      (T.current.range.width > 1 || T.current.range.height > 1) && _t.push(T.current.range), Le({
        ...T,
        current: {
          cell: [Ee, Ye],
          range: { x: Ee, y: Ye, width: 1, height: 1 },
          rangeStack: _t
        }
      }, !0);
    } else
      Tt({
        cell: [Ee, Ye],
        range: { x: Ee, y: Ye, width: 1, height: 1 }
      }, !0, !1, "keyboard-nav");
    return d.current !== void 0 && d.current[0] === Ee && d.current[1] === Ye && (d.current = void 0), ii(Ee - dt, Ye), !0;
  }, [
    vi,
    dt,
    zr.length,
    ll,
    T,
    ii,
    Le,
    Tt
  ]), Wy = D.useCallback((Ee, Ye) => {
    a?.cell !== void 0 && Ee !== void 0 && Cc(Ee) && (ha([{ location: a.cell, value: Ee }]), window.requestAnimationFrame(() => {
      Fi.current?.damage([
        {
          cell: a.cell
        }
      ]);
    })), ki(!0), s(void 0);
    const [Xe, ht] = Ye;
    if (T.current !== void 0 && (Xe !== 0 || ht !== 0)) {
      const mt = T.current.cell[1] === vi - 1 && Ee !== void 0;
      xs(Rs(T.current.cell[0] + Xe, 0, Hr.length - 1), Rs(T.current.cell[1] + ht, 0, vi - 1), mt, !1);
    }
    k?.(Ee, Ye);
  }, [
    a?.cell,
    ki,
    T,
    k,
    ha,
    vi,
    xs,
    Hr.length
  ]), Ky = D.useMemo(() => `gdg-overlay-${uoe++}`, []), Eo = D.useCallback((Ee) => {
    ki();
    const Ye = [];
    for (let Xe = Ee.x; Xe < Ee.x + Ee.width; Xe++)
      for (let ht = Ee.y; ht < Ee.y + Ee.height; ht++) {
        const mt = _([Xe - dt, ht]);
        if (!mt.allowOverlay && mt.kind !== Gt.Boolean)
          continue;
        let _t;
        if (mt.kind === Gt.Custom) {
          const ot = Sr(mt), pt = ot?.provideEditor?.(mt);
          ot?.onDelete !== void 0 ? _t = ot.onDelete(mt) : pre(pt) && (_t = pt?.deletedValue?.(mt));
        } else (Cc(mt) && mt.allowOverlay || mt.kind === Gt.Boolean) && (_t = Sr(mt)?.onDelete?.(mt));
        _t !== void 0 && !Oc(_t) && Cc(_t) && Ye.push({ location: [Xe, ht], value: _t });
      }
    ha(Ye), Fi.current?.damage(Ye.map((Xe) => ({ cell: Xe.location })));
  }, [ki, _, Sr, ha, dt]), iu = a !== void 0, Yd = D.useCallback((Ee) => {
    const Ye = () => {
      Ee.stopPropagation(), Ee.preventDefault();
    }, Xe = {
      didMatch: !1
    }, { bounds: ht } = Ee, mt = T.columns, _t = T.rows, ot = _i;
    if (!iu && Zr(ot.clear, Ee, Xe))
      Le(im, !1), kr?.();
    else if (!iu && Zr(ot.selectAll, Ee, Xe))
      Le({
        columns: fn.empty(),
        rows: fn.empty(),
        current: {
          cell: T.current?.cell ?? [dt, 0],
          range: {
            x: dt,
            y: 0,
            width: v.length,
            height: x
          },
          rangeStack: []
        }
      }, !1);
    else if (Zr(ot.search, Ee, Xe))
      i?.current?.focus({ preventScroll: !0 }), Zi(!0);
    else if (Zr(ot.delete, Ee, Xe)) {
      const Z = it?.(T) ?? !0;
      if (Z !== !1) {
        const ve = Z === !0 ? T : Z;
        if (ve.current !== void 0) {
          Eo(ve.current.range);
          for (const oe of ve.current.rangeStack)
            Eo(oe);
        }
        for (const oe of ve.rows)
          Eo({
            x: dt,
            y: oe,
            width: v.length,
            height: 1
          });
        for (const oe of ve.columns)
          Eo({
            x: oe,
            y: 0,
            width: 1,
            height: x
          });
      }
    }
    if (Xe.didMatch)
      return Ye(), !0;
    if (T.current === void 0)
      return !1;
    let [pt, Ft] = T.current.cell, Zt = !1, mr = !1;
    Zr(ot.scrollToSelectedCell, Ee, Xe) ? fl.current(pt - dt, Ft) : R !== "none" && Zr(ot.selectColumn, Ee, Xe) ? mt.hasIndex(pt) ? Xt(mt.remove(pt), void 0, !0) : R === "single" ? Xt(fn.fromSingleSelection(pt), void 0, !0) : Xt(void 0, pt, !0) : H !== "none" && Zr(ot.selectRow, Ee, Xe) ? _t.hasIndex(Ft) ? rr(_t.remove(Ft), void 0, !0) : H === "single" ? rr(fn.fromSingleSelection(Ft), void 0, !0) : rr(void 0, Ft, !0) : !iu && ht !== void 0 && Zr(ot.activateCell, Ee, Xe) ? Ft === x && Sn ? window.setTimeout(() => {
      const Z = nu(pt);
      al(Z ?? pt);
    }, 0) : (w?.([pt - dt, Ft]), il(ht, !0)) : T.current.range.height > 1 && Zr(ot.downFill, Ee, Xe) ? nc() : T.current.range.width > 1 && Zr(ot.rightFill, Ee, Xe) ? Gd() : Zr(ot.goToNextPage, Ee, Xe) ? Ft += Math.max(1, ni.current.height - 4) : Zr(ot.goToPreviousPage, Ee, Xe) ? Ft -= Math.max(1, ni.current.height - 4) : Zr(ot.goToFirstCell, Ee, Xe) ? (s(void 0), Ft = 0, pt = 0) : Zr(ot.goToLastCell, Ee, Xe) ? (s(void 0), Ft = Number.MAX_SAFE_INTEGER, pt = Number.MAX_SAFE_INTEGER) : Zr(ot.selectToFirstCell, Ee, Xe) ? (s(void 0), ma([-2, -2])) : Zr(ot.selectToLastCell, Ee, Xe) ? (s(void 0), ma([2, 2])) : iu ? (Zr(ot.closeOverlay, Ee, Xe) && s(void 0), Zr(ot.acceptOverlayDown, Ee, Xe) && (s(void 0), Ft++), Zr(ot.acceptOverlayUp, Ee, Xe) && (s(void 0), Ft--), Zr(ot.acceptOverlayLeft, Ee, Xe) && (s(void 0), pt--), Zr(ot.acceptOverlayRight, Ee, Xe) && (s(void 0), pt++)) : (Zr(ot.goDownCell, Ee, Xe) ? Ft += 1 : Zr(ot.goUpCell, Ee, Xe) ? Ft -= 1 : Zr(ot.goRightCell, Ee, Xe) ? pt += 1 : Zr(ot.goLeftCell, Ee, Xe) ? pt -= 1 : Zr(ot.goDownCellRetainSelection, Ee, Xe) ? (Ft += 1, Zt = !0) : Zr(ot.goUpCellRetainSelection, Ee, Xe) ? (Ft -= 1, Zt = !0) : Zr(ot.goRightCellRetainSelection, Ee, Xe) ? (pt += 1, Zt = !0) : Zr(ot.goLeftCellRetainSelection, Ee, Xe) ? (pt -= 1, Zt = !0) : Zr(ot.goToLastRow, Ee, Xe) ? Ft = x - 1 : Zr(ot.goToFirstRow, Ee, Xe) ? Ft = Number.MIN_SAFE_INTEGER : Zr(ot.goToLastColumn, Ee, Xe) ? pt = Number.MAX_SAFE_INTEGER : Zr(ot.goToFirstColumn, Ee, Xe) ? pt = Number.MIN_SAFE_INTEGER : (A === "rect" || A === "multi-rect") && (Zr(ot.selectGrowDown, Ee, Xe) ? ma([0, 1]) : Zr(ot.selectGrowUp, Ee, Xe) ? ma([0, -1]) : Zr(ot.selectGrowRight, Ee, Xe) ? ma([1, 0]) : Zr(ot.selectGrowLeft, Ee, Xe) ? ma([-1, 0]) : Zr(ot.selectToLastRow, Ee, Xe) ? ma([0, 2]) : Zr(ot.selectToFirstRow, Ee, Xe) ? ma([0, -2]) : Zr(ot.selectToLastColumn, Ee, Xe) ? ma([2, 0]) : Zr(ot.selectToFirstColumn, Ee, Xe) && ma([-2, 0])), mr = Xe.didMatch);
    const Vt = xs(pt, Ft, !1, Zt), L = Xe.didMatch;
    return L && (Vt || !mr || yi) && Ye(), L;
  }, [
    iu,
    T,
    _i,
    R,
    H,
    A,
    dt,
    x,
    xs,
    Le,
    kr,
    v.length,
    it,
    yi,
    Eo,
    Xt,
    rr,
    Sn,
    nu,
    al,
    w,
    il,
    nc,
    Gd,
    ma
  ]), ul = D.useCallback((Ee) => {
    let Ye = !1;
    if (ge !== void 0 && ge({
      ...Ee,
      cancel: () => {
        Ye = !0;
      }
    }), Ye || Yd(Ee) || T.current === void 0)
      return;
    const [Xe, ht] = T.current.cell, mt = ni.current;
    if (re && !Ee.metaKey && !Ee.ctrlKey && T.current !== void 0 && Ee.key.length === 1 && /[ -~]/g.test(Ee.key) && Ee.bounds !== void 0 && Pf(_([Xe - dt, Math.max(0, Math.min(ht, x - 1))]))) {
      if ((!Sn || ht !== x) && (mt.y > ht || ht > mt.y + mt.height || mt.x > Xe || Xe > mt.x + mt.width))
        return;
      il(Ee.bounds, !0, Ee.key), Ee.stopPropagation(), Ee.preventDefault();
    }
  }, [
    re,
    ge,
    Yd,
    T,
    _,
    dt,
    x,
    Sn,
    il
  ]), Da = D.useCallback((Ee, Ye) => {
    const Xe = Ee.location[0] - dt;
    if (Ee.kind === "header" && le?.(Xe, { ...Ee, preventDefault: Ye }), Ee.kind === Ma) {
      if (Xe < 0)
        return;
      X?.(Xe, { ...Ee, preventDefault: Ye });
    }
    if (Ee.kind === "cell") {
      const [ht, mt] = Ee.location;
      Q?.([Xe, mt], {
        ...Ee,
        preventDefault: Ye
      }), Rne(T, Ee.location) || xs(ht, mt, !1, !1);
    }
  }, [
    T,
    Q,
    X,
    le,
    dt,
    xs
  ]), cl = D.useCallback(async (Ee) => {
    if (!_i.paste)
      return;
    function Ye(ot, pt, Ft, Zt) {
      const mr = typeof Ft == "object" ? Ft?.join(`
`) ?? "" : Ft?.toString() ?? "";
      if (!Oc(ot) && Pf(ot) && ot.readonly !== !0) {
        const Vt = S?.(mr, ot);
        if (Vt !== void 0 && Cc(Vt))
          return process.env.NODE_ENV !== "production" && Vt.kind !== ot.kind && console.warn("Coercion should not change cell kind."), {
            location: pt,
            value: Vt
          };
        const L = Sr(ot);
        if (L === void 0)
          return;
        if (L.kind === Gt.Custom) {
          Fa(ot.kind === Gt.Custom);
          const Z = L.onPaste?.(mr, ot.data);
          return Z === void 0 ? void 0 : {
            location: pt,
            value: {
              ...ot,
              data: Z
            }
          };
        } else {
          const Z = L.onPaste?.(mr, ot, {
            formatted: Zt,
            formattedString: typeof Zt == "string" ? Zt : Zt?.join(`
`),
            rawValue: Ft
          });
          return Z === void 0 ? void 0 : (Fa(Z.kind === ot.kind), {
            location: pt,
            value: Z
          });
        }
      }
    }
    const Xe = T.columns, ht = T.rows, mt = c.current?.contains(document.activeElement) === !0 || o.current?.contains(document.activeElement) === !0;
    let _t;
    if (T.current !== void 0 ? _t = [T.current.range.x, T.current.range.y] : Xe.length === 1 ? _t = [Xe.first() ?? 0, 0] : ht.length === 1 && (_t = [dt, ht.first() ?? 0]), mt && _t !== void 0) {
      let ot, pt;
      const Ft = "text/plain", Zt = "text/html";
      if (navigator.clipboard.read !== void 0) {
        const Z = await navigator.clipboard.read();
        for (const ve of Z) {
          if (ve.types.includes(Zt)) {
            const De = await (await ve.getType(Zt)).text(), Ne = _P(De);
            if (Ne !== void 0) {
              ot = Ne;
              break;
            }
          }
          ve.types.includes(Ft) && (pt = await (await ve.getType(Ft)).text());
        }
      } else if (navigator.clipboard.readText !== void 0)
        pt = await navigator.clipboard.readText();
      else if (Ee !== void 0 && Ee?.clipboardData !== null) {
        if (Ee.clipboardData.types.includes(Zt)) {
          const Z = Ee.clipboardData.getData(Zt);
          ot = _P(Z);
        }
        ot === void 0 && Ee.clipboardData.types.includes(Ft) && (pt = Ee.clipboardData.getData(Ft));
      } else
        return;
      const [mr, Vt] = _t, L = [];
      do {
        if (te === void 0) {
          const Z = Qi(_t), ve = pt ?? ot?.map((De) => De.map((Ne) => Ne.rawValue).join("	")).join("	") ?? "", oe = Ye(Z, _t, ve, void 0);
          oe !== void 0 && L.push(oe);
          break;
        }
        if (ot === void 0) {
          if (pt === void 0)
            return;
          ot = Jse(pt);
        }
        if (te === !1 || typeof te == "function" && te?.([_t[0] - dt, _t[1]], ot.map((Z) => Z.map((ve) => ve.rawValue?.toString() ?? ""))) !== !0)
          return;
        for (const [Z, ve] of ot.entries()) {
          if (Z + Vt >= x)
            break;
          for (const [oe, De] of ve.entries()) {
            const Ne = [oe + mr, Z + Vt], [Qe, Ke] = Ne;
            if (Qe >= Hr.length || Ke >= vi)
              continue;
            const Jt = Qi(Ne), gt = Ye(Jt, Ne, De.rawValue, De.formatted);
            gt !== void 0 && L.push(gt);
          }
        }
      } while (!1);
      ha(L), Fi.current?.damage(L.map((Z) => ({
        cell: Z.location
      })));
    }
  }, [
    S,
    Sr,
    Qi,
    T,
    _i.paste,
    Hr.length,
    ha,
    vi,
    te,
    dt,
    x
  ]);
  Oi("paste", cl, p, !1, !0);
  const au = D.useCallback(async (Ee, Ye) => {
    if (!_i.copy)
      return;
    const Xe = Ye === !0 || c.current?.contains(document.activeElement) === !0 || o.current?.contains(document.activeElement) === !0, ht = T.columns, mt = T.rows, _t = (ot, pt) => {
      if (!Fe)
        CP(ot, pt, Ee);
      else {
        const Ft = pt.map((Zt) => ({
          kind: Gt.Text,
          data: v[Zt].title,
          displayData: v[Zt].title,
          allowOverlay: !1
        }));
        CP([Ft, ...ot], pt, Ee);
      }
    };
    if (Xe && fe !== void 0) {
      if (T.current !== void 0) {
        let ot = fe(T.current.range, ee.current.signal);
        typeof ot != "object" && (ot = await ot()), _t(ot, hu(T.current.range.x - dt, T.current.range.x + T.current.range.width - dt));
      } else if (mt !== void 0 && mt.length > 0) {
        const pt = [...mt].map((Ft) => {
          const Zt = fe({
            x: dt,
            y: Ft,
            width: v.length,
            height: 1
          }, ee.current.signal);
          return typeof Zt == "object" ? Zt[0] : Zt().then((mr) => mr[0]);
        });
        if (pt.some((Ft) => Ft instanceof Promise)) {
          const Ft = await Promise.all(pt);
          _t(Ft, hu(v.length));
        } else
          _t(pt, hu(v.length));
      } else if (ht.length > 0) {
        const ot = [], pt = [];
        for (const Ft of ht) {
          let Zt = fe({
            x: Ft,
            y: 0,
            width: 1,
            height: x
          }, ee.current.signal);
          typeof Zt != "object" && (Zt = await Zt()), ot.push(Zt), pt.push(Ft - dt);
        }
        if (ot.length === 1)
          _t(ot[0], pt);
        else {
          const Ft = ot.reduce((Zt, mr) => Zt.map((Vt, L) => [...Vt, ...mr[L]]));
          _t(Ft, pt);
        }
      }
    }
  }, [v, fe, T, _i.copy, dt, x, Fe]);
  Oi("copy", au, p, !1, !1);
  const Yy = D.useCallback(async (Ee) => {
    if (!(!_i.cut || !(c.current?.contains(document.activeElement) === !0 || o.current?.contains(document.activeElement) === !0)) && (await au(Ee), T.current !== void 0)) {
      let Xe = {
        current: {
          cell: T.current.cell,
          range: T.current.range,
          rangeStack: []
        },
        rows: fn.empty(),
        columns: fn.empty()
      };
      const ht = it?.(Xe);
      if (ht === !1 || (Xe = ht === !0 ? Xe : ht, Xe.current === void 0))
        return;
      Eo(Xe.current.range);
    }
  }, [Eo, T, _i.cut, au, it]);
  Oi("cut", Yy, p, !1, !1);
  const Xy = D.useCallback((Ee, Ye) => {
    if (ye !== void 0) {
      dt !== 0 && (Ee = Ee.map((mt) => [mt[0] - dt, mt[1]])), ye(Ee, Ye);
      return;
    }
    if (Ee.length === 0 || Ye === -1)
      return;
    const [Xe, ht] = Ee[Ye];
    d.current !== void 0 && d.current[0] === Xe && d.current[1] === ht || (d.current = [Xe, ht], xs(Xe, ht, !1, !1));
  }, [ye, dt, xs]), [dl, ac] = Ie?.current?.cell ?? [], fl = D.useRef(ii);
  fl.current = ii, D.useLayoutEffect(() => {
    !bn.current && dl !== void 0 && ac !== void 0 && (dl !== _e.current?.current?.cell[0] || ac !== _e.current?.current?.cell[1]) && fl.current(dl, ac), bn.current = !1;
  }, [dl, ac]);
  const su = T.current !== void 0 && (T.current.cell[0] >= Hr.length || T.current.cell[1] >= vi);
  D.useLayoutEffect(() => {
    su && Le(im, !1);
  }, [su, Le]);
  const ga = D.useMemo(() => Sn === !0 && ct?.tint === !0 ? fn.fromSingleSelection(vi - 1) : fn.empty(), [vi, Sn, ct?.tint]), Vh = D.useCallback((Ee) => typeof dr == "boolean" ? dr : dr?.(Ee - dt) ?? !0, [dt, dr]), ba = D.useMemo(() => {
    if (ol === void 0 || o.current === null)
      return null;
    const { bounds: Ee, group: Ye } = ol, Xe = o.current.getBoundingClientRect();
    return D.createElement(zse, { bounds: Ee, group: Ye, canvasBounds: Xe, onClose: () => jd(void 0), onFinish: (ht) => {
      jd(void 0), G?.(Ye, ht);
    } });
  }, [G, ol]), Ya = Math.min(Hr.length, Y + (Ir ? 1 : 0));
  D.useImperativeHandle(t, () => ({
    appendRow: (Ee, Ye) => al(Ee + dt, Ye),
    updateCells: (Ee) => (dt !== 0 && (Ee = Ee.map((Ye) => ({ cell: [Ye.cell[0] + dt, Ye.cell[1]] }))), Fi.current?.damage(Ee)),
    getBounds: (Ee, Ye) => {
      if (!(o?.current === null || c?.current === null)) {
        if (Ee === void 0 && Ye === void 0) {
          const Xe = o.current.getBoundingClientRect(), ht = Xe.width / c.current.clientWidth;
          return {
            x: Xe.x - c.current.scrollLeft * ht,
            y: Xe.y - c.current.scrollTop * ht,
            width: c.current.scrollWidth * ht,
            height: c.current.scrollHeight * ht
          };
        }
        return Fi.current?.getBounds((Ee ?? 0) + dt, Ye);
      }
    },
    focus: () => Fi.current?.focus(),
    emit: async (Ee) => {
      switch (Ee) {
        case "delete":
          ul({
            bounds: void 0,
            cancel: () => {
            },
            stopPropagation: () => {
            },
            preventDefault: () => {
            },
            ctrlKey: !1,
            key: "Delete",
            keyCode: 46,
            metaKey: !1,
            shiftKey: !1,
            altKey: !1,
            rawEvent: void 0,
            location: void 0
          });
          break;
        case "fill-right":
          ul({
            bounds: void 0,
            cancel: () => {
            },
            stopPropagation: () => {
            },
            preventDefault: () => {
            },
            ctrlKey: !0,
            key: "r",
            keyCode: 82,
            metaKey: !1,
            shiftKey: !1,
            altKey: !1,
            rawEvent: void 0,
            location: void 0
          });
          break;
        case "fill-down":
          ul({
            bounds: void 0,
            cancel: () => {
            },
            stopPropagation: () => {
            },
            preventDefault: () => {
            },
            ctrlKey: !0,
            key: "d",
            keyCode: 68,
            metaKey: !1,
            shiftKey: !1,
            altKey: !1,
            rawEvent: void 0,
            location: void 0
          });
          break;
        case "copy":
          await au(void 0, !0);
          break;
        case "paste":
          await cl();
          break;
      }
    },
    scrollTo: ii,
    remeasureColumns: (Ee) => {
      for (const Ye of Ee)
        Ks(Ye + dt);
    }
  }), [al, Ks, au, ul, cl, dt, ii]);
  const [Ni, Di] = ll ?? [], Xd = D.useCallback((Ee) => {
    const [Ye, Xe] = Ee;
    if (Xe === -1) {
      R !== "none" && (Xt(fn.fromSingleSelection(Ye), void 0, !1), ki());
      return;
    }
    Ni === Ye && Di === Xe || (Tt({
      cell: Ee,
      range: { x: Ye, y: Xe, width: 1, height: 1 }
    }, !0, !1, "keyboard-nav"), ii(Ye, Xe));
  }, [R, ki, ii, Ni, Di, Tt, Xt]), [wi, Zd] = D.useState(!1), Gh = D.useRef(XU((Ee) => {
    Zd(Ee);
  }, 5)), Zy = D.useCallback(() => {
    Gh.current(!0), T.current === void 0 && T.columns.length === 0 && T.rows.length === 0 && l === void 0 && Tt({
      cell: [dt, Yu],
      range: {
        x: dt,
        y: Yu,
        width: 1,
        height: 1
      }
    }, !0, !1, "keyboard-select");
  }, [Yu, T, l, dt, Tt]), Jd = D.useCallback(() => {
    Gh.current(!1);
  }, []), [yn, Wh] = D.useMemo(() => {
    let Ee;
    const Ye = Ve?.scrollbarWidthOverride ?? MT(), Xe = x + (Sn ? 1 : 0);
    if (typeof Yt == "number")
      Ee = _n + Xe * Yt;
    else {
      let mt = 0;
      const _t = Math.min(Xe, 10);
      for (let ot = 0; ot < _t; ot++)
        mt += Yt(ot);
      mt = Math.floor(mt / _t), Ee = _n + Xe * mt;
    }
    Ee += Ye;
    const ht = Hr.reduce((mt, _t) => _t.width + mt, 0) + Ye;
    return [`${Math.min(1e5, ht)}px`, `${Math.min(1e5, Ee)}px`];
  }, [Hr, Ve?.scrollbarWidthOverride, Yt, x, Sn, _n]), Ys = D.useMemo(() => Hne(Dt), [Dt]);
  return D.createElement(
    Vne.Provider,
    { value: Dt },
    D.createElement(
      roe,
      { style: Ys, className: ne, inWidth: y ?? yn, inHeight: b ?? Wh },
      D.createElement(Fse, { fillHandle: or, drawFocusRing: Ae, experimental: Ve, fixedShadowX: Ge, fixedShadowY: lr, getRowThemeOverride: h, headerIcons: br, imageWindowLoader: Ut, initialSize: cn, isDraggable: Re, onDragLeave: J, onRowMoved: He, overscrollX: bs, overscrollY: ys, preventDiagonalScrolling: ut, rightElement: qn, rightElementProps: En, smoothScrollX: Yi, smoothScrollY: Xi, className: ne, enableGroups: Xn, onCanvasFocused: Zy, onCanvasBlur: Jd, canvasRef: o, onContextMenu: Da, theme: Dt, cellXOffset: Hs, cellYOffset: Yu, accessibilityHeight: li.height, onDragEnd: hi, columns: Hr, nonGrowWidth: Yn, drawHeader: en, onColumnProposeMove: I, drawCell: pi, disabledRows: ga, freezeColumns: Ya, lockColumns: dt, firstColAccessible: dt === 0, getCellContent: Qi, minColumnWidth: wt, maxColumnWidth: Se, searchInputRef: i, showSearch: ws, onSearchClose: pa, highlightRegions: Hy, getCellsForSelection: fe, getGroupDetails: qd, headerHeight: Vr, isFocused: wi, groupHeaderHeight: Xn ? gn : 0, freezeTrailingRows: ir + (Sn && ct?.sticky === !0 ? 1 : 0), hasAppendRow: Sn, onColumnResize: et, onColumnResizeEnd: vt, onColumnResizeStart: Wt, onCellFocused: Xd, onColumnMoved: jh, onDragStart: Hh, onHeaderMenuClick: qh, onItemHovered: ic, isFilling: l?.fillHandle === !0, onMouseMove: Gy, onKeyDown: ul, onKeyUp: ce, onMouseDown: It, onMouseUp: Et, onDragOverCell: $e, onDrop: at, onSearchResultsChanged: Xy, onVisibleRegionChanged: Ka, clientSize: ur, rowHeight: Yt, searchResults: pe, searchValue: F, onSearchValueChange: $, rows: vi, scrollRef: c, selection: T, translateX: li.tx, translateY: li.ty, verticalBorder: Vh, gridRef: Fi, getCellRenderer: Sr }),
      ba,
      a !== void 0 && D.createElement(
        D.Suspense,
        { fallback: null },
        D.createElement(loe, { ...a, validateCell: de, bloom: N, id: Ky, getCellRenderer: Sr, className: Ve?.isSubGrid === !0 ? "click-outside-ignore" : void 0, provideEditor: Kt, imageEditorOverride: f, onFinishEditing: Wy, markdownDivCreateNode: m, isOutsideClick: Ii })
      )
    )
  );
}, foe = D.forwardRef(doe), RP = 20, poe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "false",
  kind: Gt.Boolean,
  needsHover: !0,
  useLabel: !1,
  needsHoverPosition: !0,
  measure: () => 50,
  draw: (e) => hoe(e, e.cell.data, LT(e.cell), e.cell.maxSize ?? RP),
  onDelete: (e) => ({
    ...e,
    data: !1
  }),
  onClick: (e) => {
    const { cell: t, posX: r, posY: n, bounds: a, theme: s } = e, { width: i, height: o, x: l, y: u } = a, c = t.maxSize ?? RP, d = Math.floor(a.y + o / 2), p = QU(c, o, s.cellVerticalPadding), f = JU(t.contentAlign ?? "center", l, i, s.cellHorizontalPadding, p), h = ZU(f, d, p), m = ez(l + r, u + n, h);
    if (LT(t) && m)
      return {
        ...t,
        data: Hz(t.data)
      };
  },
  onPaste: (e, t) => {
    let r = Tg;
    return e.toLowerCase() === "true" ? r = !0 : e.toLowerCase() === "false" ? r = !1 : e.toLowerCase() === "indeterminate" && (r = TI), r === t.data ? void 0 : {
      ...t,
      data: r
    };
  }
};
function hoe(e, t, r, n) {
  if (!r && t === Tg)
    return;
  const { ctx: a, hoverAmount: s, theme: i, rect: o, highlighted: l, hoverX: u, hoverY: c, cell: { contentAlign: d } } = e, { x: p, y: f, width: h, height: m } = o, y = 0.35;
  let b = r ? 1 - y + y * s : 0.4;
  t === Tg && (b *= s), b !== 0 && (a.globalAlpha = b, zI(a, i, t, p, f, h, m, l, u, c, n, d), a.globalAlpha = 1);
}
const moe = /* @__PURE__ */ Ga("div")({
  name: "BubblesOverlayEditorStyle",
  class: "gdg-b1ygi5by",
  propsAsIs: !1
}), goe = (e) => {
  const { bubbles: t } = e;
  return D.createElement(
    moe,
    null,
    t.map((r, n) => D.createElement("div", { key: n, className: "boe-bubble" }, r)),
    D.createElement("textarea", { className: "gdg-input", autoFocus: !0 })
  );
}, boe = {
  getAccessibilityString: (e) => tz(e.data),
  kind: Gt.Bubble,
  needsHover: !1,
  useLabel: !1,
  needsHoverPosition: !1,
  measure: (e, t, r) => t.data.reduce((n, a) => e.measureText(a).width + n + 20, 0) + 2 * r.cellHorizontalPadding - 4,
  draw: (e) => voe(e, e.cell.data),
  provideEditor: () => (e) => {
    const { value: t } = e;
    return D.createElement(goe, { bubbles: t.data });
  },
  onPaste: () => {
  }
}, yoe = 4;
function voe(e, t) {
  const { rect: r, theme: n, ctx: a, highlighted: s } = e, { x: i, y: o, width: l, height: u } = r, c = 20, d = 8, p = yoe;
  let f = i + n.cellHorizontalPadding;
  const h = [];
  for (const m of t) {
    if (f > i + l)
      break;
    const y = oh(m, a, n.baseFontFull).width;
    h.push({
      x: f,
      width: y
    }), f += y + d * 2 + p;
  }
  a.beginPath();
  for (const m of h)
    os(a, m.x, o + (u - c) / 2, m.width + d * 2, c, n.roundingRadius ?? c / 2);
  a.fillStyle = s ? n.bgBubbleSelected : n.bgBubble, a.fill();
  for (const [m, y] of h.entries())
    a.beginPath(), a.fillStyle = n.textBubble, a.fillText(t[m], y.x + d, o + u / 2 + Yo(a, n));
}
const woe = /* @__PURE__ */ Ga("div")({
  name: "DrilldownOverlayEditorStyle",
  class: "gdg-d4zsq0x",
  propsAsIs: !1
}), xoe = (e) => {
  const {
    drilldowns: t
  } = e;
  return D.createElement(woe, null, t.map((r, n) => D.createElement("div", {
    key: n,
    className: "doe-bubble"
  }, r.img !== void 0 && D.createElement("img", {
    src: r.img
  }), D.createElement("div", null, r.text))));
}, Eoe = {
  getAccessibilityString: (e) => tz(e.data.map((t) => t.text)),
  kind: Gt.Drilldown,
  needsHover: !1,
  useLabel: !1,
  needsHoverPosition: !1,
  measure: (e, t, r) => t.data.reduce((n, a) => e.measureText(a.text).width + n + 20 + (a.img !== void 0 ? 18 : 0), 0) + 2 * r.cellHorizontalPadding - 4,
  draw: (e) => koe(e, e.cell.data),
  provideEditor: () => (e) => {
    const { value: t } = e;
    return D.createElement(xoe, { drilldowns: t.data });
  },
  onPaste: () => {
  }
}, Soe = 4, i1 = {};
function _oe(e, t, r, n) {
  const a = Math.ceil(window.devicePixelRatio), s = 5, i = r - s * 2, o = 4, l = r * a, u = n + s, c = n * 3, d = (c + s * 2) * a, p = `${e},${t},${a},${r}`;
  if (i1[p] !== void 0)
    return {
      el: i1[p],
      height: l,
      width: d,
      middleWidth: o * a,
      sideWidth: u * a,
      padding: s * a,
      dpr: a
    };
  const f = document.createElement("canvas"), h = f.getContext("2d");
  return h === null ? null : (f.width = d, f.height = l, h.scale(a, a), i1[p] = f, h.beginPath(), os(h, s, s, c, i, n), h.shadowColor = "rgba(24, 25, 34, 0.4)", h.shadowBlur = 1, h.fillStyle = e, h.fill(), h.shadowColor = "rgba(24, 25, 34, 0.3)", h.shadowOffsetY = 1, h.shadowBlur = 5, h.fillStyle = e, h.fill(), h.shadowOffsetY = 0, h.shadowBlur = 0, h.shadowBlur = 0, h.beginPath(), os(h, s + 0.5, s + 0.5, c, i, n), h.strokeStyle = t, h.lineWidth = 1, h.stroke(), {
    el: f,
    height: l,
    width: d,
    sideWidth: u * a,
    middleWidth: n * a,
    padding: s * a,
    dpr: a
  });
}
function koe(e, t) {
  const { rect: r, theme: n, ctx: a, imageLoader: s, col: i, row: o } = e, { x: l, width: u } = r, c = n.baseFontFull, d = hz(a, c), p = Math.min(r.height, Math.max(16, Math.ceil(d * n.lineHeight) * 2)), f = Math.floor(r.y + (r.height - p) / 2), h = p - 10, m = 8, y = Soe;
  let b = l + n.cellHorizontalPadding;
  const v = n.roundingRadius ?? 6, x = _oe(n.bgCell, n.drilldownBorder, p, v), _ = [];
  for (const E of t) {
    if (b > l + u)
      break;
    const C = oh(E.text, a, c).width;
    let k = 0;
    E.img !== void 0 && s.loadOrGetImage(E.img, i, o) !== void 0 && (k = h - 8 + 4);
    const S = C + k + m * 2;
    _.push({
      x: b,
      width: S
    }), b += S + y;
  }
  if (x !== null) {
    const { el: E, height: w, middleWidth: C, sideWidth: k, width: S, dpr: B, padding: U } = x, N = k / B, O = U / B;
    for (const I of _) {
      const q = Math.floor(I.x), ae = Math.floor(I.width), Q = ae - (N - O) * 2;
      a.imageSmoothingEnabled = !1, a.drawImage(E, 0, 0, k, w, q - O, f, N, p), Q > 0 && a.drawImage(E, k, 0, C, w, q + (N - O), f, Q, p), a.drawImage(E, S - k, 0, k, w, q + ae - (N - O), f, N, p), a.imageSmoothingEnabled = !0;
    }
  }
  a.beginPath();
  for (const [E, w] of _.entries()) {
    const C = t[E];
    let k = w.x + m;
    if (C.img !== void 0) {
      const S = s.loadOrGetImage(C.img, i, o);
      if (S !== void 0) {
        const B = h - 8;
        let U = 0, N = 0, O = S.width, I = S.height;
        O > I ? (U += (O - I) / 2, O = I) : I > O && (N += (I - O) / 2, I = O), a.beginPath(), os(a, k, f + p / 2 - B / 2, B, B, n.roundingRadius ?? 3), a.save(), a.clip(), a.drawImage(S, U, N, O, I, k, f + p / 2 - B / 2, B, B), a.restore(), k += B + 4;
      }
    }
    a.beginPath(), a.fillStyle = n.textBubble, a.fillText(C.text, k, f + p / 2 + Yo(a, n));
  }
}
const Coe = {
  getAccessibilityString: (e) => e.data.join(", "),
  kind: Gt.Image,
  needsHover: !1,
  useLabel: !1,
  needsHoverPosition: !1,
  draw: (e) => Aoe(e, e.cell.displayData ?? e.cell.data, e.cell.rounding ?? e.theme.roundingRadius ?? 4, e.cell.contentAlign),
  measure: (e, t) => t.data.length * 50,
  onDelete: (e) => ({
    ...e,
    data: []
  }),
  provideEditor: () => (e) => {
    const { value: t, onFinishedEditing: r, imageEditorOverride: n } = e, a = n ?? Jre;
    return D.createElement(a, { urls: t.data, canWrite: t.readonly !== !1, onCancel: r, onChange: (s) => {
      r({
        ...t,
        data: [s]
      });
    } });
  },
  onPaste: (e, t) => {
    e = e.trim();
    const n = e.split(",").map((a) => {
      try {
        return new URL(a), a;
      } catch {
        return;
      }
    }).filter((a) => a !== void 0);
    if (!(n.length === t.data.length && n.every((a, s) => a === t.data[s])))
      return {
        ...t,
        data: n
      };
  }
}, a1 = 4;
function Aoe(e, t, r, n) {
  const { rect: a, col: s, row: i, theme: o, ctx: l, imageLoader: u } = e, { x: c, y: d, height: p, width: f } = a, h = p - o.cellVerticalPadding * 2, m = [];
  let y = 0;
  for (let v = 0; v < t.length; v++) {
    const x = t[v];
    if (x.length === 0)
      continue;
    const _ = u.loadOrGetImage(x, s, i);
    if (_ !== void 0) {
      m[v] = _;
      const E = _.width * (h / _.height);
      y += E + a1;
    }
  }
  if (y === 0)
    return;
  y -= a1;
  let b = c + o.cellHorizontalPadding;
  n === "right" ? b = Math.floor(c + f - o.cellHorizontalPadding - y) : n === "center" && (b = Math.floor(c + f / 2 - y / 2));
  for (const v of m) {
    if (v === void 0)
      continue;
    const x = v.width * (h / v.height);
    r > 0 && (l.beginPath(), os(l, b, d + o.cellVerticalPadding, x, h, r), l.save(), l.clip()), l.drawImage(v, b, d + o.cellVerticalPadding, x, h), r > 0 && l.restore(), b += x + a1;
  }
}
function Toe(e, t) {
  let r = e * 49632 + t * 325176;
  return r ^= r << 13, r ^= r >> 17, r ^= r << 5, r / 4294967295 * 2;
}
const Roe = {
  getAccessibilityString: () => "",
  kind: Gt.Loading,
  needsHover: !1,
  useLabel: !1,
  needsHoverPosition: !1,
  measure: () => 120,
  draw: (e) => {
    const { cell: t, col: r, row: n, ctx: a, rect: s, theme: i } = e;
    if (t.skeletonWidth === void 0 || t.skeletonWidth === 0)
      return;
    let o = t.skeletonWidth;
    t.skeletonWidthVariability !== void 0 && t.skeletonWidthVariability > 0 && (o += Math.round(Toe(r, n) * t.skeletonWidthVariability));
    const l = i.cellHorizontalPadding, u = t.skeletonHeight ?? Math.min(18, s.height - 2 * i.cellVerticalPadding);
    os(a, s.x + l, s.y + (s.height - u) / 2, o, u, i.roundingRadius ?? 3), a.fillStyle = ku(i.textDark, 0.1), a.fill();
  },
  onPaste: () => {
  }
}, Ioe = () => (e) => e.targetWidth, IP = /* @__PURE__ */ Ga("div")({
  name: "MarkdownOverlayEditorStyle",
  class: "gdg-m1pnx84e",
  propsAsIs: !1,
  vars: {
    "m1pnx84e-0": [Ioe(), "px"]
  }
}), Noe = (e) => {
  const { value: t, onChange: r, forceEditMode: n, createNode: a, targetRect: s, onFinish: i, validatedSelection: o } = e, l = t.data, u = t.readonly === !0, [c, d] = D.useState(l === "" || n), p = D.useCallback(() => {
    d((h) => !h);
  }, []), f = l ? "gdg-ml-6" : "";
  return c ? D.createElement(
    IP,
    { targetWidth: s.width - 20 },
    D.createElement(Pb, { autoFocus: !0, highlight: !1, validatedSelection: o, value: l, onKeyDown: (h) => {
      h.key === "Enter" && h.stopPropagation();
    }, onChange: r }),
    D.createElement(
      "div",
      { className: `gdg-edit-icon gdg-checkmark-hover ${f}`, onClick: () => i(t) },
      D.createElement(Vre, null)
    )
  ) : D.createElement(
    IP,
    { targetWidth: s.width },
    D.createElement(bne, { contents: l, createNode: a }),
    !u && D.createElement(
      D.Fragment,
      null,
      D.createElement("div", { className: "spacer" }),
      D.createElement(
        "div",
        { className: `gdg-edit-icon gdg-edit-hover ${f}`, onClick: p },
        D.createElement(DI, null)
      )
    ),
    D.createElement("textarea", { className: "gdg-md-edit-textarea gdg-input", autoFocus: !0 })
  );
}, Doe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "",
  kind: Gt.Markdown,
  needsHover: !1,
  needsHoverPosition: !1,
  drawPrep: lh,
  measure: (e, t, r) => {
    const n = t.data.split(`
`)[0];
    return e.measureText(n).width + 2 * r.cellHorizontalPadding;
  },
  draw: (e) => No(e, e.cell.data, e.cell.contentAlign),
  onDelete: (e) => ({
    ...e,
    data: ""
  }),
  provideEditor: () => (e) => {
    const { onChange: t, value: r, target: n, onFinishedEditing: a, markdownDivCreateNode: s, forceEditMode: i, validatedSelection: o } = e;
    return D.createElement(Noe, { onFinish: a, targetRect: n, value: r, validatedSelection: o, onChange: (l) => t({
      ...r,
      data: l.target.value
    }), forceEditMode: i, createNode: s });
  },
  onPaste: (e, t) => e === t.data ? void 0 : { ...t, data: e }
}, Ooe = {
  getAccessibilityString: (e) => e.row.toString(),
  kind: as.Marker,
  needsHover: !0,
  needsHoverPosition: !1,
  drawPrep: Poe,
  measure: () => 44,
  draw: (e) => Moe(e, e.cell.row, e.cell.checked, e.cell.markerKind, e.cell.drawHandle, e.cell.checkboxStyle),
  onClick: (e) => {
    const { bounds: t, cell: r, posX: n, posY: a } = e, { width: s, height: i } = t, o = r.drawHandle ? 7 + (s - 7) / 2 : s / 2, l = i / 2;
    if (Math.abs(n - o) <= 10 && Math.abs(a - l) <= 10)
      return {
        ...r,
        checked: !r.checked
      };
  },
  onPaste: () => {
  }
};
function Poe(e, t) {
  const { ctx: r, theme: n } = e, a = n.markerFontFull, s = t ?? {};
  return s?.font !== a && (r.font = a, s.font = a), s.deprep = Loe, r.textAlign = "center", s;
}
function Loe(e) {
  const { ctx: t } = e;
  t.textAlign = "start";
}
function Moe(e, t, r, n, a, s) {
  const { ctx: i, rect: o, hoverAmount: l, theme: u } = e, { x: c, y: d, width: p, height: f } = o, h = r ? 1 : n === "checkbox-visible" ? 0.6 + 0.4 * l : l;
  if (n !== "number" && h > 0) {
    i.globalAlpha = h;
    const m = 7 * (r ? l : 1);
    if (zI(i, u, r, a ? c + m : c, d, a ? p - m : p, f, !0, void 0, void 0, 18, "center", s), a) {
      i.globalAlpha = l, i.beginPath();
      for (const y of [3, 6])
        for (const b of [-5, -1, 3])
          i.rect(c + y, d + f / 2 + b, 2, 2);
      i.fillStyle = u.textLight, i.fill(), i.beginPath();
    }
    i.globalAlpha = 1;
  }
  if (n === "number" || n === "both" && !r) {
    const m = t.toString(), y = u.markerFontFull, b = c + p / 2;
    n === "both" && l !== 0 && (i.globalAlpha = 1 - l), i.fillStyle = u.textLight, i.font = y, i.fillText(m, b, d + f / 2 + Yo(i, y)), l !== 0 && (i.globalAlpha = 1);
  }
}
const Foe = {
  getAccessibilityString: () => "",
  kind: as.NewRow,
  needsHover: !0,
  needsHoverPosition: !1,
  measure: () => 200,
  draw: (e) => $oe(e, e.cell.hint, e.cell.icon),
  onPaste: () => {
  }
};
function $oe(e, t, r) {
  const { ctx: n, rect: a, hoverAmount: s, theme: i, spriteManager: o } = e, { x: l, y: u, width: c, height: d } = a;
  n.beginPath(), n.globalAlpha = s, n.rect(l + 1, u + 1, c, d - 2), n.fillStyle = i.bgHeaderHovered, n.fill(), n.globalAlpha = 1, n.beginPath();
  const p = t !== "";
  let f = 0;
  if (r !== void 0) {
    const m = d - 8, y = l + 8 / 2, b = u + 8 / 2;
    o.drawSprite(r, "normal", n, y, b, m, i, p ? 1 : s), f = m;
  } else {
    f = 24;
    const h = 12, m = p ? h : s * h, y = p ? 0 : (1 - s) * h * 0.5, b = i.cellHorizontalPadding + 4;
    m > 0 && (n.moveTo(l + b + y, u + d / 2), n.lineTo(l + b + y + m, u + d / 2), n.moveTo(l + b + y + m * 0.5, u + d / 2 - m * 0.5), n.lineTo(l + b + y + m * 0.5, u + d / 2 + m * 0.5), n.lineWidth = 2, n.strokeStyle = i.bgIconHeader, n.lineCap = "round", n.stroke());
  }
  n.fillStyle = i.textMedium, n.fillText(t, f + l + i.cellHorizontalPadding + 0.5, u + d / 2 + Yo(n, i)), n.beginPath();
}
const Boe = D.lazy(async () => await import("./number-overlay-editor-CvwOrFrV.js")), Uoe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "",
  kind: Gt.Number,
  needsHover: !1,
  needsHoverPosition: !1,
  useLabel: !0,
  drawPrep: lh,
  draw: (e) => No(e, e.cell.displayData, e.cell.contentAlign),
  measure: (e, t, r) => e.measureText(t.displayData).width + r.cellHorizontalPadding * 2,
  onDelete: (e) => ({
    ...e,
    data: void 0
  }),
  provideEditor: () => (e) => {
    const { isHighlighted: t, onChange: r, value: n, validatedSelection: a } = e;
    return D.createElement(
      D.Suspense,
      { fallback: null },
      D.createElement(Boe, { highlight: t, disabled: n.readonly === !0, value: n.data, fixedDecimals: n.fixedDecimals, allowNegative: n.allowNegative, thousandSeparator: n.thousandSeparator, decimalSeparator: n.decimalSeparator, validatedSelection: a, onChange: (s) => r({
        ...n,
        data: Number.isNaN(s.floatValue ?? 0) ? 0 : s.floatValue
      }) })
    );
  },
  onPaste: (e, t, r) => {
    const n = typeof r.rawValue == "number" ? r.rawValue : Number.parseFloat(typeof r.rawValue == "string" ? r.rawValue : e);
    if (!(Number.isNaN(n) || t.data === n))
      return { ...t, data: n, displayData: r.formattedString ?? t.displayData };
  }
}, zoe = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: Gt.Protected,
  needsHover: !1,
  needsHoverPosition: !1,
  draw: qoe,
  onPaste: () => {
  }
};
function qoe(e) {
  const { ctx: t, theme: r, rect: n } = e, { x: a, y: s, height: i } = n;
  t.beginPath();
  const o = 2.5;
  let l = a + r.cellHorizontalPadding + o;
  const u = s + i / 2, c = Math.cos(v4(30)) * o, d = Math.sin(v4(30)) * o;
  for (let p = 0; p < 12; p++)
    t.moveTo(l, u - o), t.lineTo(l, u + o), t.moveTo(l + c, u - d), t.lineTo(l - c, u + d), t.moveTo(l - c, u - d), t.lineTo(l + c, u + d), l += 8;
  t.lineWidth = 1.1, t.lineCap = "square", t.strokeStyle = r.textLight, t.stroke();
}
const joe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "",
  kind: Gt.RowID,
  needsHover: !1,
  needsHoverPosition: !1,
  drawPrep: (e, t) => lh(e, t, e.theme.textLight),
  draw: (e) => No(e, e.cell.data, e.cell.contentAlign),
  measure: (e, t, r) => e.measureText(t.data).width + r.cellHorizontalPadding * 2,
  // eslint-disable-next-line react/display-name
  provideEditor: () => (e) => {
    const { isHighlighted: t, onChange: r, value: n, validatedSelection: a } = e;
    return kt.createElement(Pb, { highlight: t, autoFocus: n.readonly !== !0, disabled: n.readonly !== !1, value: n.data, validatedSelection: a, onChange: (s) => r({
      ...n,
      data: s.target.value
    }) });
  },
  onPaste: () => {
  }
}, Hoe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "",
  kind: Gt.Text,
  needsHover: (e) => e.hoverEffect === !0,
  needsHoverPosition: !1,
  drawPrep: lh,
  useLabel: !0,
  draw: (e) => {
    const { cell: t, hoverAmount: r, hyperWrapping: n, ctx: a, rect: s, theme: i, overrideCursor: o } = e, { displayData: l, contentAlign: u, hoverEffect: c, allowWrapping: d } = t;
    if (c === !0 && r > 0) {
      a.textBaseline = "alphabetic";
      const p = i.cellHorizontalPadding, f = i.cellVerticalPadding, h = oh(l, a, i.baseFontFull, "alphabetic"), m = s.height - f, y = Math.min(m, h.actualBoundingBoxAscent * 2.5);
      a.beginPath(), os(a, s.x + p / 2, s.y + (s.height - y) / 2 + 1, h.width + p * 3, y - 1, i.roundingRadius ?? 4), a.globalAlpha = r, a.fillStyle = ku(i.textDark, 0.1), a.fill(), a.globalAlpha = 1, a.fillStyle = i.textDark, a.textBaseline = "middle", o?.("text");
    }
    No(e, l, u, d, n);
  },
  measure: (e, t, r) => {
    const n = t.displayData.split(`
`, t.allowWrapping === !0 ? void 0 : 1);
    let a = 0;
    for (const s of n)
      a = Math.max(a, e.measureText(s).width);
    return a + 2 * r.cellHorizontalPadding;
  },
  onDelete: (e) => ({
    ...e,
    data: ""
  }),
  provideEditor: (e) => ({
    disablePadding: e.allowWrapping === !0,
    editor: (t) => {
      const { isHighlighted: r, onChange: n, value: a, validatedSelection: s } = t;
      return D.createElement(Pb, { style: e.allowWrapping === !0 ? { padding: "3px 8.5px" } : void 0, highlight: r, autoFocus: a.readonly !== !0, disabled: a.readonly === !0, altNewline: !0, value: a.data, validatedSelection: s, onChange: (i) => n({
        ...a,
        data: i.target.value
      }) });
    }
  }),
  onPaste: (e, t, r) => e === t.data ? void 0 : { ...t, data: e, displayData: r.formattedString ?? t.displayData }
}, Voe = /* @__PURE__ */ Ga("div")({
  name: "UriOverlayEditorStyle",
  class: "gdg-u1rrojo",
  propsAsIs: !1
}), Goe = (e) => {
  const { uri: t, onChange: r, forceEditMode: n, readonly: a, validatedSelection: s, preview: i } = e, [o, l] = D.useState(!a && (t === "" || n)), u = D.useCallback(() => {
    l(!0);
  }, []);
  return o ? D.createElement(Pb, { validatedSelection: s, highlight: !0, autoFocus: !0, value: t, onChange: r }) : D.createElement(
    Voe,
    null,
    D.createElement("a", { className: "gdg-link-area", href: t, target: "_blank", rel: "noopener noreferrer" }, i),
    !a && D.createElement(
      "div",
      { className: "gdg-edit-icon", onClick: u },
      D.createElement(DI, null)
    ),
    D.createElement("textarea", { className: "gdg-input", autoFocus: !0 })
  );
};
function NP(e, t, r, n) {
  let a = r.cellHorizontalPadding;
  const s = t.height / 2 - e.actualBoundingBoxAscent / 2, i = e.width, o = e.actualBoundingBoxAscent;
  return n === "right" ? a = t.width - i - r.cellHorizontalPadding : n === "center" && (a = t.width / 2 - i / 2), { x: a, y: s, width: i, height: o };
}
const Woe = {
  getAccessibilityString: (e) => e.data?.toString() ?? "",
  kind: Gt.Uri,
  needsHover: (e) => e.hoverEffect === !0,
  needsHoverPosition: !0,
  useLabel: !0,
  drawPrep: lh,
  draw: (e) => {
    const { cell: t, theme: r, overrideCursor: n, hoverX: a, hoverY: s, rect: i, ctx: o } = e, l = t.displayData ?? t.data, u = t.hoverEffect === !0;
    if (n !== void 0 && u && a !== void 0 && s !== void 0) {
      const c = oh(l, o, r.baseFontFull), d = NP(c, i, r, t.contentAlign), { x: p, y: f, width: h, height: m } = d;
      if (a >= p - 4 && a <= p - 4 + h + 8 && s >= f - 4 && s <= f - 4 + m + 8) {
        const y = Yo(o, r.baseFontFull);
        n("pointer");
        const b = 5, v = f - y;
        o.beginPath(), o.moveTo(i.x + p, Math.floor(i.y + v + m + b) + 0.5), o.lineTo(i.x + p + h, Math.floor(i.y + v + m + b) + 0.5), o.strokeStyle = r.linkColor, o.stroke(), o.save(), o.fillStyle = e.cellFillColor, No({ ...e, rect: { ...i, x: i.x - 1 } }, l, t.contentAlign), No({ ...e, rect: { ...i, x: i.x - 2 } }, l, t.contentAlign), No({ ...e, rect: { ...i, x: i.x + 1 } }, l, t.contentAlign), No({ ...e, rect: { ...i, x: i.x + 2 } }, l, t.contentAlign), o.restore();
      }
    }
    o.fillStyle = u ? r.linkColor : r.textDark, No(e, l, t.contentAlign);
  },
  onClick: (e) => {
    const { cell: t, bounds: r, posX: n, posY: a, theme: s } = e, i = t.displayData ?? t.data;
    if (t.hoverEffect !== !0 || t.onClickUri === void 0)
      return;
    const o = Mne(i, s.baseFontFull);
    if (o === void 0)
      return;
    const l = NP(o, r, s, t.contentAlign);
    Mb({
      x: l.x - 4,
      y: l.y - 4,
      width: l.width + 8,
      height: l.height + 8
    }, n, a) && t.onClickUri(e);
  },
  measure: (e, t, r) => e.measureText(t.displayData ?? t.data).width + r.cellHorizontalPadding * 2,
  onDelete: (e) => ({
    ...e,
    data: ""
  }),
  provideEditor: (e) => (t) => {
    const { onChange: r, value: n, forceEditMode: a, validatedSelection: s } = t;
    return D.createElement(Goe, { forceEditMode: n.readonly !== !0 && (a || e.hoverEffect === !0 && e.onClickUri !== void 0), uri: n.data, preview: n.displayData ?? n.data, validatedSelection: s, readonly: n.readonly === !0, onChange: (i) => r({
      ...n,
      data: i.target.value
    }) });
  },
  onPaste: (e, t, r) => e === t.data ? void 0 : { ...t, data: e, displayData: r.formattedString ?? t.displayData }
}, Koe = [
  Ooe,
  Foe,
  poe,
  boe,
  Eoe,
  Coe,
  Roe,
  Doe,
  Uoe,
  zoe,
  joe,
  Hoe,
  Woe
];
var s1, DP;
function Yoe() {
  if (DP) return s1;
  DP = 1;
  var e = YU(), t = Fu(), r = "Expected a function";
  function n(a, s, i) {
    var o = !0, l = !0;
    if (typeof a != "function")
      throw new TypeError(r);
    return t(i) && (o = "leading" in i ? !!i.leading : o, l = "trailing" in i ? !!i.trailing : l), e(a, s, {
      leading: o,
      maxWait: s,
      trailing: l
    });
  }
  return s1 = n, s1;
}
var Xoe = Yoe();
const Zoe = /* @__PURE__ */ da(Xoe), o1 = [];
class Joe extends gz {
  imageLoaded = () => {
  };
  loadedLocations = [];
  cache = {};
  setCallback(t) {
    this.imageLoaded = t;
  }
  // eslint-disable-next-line unicorn/consistent-function-scoping
  sendLoaded = Zoe(() => {
    this.imageLoaded(new Zf(this.loadedLocations)), this.loadedLocations = [];
  }, 20);
  clearOutOfWindow = () => {
    const t = Object.keys(this.cache);
    for (const r of t) {
      const n = this.cache[r];
      let a = !1;
      for (let s = 0; s < n.cells.length; s++) {
        const i = n.cells[s];
        if (this.isInWindow(i)) {
          a = !0;
          break;
        }
      }
      a ? n.cells = n.cells.filter(this.isInWindow) : (n.cancel(), delete this.cache[r]);
    }
  };
  loadImage(t, r, n, a) {
    let s = !1;
    const i = o1.pop() ?? new Image();
    let o = !1;
    const l = {
      img: void 0,
      cells: [Ns(r, n)],
      url: t,
      cancel: () => {
        o || (o = !0, o1.length < 12 ? o1.unshift(i) : s || (i.src = ""));
      }
    }, u = new Promise((c) => i.addEventListener("load", () => c(null)));
    requestAnimationFrame(async () => {
      try {
        i.src = t, await u, await i.decode();
        const c = this.cache[a];
        if (c !== void 0 && !o) {
          c.img = i;
          for (const d of c.cells)
            this.loadedLocations.push($I(d));
          s = !0, this.sendLoaded();
        }
      } catch {
        l.cancel();
      }
    }), this.cache[a] = l;
  }
  loadOrGetImage(t, r, n) {
    const a = t, s = this.cache[a];
    if (s !== void 0) {
      const i = Ns(r, n);
      return s.cells.includes(i) || s.cells.push(i), s.img;
    } else
      this.loadImage(t, r, n, a);
  }
}
const Qoe = (e, t) => {
  const r = D.useMemo(() => ({ ...Yie, ...e.headerIcons }), [e.headerIcons]), n = D.useMemo(() => e.imageWindowLoader ?? new Joe(), [e.imageWindowLoader]);
  return D.createElement(foe, { ...e, renderers: Koe, headerIcons: r, ref: t, imageWindowLoader: n });
}, ele = D.forwardRef(Qoe);
function l1(e, t, r) {
  if (typeof e == "string")
    return t[e] !== void 0 ? t[e] : e;
  let [n, a] = e;
  return t[n] !== void 0 && (n = t[n]), t[a] !== void 0 && (a = t[a]), Ene(n, a, r);
}
function OP(e, t, r, n) {
  const a = Math.floor(e.x + n.cellHorizontalPadding + 1), s = Math.floor(e.y + n.cellVerticalPadding + 1), i = Math.ceil(e.width - n.cellHorizontalPadding * 2 - 1), o = Math.ceil(e.height - n.cellVerticalPadding * 2 - 1);
  return t !== void 0 && r !== void 0 && t + e.x >= a && t + e.x < a + i && r + e.y >= s && r + e.y < s + o;
}
const tle = {
  kind: Gt.Custom,
  isMatch: (e) => e.data.kind === "row-header",
  needsHoverPosition: !0,
  needsHover: !0,
  onSelect: (e) => e.preventDefault(),
  onClick: (e) => {
    const { cell: t, theme: r, bounds: n, posX: a, posY: s } = e;
    OP(n, a, s, r) && t.data.onClick?.();
  },
  drawPrep: (e) => {
    const { ctx: t } = e;
    return t.textAlign = "center", {
      deprep: (r) => {
        r.ctx.textAlign = "start";
      }
    };
  },
  draw: (e) => {
    const { ctx: t, theme: r, rect: n, hoverX: a, hoverY: s, frameTime: i, drawState: o } = e, l = Math.floor(n.x + r.cellHorizontalPadding + 1), u = Math.floor(n.y + r.cellVerticalPadding + 1), c = Math.ceil(n.width - r.cellHorizontalPadding * 2 - 1), d = Math.ceil(n.height - r.cellVerticalPadding * 2 - 1);
    if (c <= 0 || d <= 0) return !0;
    const p = OP(n, a, s, r);
    let [f, h] = o;
    p && e.overrideCursor?.("pointer"), f ??= { hovered: !1, animationStartTime: 0 }, p !== f.hovered && (f = { ...f, hovered: p, animationStartTime: i }, h(f));
    const m = Math.min(1, (i - f.animationStartTime) / 200), y = p ? m : 1 - m;
    m < 1 && e.requestAnimationFrame?.();
    const b = 4, v = p ? r.bgHeader : r.bgCell, x = p ? r.textDark : r.textLight;
    t.beginPath(), os(t, l, u, c, d, b), t.fillStyle = l1(v, r, y), t.fill();
    const _ = r.borderColor;
    return t.beginPath(), os(
      t,
      l + 0.5,
      u + 0.5,
      c - 1,
      d - 1,
      r.roundingRadius || 4
    ), t.strokeStyle = l1(_, r, y), t.lineWidth = 1, t.stroke(), t.fillStyle = l1(x, r, y), t.fillText(
      "→",
      l + c / 2,
      u + d / 2 + Yo(t, r.baseFontFull),
      c
    ), !0;
  },
  provideEditor: void 0
};
function rle(e) {
  return e.match(/^[0-9]+$/) || e.match(/^[0-9]+\.[0-9]+$/);
}
function nle(e) {
  return e.toUpperCase() === "TRUE" || e.toUpperCase() === "FALSE";
}
function ile(e) {
  return e.match(/\.(jpeg|jpg|gif|png)$/);
}
function ale(e) {
  return e.match(/^(http|https):\/\/[^ "]+$/);
}
const sle = (e) => rle(e) ? Gt.Number : nle(e) ? Gt.Boolean : ile(e) ? Gt.Image : ale(e) ? Gt.Uri : Gt.Text, Vz = (e) => {
  const {
    columns: t,
    data: r,
    openable: n = !1,
    onOpen: a,
    onReachedBottom: s,
    width: i,
    height: o
  } = e, [l, u] = D.useState({}), c = D.useMemo(() => n ? [{ title: "", id: "morphRowHeader", width: 50 }, ...t] : t, [t, n]), d = D.useMemo(() => c.map((m) => {
    const y = m.id;
    return l[y] ? { ...m, width: l[y] } : m;
  }), [c, l]), p = D.useCallback(
    (m) => {
      const [y, b] = m, v = r[b];
      if (n && y === 0)
        return {
          kind: Gt.Custom,
          allowOverlay: !0,
          data: {
            kind: "row-header",
            value: v,
            onClick: () => a?.(v)
          },
          copyData: ""
        };
      const x = c.map(
        (w) => w.id
      ), _ = v[x[y]], E = sle(String(_));
      return E === Gt.Text ? {
        kind: Gt.Text,
        allowOverlay: !1,
        displayData: _ ? String(_) : "",
        data: _ ? String(_) : ""
      } : E === Gt.Uri ? {
        kind: Gt.Uri,
        allowOverlay: !1,
        displayData: _ ? String(_) : "",
        data: _ ? String(_) : "",
        readonly: !0,
        hoverEffect: !0,
        onClickUri: () => {
          window?.open(String(_), "_blank");
        }
      } : E === Gt.Number ? {
        kind: Gt.Number,
        allowOverlay: !1,
        displayData: _ ? String(_) : "",
        data: _ ? Number(_) : void 0
      } : E === Gt.Image ? {
        kind: Gt.Image,
        allowOverlay: !1,
        displayData: [_ ? String(_) : ""],
        data: [_ ? String(_) : ""],
        readonly: !0
      } : E === Gt.Boolean ? {
        kind: Gt.Boolean,
        allowOverlay: !1,
        data: _ ? !!_ : !1,
        readonly: !0
      } : {
        kind: Gt.Text,
        allowOverlay: !1,
        displayData: String(_),
        data: String(_)
      };
    },
    [c, r, a, n]
  ), f = D.useCallback(
    (m) => {
      m.y + m.height - 1 >= r.length - 5 && s?.();
    },
    [r.length, s]
  ), h = D.useCallback(
    (m, y) => {
      if (m.id) {
        const b = m.id;
        u((v) => ({
          ...v,
          [b]: y
        }));
      }
    },
    []
  );
  return /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K(
    ele,
    {
      getCellContent: p,
      columns: d,
      rows: r.length,
      width: i || "100%",
      height: o,
      freezeColumns: n ? 1 : 0,
      customRenderers: [tle],
      onVisibleRegionChanged: f,
      onColumnResize: h,
      maxColumnAutoWidth: 500,
      maxColumnWidth: 800,
      overscrollX: 200,
      overscrollY: 200,
      theme: {
        accentColor: "#111827",
        accentLight: "#f3f4f6"
      },
      getCellsForSelection: !0
    }
  ) });
};
function Gz(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (r = Gz(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function HI() {
  for (var e, t, r = 0, n = "", a = arguments.length; r < a; r++) (e = arguments[r]) && (t = Gz(e)) && (n && (n += " "), n += t);
  return n;
}
const VI = "-", ole = (e) => {
  const t = ule(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = e;
  return {
    getClassGroupId: (i) => {
      const o = i.split(VI);
      return o[0] === "" && o.length !== 1 && o.shift(), Wz(o, t) || lle(i);
    },
    getConflictingClassGroupIds: (i, o) => {
      const l = r[i] || [];
      return o && n[i] ? [...l, ...n[i]] : l;
    }
  };
}, Wz = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], n = t.nextPart.get(r), a = n ? Wz(e.slice(1), n) : void 0;
  if (a)
    return a;
  if (t.validators.length === 0)
    return;
  const s = e.join(VI);
  return t.validators.find(({
    validator: i
  }) => i(s))?.classGroupId;
}, PP = /^\[(.+)\]$/, lle = (e) => {
  if (PP.test(e)) {
    const t = PP.exec(e)[1], r = t?.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, ule = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return dle(Object.entries(e.classGroups), r).forEach(([s, i]) => {
    HT(i, n, s, t);
  }), n;
}, HT = (e, t, r, n) => {
  e.forEach((a) => {
    if (typeof a == "string") {
      const s = a === "" ? t : LP(t, a);
      s.classGroupId = r;
      return;
    }
    if (typeof a == "function") {
      if (cle(a)) {
        HT(a(n), t, r, n);
        return;
      }
      t.validators.push({
        validator: a,
        classGroupId: r
      });
      return;
    }
    Object.entries(a).forEach(([s, i]) => {
      HT(i, LP(t, s), r, n);
    });
  });
}, LP = (e, t) => {
  let r = e;
  return t.split(VI).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, cle = (e) => e.isThemeGetter, dle = (e, t) => t ? e.map(([r, n]) => {
  const a = n.map((s) => typeof s == "string" ? t + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([i, o]) => [t + i, o])) : s);
  return [r, a];
}) : e, fle = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const a = (s, i) => {
    r.set(s, i), t++, t > e && (t = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let i = r.get(s);
      if (i !== void 0)
        return i;
      if ((i = n.get(s)) !== void 0)
        return a(s, i), i;
    },
    set(s, i) {
      r.has(s) ? r.set(s, i) : a(s, i);
    }
  };
}, Kz = "!", ple = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, n = t.length === 1, a = t[0], s = t.length, i = (o) => {
    const l = [];
    let u = 0, c = 0, d;
    for (let y = 0; y < o.length; y++) {
      let b = o[y];
      if (u === 0) {
        if (b === a && (n || o.slice(y, y + s) === t)) {
          l.push(o.slice(c, y)), c = y + s;
          continue;
        }
        if (b === "/") {
          d = y;
          continue;
        }
      }
      b === "[" ? u++ : b === "]" && u--;
    }
    const p = l.length === 0 ? o : o.substring(c), f = p.startsWith(Kz), h = f ? p.substring(1) : p, m = d && d > c ? d - c : void 0;
    return {
      modifiers: l,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: m
    };
  };
  return r ? (o) => r({
    className: o,
    parseClassName: i
  }) : i;
}, hle = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((n) => {
    n[0] === "[" ? (t.push(...r.sort(), n), r = []) : r.push(n);
  }), t.push(...r.sort()), t;
}, mle = (e) => ({
  cache: fle(e.cacheSize),
  parseClassName: ple(e),
  ...ole(e)
}), gle = /\s+/, ble = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: a
  } = t, s = [], i = e.trim().split(gle);
  let o = "";
  for (let l = i.length - 1; l >= 0; l -= 1) {
    const u = i[l], {
      modifiers: c,
      hasImportantModifier: d,
      baseClassName: p,
      maybePostfixModifierPosition: f
    } = r(u);
    let h = !!f, m = n(h ? p.substring(0, f) : p);
    if (!m) {
      if (!h) {
        o = u + (o.length > 0 ? " " + o : o);
        continue;
      }
      if (m = n(p), !m) {
        o = u + (o.length > 0 ? " " + o : o);
        continue;
      }
      h = !1;
    }
    const y = hle(c).join(":"), b = d ? y + Kz : y, v = b + m;
    if (s.includes(v))
      continue;
    s.push(v);
    const x = a(m, h);
    for (let _ = 0; _ < x.length; ++_) {
      const E = x[_];
      s.push(b + E);
    }
    o = u + (o.length > 0 ? " " + o : o);
  }
  return o;
};
function yle() {
  let e = 0, t, r, n = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = Yz(t)) && (n && (n += " "), n += r);
  return n;
}
const Yz = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let n = 0; n < e.length; n++)
    e[n] && (t = Yz(e[n])) && (r && (r += " "), r += t);
  return r;
};
function VT(e, ...t) {
  let r, n, a, s = i;
  function i(l) {
    const u = t.reduce((c, d) => d(c), e());
    return r = mle(u), n = r.cache.get, a = r.cache.set, s = o, o(l);
  }
  function o(l) {
    const u = n(l);
    if (u)
      return u;
    const c = ble(l, r);
    return a(l, c), c;
  }
  return function() {
    return s(yle.apply(null, arguments));
  };
}
const Jn = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, Xz = /^\[(?:([a-z-]+):)?(.+)\]$/i, vle = /^\d+\/\d+$/, wle = /* @__PURE__ */ new Set(["px", "full", "screen"]), xle = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Ele = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Sle = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, _le = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, kle = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, So = (e) => qc(e) || wle.has(e) || vle.test(e), gl = (e) => _d(e, "length", Ole), qc = (e) => !!e && !Number.isNaN(Number(e)), u1 = (e) => _d(e, "number", qc), cf = (e) => !!e && Number.isInteger(Number(e)), Cle = (e) => e.endsWith("%") && qc(e.slice(0, -1)), Qr = (e) => Xz.test(e), bl = (e) => xle.test(e), Ale = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Tle = (e) => _d(e, Ale, Zz), Rle = (e) => _d(e, "position", Zz), Ile = /* @__PURE__ */ new Set(["image", "url"]), Nle = (e) => _d(e, Ile, Lle), Dle = (e) => _d(e, "", Ple), df = () => !0, _d = (e, t, r) => {
  const n = Xz.exec(e);
  return n ? n[1] ? typeof t == "string" ? n[1] === t : t.has(n[1]) : r(n[2]) : !1;
}, Ole = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Ele.test(e) && !Sle.test(e)
), Zz = () => !1, Ple = (e) => _le.test(e), Lle = (e) => kle.test(e), GT = () => {
  const e = Jn("colors"), t = Jn("spacing"), r = Jn("blur"), n = Jn("brightness"), a = Jn("borderColor"), s = Jn("borderRadius"), i = Jn("borderSpacing"), o = Jn("borderWidth"), l = Jn("contrast"), u = Jn("grayscale"), c = Jn("hueRotate"), d = Jn("invert"), p = Jn("gap"), f = Jn("gradientColorStops"), h = Jn("gradientColorStopPositions"), m = Jn("inset"), y = Jn("margin"), b = Jn("opacity"), v = Jn("padding"), x = Jn("saturate"), _ = Jn("scale"), E = Jn("sepia"), w = Jn("skew"), C = Jn("space"), k = Jn("translate"), S = () => ["auto", "contain", "none"], B = () => ["auto", "hidden", "clip", "visible", "scroll"], U = () => ["auto", Qr, t], N = () => [Qr, t], O = () => ["", So, gl], I = () => ["auto", qc, Qr], q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], ae = () => ["solid", "dashed", "dotted", "double", "none"], Q = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], le = () => ["", "0", Qr], W = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], X = () => [qc, Qr];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [df],
      spacing: [So, gl],
      blur: ["none", "", bl, Qr],
      brightness: X(),
      borderColor: [e],
      borderRadius: ["none", "", "full", bl, Qr],
      borderSpacing: N(),
      borderWidth: O(),
      contrast: X(),
      grayscale: le(),
      hueRotate: X(),
      invert: le(),
      gap: N(),
      gradientColorStops: [e],
      gradientColorStopPositions: [Cle, gl],
      inset: U(),
      margin: U(),
      opacity: X(),
      padding: N(),
      saturate: X(),
      scale: X(),
      sepia: le(),
      skew: X(),
      space: N(),
      translate: N()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Qr]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [bl]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": W()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": W()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...q(), Qr]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: B()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": B()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": B()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: S()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": S()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": S()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [m]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [m]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [m]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [m]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [m]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [m]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [m]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [m]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [m]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", cf, Qr]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: U()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Qr]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: le()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: le()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", cf, Qr]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [df]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", cf, Qr]
        }, Qr]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": I()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": I()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [df]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [cf, Qr]
        }, Qr]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": I()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": I()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Qr]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Qr]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [p]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [p]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [p]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...ne()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...ne(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [v]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [v]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [v]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [v]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [v]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [v]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [v]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [v]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [v]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [y]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [y]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [y]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [y]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [y]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [y]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [y]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [y]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [y]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [C]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [C]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Qr, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Qr, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Qr, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [bl]
        }, bl]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Qr, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Qr, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Qr, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Qr, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", bl, gl]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", u1]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [df]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Qr]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", qc, u1]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", So, Qr]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Qr]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Qr]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [b]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [b]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ae(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", So, gl]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", So, Qr]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: N()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Qr]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Qr]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [b]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...q(), Rle]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Tle]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Nle]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [h]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [f]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [b]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ae(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [b]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: ae()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [a]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [a]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...ae()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [So, Qr]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [So, gl]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: O()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [b]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [So, gl]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", bl, Dle]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [df]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [b]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...Q(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Q()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", bl, Qr]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [E]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [b]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [E]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Qr]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: X()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Qr]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: X()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Qr]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [_]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [_]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [_]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [cf, Qr]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [k]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [k]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [w]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [w]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Qr]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Qr]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": N()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": N()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": N()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": N()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": N()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": N()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": N()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": N()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": N()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": N()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": N()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": N()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": N()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": N()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": N()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": N()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": N()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": N()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Qr]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [So, gl, u1]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Mle = (e, {
  cacheSize: t,
  prefix: r,
  separator: n,
  experimentalParseClassName: a,
  extend: s = {},
  override: i = {}
}) => {
  Ff(e, "cacheSize", t), Ff(e, "prefix", r), Ff(e, "separator", n), Ff(e, "experimentalParseClassName", a);
  for (const o in i)
    Fle(e[o], i[o]);
  for (const o in s)
    $le(e[o], s[o]);
  return e;
}, Ff = (e, t, r) => {
  r !== void 0 && (e[t] = r);
}, Fle = (e, t) => {
  if (t)
    for (const r in t)
      Ff(e, r, t[r]);
}, $le = (e, t) => {
  if (t)
    for (const r in t) {
      const n = t[r];
      n !== void 0 && (e[r] = (e[r] || []).concat(n));
    }
}, Ble = (e, ...t) => typeof e == "function" ? VT(GT, e, ...t) : VT(() => Mle(GT(), e), ...t), GI = /* @__PURE__ */ VT(GT);
function ja(...e) {
  return GI(HI(e));
}
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ule = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Jz = (...e) => e.filter((t, r, n) => !!t && t.trim() !== "" && n.indexOf(t) === r).join(" ").trim();
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var zle = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qle = Mu(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: a = "",
    children: s,
    iconNode: i,
    ...o
  }, l) => RT(
    "svg",
    {
      ref: l,
      ...zle,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: n ? Number(r) * 24 / Number(t) : r,
      className: Jz("lucide", a),
      ...o
    },
    [
      ...i.map(([u, c]) => RT(u, c)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const di = (e, t) => {
  const r = Mu(
    ({ className: n, ...a }, s) => RT(qle, {
      ref: s,
      iconNode: t,
      className: Jz(`lucide-${Ule(e)}`, n),
      ...a
    })
  );
  return r.displayName = `${e}`, r;
};
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jle = [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
], Hle = di("ArrowUp", jle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vle = [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
], Gle = di("Calendar", Vle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wle = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Qz = di("Check", Wle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kle = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], eq = di("ChevronDown", Kle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yle = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], MP = di("ChevronLeft", Yle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xle = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], WT = di("ChevronRight", Xle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zle = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], Jle = di("ChevronUp", Zle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Qle = [
  ["path", { d: "m11 17-5-5 5-5", key: "13zhaf" }],
  ["path", { d: "m18 17-5-5 5-5", key: "h8a8et" }]
], eue = di("ChevronsLeft", Qle);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tue = [
  ["path", { d: "m6 17 5-5-5-5", key: "xnjwq" }],
  ["path", { d: "m13 17 5-5-5-5", key: "17xmmf" }]
], rue = di("ChevronsRight", tue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nue = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
], iue = di("ChevronsUpDown", nue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aue = [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
], tq = di("Download", aue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sue = [
  [
    "path",
    {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
    }
  ],
  ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }],
  [
    "path",
    {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
    }
  ],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
], oue = di("EyeOff", sue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lue = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], uue = di("Eye", lue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cue = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], due = di("GripVertical", cue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fue = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
], rq = di("Loader", fue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pue = [
  ["polyline", { points: "15 3 21 3 21 9", key: "mznyad" }],
  ["polyline", { points: "9 21 3 21 3 15", key: "1avn1i" }],
  ["line", { x1: "21", x2: "14", y1: "3", y2: "10", key: "ota7mn" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
], hue = di("Maximize2", pue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mue = [
  ["polyline", { points: "4 14 10 14 10 20", key: "11kfnr" }],
  ["polyline", { points: "20 10 14 10 14 4", key: "rlmsce" }],
  ["line", { x1: "14", x2: "21", y1: "10", y2: "3", key: "o5lafz" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
], gue = di("Minimize2", mue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bue = [["path", { d: "M5 12h14", key: "1ays0h" }]], yue = di("Minus", bue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vue = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], nq = di("Plus", vue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wue = [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
], xue = di("Search", wue);
/**
 * @license lucide-react v0.471.1 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eue = [
  ["path", { d: "M16 12H3", key: "1a2rj7" }],
  ["path", { d: "M16 18H3", key: "12xzn7" }],
  ["path", { d: "M16 6H3", key: "1wxfjs" }],
  ["path", { d: "M21 12h.01", key: "msek7k" }],
  ["path", { d: "M21 18h.01", key: "1e8rq1" }],
  ["path", { d: "M21 6h.01", key: "1koanj" }]
], Sue = di("TableOfContents", Eue), _ue = "w-16 h-16 rounded-full animate-spin", Cu = D.forwardRef(
  (e, t) => {
    const { className: r, ...n } = e;
    return /* @__PURE__ */ K(
      rq,
      {
        ref: t,
        className: ja(_ue, r),
        ...n
      }
    );
  }
);
Cu.displayName = "LoadingSpinner";
var FP = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, va = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, kue = (e, t) => JSON.stringify(e) === JSON.stringify(t);
function iq(e, t) {
  e.forEach(function(r) {
    Array.isArray(r) ? iq(r, t) : t.push(r);
  });
}
function aq(e) {
  let t = [];
  return iq(e, t), t;
}
var sq = (...e) => aq(e).filter(Boolean), oq = (e, t) => {
  let r = {}, n = Object.keys(e), a = Object.keys(t);
  for (let s of n) if (a.includes(s)) {
    let i = e[s], o = t[s];
    Array.isArray(i) || Array.isArray(o) ? r[s] = sq(o, i) : typeof i == "object" && typeof o == "object" ? r[s] = oq(i, o) : r[s] = o + " " + i;
  } else r[s] = e[s];
  for (let s of a) n.includes(s) || (r[s] = t[s]);
  return r;
}, $P = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim(), Cue = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 }, lq = (e) => e || void 0, Ep = (...e) => lq(aq(e).filter(Boolean).join(" ")), c1 = null, Ro = {}, KT = !1, ff = (...e) => (t) => t.twMerge ? ((!c1 || KT) && (KT = !1, c1 = va(Ro) ? GI : Ble({ ...Ro, extend: { theme: Ro.theme, classGroups: Ro.classGroups, conflictingClassGroupModifiers: Ro.conflictingClassGroupModifiers, conflictingClassGroups: Ro.conflictingClassGroups, ...Ro.extend } })), lq(c1(Ep(e)))) : Ep(e), BP = (e, t) => {
  for (let r in t) e.hasOwnProperty(r) ? e[r] = Ep(e[r], t[r]) : e[r] = t[r];
  return e;
}, uh = (e, t) => {
  let { extend: r = null, slots: n = {}, variants: a = {}, compoundVariants: s = [], compoundSlots: i = [], defaultVariants: o = {} } = e, l = { ...Cue, ...t }, u = r != null && r.base ? Ep(r.base, e?.base) : e?.base, c = r != null && r.variants && !va(r.variants) ? oq(a, r.variants) : a, d = r != null && r.defaultVariants && !va(r.defaultVariants) ? { ...r.defaultVariants, ...o } : o;
  !va(l.twMergeConfig) && !kue(l.twMergeConfig, Ro) && (KT = !0, Ro = l.twMergeConfig);
  let p = va(r?.slots), f = va(n) ? {} : { base: Ep(e?.base, p && r?.base), ...n }, h = p ? f : BP({ ...r?.slots }, va(f) ? { base: e?.base } : f), m = va(r?.compoundVariants) ? s : sq(r?.compoundVariants, s), y = (v) => {
    if (va(c) && va(n) && p) return ff(u, v?.class, v?.className)(l);
    if (m && !Array.isArray(m)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof m}`);
    if (i && !Array.isArray(i)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof i}`);
    let x = (N, O, I = [], q) => {
      let ae = I;
      if (typeof O == "string") ae = ae.concat($P(O).split(" ").map((Q) => `${N}:${Q}`));
      else if (Array.isArray(O)) ae = ae.concat(O.reduce((Q, ne) => Q.concat(`${N}:${ne}`), []));
      else if (typeof O == "object" && typeof q == "string") {
        for (let Q in O) if (O.hasOwnProperty(Q) && Q === q) {
          let ne = O[Q];
          if (ne && typeof ne == "string") {
            let le = $P(ne);
            ae[q] ? ae[q] = ae[q].concat(le.split(" ").map((W) => `${N}:${W}`)) : ae[q] = le.split(" ").map((W) => `${N}:${W}`);
          } else Array.isArray(ne) && ne.length > 0 && (ae[q] = ne.reduce((le, W) => le.concat(`${N}:${W}`), []));
        }
      }
      return ae;
    }, _ = (N, O = c, I = null, q = null) => {
      var ae;
      let Q = O[N];
      if (!Q || va(Q)) return null;
      let ne = (ae = q?.[N]) != null ? ae : v?.[N];
      if (ne === null) return null;
      let le = FP(ne), W = Array.isArray(l.responsiveVariants) && l.responsiveVariants.length > 0 || l.responsiveVariants === !0, X = d?.[N], G = [];
      if (typeof le == "object" && W) for (let [ye, pe] of Object.entries(le)) {
        let $ = Q[pe];
        if (ye === "initial") {
          X = pe;
          continue;
        }
        Array.isArray(l.responsiveVariants) && !l.responsiveVariants.includes(ye) || (G = x(ye, $, G, I));
      }
      let P = le != null && typeof le != "object" ? le : FP(X), he = Q[P || "false"];
      return typeof G == "object" && typeof I == "string" && G[I] ? BP(G, he) : G.length > 0 ? (G.push(he), I === "base" ? G.join(" ") : G) : he;
    }, E = () => c ? Object.keys(c).map((N) => _(N, c)) : null, w = (N, O) => {
      if (!c || typeof c != "object") return null;
      let I = new Array();
      for (let q in c) {
        let ae = _(q, c, N, O), Q = N === "base" && typeof ae == "string" ? ae : ae && ae[N];
        Q && (I[I.length] = Q);
      }
      return I;
    }, C = {};
    for (let N in v) v[N] !== void 0 && (C[N] = v[N]);
    let k = (N, O) => {
      var I;
      let q = typeof v?.[N] == "object" ? { [N]: (I = v[N]) == null ? void 0 : I.initial } : {};
      return { ...d, ...C, ...q, ...O };
    }, S = (N = [], O) => {
      let I = [];
      for (let { class: q, className: ae, ...Q } of N) {
        let ne = !0;
        for (let [le, W] of Object.entries(Q)) {
          let X = k(le, O)[le];
          if (Array.isArray(W)) {
            if (!W.includes(X)) {
              ne = !1;
              break;
            }
          } else {
            let G = (P) => P == null || P === !1;
            if (G(W) && G(X)) continue;
            if (X !== W) {
              ne = !1;
              break;
            }
          }
        }
        ne && (q && I.push(q), ae && I.push(ae));
      }
      return I;
    }, B = (N) => {
      let O = S(m, N);
      if (!Array.isArray(O)) return O;
      let I = {};
      for (let q of O) if (typeof q == "string" && (I.base = ff(I.base, q)(l)), typeof q == "object") for (let [ae, Q] of Object.entries(q)) I[ae] = ff(I[ae], Q)(l);
      return I;
    }, U = (N) => {
      if (i.length < 1) return null;
      let O = {};
      for (let { slots: I = [], class: q, className: ae, ...Q } of i) {
        if (!va(Q)) {
          let ne = !0;
          for (let le of Object.keys(Q)) {
            let W = k(le, N)[le];
            if (W === void 0 || (Array.isArray(Q[le]) ? !Q[le].includes(W) : Q[le] !== W)) {
              ne = !1;
              break;
            }
          }
          if (!ne) continue;
        }
        for (let ne of I) O[ne] = O[ne] || [], O[ne].push([q, ae]);
      }
      return O;
    };
    if (!va(n) || !p) {
      let N = {};
      if (typeof h == "object" && !va(h)) for (let O of Object.keys(h)) N[O] = (I) => {
        var q, ae;
        return ff(h[O], w(O, I), ((q = B(I)) != null ? q : [])[O], ((ae = U(I)) != null ? ae : [])[O], I?.class, I?.className)(l);
      };
      return N;
    }
    return ff(u, E(), S(m), v?.class, v?.className)(l);
  }, b = () => {
    if (!(!c || typeof c != "object")) return Object.keys(c);
  };
  return y.variantKeys = b(), y.extend = r, y.base = u, y.slots = h, y.variants = c, y.defaultVariants = d, y.compoundSlots = i, y.compoundVariants = m, y;
};
function gr(...e) {
  return GI(HI(...e));
}
const ch = [
  // base
  "focus:ring-2",
  // ring color
  "focus:ring-gray-200 focus:dark:ring-gray-700/30",
  // border color
  "focus:border-gray-500 focus:dark:border-gray-700"
], dh = [
  // base
  "outline outline-offset-2 outline-0 focus-visible:outline-2",
  // outline color
  "outline-gray-500 dark:outline-gray-500"
], Fb = [
  // base
  "ring-2",
  // border color
  "border-red-500 dark:border-red-700",
  // ring color
  "ring-red-200 dark:ring-red-700/30"
], Aue = uh({
  base: "flex flex-col overflow-hidden rounded-md p-4 text-sm",
  variants: {
    variant: {
      default: [
        // text color
        "text-blue-900 dark:text-blue-400",
        // background color
        "bg-blue-50 dark:bg-blue-950/70"
      ],
      success: [
        // text color
        "text-emerald-900 dark:text-emerald-500",
        // background color
        "bg-emerald-50 dark:bg-emerald-950/70"
      ],
      error: [
        // text color
        "text-red-900 dark:text-red-500",
        // background color
        "bg-red-50 dark:bg-red-950/70"
      ],
      destructive: [
        // text color
        "text-red-900 dark:text-red-500",
        // background color
        "bg-red-50 dark:bg-red-950/70"
      ],
      warning: [
        // text color
        "text-yellow-900 dark:text-yellow-500",
        // background color
        "bg-yellow-50 dark:bg-yellow-950/70"
      ],
      neutral: [
        // text color
        "text-gray-900 dark:text-gray-400",
        // background color
        "bg-gray-100 dark:bg-gray-800/70"
      ]
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), kd = kt.forwardRef(
  ({ title: e, icon: t, className: r, variant: n, children: a, ...s }, i) => /* @__PURE__ */ $t(
    "div",
    {
      ref: i,
      className: gr(Aue({ variant: n }), r),
      "tremor-id": "tremor-raw",
      ...s,
      children: [
        /* @__PURE__ */ $t("div", { className: gr("flex items-start"), children: [
          t && typeof t == "function" ? /* @__PURE__ */ K(
            t,
            {
              className: gr("mr-1.5 h-5 w-5 shrink-0"),
              "aria-hidden": "true"
            }
          ) : t,
          /* @__PURE__ */ K("span", { className: gr("font-semibold"), children: e })
        ] }),
        /* @__PURE__ */ K("div", { className: gr("overflow-y-auto", a ? "mt-2" : ""), children: a })
      ]
    }
  )
);
kd.displayName = "Callout";
const Tue = [
  {
    title: "XXX",
    id: "001"
  },
  {
    title: "XXX",
    id: "002"
  },
  {
    title: "XXX",
    id: "003"
  },
  {
    title: "XXX",
    id: "004"
  },
  {
    title: "XXX",
    id: "005"
  }
], Rue = {
  "001": "---",
  "002": "---",
  "003": "---",
  "004": "---",
  "005": "---"
}, Iue = Array.from({ length: 100 }, () => ({
  ...Rue
})), Nue = (e) => {
  const { error: t, width: r, height: n } = e;
  return /* @__PURE__ */ $t("div", { className: "relative", children: [
    /* @__PURE__ */ K(Vz, { columns: Tue, data: Iue, width: r, height: n }),
    /* @__PURE__ */ K("div", { className: "absolute top-12 left-0 right-0 flex justify-center items-center", children: /* @__PURE__ */ K(
      kd,
      {
        title: "An error occured with DataTable comopnent.",
        className: "shadow-lg",
        variant: "error",
        children: /* @__PURE__ */ $t("div", { className: "mt-3", children: [
          "Error Message: ",
          t.message
        ] })
      }
    ) })
  ] });
}, fh = (e) => {
  const { alias: t, loadData: r } = e;
  if (!r && !t)
    throw new Error("Either alias or loadData must be provided");
  return r || t || "";
}, Ize = (e) => {
  const {
    alias: t,
    loadData: r,
    loadDataUrl: n = (b) => `${window.location.protocol}//${window.location.host}/cli/run/${b}/json`,
    // postData,
    variables: a = {},
    headerKeys: s,
    height: i,
    width: o
  } = e, l = fh({ loadData: r, alias: t }), { items: u, count: c, error: d, isLoading: p, goNextPage: f, hasNext: h } = Ab({
    loadData: l,
    variables: a,
    loadDataUrl: n
  }), m = ci(() => {
    !h || p || f();
  }, [f, h, p]), y = Or(() => u.length === 0 ? [] : s ? s.map((b) => ({
    id: b,
    title: b
  })) : Object.keys(u[0]).map((b) => ({
    id: b,
    title: b
  })), [u, s]);
  return /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K("div", { className: "relative", children: d ? /* @__PURE__ */ K(Nue, { error: d, height: i, width: o }) : /* @__PURE__ */ $t(ln, { children: [
    /* @__PURE__ */ K(
      Vz,
      {
        columns: y,
        data: u,
        height: i,
        width: o,
        onReachedBottom: m
      },
      `data-grid-${r}`
    ),
    c && /* @__PURE__ */ $t("div", { className: "text-sm text-gray-500", children: [
      "Total Rows: ",
      c.toLocaleString()
    ] }),
    p && /* @__PURE__ */ K(Cu, { className: "h-4 w-4 text-gray-500" })
  ] }) }) });
}, Due = _a.object({
  type: _a.literal("html"),
  data: _a.string()
}), Oue = (e) => {
  const { loadData: t, variables: r, loadDataUrl: n } = e, a = kb(r), s = Or(() => _U(
    [t, "html", JSON.stringify(a)],
    {
      fetcher: async () => {
        const c = await (await fetch(`${n(t)}`, {
          method: "POST",
          body: JSON.stringify({
            variables: a
          }),
          headers: {
            "content-type": "application/json"
          }
        })).json(), d = Due.safeParse(c);
        if (!d.success)
          throw new Error("Invalid response");
        return d.data;
      },
      cacheLifetime: 1e3 * 60 * 5
    }
  ), [t, JSON.stringify(a)]), { data: i, error: o, loading: l } = _c(s);
  return {
    data: i,
    error: o,
    isLoading: l
  };
}, Pue = new Blob(
  [
    `<html>
      <head>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/destyle.css@1.0.15/destyle.css"
        />
      </head>
      <body><div><script>window.PlotlyConfig={MathJaxConfig:"local"}<\/script><script charset=utf-8 src=https://cdn.plot.ly/plotly-2.35.2.min.js><\/script><div class=plotly-graph-div id=980be6b7-6fff-4059-a5cc-cfb5eaf18a87 style=height:100%;width:100%></div><script>window.PLOTLYENV=window.PLOTLYENV||{},document.getElementById("980be6b7-6fff-4059-a5cc-cfb5eaf18a87")&&Plotly.newPlot("980be6b7-6fff-4059-a5cc-cfb5eaf18a87",[{alignmentgroup:"True",hovertemplate:"Category=%{x}<br>Y Axis=%{y}<extra></extra>",legendgroup:"",marker:{color:"#636efa",pattern:{shape:""}},name:"",offsetgroup:"",orientation:"v",showlegend:!1,textposition:"auto",x:["A","B","C"],xaxis:"x",y:[.47639858654107337,.4904209303692657,.5314829741213475],yaxis:"y",type:"bar"}],{template:{data:{histogram2dcontour:[{type:"histogram2dcontour",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],choropleth:[{type:"choropleth",colorbar:{outlinewidth:0,ticks:""}}],histogram2d:[{type:"histogram2d",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],heatmap:[{type:"heatmap",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],heatmapgl:[{type:"heatmapgl",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],contourcarpet:[{type:"contourcarpet",colorbar:{outlinewidth:0,ticks:""}}],contour:[{type:"contour",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],surface:[{type:"surface",colorbar:{outlinewidth:0,ticks:""},colorscale:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]]}],mesh3d:[{type:"mesh3d",colorbar:{outlinewidth:0,ticks:""}}],scatter:[{fillpattern:{fillmode:"overlay",size:10,solidity:.2},type:"scatter"}],parcoords:[{type:"parcoords",line:{colorbar:{outlinewidth:0,ticks:""}}}],scatterpolargl:[{type:"scatterpolargl",marker:{colorbar:{outlinewidth:0,ticks:""}}}],bar:[{error_x:{color:"#2a3f5f"},error_y:{color:"#2a3f5f"},marker:{line:{color:"#E5ECF6",width:.5},pattern:{fillmode:"overlay",size:10,solidity:.2}},type:"bar"}],scattergeo:[{type:"scattergeo",marker:{colorbar:{outlinewidth:0,ticks:""}}}],scatterpolar:[{type:"scatterpolar",marker:{colorbar:{outlinewidth:0,ticks:""}}}],histogram:[{marker:{pattern:{fillmode:"overlay",size:10,solidity:.2}},type:"histogram"}],scattergl:[{type:"scattergl",marker:{colorbar:{outlinewidth:0,ticks:""}}}],scatter3d:[{type:"scatter3d",line:{colorbar:{outlinewidth:0,ticks:""}},marker:{colorbar:{outlinewidth:0,ticks:""}}}],scattermapbox:[{type:"scattermapbox",marker:{colorbar:{outlinewidth:0,ticks:""}}}],scatterternary:[{type:"scatterternary",marker:{colorbar:{outlinewidth:0,ticks:""}}}],scattercarpet:[{type:"scattercarpet",marker:{colorbar:{outlinewidth:0,ticks:""}}}],carpet:[{aaxis:{endlinecolor:"#2a3f5f",gridcolor:"white",linecolor:"white",minorgridcolor:"white",startlinecolor:"#2a3f5f"},baxis:{endlinecolor:"#2a3f5f",gridcolor:"white",linecolor:"white",minorgridcolor:"white",startlinecolor:"#2a3f5f"},type:"carpet"}],table:[{cells:{fill:{color:"#EBF0F8"},line:{color:"white"}},header:{fill:{color:"#C8D4E3"},line:{color:"white"}},type:"table"}],barpolar:[{marker:{line:{color:"#E5ECF6",width:.5},pattern:{fillmode:"overlay",size:10,solidity:.2}},type:"barpolar"}],pie:[{automargin:!0,type:"pie"}]},layout:{autotypenumbers:"strict",colorway:["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],font:{color:"#2a3f5f"},hovermode:"closest",hoverlabel:{align:"left"},paper_bgcolor:"white",plot_bgcolor:"#E5ECF6",polar:{bgcolor:"#E5ECF6",angularaxis:{gridcolor:"white",linecolor:"white",ticks:""},radialaxis:{gridcolor:"white",linecolor:"white",ticks:""}},ternary:{bgcolor:"#E5ECF6",aaxis:{gridcolor:"white",linecolor:"white",ticks:""},baxis:{gridcolor:"white",linecolor:"white",ticks:""},caxis:{gridcolor:"white",linecolor:"white",ticks:""}},coloraxis:{colorbar:{outlinewidth:0,ticks:""}},colorscale:{sequential:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]],sequentialminus:[[0,"#0d0887"],[.1111111111111111,"#46039f"],[.2222222222222222,"#7201a8"],[.3333333333333333,"#9c179e"],[.4444444444444444,"#bd3786"],[.5555555555555556,"#d8576b"],[.6666666666666666,"#ed7953"],[.7777777777777778,"#fb9f3a"],[.8888888888888888,"#fdca26"],[1,"#f0f921"]],diverging:[[0,"#8e0152"],[.1,"#c51b7d"],[.2,"#de77ae"],[.3,"#f1b6da"],[.4,"#fde0ef"],[.5,"#f7f7f7"],[.6,"#e6f5d0"],[.7,"#b8e186"],[.8,"#7fbc41"],[.9,"#4d9221"],[1,"#276419"]]},xaxis:{gridcolor:"white",linecolor:"white",ticks:"",title:{standoff:15},zerolinecolor:"white",automargin:!0,zerolinewidth:2},yaxis:{gridcolor:"white",linecolor:"white",ticks:"",title:{standoff:15},zerolinecolor:"white",automargin:!0,zerolinewidth:2},scene:{xaxis:{backgroundcolor:"#E5ECF6",gridcolor:"white",linecolor:"white",showbackground:!0,ticks:"",zerolinecolor:"white",gridwidth:2},yaxis:{backgroundcolor:"#E5ECF6",gridcolor:"white",linecolor:"white",showbackground:!0,ticks:"",zerolinecolor:"white",gridwidth:2},zaxis:{backgroundcolor:"#E5ECF6",gridcolor:"white",linecolor:"white",showbackground:!0,ticks:"",zerolinecolor:"white",gridwidth:2}},shapedefaults:{line:{color:"#2a3f5f"}},annotationdefaults:{arrowcolor:"#2a3f5f",arrowhead:0,arrowwidth:1},geo:{bgcolor:"white",landcolor:"#E5ECF6",subunitcolor:"white",showland:!0,showlakes:!0,lakecolor:"white"},title:{x:.05},mapbox:{style:"light"}}},xaxis:{anchor:"y",domain:[0,1],title:{text:"Category"}},yaxis:{anchor:"x",domain:[0,1],title:{text:"Values"}},legend:{tracegroupgap:0},title:{text:"Sample Chart"},barmode:"relative"},{modeBarButtonsToRemove:["zoom","pan","select","zoomIn","zoomOut","autoScale","resetScale","lasso2d"],displaylogo:!1,responsive:!0})<\/script></div></body>
    </html>`
  ],
  { type: "text/html" }
), UP = URL.createObjectURL(Pue), Lue = (e) => {
  const { height: t, width: r, error: n } = e;
  return /* @__PURE__ */ $t(
    "div",
    {
      className: "relative",
      style: {
        height: t,
        width: r
      },
      children: [
        /* @__PURE__ */ K(
          "iframe",
          {
            className: "opacity-60",
            width: r,
            height: t,
            src: UP
          },
          UP
        ),
        /* @__PURE__ */ K("div", { className: "absolute top-0 left-0 right-0 bottom-0 flex justify-center items-center", children: /* @__PURE__ */ K(
          kd,
          {
            title: "An error occured with Embed comopnent.",
            className: "shadow-lg",
            variant: "error",
            children: /* @__PURE__ */ $t("div", { className: "mt-3", children: [
              "Error Message: ",
              n.message
            ] })
          }
        ) })
      ]
    }
  );
}, Nze = (e) => {
  const {
    alias: t,
    loadData: r,
    loadDataUrl: n = (p) => `${window.location.protocol}//${window.location.host}/cli/run/${p}/html`,
    // postData,
    variables: a = {},
    width: s,
    height: i
  } = e, o = fh({ loadData: r, alias: t }), { data: l, error: u, isLoading: c } = Oue({
    loadData: o,
    variables: a,
    loadDataUrl: n
  }), d = Or(() => {
    if (!l)
      return;
    const p = new Blob(
      [
        `<html>
          <head></head>
          <body>${l.data}</body>
        </html>`
      ],
      { type: "text/html" }
    );
    return URL.createObjectURL(p);
  }, [l]);
  return u ? /* @__PURE__ */ K(Lue, { error: u, height: i, width: s }) : /* @__PURE__ */ $t(ln, { children: [
    /* @__PURE__ */ K(
      "iframe",
      {
        title: "MorphEmbed",
        width: s,
        height: i,
        src: d
      },
      d
    ),
    c && /* @__PURE__ */ K(Cu, { className: "h-4 w-4 text-gray-500 absolute top-2 left-2" })
  ] });
};
function zP(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function ph(...e) {
  return (t) => {
    let r = !1;
    const n = e.map((a) => {
      const s = zP(a, t);
      return !r && typeof s == "function" && (r = !0), s;
    });
    if (r)
      return () => {
        for (let a = 0; a < n.length; a++) {
          const s = n[a];
          typeof s == "function" ? s() : zP(e[a], null);
        }
      };
  };
}
function sn(...e) {
  return D.useCallback(ph(...e), e);
}
var zo = D.forwardRef((e, t) => {
  const { children: r, ...n } = e, a = D.Children.toArray(r), s = a.find(Fue);
  if (s) {
    const i = s.props.children, o = a.map((l) => l === s ? D.Children.count(i) > 1 ? D.Children.only(null) : D.isValidElement(i) ? i.props.children : null : l);
    return /* @__PURE__ */ K(YT, { ...n, ref: t, children: D.isValidElement(i) ? D.cloneElement(i, void 0, o) : null });
  }
  return /* @__PURE__ */ K(YT, { ...n, ref: t, children: r });
});
zo.displayName = "Slot";
var YT = D.forwardRef((e, t) => {
  const { children: r, ...n } = e;
  if (D.isValidElement(r)) {
    const a = Bue(r);
    return D.cloneElement(r, {
      ...$ue(n, r.props),
      // @ts-ignore
      ref: t ? ph(t, a) : a
    });
  }
  return D.Children.count(r) > 1 ? D.Children.only(null) : null;
});
YT.displayName = "SlotClone";
var Mue = ({ children: e }) => /* @__PURE__ */ K(ln, { children: e });
function Fue(e) {
  return D.isValidElement(e) && e.type === Mue;
}
function $ue(e, t) {
  const r = { ...t };
  for (const n in t) {
    const a = e[n], s = t[n];
    /^on[A-Z]/.test(n) ? a && s ? r[n] = (...o) => {
      s(...o), a(...o);
    } : a && (r[n] = a) : n === "style" ? r[n] = { ...a, ...s } : n === "className" && (r[n] = [a, s].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function Bue(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
const zu = kt.forwardRef(
  ({ className: e, asChild: t, ...r }, n) => /* @__PURE__ */ K(
    t ? zo : "div",
    {
      ref: n,
      className: gr(
        // base
        "relative w-full rounded-lg border p-6 text-left shadow-sm",
        // background color
        "bg-white dark:bg-[#090E1A]",
        // border color
        "border-gray-200 dark:border-gray-900",
        e
      ),
      "tremor-id": "tremor-raw",
      ...r
    }
  )
);
zu.displayName = "Card";
const Uue = (e) => {
  const { error: t } = e;
  return /* @__PURE__ */ K($b, { label: "metrics", children: /* @__PURE__ */ K(kd, { title: "An error occured with Metrics comopnent.", variant: "error", children: /* @__PURE__ */ $t("div", { className: "mt-3", children: [
    "Error Message: ",
    t.message
  ] }) }) });
}, Dze = (e) => {
  const {
    alias: t,
    loadData: r,
    loadDataUrl: n = (x) => `${window.location.protocol}//${window.location.host}/cli/run/${x}/json`,
    // postData,
    variables: a = {},
    value: s,
    label: i,
    prefix: o,
    suffix: l,
    footer: u
  } = e, c = fh({ loadData: r, alias: t }), { items: d, error: p, isLoading: f } = Ab({
    loadData: c,
    variables: a,
    loadDataUrl: n
  }), h = Or(() => {
    if (!d || d.length === 0)
      return;
    const x = d[0];
    return typeof s == "function" ? s(x) : x[s];
  }, [d, s]), m = Or(() => {
    if (!d || d.length === 0 || !i)
      return;
    const x = d[0];
    return typeof i == "function" ? i(x) : x[i];
  }, [i, d]), y = Or(() => {
    if (!d || d.length === 0 || !o)
      return;
    const x = d[0];
    return typeof o == "function" ? o(x) : x[o];
  }, [d, o]), b = Or(() => {
    if (!d || d.length === 0 || !l)
      return;
    const x = d[0];
    return typeof l == "function" ? l(x) : x[l];
  }, [d, l]), v = Or(() => {
    if (!d || d.length === 0 || !u)
      return;
    const x = d[0];
    return typeof u == "function" ? u(x) : x[u];
  }, [d, u]);
  return /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K(zu, { className: "relative", children: p ? /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K(Uue, { error: p }) }) : /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K(
    $b,
    {
      value: h,
      label: m,
      prefix: y,
      suffix: b,
      footer: v,
      children: f && /* @__PURE__ */ K(Cu, { className: "h-4 w-4 text-gray-500" })
    }
  ) }) }) });
}, $b = (e) => {
  const { label: t, value: r, prefix: n, suffix: a, footer: s, children: i } = e;
  return /* @__PURE__ */ $t("div", { className: "flex flex-col gap-1 items-center w-full", children: [
    /* @__PURE__ */ K("div", { children: t }),
    /* @__PURE__ */ $t("div", { className: "flex items-baseline gap-2", children: [
      /* @__PURE__ */ K("div", { className: "mb-0.5", children: n }),
      /* @__PURE__ */ K("div", { className: "text-4xl font-semibold", children: r }),
      /* @__PURE__ */ K("div", { className: "mb-0.5", children: a })
    ] }),
    /* @__PURE__ */ K("div", { children: s }),
    i
  ] });
}, zue = {
  1: "sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-1 xl:grid-cols-1",
  2: "sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-2 xl:grid-cols-2",
  3: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-3",
  4: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-4",
  5: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5",
  6: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6"
}, que = ({ cols: e, children: t, className: r }) => {
  const n = "grid gap-3", a = zue[e];
  return /* @__PURE__ */ K("div", { className: ja([n, a, r]), children: t });
}, jue = (e) => {
  const t = parseInt(e.cols || "3") || 3, { error: r } = e;
  return /* @__PURE__ */ $t(ln, { children: [
    [...new Array(t * 2)].map((n, a) => /* @__PURE__ */ K(zu, { children: /* @__PURE__ */ K(
      $b,
      {
        label: /* @__PURE__ */ K("span", { className: "opacity-50", children: "metrics" }),
        value: /* @__PURE__ */ K("span", { className: "opacity-50", children: "123.0" })
      }
    ) }, a)),
    /* @__PURE__ */ K("div", { className: "absolute top-12 left-0 right-0 flex justify-center items-center", children: /* @__PURE__ */ K(
      kd,
      {
        title: "An error occured with MetricsGrid comopnent.",
        variant: "error",
        className: "shadow-lg",
        children: /* @__PURE__ */ $t("div", { className: "mt-3", children: [
          "Error Message: ",
          r.message
        ] })
      }
    ) })
  ] });
}, Oze = (e) => {
  const {
    alias: t,
    loadData: r,
    loadDataUrl: n = (y) => `${window.location.protocol}//${window.location.host}/cli/run/${y}/json`,
    variables: a = {},
    cols: s,
    className: i,
    value: o,
    label: l,
    prefix: u,
    suffix: c,
    footer: d
  } = e, p = fh({ loadData: r, alias: t }), { items: f, error: h, isLoading: m } = Ab({
    loadData: p,
    variables: a,
    loadDataUrl: n
  });
  return /* @__PURE__ */ $t(ln, { children: [
    /* @__PURE__ */ K(que, { cols: s, className: `${i} relative`, children: h ? /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ K(jue, { error: h, cols: s }) }) : /* @__PURE__ */ K(ln, { children: f.map((y, b) => /* @__PURE__ */ K(
      Hue,
      {
        item: y,
        label: l,
        value: o,
        prefix: u,
        suffix: c,
        footer: d
      },
      b
    )) }) }),
    m && /* @__PURE__ */ K(Cu, { className: "h-4 w-4 text-gray-500 absolute top-2 left-2" })
  ] });
}, Hue = ({
  item: e,
  value: t,
  label: r,
  prefix: n,
  suffix: a,
  footer: s
}) => {
  const i = Or(() => typeof t == "function" ? t(e) : e[t], [e, t]), o = Or(() => {
    if (r)
      return typeof r == "function" ? r(e) : e[r];
  }, [r, e]), l = Or(() => {
    if (n)
      return typeof n == "function" ? n(e) : e[n];
  }, [e, n]), u = Or(() => {
    if (a)
      return typeof a == "function" ? a(e) : e[a];
  }, [e, a]), c = Or(() => {
    if (s)
      return typeof s == "function" ? s(e) : e[s];
  }, [e, s]);
  return /* @__PURE__ */ K(zu, { children: /* @__PURE__ */ K(
    $b,
    {
      value: i,
      label: o,
      prefix: l,
      suffix: u,
      footer: c
    }
  ) });
}, Vue = uh({
  base: [
    // base
    "relative inline-flex items-center justify-center whitespace-nowrap rounded-md border text-center text-sm font-medium shadow-sm transition-all duration-100 ease-in-out",
    // disabled
    "disabled:pointer-events-none disabled:shadow-none",
    // focus
    dh
  ],
  variants: {
    size: {
      sm: "text-xs px-2.5 py-1.5",
      md: "px-3 py-2",
      lg: "text-base px-4 py-2"
    },
    variant: {
      primary: [
        // border
        "border-transparent",
        // text color
        "text-white dark:text-black",
        // background color
        "bg-gray-900 dark:bg-gray-100",
        // hover color
        "hover:bg-gray-700 dark:hover:bg-gray-300",
        // disabled
        "disabled:bg-gray-300 disabled:text-white",
        "disabled:dark:bg-gray-800 disabled:dark:text-gray-400"
      ],
      secondary: [
        // border
        "border-gray-300 dark:border-gray-800",
        // text color
        "text-gray-900 dark:text-gray-50",
        // background color
        "bg-white dark:bg-gray-950",
        //hover color
        "hover:bg-gray-50 dark:hover:bg-gray-900/60",
        // disabled
        "disabled:text-gray-400",
        "disabled:dark:text-gray-600"
      ],
      light: [
        // base
        "shadow-none",
        // border
        "border-transparent",
        // text color
        "text-gray-900 dark:text-gray-50",
        // background color
        "bg-gray-100 dark:bg-gray-900",
        // hover color
        "hover:bg-gray-300/70 dark:hover:bg-gray-800/80",
        // disabled
        "disabled:bg-gray-100 disabled:text-gray-400",
        "disabled:dark:bg-gray-800 disabled:dark:text-gray-600"
      ],
      ghost: [
        // base
        "shadow-none",
        // border
        "border-transparent",
        // text color
        "text-gray-900 dark:text-gray-50",
        // hover color
        "bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800/80",
        // disabled
        "disabled:text-gray-400",
        "disabled:dark:text-gray-600"
      ],
      destructive: [
        // text color
        "text-white",
        // border
        "border-transparent",
        // background color
        "bg-red-600 dark:bg-red-700",
        // hover color
        "hover:bg-red-700 dark:hover:bg-red-600",
        // disabled
        "disabled:bg-red-300 disabled:text-white",
        "disabled:dark:bg-red-950 disabled:dark:text-red-400"
      ]
    }
  },
  defaultVariants: {
    variant: "primary",
    size: "md"
  }
}), ca = kt.forwardRef(
  ({
    asChild: e,
    isLoading: t = !1,
    loadingText: r,
    className: n,
    disabled: a,
    variant: s,
    size: i,
    children: o,
    ...l
  }, u) => /* @__PURE__ */ K(
    e ? zo : "button",
    {
      ref: u,
      className: gr(Vue({ variant: s, size: i }), n),
      disabled: a || t,
      "tremor-id": "tremor-raw",
      ...l,
      children: t ? /* @__PURE__ */ $t("span", { className: "pointer-events-none flex shrink-0 items-center justify-center gap-1.5", children: [
        /* @__PURE__ */ K(
          rq,
          {
            className: "size-4 shrink-0 animate-spin",
            "aria-hidden": "true"
          }
        ),
        /* @__PURE__ */ K("span", { className: "sr-only", children: r || "Loading" }),
        r || o
      ] }) : o
    }
  )
);
ca.displayName = "Button";
var Gue = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Wr = Gue.reduce((e, t) => {
  const r = D.forwardRef((n, a) => {
    const { asChild: s, ...i } = n, o = s ? zo : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ K(o, { ...i, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function WI(e, t) {
  e && _b.flushSync(() => e.dispatchEvent(t));
}
var Ti = globalThis?.document ? D.useLayoutEffect : () => {
};
function Wue(e, t) {
  return D.useReducer((r, n) => t[r][n] ?? r, e);
}
var Ra = (e) => {
  const { present: t, children: r } = e, n = Kue(t), a = typeof r == "function" ? r({ present: n.isPresent }) : D.Children.only(r), s = sn(n.ref, Yue(a));
  return typeof r == "function" || n.isPresent ? D.cloneElement(a, { ref: s }) : null;
};
Ra.displayName = "Presence";
function Kue(e) {
  const [t, r] = D.useState(), n = D.useRef({}), a = D.useRef(e), s = D.useRef("none"), i = e ? "mounted" : "unmounted", [o, l] = Wue(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return D.useEffect(() => {
    const u = am(n.current);
    s.current = o === "mounted" ? u : "none";
  }, [o]), Ti(() => {
    const u = n.current, c = a.current;
    if (c !== e) {
      const p = s.current, f = am(u);
      e ? l("MOUNT") : f === "none" || u?.display === "none" ? l("UNMOUNT") : l(c && p !== f ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [e, l]), Ti(() => {
    if (t) {
      let u;
      const c = t.ownerDocument.defaultView ?? window, d = (f) => {
        const m = am(n.current).includes(f.animationName);
        if (f.target === t && m && (l("ANIMATION_END"), !a.current)) {
          const y = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = c.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = y);
          });
        }
      }, p = (f) => {
        f.target === t && (s.current = am(n.current));
      };
      return t.addEventListener("animationstart", p), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        c.clearTimeout(u), t.removeEventListener("animationstart", p), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(o),
    ref: D.useCallback((u) => {
      u && (n.current = getComputedStyle(u)), r(u);
    }, [])
  };
}
function am(e) {
  return e?.animationName || "none";
}
function Yue(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
function ds(e, t = []) {
  let r = [];
  function n(s, i) {
    const o = D.createContext(i), l = r.length;
    r = [...r, i];
    const u = (d) => {
      const { scope: p, children: f, ...h } = d, m = p?.[e]?.[l] || o, y = D.useMemo(() => h, Object.values(h));
      return /* @__PURE__ */ K(m.Provider, { value: y, children: f });
    };
    u.displayName = s + "Provider";
    function c(d, p) {
      const f = p?.[e]?.[l] || o, h = D.useContext(f);
      if (h) return h;
      if (i !== void 0) return i;
      throw new Error(`\`${d}\` must be used within \`${s}\``);
    }
    return [u, c];
  }
  const a = () => {
    const s = r.map((i) => D.createContext(i));
    return function(o) {
      const l = o?.[e] || s;
      return D.useMemo(
        () => ({ [`__scope${e}`]: { ...o, [e]: l } }),
        [o, l]
      );
    };
  };
  return a.scopeName = e, [n, Xue(a, ...t)];
}
function Xue(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const r = () => {
    const n = e.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(s) {
      const i = n.reduce((o, { useScope: l, scopeName: u }) => {
        const d = l(s)[`__scope${u}`];
        return { ...o, ...d };
      }, {});
      return D.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
    };
  };
  return r.scopeName = t.scopeName, r;
}
function si(e) {
  const t = D.useRef(e);
  return D.useEffect(() => {
    t.current = e;
  }), D.useMemo(() => (...r) => t.current?.(...r), []);
}
var Zue = D.createContext(void 0);
function hh(e) {
  const t = D.useContext(Zue);
  return e || t || "ltr";
}
function XT(e, [t, r]) {
  return Math.min(r, Math.max(t, e));
}
function nr(e, t, { checkForDefaultPrevented: r = !0 } = {}) {
  return function(a) {
    if (e?.(a), r === !1 || !a.defaultPrevented)
      return t?.(a);
  };
}
function Jue(e, t) {
  return D.useReducer((r, n) => t[r][n] ?? r, e);
}
var KI = "ScrollArea", [uq, Pze] = ds(KI), [Que, fs] = uq(KI), cq = D.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: r,
      type: n = "hover",
      dir: a,
      scrollHideDelay: s = 600,
      ...i
    } = e, [o, l] = D.useState(null), [u, c] = D.useState(null), [d, p] = D.useState(null), [f, h] = D.useState(null), [m, y] = D.useState(null), [b, v] = D.useState(0), [x, _] = D.useState(0), [E, w] = D.useState(!1), [C, k] = D.useState(!1), S = sn(t, (U) => l(U)), B = hh(a);
    return /* @__PURE__ */ K(
      Que,
      {
        scope: r,
        type: n,
        dir: B,
        scrollHideDelay: s,
        scrollArea: o,
        viewport: u,
        onViewportChange: c,
        content: d,
        onContentChange: p,
        scrollbarX: f,
        onScrollbarXChange: h,
        scrollbarXEnabled: E,
        onScrollbarXEnabledChange: w,
        scrollbarY: m,
        onScrollbarYChange: y,
        scrollbarYEnabled: C,
        onScrollbarYEnabledChange: k,
        onCornerWidthChange: v,
        onCornerHeightChange: _,
        children: /* @__PURE__ */ K(
          Wr.div,
          {
            dir: B,
            ...i,
            ref: S,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": b + "px",
              "--radix-scroll-area-corner-height": x + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
cq.displayName = KI;
var dq = "ScrollAreaViewport", fq = D.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: r, children: n, nonce: a, ...s } = e, i = fs(dq, r), o = D.useRef(null), l = sn(t, o, i.onViewportChange);
    return /* @__PURE__ */ $t(ln, { children: [
      /* @__PURE__ */ K(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: a
        }
      ),
      /* @__PURE__ */ K(
        Wr.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...s,
          ref: l,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: i.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: i.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ K("div", { ref: i.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
fq.displayName = dq;
var ho = "ScrollAreaScrollbar", YI = D.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, a = fs(ho, e.__scopeScrollArea), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: i } = a, o = e.orientation === "horizontal";
    return D.useEffect(() => (o ? s(!0) : i(!0), () => {
      o ? s(!1) : i(!1);
    }), [o, s, i]), a.type === "hover" ? /* @__PURE__ */ K(ece, { ...n, ref: t, forceMount: r }) : a.type === "scroll" ? /* @__PURE__ */ K(tce, { ...n, ref: t, forceMount: r }) : a.type === "auto" ? /* @__PURE__ */ K(pq, { ...n, ref: t, forceMount: r }) : a.type === "always" ? /* @__PURE__ */ K(XI, { ...n, ref: t }) : null;
  }
);
YI.displayName = ho;
var ece = D.forwardRef((e, t) => {
  const { forceMount: r, ...n } = e, a = fs(ho, e.__scopeScrollArea), [s, i] = D.useState(!1);
  return D.useEffect(() => {
    const o = a.scrollArea;
    let l = 0;
    if (o) {
      const u = () => {
        window.clearTimeout(l), i(!0);
      }, c = () => {
        l = window.setTimeout(() => i(!1), a.scrollHideDelay);
      };
      return o.addEventListener("pointerenter", u), o.addEventListener("pointerleave", c), () => {
        window.clearTimeout(l), o.removeEventListener("pointerenter", u), o.removeEventListener("pointerleave", c);
      };
    }
  }, [a.scrollArea, a.scrollHideDelay]), /* @__PURE__ */ K(Ra, { present: r || s, children: /* @__PURE__ */ K(
    pq,
    {
      "data-state": s ? "visible" : "hidden",
      ...n,
      ref: t
    }
  ) });
}), tce = D.forwardRef((e, t) => {
  const { forceMount: r, ...n } = e, a = fs(ho, e.__scopeScrollArea), s = e.orientation === "horizontal", i = Ub(() => l("SCROLL_END"), 100), [o, l] = Jue("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return D.useEffect(() => {
    if (o === "idle") {
      const u = window.setTimeout(() => l("HIDE"), a.scrollHideDelay);
      return () => window.clearTimeout(u);
    }
  }, [o, a.scrollHideDelay, l]), D.useEffect(() => {
    const u = a.viewport, c = s ? "scrollLeft" : "scrollTop";
    if (u) {
      let d = u[c];
      const p = () => {
        const f = u[c];
        d !== f && (l("SCROLL"), i()), d = f;
      };
      return u.addEventListener("scroll", p), () => u.removeEventListener("scroll", p);
    }
  }, [a.viewport, s, l, i]), /* @__PURE__ */ K(Ra, { present: r || o !== "hidden", children: /* @__PURE__ */ K(
    XI,
    {
      "data-state": o === "hidden" ? "hidden" : "visible",
      ...n,
      ref: t,
      onPointerEnter: nr(e.onPointerEnter, () => l("POINTER_ENTER")),
      onPointerLeave: nr(e.onPointerLeave, () => l("POINTER_LEAVE"))
    }
  ) });
}), pq = D.forwardRef((e, t) => {
  const r = fs(ho, e.__scopeScrollArea), { forceMount: n, ...a } = e, [s, i] = D.useState(!1), o = e.orientation === "horizontal", l = Ub(() => {
    if (r.viewport) {
      const u = r.viewport.offsetWidth < r.viewport.scrollWidth, c = r.viewport.offsetHeight < r.viewport.scrollHeight;
      i(o ? u : c);
    }
  }, 10);
  return id(r.viewport, l), id(r.content, l), /* @__PURE__ */ K(Ra, { present: n || s, children: /* @__PURE__ */ K(
    XI,
    {
      "data-state": s ? "visible" : "hidden",
      ...a,
      ref: t
    }
  ) });
}), XI = D.forwardRef((e, t) => {
  const { orientation: r = "vertical", ...n } = e, a = fs(ho, e.__scopeScrollArea), s = D.useRef(null), i = D.useRef(0), [o, l] = D.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = yq(o.viewport, o.content), c = {
    ...n,
    sizes: o,
    onSizesChange: l,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (p) => s.current = p,
    onThumbPointerUp: () => i.current = 0,
    onThumbPointerDown: (p) => i.current = p
  };
  function d(p, f) {
    return oce(p, i.current, o, f);
  }
  return r === "horizontal" ? /* @__PURE__ */ K(
    rce,
    {
      ...c,
      ref: t,
      onThumbPositionChange: () => {
        if (a.viewport && s.current) {
          const p = a.viewport.scrollLeft, f = qP(p, o, a.dir);
          s.current.style.transform = `translate3d(${f}px, 0, 0)`;
        }
      },
      onWheelScroll: (p) => {
        a.viewport && (a.viewport.scrollLeft = p);
      },
      onDragScroll: (p) => {
        a.viewport && (a.viewport.scrollLeft = d(p, a.dir));
      }
    }
  ) : r === "vertical" ? /* @__PURE__ */ K(
    nce,
    {
      ...c,
      ref: t,
      onThumbPositionChange: () => {
        if (a.viewport && s.current) {
          const p = a.viewport.scrollTop, f = qP(p, o);
          s.current.style.transform = `translate3d(0, ${f}px, 0)`;
        }
      },
      onWheelScroll: (p) => {
        a.viewport && (a.viewport.scrollTop = p);
      },
      onDragScroll: (p) => {
        a.viewport && (a.viewport.scrollTop = d(p));
      }
    }
  ) : null;
}), rce = D.forwardRef((e, t) => {
  const { sizes: r, onSizesChange: n, ...a } = e, s = fs(ho, e.__scopeScrollArea), [i, o] = D.useState(), l = D.useRef(null), u = sn(t, l, s.onScrollbarXChange);
  return D.useEffect(() => {
    l.current && o(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ K(
    mq,
    {
      "data-orientation": "horizontal",
      ...a,
      ref: u,
      sizes: r,
      style: {
        bottom: 0,
        left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Bb(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (c) => e.onThumbPointerDown(c.x),
      onDragScroll: (c) => e.onDragScroll(c.x),
      onWheelScroll: (c, d) => {
        if (s.viewport) {
          const p = s.viewport.scrollLeft + c.deltaX;
          e.onWheelScroll(p), wq(p, d) && c.preventDefault();
        }
      },
      onResize: () => {
        l.current && s.viewport && i && n({
          content: s.viewport.scrollWidth,
          viewport: s.viewport.offsetWidth,
          scrollbar: {
            size: l.current.clientWidth,
            paddingStart: Mg(i.paddingLeft),
            paddingEnd: Mg(i.paddingRight)
          }
        });
      }
    }
  );
}), nce = D.forwardRef((e, t) => {
  const { sizes: r, onSizesChange: n, ...a } = e, s = fs(ho, e.__scopeScrollArea), [i, o] = D.useState(), l = D.useRef(null), u = sn(t, l, s.onScrollbarYChange);
  return D.useEffect(() => {
    l.current && o(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ K(
    mq,
    {
      "data-orientation": "vertical",
      ...a,
      ref: u,
      sizes: r,
      style: {
        top: 0,
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Bb(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (c) => e.onThumbPointerDown(c.y),
      onDragScroll: (c) => e.onDragScroll(c.y),
      onWheelScroll: (c, d) => {
        if (s.viewport) {
          const p = s.viewport.scrollTop + c.deltaY;
          e.onWheelScroll(p), wq(p, d) && c.preventDefault();
        }
      },
      onResize: () => {
        l.current && s.viewport && i && n({
          content: s.viewport.scrollHeight,
          viewport: s.viewport.offsetHeight,
          scrollbar: {
            size: l.current.clientHeight,
            paddingStart: Mg(i.paddingTop),
            paddingEnd: Mg(i.paddingBottom)
          }
        });
      }
    }
  );
}), [ice, hq] = uq(ho), mq = D.forwardRef((e, t) => {
  const {
    __scopeScrollArea: r,
    sizes: n,
    hasThumb: a,
    onThumbChange: s,
    onThumbPointerUp: i,
    onThumbPointerDown: o,
    onThumbPositionChange: l,
    onDragScroll: u,
    onWheelScroll: c,
    onResize: d,
    ...p
  } = e, f = fs(ho, r), [h, m] = D.useState(null), y = sn(t, (S) => m(S)), b = D.useRef(null), v = D.useRef(""), x = f.viewport, _ = n.content - n.viewport, E = si(c), w = si(l), C = Ub(d, 10);
  function k(S) {
    if (b.current) {
      const B = S.clientX - b.current.left, U = S.clientY - b.current.top;
      u({ x: B, y: U });
    }
  }
  return D.useEffect(() => {
    const S = (B) => {
      const U = B.target;
      h?.contains(U) && E(B, _);
    };
    return document.addEventListener("wheel", S, { passive: !1 }), () => document.removeEventListener("wheel", S, { passive: !1 });
  }, [x, h, _, E]), D.useEffect(w, [n, w]), id(h, C), id(f.content, C), /* @__PURE__ */ K(
    ice,
    {
      scope: r,
      scrollbar: h,
      hasThumb: a,
      onThumbChange: si(s),
      onThumbPointerUp: si(i),
      onThumbPositionChange: w,
      onThumbPointerDown: si(o),
      children: /* @__PURE__ */ K(
        Wr.div,
        {
          ...p,
          ref: y,
          style: { position: "absolute", ...p.style },
          onPointerDown: nr(e.onPointerDown, (S) => {
            S.button === 0 && (S.target.setPointerCapture(S.pointerId), b.current = h.getBoundingClientRect(), v.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", f.viewport && (f.viewport.style.scrollBehavior = "auto"), k(S));
          }),
          onPointerMove: nr(e.onPointerMove, k),
          onPointerUp: nr(e.onPointerUp, (S) => {
            const B = S.target;
            B.hasPointerCapture(S.pointerId) && B.releasePointerCapture(S.pointerId), document.body.style.webkitUserSelect = v.current, f.viewport && (f.viewport.style.scrollBehavior = ""), b.current = null;
          })
        }
      )
    }
  );
}), Lg = "ScrollAreaThumb", gq = D.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, a = hq(Lg, e.__scopeScrollArea);
    return /* @__PURE__ */ K(Ra, { present: r || a.hasThumb, children: /* @__PURE__ */ K(ace, { ref: t, ...n }) });
  }
), ace = D.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: r, style: n, ...a } = e, s = fs(Lg, r), i = hq(Lg, r), { onThumbPositionChange: o } = i, l = sn(
      t,
      (d) => i.onThumbChange(d)
    ), u = D.useRef(void 0), c = Ub(() => {
      u.current && (u.current(), u.current = void 0);
    }, 100);
    return D.useEffect(() => {
      const d = s.viewport;
      if (d) {
        const p = () => {
          if (c(), !u.current) {
            const f = lce(d, o);
            u.current = f, o();
          }
        };
        return o(), d.addEventListener("scroll", p), () => d.removeEventListener("scroll", p);
      }
    }, [s.viewport, c, o]), /* @__PURE__ */ K(
      Wr.div,
      {
        "data-state": i.hasThumb ? "visible" : "hidden",
        ...a,
        ref: l,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: nr(e.onPointerDownCapture, (d) => {
          const f = d.target.getBoundingClientRect(), h = d.clientX - f.left, m = d.clientY - f.top;
          i.onThumbPointerDown({ x: h, y: m });
        }),
        onPointerUp: nr(e.onPointerUp, i.onThumbPointerUp)
      }
    );
  }
);
gq.displayName = Lg;
var ZI = "ScrollAreaCorner", bq = D.forwardRef(
  (e, t) => {
    const r = fs(ZI, e.__scopeScrollArea), n = !!(r.scrollbarX && r.scrollbarY);
    return r.type !== "scroll" && n ? /* @__PURE__ */ K(sce, { ...e, ref: t }) : null;
  }
);
bq.displayName = ZI;
var sce = D.forwardRef((e, t) => {
  const { __scopeScrollArea: r, ...n } = e, a = fs(ZI, r), [s, i] = D.useState(0), [o, l] = D.useState(0), u = !!(s && o);
  return id(a.scrollbarX, () => {
    const c = a.scrollbarX?.offsetHeight || 0;
    a.onCornerHeightChange(c), l(c);
  }), id(a.scrollbarY, () => {
    const c = a.scrollbarY?.offsetWidth || 0;
    a.onCornerWidthChange(c), i(c);
  }), u ? /* @__PURE__ */ K(
    Wr.div,
    {
      ...n,
      ref: t,
      style: {
        width: s,
        height: o,
        position: "absolute",
        right: a.dir === "ltr" ? 0 : void 0,
        left: a.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function Mg(e) {
  return e ? parseInt(e, 10) : 0;
}
function yq(e, t) {
  const r = e / t;
  return isNaN(r) ? 0 : r;
}
function Bb(e) {
  const t = yq(e.viewport, e.content), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, n = (e.scrollbar.size - r) * t;
  return Math.max(n, 18);
}
function oce(e, t, r, n = "ltr") {
  const a = Bb(r), s = a / 2, i = t || s, o = a - i, l = r.scrollbar.paddingStart + i, u = r.scrollbar.size - r.scrollbar.paddingEnd - o, c = r.content - r.viewport, d = n === "ltr" ? [0, c] : [c * -1, 0];
  return vq([l, u], d)(e);
}
function qP(e, t, r = "ltr") {
  const n = Bb(t), a = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - a, i = t.content - t.viewport, o = s - n, l = r === "ltr" ? [0, i] : [i * -1, 0], u = XT(e, l);
  return vq([0, i], [0, o])(u);
}
function vq(e, t) {
  return (r) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const n = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + n * (r - e[0]);
  };
}
function wq(e, t) {
  return e > 0 && e < t;
}
var lce = (e, t = () => {
}) => {
  let r = { left: e.scrollLeft, top: e.scrollTop }, n = 0;
  return function a() {
    const s = { left: e.scrollLeft, top: e.scrollTop }, i = r.left !== s.left, o = r.top !== s.top;
    (i || o) && t(), r = s, n = window.requestAnimationFrame(a);
  }(), () => window.cancelAnimationFrame(n);
};
function Ub(e, t) {
  const r = si(e), n = D.useRef(0);
  return D.useEffect(() => () => window.clearTimeout(n.current), []), D.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(r, t);
  }, [r, t]);
}
function id(e, t) {
  const r = si(t);
  Ti(() => {
    let n = 0;
    if (e) {
      const a = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(r);
      });
      return a.observe(e), () => {
        window.cancelAnimationFrame(n), a.unobserve(e);
      };
    }
  }, [e, r]);
}
var xq = cq, uce = fq, cce = bq;
const Eq = D.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ $t(
  xq,
  {
    ref: n,
    className: ja("relative overflow-hidden", e),
    ...r,
    children: [
      /* @__PURE__ */ K(uce, { className: "h-full w-full rounded-[inherit]", children: t }),
      /* @__PURE__ */ K(Sq, {}),
      /* @__PURE__ */ K(cce, {})
    ]
  }
));
Eq.displayName = xq.displayName;
const Sq = D.forwardRef(({ className: e, orientation: t = "vertical", ...r }, n) => /* @__PURE__ */ K(
  YI,
  {
    ref: n,
    orientation: t,
    className: ja(
      "flex touch-none select-none transition-colors",
      t === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      e
    ),
    ...r,
    children: /* @__PURE__ */ K(gq, { className: "relative flex-1 rounded-full bg-border" })
  }
));
Sq.displayName = YI.displayName;
const d1 = D.lazy(() => Promise.resolve().then(() => vFe)), dce = (e) => {
  const {
    messages: t,
    layout: r,
    historyOrder: n,
    height: a,
    isLoading: s = !1,
    onStartNewThread: i,
    commingMessage: o
  } = e, l = D.useMemo(() => {
    if (s && o)
      return o;
    const u = t.filter((c) => c.role !== "user");
    return u[u.length - 1];
  }, [s, o, t]);
  return /* @__PURE__ */ $t(
    Eq,
    {
      className: `flex-1 w-full pb-8 ${n === "default" ? "flex-col" : "flex-col-reverse"} [&>div>div[style]]:!block`,
      style: { height: a },
      children: [
        (r === "chat" || r === "side-by-side") && /* @__PURE__ */ $t(ln, { children: [
          t.map((u) => /* @__PURE__ */ $t("div", { className: "my-5 w-full", children: [
            /* @__PURE__ */ K("div", { className: "w-full", children: /* @__PURE__ */ K(D.Suspense, { fallback: /* @__PURE__ */ K("div", { children: u.content }), children: /* @__PURE__ */ K(
              d1,
              {
                sender: u.role === "user" ? "You: " : "AI: ",
                source: u.content
              }
            ) }) }),
            /* @__PURE__ */ K("hr", { className: "mt-5" })
          ] }, u.id)),
          s && o && /* @__PURE__ */ $t("div", { className: "my-5 w-full", children: [
            /* @__PURE__ */ K("div", { className: "w-full", children: /* @__PURE__ */ K(D.Suspense, { fallback: /* @__PURE__ */ K("div", { children: o.content }), children: /* @__PURE__ */ K(
              d1,
              {
                sender: o.role === "user" ? "You: " : "AI: ",
                source: o.content
              }
            ) }) }),
            /* @__PURE__ */ K("hr", { className: "mt-5" })
          ] }, o.id),
          t.length > 0 && /* @__PURE__ */ $t("div", { className: "flex", children: [
            /* @__PURE__ */ K("div", { className: "flex-1" }),
            /* @__PURE__ */ $t(ca, { variant: "ghost", onClick: i, children: [
              /* @__PURE__ */ K(nq, { size: 16, className: "mr-3" }),
              "Start New Thread"
            ] }),
            /* @__PURE__ */ K("div", { className: "flex-1" })
          ] }),
          s && /* @__PURE__ */ K("div", { className: "w-full flex justify-center", children: /* @__PURE__ */ K(Cu, { className: "h-4 w-4 my-2" }) })
        ] }),
        r === "single" && /* @__PURE__ */ $t("div", { className: "my-4", children: [
          s && /* @__PURE__ */ K("div", { className: "w-full flex justify-center", children: /* @__PURE__ */ K(Cu, { className: "h-4 w-4 my-2" }) }),
          l && /* @__PURE__ */ K(D.Suspense, { fallback: /* @__PURE__ */ K("div", { children: l.content }), children: /* @__PURE__ */ K(d1, { source: l.content }) })
        ] })
      ]
    }
  );
}, fce = ({
  textAreaRef: e,
  triggerAutoSize: t,
  maxHeight: r = Number.MAX_SAFE_INTEGER,
  minHeight: n = 0
}) => {
  const [a, s] = D.useState(!0);
  D.useEffect(() => {
    const o = e.current;
    if (o) {
      a && (o.style.minHeight = `${n + 2}px`, r > n && (o.style.maxHeight = `${r}px`), s(!1)), o.style.height = `${n + 2}px`;
      const l = o.scrollHeight;
      l > r ? o.style.height = `${r}px` : o.style.height = `${l + 2}px`;
    }
  }, [e.current, t]);
}, _q = D.forwardRef(
  ({
    maxHeight: e = Number.MAX_SAFE_INTEGER,
    minHeight: t = 40,
    className: r,
    onChange: n,
    value: a,
    ...s
  }, i) => {
    const o = D.useRef(null), [l, u] = D.useState("");
    return fce({
      textAreaRef: o,
      triggerAutoSize: l,
      maxHeight: e,
      minHeight: t
    }), ZQ(i, () => ({
      textArea: o.current,
      focus: () => o?.current?.focus(),
      maxHeight: e,
      minHeight: t
    })), D.useEffect(() => {
      u(a);
    }, [s?.defaultValue, a]), /* @__PURE__ */ K(
      "textarea",
      {
        ...s,
        value: a,
        ref: o,
        className: ja(r),
        onChange: (c) => {
          u(c.target.value), n?.(c);
        }
      }
    );
  }
);
_q.displayName = "AutosizeTextarea";
const pce = (e) => {
  const {
    layout: t,
    inputType: r,
    inputValue: n,
    onIpuntChange: a,
    onKeydown: s,
    onSubmit: i,
    submitButtonRef: o,
    submitLabel: l
  } = e, u = D.useMemo(() => t === "chat" || t === "side-by-side" ? "Type your message here" : t === "single" ? "Type your prompt here" : "", [t]);
  return /* @__PURE__ */ $t(ln, { children: [
    (r === "default" || r === "text") && /* @__PURE__ */ $t("div", { className: "relative w-full bg-gray-100 dark:bg-gray-800 px-3 pt-3 pb-2 rounded-xl focus:ring-2 focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2", children: [
      /* @__PURE__ */ K(
        _q,
        {
          className: "resize-none w-full ring-0 outline-none bg-transparent h-10 peer",
          maxHeight: 240,
          minHeight: 24,
          value: n,
          onChange: a,
          placeholder: u,
          onKeyDown: s
        }
      ),
      r === "default" && /* @__PURE__ */ $t("div", { className: "flex items-center peer-focus:[&_.description]:visible", children: [
        /* @__PURE__ */ K("div", { className: "flex-1" }),
        /* @__PURE__ */ $t("div", { className: "flex items-center gap-2.5", children: [
          /* @__PURE__ */ K("div", { className: "description invisible text-sm text-gray-500 dark:text-gray-700", children: "⌘ + Return" }),
          /* @__PURE__ */ K(
            ca,
            {
              ref: o,
              className: "rounded-full",
              onClick: (c) => i(c, { allowEmptySubmit: !0 }),
              children: /* @__PURE__ */ K(Hle, { size: 17 })
            }
          )
        ] })
      ] })
    ] }),
    r === "button" && /* @__PURE__ */ K("div", { className: "p-3 w-full", children: /* @__PURE__ */ K(
      ca,
      {
        ref: o,
        className: "w-full",
        onClick: (c) => i(c, { allowEmptySubmit: !0 }),
        children: l
      }
    ) })
  ] });
};
var kq = "vercel.ai.error", hce = Symbol.for(kq), Cq, mce = class Aq extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: r,
    cause: n
  }) {
    super(r), this[Cq] = !0, this.name = t, this.cause = n;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return Aq.hasMarker(t, kq);
  }
  static hasMarker(t, r) {
    const n = Symbol.for(r);
    return t != null && typeof t == "object" && n in t && typeof t[n] == "boolean" && t[n] === !0;
  }
};
Cq = hce;
var ad = mce;
function Tq(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var Rq = "AI_InvalidArgumentError", Iq = `vercel.ai.error.${Rq}`, gce = Symbol.for(Iq), Nq, bce = class extends ad {
  constructor({
    message: e,
    cause: t,
    argument: r
  }) {
    super({ name: Rq, message: e, cause: t }), this[Nq] = !0, this.argument = r;
  }
  static isInstance(e) {
    return ad.hasMarker(e, Iq);
  }
};
Nq = gce;
var Dq = "AI_JSONParseError", Oq = `vercel.ai.error.${Dq}`, yce = Symbol.for(Oq), Pq, jP = class extends ad {
  constructor({ text: e, cause: t }) {
    super({
      name: Dq,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${Tq(t)}`,
      cause: t
    }), this[Pq] = !0, this.text = e;
  }
  static isInstance(e) {
    return ad.hasMarker(e, Oq);
  }
};
Pq = yce;
var Lq = "AI_TypeValidationError", Mq = `vercel.ai.error.${Lq}`, vce = Symbol.for(Mq), Fq, wce = class ZT extends ad {
  constructor({ value: t, cause: r }) {
    super({
      name: Lq,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${Tq(r)}`,
      cause: r
    }), this[Fq] = !0, this.value = t;
  }
  static isInstance(t) {
    return ad.hasMarker(t, Mq);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: r
  }) {
    return ZT.isInstance(r) && r.value === t ? r : new ZT({ value: t, cause: r });
  }
};
Fq = vce;
var HP = wce;
let xce = (e, t = 21) => (r = t) => {
  let n = "", a = r | 0;
  for (; a--; )
    n += e[Math.random() * e.length | 0];
  return n;
};
var lu = { exports: {} }, VP;
function Ece() {
  if (VP) return lu.exports;
  VP = 1;
  const e = typeof Buffer < "u", t = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, r = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function n(o, l, u) {
    u == null && l !== null && typeof l == "object" && (u = l, l = void 0), e && Buffer.isBuffer(o) && (o = o.toString()), o && o.charCodeAt(0) === 65279 && (o = o.slice(1));
    const c = JSON.parse(o, l);
    if (c === null || typeof c != "object")
      return c;
    const d = u && u.protoAction || "error", p = u && u.constructorAction || "error";
    if (d === "ignore" && p === "ignore")
      return c;
    if (d !== "ignore" && p !== "ignore") {
      if (t.test(o) === !1 && r.test(o) === !1)
        return c;
    } else if (d !== "ignore" && p === "ignore") {
      if (t.test(o) === !1)
        return c;
    } else if (r.test(o) === !1)
      return c;
    return a(c, { protoAction: d, constructorAction: p, safe: u && u.safe });
  }
  function a(o, { protoAction: l = "error", constructorAction: u = "error", safe: c } = {}) {
    let d = [o];
    for (; d.length; ) {
      const p = d;
      d = [];
      for (const f of p) {
        if (l !== "ignore" && Object.prototype.hasOwnProperty.call(f, "__proto__")) {
          if (c === !0)
            return null;
          if (l === "error")
            throw new SyntaxError("Object contains forbidden prototype property");
          delete f.__proto__;
        }
        if (u !== "ignore" && Object.prototype.hasOwnProperty.call(f, "constructor") && Object.prototype.hasOwnProperty.call(f.constructor, "prototype")) {
          if (c === !0)
            return null;
          if (u === "error")
            throw new SyntaxError("Object contains forbidden prototype property");
          delete f.constructor;
        }
        for (const h in f) {
          const m = f[h];
          m && typeof m == "object" && d.push(m);
        }
      }
    }
    return o;
  }
  function s(o, l, u) {
    const c = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return n(o, l, u);
    } finally {
      Error.stackTraceLimit = c;
    }
  }
  function i(o, l) {
    const u = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return n(o, l, { safe: !0 });
    } catch {
      return null;
    } finally {
      Error.stackTraceLimit = u;
    }
  }
  return lu.exports = s, lu.exports.default = s, lu.exports.parse = s, lu.exports.safeParse = i, lu.exports.scan = a, lu.exports;
}
var Sce = Ece();
const _ce = /* @__PURE__ */ da(Sce);
var kce = ({
  prefix: e,
  size: t = 16,
  alphabet: r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: n = "-"
} = {}) => {
  const a = xce(r, t);
  if (e == null)
    return a;
  if (r.includes(n))
    throw new bce({
      argument: "separator",
      message: `The separator "${n}" must not be part of the alphabet "${r}".`
    });
  return (s) => `${e}${n}${a(s)}`;
};
kce();
function Cce(e) {
  return e instanceof Error && (e.name === "AbortError" || e.name === "TimeoutError");
}
var Fg = Symbol.for("vercel.ai.validator");
function Ace(e) {
  return { [Fg]: !0, validate: e };
}
function Tce(e) {
  return typeof e == "object" && e !== null && Fg in e && e[Fg] === !0 && "validate" in e;
}
function Rce(e) {
  return Tce(e) ? e : Ice(e);
}
function Ice(e) {
  return Ace((t) => {
    const r = e.safeParse(t);
    return r.success ? { success: !0, value: r.data } : { success: !1, error: r.error };
  });
}
function $q({
  value: e,
  schema: t
}) {
  const r = Rce(t);
  try {
    if (r.validate == null)
      return { success: !0, value: e };
    const n = r.validate(e);
    return n.success ? n : {
      success: !1,
      error: HP.wrap({ value: e, cause: n.error })
    };
  } catch (n) {
    return {
      success: !1,
      error: HP.wrap({ value: e, cause: n })
    };
  }
}
function GP({
  text: e,
  schema: t
}) {
  try {
    const r = _ce.parse(e);
    return t == null ? {
      success: !0,
      value: r
    } : $q({ value: r, schema: t });
  } catch (r) {
    return {
      success: !1,
      error: jP.isInstance(r) ? r : new jP({ text: e, cause: r })
    };
  }
}
const Nce = Symbol("Let zodToJsonSchema decide on which parser to use"), WP = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, Dce = (e) => typeof e == "string" ? {
  ...WP,
  name: e
} : {
  ...WP,
  ...e
}, Oce = (e) => {
  const t = Dce(e), r = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: r,
    propertyPath: void 0,
    seen: new Map(Object.entries(t.definitions).map(([n, a]) => [
      a._def,
      {
        def: a._def,
        path: [...t.basePath, t.definitionPath, n],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function Bq(e, t, r, n) {
  n?.errorMessages && r && (e.errorMessage = {
    ...e.errorMessage,
    [t]: r
  });
}
function Mn(e, t, r, n, a) {
  e[t] = r, Bq(e, t, n, a);
}
function Pce() {
  return {};
}
function Lce(e, t) {
  const r = {
    type: "array"
  };
  return e.type?._def && e.type?._def?.typeName !== qt.ZodAny && (r.items = Cn(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && Mn(r, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Mn(r, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Mn(r, "minItems", e.exactLength.value, e.exactLength.message, t), Mn(r, "maxItems", e.exactLength.value, e.exactLength.message, t)), r;
}
function Mce(e, t) {
  const r = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks)
    return r;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.target === "jsonSchema7" ? n.inclusive ? Mn(r, "minimum", n.value, n.message, t) : Mn(r, "exclusiveMinimum", n.value, n.message, t) : (n.inclusive || (r.exclusiveMinimum = !0), Mn(r, "minimum", n.value, n.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? n.inclusive ? Mn(r, "maximum", n.value, n.message, t) : Mn(r, "exclusiveMaximum", n.value, n.message, t) : (n.inclusive || (r.exclusiveMaximum = !0), Mn(r, "maximum", n.value, n.message, t));
        break;
      case "multipleOf":
        Mn(r, "multipleOf", n.value, n.message, t);
        break;
    }
  return r;
}
function Fce() {
  return {
    type: "boolean"
  };
}
function Uq(e, t) {
  return Cn(e.type._def, t);
}
const $ce = (e, t) => Cn(e.innerType._def, t);
function zq(e, t, r) {
  const n = r ?? t.dateStrategy;
  if (Array.isArray(n))
    return {
      anyOf: n.map((a, s) => zq(e, t, a))
    };
  switch (n) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return Bce(e, t);
  }
}
const Bce = (e, t) => {
  const r = {
    type: "integer",
    format: "unix-time"
  };
  if (t.target === "openApi3")
    return r;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        Mn(
          r,
          "minimum",
          n.value,
          // This is in milliseconds
          n.message,
          t
        );
        break;
      case "max":
        Mn(
          r,
          "maximum",
          n.value,
          // This is in milliseconds
          n.message,
          t
        );
        break;
    }
  return r;
};
function Uce(e, t) {
  return {
    ...Cn(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function zce(e, t) {
  return t.effectStrategy === "input" ? Cn(e.schema._def, t) : {};
}
function qce(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
const jce = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function Hce(e, t) {
  const r = [
    Cn(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    Cn(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((s) => !!s);
  let n = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const a = [];
  return r.forEach((s) => {
    if (jce(s))
      a.push(...s.allOf), s.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let i = s;
      if ("additionalProperties" in s && s.additionalProperties === !1) {
        const { additionalProperties: o, ...l } = s;
        i = l;
      } else
        n = void 0;
      a.push(i);
    }
  }), a.length ? {
    allOf: a,
    ...n
  } : void 0;
}
function Vce(e, t) {
  const r = typeof e.value;
  return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: r === "bigint" ? "integer" : r,
    enum: [e.value]
  } : {
    type: r === "bigint" ? "integer" : r,
    const: e.value
  };
}
let f1;
const _s = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (f1 === void 0 && (f1 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), f1),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function qq(e, t) {
  const r = {
    type: "string"
  };
  if (e.checks)
    for (const n of e.checks)
      switch (n.kind) {
        case "min":
          Mn(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, n.value) : n.value, n.message, t);
          break;
        case "max":
          Mn(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, n.value) : n.value, n.message, t);
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              ks(r, "email", n.message, t);
              break;
            case "format:idn-email":
              ks(r, "idn-email", n.message, t);
              break;
            case "pattern:zod":
              ea(r, _s.email, n.message, t);
              break;
          }
          break;
        case "url":
          ks(r, "uri", n.message, t);
          break;
        case "uuid":
          ks(r, "uuid", n.message, t);
          break;
        case "regex":
          ea(r, n.regex, n.message, t);
          break;
        case "cuid":
          ea(r, _s.cuid, n.message, t);
          break;
        case "cuid2":
          ea(r, _s.cuid2, n.message, t);
          break;
        case "startsWith":
          ea(r, RegExp(`^${p1(n.value, t)}`), n.message, t);
          break;
        case "endsWith":
          ea(r, RegExp(`${p1(n.value, t)}$`), n.message, t);
          break;
        case "datetime":
          ks(r, "date-time", n.message, t);
          break;
        case "date":
          ks(r, "date", n.message, t);
          break;
        case "time":
          ks(r, "time", n.message, t);
          break;
        case "duration":
          ks(r, "duration", n.message, t);
          break;
        case "length":
          Mn(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, n.value) : n.value, n.message, t), Mn(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, n.value) : n.value, n.message, t);
          break;
        case "includes": {
          ea(r, RegExp(p1(n.value, t)), n.message, t);
          break;
        }
        case "ip": {
          n.version !== "v6" && ks(r, "ipv4", n.message, t), n.version !== "v4" && ks(r, "ipv6", n.message, t);
          break;
        }
        case "base64url":
          ea(r, _s.base64url, n.message, t);
          break;
        case "jwt":
          ea(r, _s.jwt, n.message, t);
          break;
        case "cidr": {
          n.version !== "v6" && ea(r, _s.ipv4Cidr, n.message, t), n.version !== "v4" && ea(r, _s.ipv6Cidr, n.message, t);
          break;
        }
        case "emoji":
          ea(r, _s.emoji(), n.message, t);
          break;
        case "ulid": {
          ea(r, _s.ulid, n.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              ks(r, "binary", n.message, t);
              break;
            }
            case "contentEncoding:base64": {
              Mn(r, "contentEncoding", "base64", n.message, t);
              break;
            }
            case "pattern:zod": {
              ea(r, _s.base64, n.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          ea(r, _s.nanoid, n.message, t);
      }
  return r;
}
function p1(e, t) {
  return t.patternStrategy === "escape" ? Wce(e) : e;
}
const Gce = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function Wce(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    Gce.has(e[r]) || (t += "\\"), t += e[r];
  return t;
}
function ks(e, t, r, n) {
  e.format || e.anyOf?.some((a) => a.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format,
    ...e.errorMessage && n.errorMessages && {
      errorMessage: { format: e.errorMessage.format }
    }
  }), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push({
    format: t,
    ...r && n.errorMessages && { errorMessage: { format: r } }
  })) : Mn(e, "format", t, r, n);
}
function ea(e, t, r, n) {
  e.pattern || e.allOf?.some((a) => a.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern,
    ...e.errorMessage && n.errorMessages && {
      errorMessage: { pattern: e.errorMessage.pattern }
    }
  }), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push({
    pattern: KP(t, n),
    ...r && n.errorMessages && { errorMessage: { pattern: r } }
  })) : Mn(e, "pattern", KP(t, n), r, n);
}
function KP(e, t) {
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const r = {
    i: e.flags.includes("i"),
    m: e.flags.includes("m"),
    s: e.flags.includes("s")
    // `.` matches newlines
  }, n = r.i ? e.source.toLowerCase() : e.source;
  let a = "", s = !1, i = !1, o = !1;
  for (let l = 0; l < n.length; l++) {
    if (s) {
      a += n[l], s = !1;
      continue;
    }
    if (r.i) {
      if (i) {
        if (n[l].match(/[a-z]/)) {
          o ? (a += n[l], a += `${n[l - 2]}-${n[l]}`.toUpperCase(), o = !1) : n[l + 1] === "-" && n[l + 2]?.match(/[a-z]/) ? (a += n[l], o = !0) : a += `${n[l]}${n[l].toUpperCase()}`;
          continue;
        }
      } else if (n[l].match(/[a-z]/)) {
        a += `[${n[l]}${n[l].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (n[l] === "^") {
        a += `(^|(?<=[\r
]))`;
        continue;
      } else if (n[l] === "$") {
        a += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && n[l] === ".") {
      a += i ? `${n[l]}\r
` : `[${n[l]}\r
]`;
      continue;
    }
    a += n[l], n[l] === "\\" ? s = !0 : i && n[l] === "]" ? i = !1 : !i && n[l] === "[" && (i = !0);
  }
  try {
    new RegExp(a);
  } catch {
    return console.warn(`Could not convert regex pattern at ${t.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), e.source;
  }
  return a;
}
function jq(e, t) {
  if (t.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), t.target === "openApi3" && e.keyType?._def.typeName === qt.ZodEnum)
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce((n, a) => ({
        ...n,
        [a]: Cn(e.valueType._def, {
          ...t,
          currentPath: [...t.currentPath, "properties", a]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const r = {
    type: "object",
    additionalProperties: Cn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (t.target === "openApi3")
    return r;
  if (e.keyType?._def.typeName === qt.ZodString && e.keyType._def.checks?.length) {
    const { type: n, ...a } = qq(e.keyType._def, t);
    return {
      ...r,
      propertyNames: a
    };
  } else {
    if (e.keyType?._def.typeName === qt.ZodEnum)
      return {
        ...r,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (e.keyType?._def.typeName === qt.ZodBranded && e.keyType._def.type._def.typeName === qt.ZodString && e.keyType._def.type._def.checks?.length) {
      const { type: n, ...a } = Uq(e.keyType._def, t);
      return {
        ...r,
        propertyNames: a
      };
    }
  }
  return r;
}
function Kce(e, t) {
  if (t.mapStrategy === "record")
    return jq(e, t);
  const r = Cn(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || {}, n = Cn(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [r, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function Yce(e) {
  const t = e.values, n = Object.keys(e.values).filter((s) => typeof t[t[s]] != "number").map((s) => t[s]), a = Array.from(new Set(n.map((s) => typeof s)));
  return {
    type: a.length === 1 ? a[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function Xce() {
  return {
    not: {}
  };
}
function Zce(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const $g = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function Jce(e, t) {
  if (t.target === "openApi3")
    return YP(e, t);
  const r = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (r.every((n) => n._def.typeName in $g && (!n._def.checks || !n._def.checks.length))) {
    const n = r.reduce((a, s) => {
      const i = $g[s._def.typeName];
      return i && !a.includes(i) ? [...a, i] : a;
    }, []);
    return {
      type: n.length > 1 ? n : n[0]
    };
  } else if (r.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = r.reduce((a, s) => {
      const i = typeof s._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...a, i];
        case "bigint":
          return [...a, "integer"];
        case "object":
          if (s._def.value === null)
            return [...a, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return a;
      }
    }, []);
    if (n.length === r.length) {
      const a = n.filter((s, i, o) => o.indexOf(s) === i);
      return {
        type: a.length > 1 ? a : a[0],
        enum: r.reduce((s, i) => s.includes(i._def.value) ? s : [...s, i._def.value], [])
      };
    }
  } else if (r.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: r.reduce((n, a) => [
        ...n,
        ...a._def.values.filter((s) => !n.includes(s))
      ], [])
    };
  return YP(e, t);
}
const YP = (e, t) => {
  const r = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map((n, a) => Cn(n._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", `${a}`]
  })).filter((n) => !!n && (!t.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return r.length ? { anyOf: r } : void 0;
};
function Qce(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: $g[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        $g[e.innerType._def.typeName],
        "null"
      ]
    };
  if (t.target === "openApi3") {
    const n = Cn(e.innerType._def, {
      ...t,
      currentPath: [...t.currentPath]
    });
    return n && "$ref" in n ? { allOf: [n], nullable: !0 } : n && { ...n, nullable: !0 };
  }
  const r = Cn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return r && { anyOf: [r, { type: "null" }] };
}
function ede(e, t) {
  const r = {
    type: "number"
  };
  if (!e.checks)
    return r;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        r.type = "integer", Bq(r, "type", n.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? n.inclusive ? Mn(r, "minimum", n.value, n.message, t) : Mn(r, "exclusiveMinimum", n.value, n.message, t) : (n.inclusive || (r.exclusiveMinimum = !0), Mn(r, "minimum", n.value, n.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? n.inclusive ? Mn(r, "maximum", n.value, n.message, t) : Mn(r, "exclusiveMaximum", n.value, n.message, t) : (n.inclusive || (r.exclusiveMaximum = !0), Mn(r, "maximum", n.value, n.message, t));
        break;
      case "multipleOf":
        Mn(r, "multipleOf", n.value, n.message, t);
        break;
    }
  return r;
}
function tde(e, t) {
  return t.removeAdditionalStrategy === "strict" ? e.catchall._def.typeName === "ZodNever" ? e.unknownKeys !== "strict" : Cn(e.catchall._def, {
    ...t,
    currentPath: [...t.currentPath, "additionalProperties"]
  }) ?? !0 : e.catchall._def.typeName === "ZodNever" ? e.unknownKeys === "passthrough" : Cn(e.catchall._def, {
    ...t,
    currentPath: [...t.currentPath, "additionalProperties"]
  }) ?? !0;
}
function rde(e, t) {
  const r = t.target === "openAi", n = {
    type: "object",
    ...Object.entries(e.shape()).reduce((a, [s, i]) => {
      if (i === void 0 || i._def === void 0)
        return a;
      let o = i.isOptional();
      o && r && (i instanceof Ls && (i = i._def.innerType), i.isNullable() || (i = i.nullable()), o = !1);
      const l = Cn(i._def, {
        ...t,
        currentPath: [...t.currentPath, "properties", s],
        propertyPath: [...t.currentPath, "properties", s]
      });
      return l === void 0 ? a : {
        properties: { ...a.properties, [s]: l },
        required: o ? a.required : [...a.required, s]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: tde(e, t)
  };
  return n.required.length || delete n.required, n;
}
const nde = (e, t) => {
  if (t.currentPath.toString() === t.propertyPath?.toString())
    return Cn(e.innerType._def, t);
  const r = Cn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return r ? {
    anyOf: [
      {
        not: {}
      },
      r
    ]
  } : {};
}, ide = (e, t) => {
  if (t.pipeStrategy === "input")
    return Cn(e.in._def, t);
  if (t.pipeStrategy === "output")
    return Cn(e.out._def, t);
  const r = Cn(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), n = Cn(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", r ? "1" : "0"]
  });
  return {
    allOf: [r, n].filter((a) => a !== void 0)
  };
};
function ade(e, t) {
  return Cn(e.type._def, t);
}
function sde(e, t) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Cn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && Mn(n, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Mn(n, "maxItems", e.maxSize.value, e.maxSize.message, t), n;
}
function ode(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map((r, n) => Cn(r._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${n}`]
    })).reduce((r, n) => n === void 0 ? r : [...r, n], []),
    additionalItems: Cn(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map((r, n) => Cn(r._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${n}`]
    })).reduce((r, n) => n === void 0 ? r : [...r, n], [])
  };
}
function lde() {
  return {
    not: {}
  };
}
function ude() {
  return {};
}
const cde = (e, t) => Cn(e.innerType._def, t);
function Cn(e, t, r = !1) {
  const n = t.seen.get(e);
  if (t.override) {
    const i = t.override?.(e, t, n, r);
    if (i !== Nce)
      return i;
  }
  if (n && !r) {
    const i = dde(n, t);
    if (i !== void 0)
      return i;
  }
  const a = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, a);
  const s = pde(e, e.typeName, t);
  return s && hde(e, t, s), a.jsonSchema = s, s;
}
const dde = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: fde(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((r, n) => t.currentPath[n] === r) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), {}) : t.$refStrategy === "seen" ? {} : void 0;
  }
}, fde = (e, t) => {
  let r = 0;
  for (; r < e.length && r < t.length && e[r] === t[r]; r++)
    ;
  return [(e.length - r).toString(), ...t.slice(r)].join("/");
}, pde = (e, t, r) => {
  switch (t) {
    case qt.ZodString:
      return qq(e, r);
    case qt.ZodNumber:
      return ede(e, r);
    case qt.ZodObject:
      return rde(e, r);
    case qt.ZodBigInt:
      return Mce(e, r);
    case qt.ZodBoolean:
      return Fce();
    case qt.ZodDate:
      return zq(e, r);
    case qt.ZodUndefined:
      return lde();
    case qt.ZodNull:
      return Zce(r);
    case qt.ZodArray:
      return Lce(e, r);
    case qt.ZodUnion:
    case qt.ZodDiscriminatedUnion:
      return Jce(e, r);
    case qt.ZodIntersection:
      return Hce(e, r);
    case qt.ZodTuple:
      return ode(e, r);
    case qt.ZodRecord:
      return jq(e, r);
    case qt.ZodLiteral:
      return Vce(e, r);
    case qt.ZodEnum:
      return qce(e);
    case qt.ZodNativeEnum:
      return Yce(e);
    case qt.ZodNullable:
      return Qce(e, r);
    case qt.ZodOptional:
      return nde(e, r);
    case qt.ZodMap:
      return Kce(e, r);
    case qt.ZodSet:
      return sde(e, r);
    case qt.ZodLazy:
      return Cn(e.getter()._def, r);
    case qt.ZodPromise:
      return ade(e, r);
    case qt.ZodNaN:
    case qt.ZodNever:
      return Xce();
    case qt.ZodEffects:
      return zce(e, r);
    case qt.ZodAny:
      return Pce();
    case qt.ZodUnknown:
      return ude();
    case qt.ZodDefault:
      return Uce(e, r);
    case qt.ZodBranded:
      return Uq(e, r);
    case qt.ZodReadonly:
      return cde(e, r);
    case qt.ZodCatch:
      return $ce(e, r);
    case qt.ZodPipeline:
      return ide(e, r);
    case qt.ZodFunction:
    case qt.ZodVoid:
    case qt.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((n) => {
      })();
  }
}, hde = (e, t, r) => (e.description && (r.description = e.description, t.markdownDescription && (r.markdownDescription = e.description)), r), mde = (e, t) => {
  const r = Oce(t), n = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce((l, [u, c]) => ({
    ...l,
    [u]: Cn(c._def, {
      ...r,
      currentPath: [...r.basePath, r.definitionPath, u]
    }, !0) ?? {}
  }), {}) : void 0, a = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = Cn(e._def, a === void 0 ? r : {
    ...r,
    currentPath: [...r.basePath, r.definitionPath, a]
  }, !1) ?? {}, i = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  i !== void 0 && (s.title = i);
  const o = a === void 0 ? n ? {
    ...s,
    [r.definitionPath]: n
  } : s : {
    $ref: [
      ...r.$refStrategy === "relative" ? [] : r.basePath,
      r.definitionPath,
      a
    ].join("/"),
    [r.definitionPath]: {
      ...n,
      [a]: s
    }
  };
  return r.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : (r.target === "jsonSchema2019-09" || r.target === "openAi") && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), r.target === "openAi" && ("anyOf" in o || "oneOf" in o || "allOf" in o || "type" in o && Array.isArray(o.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), o;
};
var Sp = {
  code: "0",
  name: "text",
  parse: (e) => {
    if (typeof e != "string")
      throw new Error('"text" parts expect a string value.');
    return { type: "text", value: e };
  }
}, _p = {
  code: "3",
  name: "error",
  parse: (e) => {
    if (typeof e != "string")
      throw new Error('"error" parts expect a string value.');
    return { type: "error", value: e };
  }
}, kp = {
  code: "4",
  name: "assistant_message",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("id" in e) || !("role" in e) || !("content" in e) || typeof e.id != "string" || typeof e.role != "string" || e.role !== "assistant" || !Array.isArray(e.content) || !e.content.every(
      (t) => t != null && typeof t == "object" && "type" in t && t.type === "text" && "text" in t && t.text != null && typeof t.text == "object" && "value" in t.text && typeof t.text.value == "string"
    ))
      throw new Error(
        '"assistant_message" parts expect an object with an "id", "role", and "content" property.'
      );
    return {
      type: "assistant_message",
      value: e
    };
  }
}, Cp = {
  code: "5",
  name: "assistant_control_data",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("threadId" in e) || !("messageId" in e) || typeof e.threadId != "string" || typeof e.messageId != "string")
      throw new Error(
        '"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.'
      );
    return {
      type: "assistant_control_data",
      value: {
        threadId: e.threadId,
        messageId: e.messageId
      }
    };
  }
}, Ap = {
  code: "6",
  name: "data_message",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("role" in e) || !("data" in e) || typeof e.role != "string" || e.role !== "data")
      throw new Error(
        '"data_message" parts expect an object with a "role" and "data" property.'
      );
    return {
      type: "data_message",
      value: e
    };
  }
}, gde = [
  Sp,
  _p,
  kp,
  Cp,
  Ap
];
Sp.code + "", _p.code + "", kp.code + "", Cp.code + "", Ap.code + "";
Sp.name + "", Sp.code, _p.name + "", _p.code, kp.name + "", kp.code, Cp.name + "", Cp.code, Ap.name + "", Ap.code;
gde.map((e) => e.code);
function bde(e) {
  const t = ["ROOT"];
  let r = -1, n = null;
  function a(l, u, c) {
    switch (l) {
      case '"': {
        r = u, t.pop(), t.push(c), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        r = u, n = u, t.pop(), t.push(c), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(c), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        r = u, t.pop(), t.push(c), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        r = u, t.pop(), t.push(c), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        r = u, t.pop(), t.push(c), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function s(l, u) {
    switch (l) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        r = u, t.pop();
        break;
      }
    }
  }
  function i(l, u) {
    switch (l) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        r = u, t.pop();
        break;
      }
    }
  }
  for (let l = 0; l < e.length; l++) {
    const u = e[l];
    switch (t[t.length - 1]) {
      case "ROOT":
        a(u, l, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            r = l, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (u) {
          case ":": {
            t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        a(u, l, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        s(u, l);
        break;
      }
      case "INSIDE_STRING": {
        switch (u) {
          case '"': {
            t.pop(), r = l;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            r = l;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (u) {
          case "]": {
            r = l, t.pop();
            break;
          }
          default: {
            r = l, a(u, l, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (u) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            r = l, t.pop();
            break;
          }
          default: {
            r = l;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        a(u, l, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), r = l;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (u) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            r = l;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && i(u, l), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(u, l);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(u, l);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && i(u, l);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const d = e.substring(n, l + 1);
        !"false".startsWith(d) && !"true".startsWith(d) && !"null".startsWith(d) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? s(u, l) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && i(u, l)) : r = l;
        break;
      }
    }
  }
  let o = e.slice(0, r + 1);
  for (let l = t.length - 1; l >= 0; l--)
    switch (t[l]) {
      case "INSIDE_STRING": {
        o += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        o += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        o += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const c = e.substring(n, e.length);
        "true".startsWith(c) ? o += "true".slice(c.length) : "false".startsWith(c) ? o += "false".slice(c.length) : "null".startsWith(c) && (o += "null".slice(c.length));
      }
    }
  return o;
}
function yde(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = GP({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = GP({ text: bde(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
var Tp = {
  code: "0",
  name: "text",
  parse: (e) => {
    if (typeof e != "string")
      throw new Error('"text" parts expect a string value.');
    return { type: "text", value: e };
  }
}, Rp = {
  code: "2",
  name: "data",
  parse: (e) => {
    if (!Array.isArray(e))
      throw new Error('"data" parts expect an array value.');
    return { type: "data", value: e };
  }
}, Ip = {
  code: "3",
  name: "error",
  parse: (e) => {
    if (typeof e != "string")
      throw new Error('"error" parts expect a string value.');
    return { type: "error", value: e };
  }
}, Np = {
  code: "8",
  name: "message_annotations",
  parse: (e) => {
    if (!Array.isArray(e))
      throw new Error('"message_annotations" parts expect an array value.');
    return { type: "message_annotations", value: e };
  }
}, Dp = {
  code: "9",
  name: "tool_call",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("toolCallId" in e) || typeof e.toolCallId != "string" || !("toolName" in e) || typeof e.toolName != "string" || !("args" in e) || typeof e.args != "object")
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    return {
      type: "tool_call",
      value: e
    };
  }
}, Op = {
  code: "a",
  name: "tool_result",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("toolCallId" in e) || typeof e.toolCallId != "string" || !("result" in e))
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    return {
      type: "tool_result",
      value: e
    };
  }
}, Pp = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("toolCallId" in e) || typeof e.toolCallId != "string" || !("toolName" in e) || typeof e.toolName != "string")
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    return {
      type: "tool_call_streaming_start",
      value: e
    };
  }
}, Lp = {
  code: "c",
  name: "tool_call_delta",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("toolCallId" in e) || typeof e.toolCallId != "string" || !("argsTextDelta" in e) || typeof e.argsTextDelta != "string")
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    return {
      type: "tool_call_delta",
      value: e
    };
  }
}, Mp = {
  code: "d",
  name: "finish_message",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("finishReason" in e) || typeof e.finishReason != "string")
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    const t = {
      finishReason: e.finishReason
    };
    return "usage" in e && e.usage != null && typeof e.usage == "object" && "promptTokens" in e.usage && "completionTokens" in e.usage && (t.usage = {
      promptTokens: typeof e.usage.promptTokens == "number" ? e.usage.promptTokens : Number.NaN,
      completionTokens: typeof e.usage.completionTokens == "number" ? e.usage.completionTokens : Number.NaN
    }), {
      type: "finish_message",
      value: t
    };
  }
}, Fp = {
  code: "e",
  name: "finish_step",
  parse: (e) => {
    if (e == null || typeof e != "object" || !("finishReason" in e) || typeof e.finishReason != "string")
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    const t = {
      finishReason: e.finishReason,
      isContinued: !1
    };
    return "usage" in e && e.usage != null && typeof e.usage == "object" && "promptTokens" in e.usage && "completionTokens" in e.usage && (t.usage = {
      promptTokens: typeof e.usage.promptTokens == "number" ? e.usage.promptTokens : Number.NaN,
      completionTokens: typeof e.usage.completionTokens == "number" ? e.usage.completionTokens : Number.NaN
    }), "isContinued" in e && typeof e.isContinued == "boolean" && (t.isContinued = e.isContinued), {
      type: "finish_step",
      value: t
    };
  }
}, vde = [
  Tp,
  Rp,
  Ip,
  Np,
  Dp,
  Op,
  Pp,
  Lp,
  Mp,
  Fp
];
Tp.code + "", Rp.code + "", Ip.code + "", Np.code + "", Dp.code + "", Op.code + "", Pp.code + "", Lp.code + "", Mp.code + "", Fp.code + "";
Tp.name + "", Tp.code, Rp.name + "", Rp.code, Ip.name + "", Ip.code, Np.name + "", Np.code, Dp.name + "", Dp.code, Op.name + "", Op.code, Pp.name + "", Pp.code, Lp.name + "", Lp.code, Mp.name + "", Mp.code, Fp.name + "", Fp.code;
vde.map((e) => e.code);
function JT(e, t) {
  if (e === t)
    return !0;
  if (e == null || t == null)
    return !1;
  if (typeof e != "object" && typeof t != "object")
    return e === t;
  if (e.constructor !== t.constructor)
    return !1;
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (Array.isArray(e)) {
    if (e.length !== t.length)
      return !1;
    for (let a = 0; a < e.length; a++)
      if (!JT(e[a], t[a]))
        return !1;
    return !0;
  }
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const a of r)
    if (!n.includes(a) || !JT(e[a], t[a]))
      return !1;
  return !0;
}
function wde(e) {
  return xde(
    mde(e, {
      $refStrategy: "none",
      // no references (to support openapi conversion for google)
      target: "openAi"
      // openai strict mode compatible
    }),
    {
      validate: (t) => {
        const r = e.safeParse(t);
        return r.success ? { success: !0, value: r.data } : { success: !1, error: r.error };
      }
    }
  );
}
var QT = Symbol.for("vercel.ai.schema");
function xde(e, {
  validate: t
} = {}) {
  return {
    [QT]: !0,
    _type: void 0,
    // should never be used directly
    [Fg]: !0,
    jsonSchema: e,
    validate: t
  };
}
function Ede(e) {
  return typeof e == "object" && e !== null && QT in e && e[QT] === !0 && "jsonSchema" in e && "validate" in e;
}
function Sde(e) {
  return Ede(e) ? e : wde(e);
}
var sm = { exports: {} }, h1 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XP;
function _de() {
  if (XP) return h1;
  XP = 1;
  var e = kt;
  function t(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, a = e.useEffect, s = e.useLayoutEffect, i = e.useDebugValue;
  function o(d, p) {
    var f = p(), h = n({ inst: { value: f, getSnapshot: p } }), m = h[0].inst, y = h[1];
    return s(
      function() {
        m.value = f, m.getSnapshot = p, l(m) && y({ inst: m });
      },
      [d, f, p]
    ), a(
      function() {
        return l(m) && y({ inst: m }), d(function() {
          l(m) && y({ inst: m });
        });
      },
      [d]
    ), i(f), f;
  }
  function l(d) {
    var p = d.getSnapshot;
    d = d.value;
    try {
      var f = p();
      return !r(d, f);
    } catch {
      return !0;
    }
  }
  function u(d, p) {
    return p();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : o;
  return h1.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, h1;
}
var m1 = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZP;
function kde() {
  return ZP || (ZP = 1, process.env.NODE_ENV !== "production" && function() {
    function e(f, h) {
      return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h;
    }
    function t(f, h) {
      c || a.startTransition === void 0 || (c = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = h();
      if (!d) {
        var y = h();
        s(m, y) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      y = i({
        inst: { value: m, getSnapshot: h }
      });
      var b = y[0].inst, v = y[1];
      return l(
        function() {
          b.value = m, b.getSnapshot = h, r(b) && v({ inst: b });
        },
        [f, m, h]
      ), o(
        function() {
          return r(b) && v({ inst: b }), f(function() {
            r(b) && v({ inst: b });
          });
        },
        [f]
      ), u(m), m;
    }
    function r(f) {
      var h = f.getSnapshot;
      f = f.value;
      try {
        var m = h();
        return !s(f, m);
      } catch {
        return !0;
      }
    }
    function n(f, h) {
      return h();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var a = kt, s = typeof Object.is == "function" ? Object.is : e, i = a.useState, o = a.useEffect, l = a.useLayoutEffect, u = a.useDebugValue, c = !1, d = !1, p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? n : t;
    m1.useSyncExternalStore = a.useSyncExternalStore !== void 0 ? a.useSyncExternalStore : p, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), m1;
}
var JP;
function Cde() {
  return JP || (JP = 1, process.env.NODE_ENV === "production" ? sm.exports = _de() : sm.exports = kde()), sm.exports;
}
var Ade = Cde(), QP = Object.prototype.hasOwnProperty;
function eR(e, t) {
  var r, n;
  if (e === t) return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
        for (; n-- && eR(e[n], t[n]); ) ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
        if (QP.call(e, r) && ++n && !QP.call(t, r) || !(r in t) || !eR(e[r], t[r])) return !1;
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
const Do = /* @__PURE__ */ new WeakMap(), Rl = () => {
}, sa = (
  /*#__NOINLINE__*/
  Rl()
), tR = Object, kn = (e) => e === sa, to = (e) => typeof e == "function", Ul = (e, t) => ({
  ...e,
  ...t
}), Hq = (e) => to(e.then), g1 = {}, om = {}, JI = "undefined", zb = typeof window != JI, rR = typeof document != JI, Tde = () => zb && typeof window.requestAnimationFrame != JI, Vq = (e, t) => {
  const r = Do.get(e);
  return [
    // Getter
    () => !kn(t) && e.get(t) || g1,
    // Setter
    (n) => {
      if (!kn(t)) {
        const a = e.get(t);
        t in om || (om[t] = a), r[5](t, Ul(a, n), a || g1);
      }
    },
    // Subscriber
    r[6],
    // Get server cache snapshot
    () => !kn(t) && t in om ? om[t] : !kn(t) && e.get(t) || g1
  ];
};
let nR = !0;
const Rde = () => nR, [iR, aR] = zb && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Rl,
  Rl
], Ide = () => {
  const e = rR && document.visibilityState;
  return kn(e) || e !== "hidden";
}, Nde = (e) => (rR && document.addEventListener("visibilitychange", e), iR("focus", e), () => {
  rR && document.removeEventListener("visibilitychange", e), aR("focus", e);
}), Dde = (e) => {
  const t = () => {
    nR = !0, e();
  }, r = () => {
    nR = !1;
  };
  return iR("online", t), iR("offline", r), () => {
    aR("online", t), aR("offline", r);
  };
}, Ode = {
  isOnline: Rde,
  isVisible: Ide
}, Pde = {
  initFocus: Nde,
  initReconnect: Dde
}, eL = !kt.useId, $p = !zb || "Deno" in globalThis, Lde = (e) => Tde() ? window.requestAnimationFrame(e) : setTimeout(e, 1), b1 = $p ? Qn : Sb, y1 = typeof navigator < "u" && navigator.connection, tL = !$p && y1 && ([
  "slow-2g",
  "2g"
].includes(y1.effectiveType) || y1.saveData), lm = /* @__PURE__ */ new WeakMap(), v1 = (e, t) => tR.prototype.toString.call(e) === `[object ${t}]`;
let Mde = 0;
const sR = (e) => {
  const t = typeof e, r = v1(e, "Date"), n = v1(e, "RegExp"), a = v1(e, "Object");
  let s, i;
  if (tR(e) === e && !r && !n) {
    if (s = lm.get(e), s) return s;
    if (s = ++Mde + "~", lm.set(e, s), Array.isArray(e)) {
      for (s = "@", i = 0; i < e.length; i++)
        s += sR(e[i]) + ",";
      lm.set(e, s);
    }
    if (a) {
      s = "#";
      const o = tR.keys(e).sort();
      for (; !kn(i = o.pop()); )
        kn(e[i]) || (s += i + ":" + sR(e[i]) + ",");
      lm.set(e, s);
    }
  } else
    s = r ? e.toJSON() : t == "symbol" ? e.toString() : t == "string" ? JSON.stringify(e) : "" + e;
  return s;
}, QI = (e) => {
  if (to(e))
    try {
      e = e();
    } catch {
      e = "";
    }
  const t = e;
  return e = typeof e == "string" ? e : (Array.isArray(e) ? e.length : e) ? sR(e) : "", [
    e,
    t
  ];
};
let Fde = 0;
const oR = () => ++Fde, Gq = 0, Wq = 1, Kq = 2, $de = 3;
var pf = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: $de,
  FOCUS_EVENT: Gq,
  MUTATE_EVENT: Kq,
  RECONNECT_EVENT: Wq
};
async function Yq(...e) {
  const [t, r, n, a] = e, s = Ul({
    populateCache: !0,
    throwOnError: !0
  }, typeof a == "boolean" ? {
    revalidate: a
  } : a || {});
  let i = s.populateCache;
  const o = s.rollbackOnError;
  let l = s.optimisticData;
  const u = (p) => typeof o == "function" ? o(p) : o !== !1, c = s.throwOnError;
  if (to(r)) {
    const p = r, f = [], h = t.keys();
    for (const m of h)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(m) && p(t.get(m)._k) && f.push(m);
    return Promise.all(f.map(d));
  }
  return d(r);
  async function d(p) {
    const [f] = QI(p);
    if (!f) return;
    const [h, m] = Vq(t, f), [y, b, v, x] = Do.get(t), _ = () => {
      const O = y[f];
      return (to(s.revalidate) ? s.revalidate(h().data, p) : s.revalidate !== !1) && (delete v[f], delete x[f], O && O[0]) ? O[0](Kq).then(() => h().data) : h().data;
    };
    if (e.length < 3)
      return _();
    let E = n, w;
    const C = oR();
    b[f] = [
      C,
      0
    ];
    const k = !kn(l), S = h(), B = S.data, U = S._c, N = kn(U) ? B : U;
    if (k && (l = to(l) ? l(N, B) : l, m({
      data: l,
      _c: N
    })), to(E))
      try {
        E = E(N);
      } catch (O) {
        w = O;
      }
    if (E && Hq(E))
      if (E = await E.catch((O) => {
        w = O;
      }), C !== b[f][0]) {
        if (w) throw w;
        return E;
      } else w && k && u(w) && (i = !0, m({
        data: N,
        _c: sa
      }));
    if (i && !w)
      if (to(i)) {
        const O = i(E, N);
        m({
          data: O,
          error: sa,
          _c: sa
        });
      } else
        m({
          data: E,
          error: sa,
          _c: sa
        });
    if (b[f][1] = oR(), Promise.resolve(_()).then(() => {
      m({
        _c: sa
      });
    }), w) {
      if (c) throw w;
      return;
    }
    return E;
  }
}
const rL = (e, t) => {
  for (const r in e)
    e[r][0] && e[r][0](t);
}, Bde = (e, t) => {
  if (!Do.has(e)) {
    const r = Ul(Pde, t), n = {}, a = Yq.bind(sa, e);
    let s = Rl;
    const i = {}, o = (c, d) => {
      const p = i[c] || [];
      return i[c] = p, p.push(d), () => p.splice(p.indexOf(d), 1);
    }, l = (c, d, p) => {
      e.set(c, d);
      const f = i[c];
      if (f)
        for (const h of f)
          h(d, p);
    }, u = () => {
      if (!Do.has(e) && (Do.set(e, [
        n,
        {},
        {},
        {},
        a,
        l,
        o
      ]), !$p)) {
        const c = r.initFocus(setTimeout.bind(sa, rL.bind(sa, n, Gq))), d = r.initReconnect(setTimeout.bind(sa, rL.bind(sa, n, Wq)));
        s = () => {
          c && c(), d && d(), Do.delete(e);
        };
      }
    };
    return u(), [
      e,
      a,
      u,
      s
    ];
  }
  return [
    e,
    Do.get(e)[4]
  ];
}, Ude = (e, t, r, n, a) => {
  const s = r.errorRetryCount, i = a.retryCount, o = ~~((Math.random() + 0.5) * (1 << (i < 8 ? i : 8))) * r.errorRetryInterval;
  !kn(s) && i > s || setTimeout(n, o, a);
}, zde = eR, [Xq, qde] = Bde(/* @__PURE__ */ new Map()), jde = Ul(
  {
    // events
    onLoadingSlow: Rl,
    onSuccess: Rl,
    onError: Rl,
    onErrorRetry: Ude,
    onDiscarded: Rl,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: tL ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: tL ? 5e3 : 3e3,
    // providers
    compare: zde,
    isPaused: () => !1,
    cache: Xq,
    mutate: qde,
    fallback: {}
  },
  // use web preset by default
  Ode
), Hde = (e, t) => {
  const r = Ul(e, t);
  if (t) {
    const { use: n, fallback: a } = e, { use: s, fallback: i } = t;
    n && s && (r.use = n.concat(s)), a && i && (r.fallback = Ul(a, i));
  }
  return r;
}, Vde = Ko({}), Gde = "$inf$", Zq = zb && window.__SWR_DEVTOOLS_USE__, Wde = Zq ? window.__SWR_DEVTOOLS_USE__ : [], Kde = () => {
  Zq && (window.__SWR_DEVTOOLS_REACT__ = kt);
}, Yde = (e) => to(e[1]) ? [
  e[0],
  e[1],
  e[2] || {}
] : [
  e[0],
  null,
  (e[1] === null ? e[2] : e[1]) || {}
], Xde = () => Ul(jde, Ta(Vde)), Zde = (e) => (t, r, n) => e(t, r && ((...s) => {
  const [i] = QI(t), [, , , o] = Do.get(Xq);
  if (i.startsWith(Gde))
    return r(...s);
  const l = o[i];
  return kn(l) ? r(...s) : (delete o[i], l);
}), n), Jde = Wde.concat(Zde), Qde = (e) => function(...r) {
  const n = Xde(), [a, s, i] = Yde(r), o = Hde(n, i);
  let l = e;
  const { use: u } = o, c = (u || []).concat(Jde);
  for (let d = c.length; d--; )
    l = c[d](l);
  return l(a, s || o.fetcher || null, o);
}, efe = (e, t, r) => {
  const n = t[e] || (t[e] = []);
  return n.push(r), () => {
    const a = n.indexOf(r);
    a >= 0 && (n[a] = n[n.length - 1], n.pop());
  };
};
Kde();
const w1 = kt.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((e) => {
  switch (e.status) {
    case "pending":
      throw e;
    case "fulfilled":
      return e.value;
    case "rejected":
      throw e.reason;
    default:
      throw e.status = "pending", e.then((t) => {
        e.status = "fulfilled", e.value = t;
      }, (t) => {
        e.status = "rejected", e.reason = t;
      }), e;
  }
}), x1 = {
  dedupe: !0
}, tfe = (e, t, r) => {
  const { cache: n, compare: a, suspense: s, fallbackData: i, revalidateOnMount: o, revalidateIfStale: l, refreshInterval: u, refreshWhenHidden: c, refreshWhenOffline: d, keepPreviousData: p } = r, [f, h, m, y] = Do.get(n), [b, v] = QI(e), x = Gr(!1), _ = Gr(!1), E = Gr(b), w = Gr(t), C = Gr(r), k = () => C.current, S = () => k().isVisible() && k().isOnline(), [B, U, N, O] = Vq(n, b), I = Gr({}).current, q = kn(i) ? kn(r.fallback) ? sa : r.fallback[b] : i, ae = (re, Te) => {
    for (const V in I) {
      const Pe = V;
      if (Pe === "data") {
        if (!a(re[Pe], Te[Pe]) && (!kn(re[Pe]) || !a(ye, Te[Pe])))
          return !1;
      } else if (Te[Pe] !== re[Pe])
        return !1;
    }
    return !0;
  }, Q = Or(() => {
    const re = !b || !t ? !1 : kn(o) ? k().isPaused() || s ? !1 : l !== !1 : o, Te = (H) => {
      const be = Ul(H);
      return delete be._k, re ? {
        isValidating: !0,
        isLoading: !0,
        ...be
      } : be;
    }, V = B(), Pe = O(), z = Te(V), A = V === Pe ? z : Te(Pe);
    let R = z;
    return [
      () => {
        const H = Te(B());
        return ae(H, R) ? (R.data = H.data, R.isLoading = H.isLoading, R.isValidating = H.isValidating, R.error = H.error, R) : (R = H, H);
      },
      () => A
    ];
  }, [
    n,
    b
  ]), ne = Ade.useSyncExternalStore(ci(
    (re) => N(b, (Te, V) => {
      ae(V, Te) || re();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      n,
      b
    ]
  ), Q[0], Q[1]), le = !x.current, W = f[b] && f[b].length > 0, X = ne.data, G = kn(X) ? q && Hq(q) ? w1(q) : q : X, P = ne.error, he = Gr(G), ye = p ? kn(X) ? he.current : X : G, pe = W && !kn(P) ? !1 : le && !kn(o) ? o : k().isPaused() ? !1 : s ? kn(G) ? !1 : l : kn(G) || l, $ = !!(b && t && le && pe), F = kn(ne.isValidating) ? $ : ne.isValidating, ge = kn(ne.isLoading) ? $ : ne.isLoading, ce = ci(
    async (re) => {
      const Te = w.current;
      if (!b || !Te || _.current || k().isPaused())
        return !1;
      let V, Pe, z = !0;
      const A = re || {}, R = !m[b] || !A.dedupe, H = () => eL ? !_.current && b === E.current && x.current : b === E.current, be = {
        isValidating: !1,
        isLoading: !1
      }, me = () => {
        U(be);
      }, Ce = () => {
        const xe = m[b];
        xe && xe[1] === Pe && delete m[b];
      }, We = {
        isValidating: !0
      };
      kn(B().data) && (We.isLoading = !0);
      try {
        if (R && (U(We), r.loadingTimeout && kn(B().data) && setTimeout(() => {
          z && H() && k().onLoadingSlow(b, r);
        }, r.loadingTimeout), m[b] = [
          Te(v),
          oR()
        ]), [V, Pe] = m[b], V = await V, R && setTimeout(Ce, r.dedupingInterval), !m[b] || m[b][1] !== Pe)
          return R && H() && k().onDiscarded(b), !1;
        be.error = sa;
        const xe = h[b];
        if (!kn(xe) && // case 1
        (Pe <= xe[0] || // case 2
        Pe <= xe[1] || // case 3
        xe[1] === 0))
          return me(), R && H() && k().onDiscarded(b), !1;
        const we = B().data;
        be.data = a(we, V) ? we : V, R && H() && k().onSuccess(V, b, r);
      } catch (xe) {
        Ce();
        const we = k(), { shouldRetryOnError: te } = we;
        we.isPaused() || (be.error = xe, R && H() && (we.onError(xe, b, we), (te === !0 || to(te) && te(xe)) && (!k().revalidateOnFocus || !k().revalidateOnReconnect || S()) && we.onErrorRetry(xe, b, we, (Fe) => {
          const Y = f[b];
          Y && Y[0] && Y[0](pf.ERROR_REVALIDATE_EVENT, Fe);
        }, {
          retryCount: (A.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return z = !1, me(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      b,
      n
    ]
  ), ie = ci(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...re) => Yq(n, E.current, ...re),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (b1(() => {
    w.current = t, C.current = r, kn(X) || (he.current = X);
  }), b1(() => {
    if (!b) return;
    const re = ce.bind(sa, x1);
    let Te = 0;
    const Pe = efe(b, f, (z, A = {}) => {
      if (z == pf.FOCUS_EVENT) {
        const R = Date.now();
        k().revalidateOnFocus && R > Te && S() && (Te = R + k().focusThrottleInterval, re());
      } else if (z == pf.RECONNECT_EVENT)
        k().revalidateOnReconnect && S() && re();
      else {
        if (z == pf.MUTATE_EVENT)
          return ce();
        if (z == pf.ERROR_REVALIDATE_EVENT)
          return ce(A);
      }
    });
    return _.current = !1, E.current = b, x.current = !0, U({
      _k: v
    }), pe && (kn(G) || $p ? re() : Lde(re)), () => {
      _.current = !0, Pe();
    };
  }, [
    b
  ]), b1(() => {
    let re;
    function Te() {
      const Pe = to(u) ? u(B().data) : u;
      Pe && re !== -1 && (re = setTimeout(V, Pe));
    }
    function V() {
      !B().error && (c || k().isVisible()) && (d || k().isOnline()) ? ce(x1).then(Te) : Te();
    }
    return Te(), () => {
      re && (clearTimeout(re), re = -1);
    };
  }, [
    u,
    c,
    d,
    b
  ]), JQ(ye), s && kn(G) && b) {
    if (!eL && $p)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    w.current = t, C.current = r, _.current = !1;
    const re = y[b];
    if (!kn(re)) {
      const Te = ie(re);
      w1(Te);
    }
    if (kn(P)) {
      const Te = ce(x1);
      kn(ye) || (Te.status = "fulfilled", Te.value = !0), w1(Te);
    } else
      throw P;
  }
  return {
    mutate: ie,
    get data() {
      return I.data = !0, ye;
    },
    get error() {
      return I.error = !0, P;
    },
    get isValidating() {
      return I.isValidating = !0, F;
    },
    get isLoading() {
      return I.isLoading = !0, ge;
    }
  };
}, rfe = Qde(tfe);
var nfe = () => fetch;
function ife({
  api: e,
  id: t,
  schema: r,
  // required, in the future we will use it for validation
  initialValue: n,
  fetch: a,
  onError: s,
  onFinish: i,
  headers: o
}) {
  const l = QQ(), u = t ?? l, { data: c, mutate: d } = rfe(
    [e, u],
    null,
    { fallbackData: n }
  ), [p, f] = Wn(void 0), [h, m] = Wn(!1), y = Gr(null), b = ci(() => {
    var x;
    try {
      (x = y.current) == null || x.abort();
    } catch {
    } finally {
      m(!1), y.current = null;
    }
  }, []);
  return {
    submit: async (x) => {
      var _;
      try {
        d(void 0), m(!0), f(void 0);
        const E = new AbortController();
        y.current = E;
        const C = await (a ?? nfe())(e, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...o
          },
          signal: E.signal,
          body: JSON.stringify(x)
        });
        if (!C.ok)
          throw new Error(
            (_ = await C.text()) != null ? _ : "Failed to fetch the response."
          );
        if (C.body == null)
          throw new Error("The response body is empty.");
        let k = "", S;
        await C.body.pipeThrough(new TextDecoderStream()).pipeTo(
          new WritableStream({
            write(B) {
              k += B;
              const { value: U } = yde(k), N = U;
              JT(S, N) || (S = N, d(N));
            },
            close() {
              if (m(!1), y.current = null, i != null) {
                const B = $q({
                  value: S,
                  schema: Sde(r)
                });
                i(
                  B.success ? { object: B.value, error: void 0 } : { object: void 0, error: B.error }
                );
              }
            }
          })
        );
      } catch (E) {
        if (Cce(E))
          return;
        s && E instanceof Error && s(E), m(!1), f(E instanceof Error ? E : new Error(String(E)));
      }
    },
    object: c,
    error: p,
    isLoading: h,
    stop: b
  };
}
var afe = ife, sfe = afe;
const ofe = _a.object({
  chunks: _a.array(
    _a.object({
      text: _a.string().nullish(),
      content: _a.string().nullish()
    })
  )
}), lfe = (e) => {
  const { variables: t, postData: r, postDataUrl: n, layout: a } = e, [s, i] = kt.useState(crypto.randomUUID()), [o, l] = kt.useState(!0), [u, c] = kt.useState([]), [d, p] = kt.useState(""), [f, h] = kt.useState(""), [m, y] = kt.useState(void 0), b = (k) => {
    p(k.target.value);
  }, { submit: v, object: x, isLoading: _, error: E } = sfe({
    api: n(r),
    headers: {
      "content-type": "application/json"
    },
    fetch: async () => fetch(n(r), {
      method: "POST",
      body: JSON.stringify({
        variables: {
          ...kb(t ?? {}),
          prompt: d,
          thread_id: s,
          is_new_conversation: o
        }
      }),
      headers: {
        "content-type": "application/json"
      }
    }),
    schema: ofe,
    onFinish: (k) => {
      c((S) => [
        ...S,
        {
          content: k.object?.chunks.map((B) => B.text).join("") || "",
          role: "assistant",
          id: crypto.randomUUID()
        }
      ]), h(
        k.object?.chunks.map((S) => S.content).join("") || ""
      ), y(void 0);
    },
    onError: (k) => {
      console.error(k);
    }
  }), w = kt.useCallback(() => {
    i(crypto.randomUUID()), c([]), l(() => !0);
  }, [c]), C = kt.useCallback(() => {
    a === "single" && w(), c([
      ...u,
      { content: d, role: "user", id: crypto.randomUUID() }
    ]), v({ input: d }), p(""), l(() => !1);
  }, [d, a, u, w, v]);
  return kt.useEffect(() => {
    y(m ? (k) => ({
      ...k,
      content: x?.chunks?.map((S) => S?.text).join("") || ""
    }) : {
      content: x?.chunks?.map((k) => k?.text).join("") || "",
      role: "assistant",
      id: crypto.randomUUID()
    });
  }, [x?.chunks]), {
    handleSubmit: C,
    handleInputChange: b,
    startNewThread: w,
    input: d,
    isLoading: _,
    content: f,
    messages: u,
    commingMessage: m,
    error: E
  };
};
function Bs({
  prop: e,
  defaultProp: t,
  onChange: r = () => {
  }
}) {
  const [n, a] = ufe({ defaultProp: t, onChange: r }), s = e !== void 0, i = s ? e : n, o = si(r), l = D.useCallback(
    (u) => {
      if (s) {
        const d = typeof u == "function" ? u(e) : u;
        d !== e && o(d);
      } else
        a(u);
    },
    [s, e, a, o]
  );
  return [i, l];
}
function ufe({
  defaultProp: e,
  onChange: t
}) {
  const r = D.useState(e), [n] = r, a = D.useRef(n), s = si(t);
  return D.useEffect(() => {
    a.current !== n && (s(n), a.current = n);
  }, [n, a, s]), r;
}
function qb(e) {
  const t = e + "CollectionProvider", [r, n] = ds(t), [a, s] = r(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), i = (f) => {
    const { scope: h, children: m } = f, y = kt.useRef(null), b = kt.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ K(a, { scope: h, itemMap: b, collectionRef: y, children: m });
  };
  i.displayName = t;
  const o = e + "CollectionSlot", l = kt.forwardRef(
    (f, h) => {
      const { scope: m, children: y } = f, b = s(o, m), v = sn(h, b.collectionRef);
      return /* @__PURE__ */ K(zo, { ref: v, children: y });
    }
  );
  l.displayName = o;
  const u = e + "CollectionItemSlot", c = "data-radix-collection-item", d = kt.forwardRef(
    (f, h) => {
      const { scope: m, children: y, ...b } = f, v = kt.useRef(null), x = sn(h, v), _ = s(u, m);
      return kt.useEffect(() => (_.itemMap.set(v, { ref: v, ...b }), () => void _.itemMap.delete(v))), /* @__PURE__ */ K(zo, { [c]: "", ref: x, children: y });
    }
  );
  d.displayName = u;
  function p(f) {
    const h = s(e + "CollectionConsumer", f);
    return kt.useCallback(() => {
      const y = h.collectionRef.current;
      if (!y) return [];
      const b = Array.from(y.querySelectorAll(`[${c}]`));
      return Array.from(h.itemMap.values()).sort(
        (_, E) => b.indexOf(_.ref.current) - b.indexOf(E.ref.current)
      );
    }, [h.collectionRef, h.itemMap]);
  }
  return [
    { Provider: i, Slot: l, ItemSlot: d },
    p,
    n
  ];
}
function Jq(e, t = globalThis?.document) {
  const r = si(e);
  D.useEffect(() => {
    const n = (a) => {
      a.key === "Escape" && r(a);
    };
    return t.addEventListener("keydown", n, { capture: !0 }), () => t.removeEventListener("keydown", n, { capture: !0 });
  }, [r, t]);
}
var cfe = "DismissableLayer", lR = "dismissableLayer.update", dfe = "dismissableLayer.pointerDownOutside", ffe = "dismissableLayer.focusOutside", nL, Qq = D.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), jb = D.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: n,
      onPointerDownOutside: a,
      onFocusOutside: s,
      onInteractOutside: i,
      onDismiss: o,
      ...l
    } = e, u = D.useContext(Qq), [c, d] = D.useState(null), p = c?.ownerDocument ?? globalThis?.document, [, f] = D.useState({}), h = sn(t, (C) => d(C)), m = Array.from(u.layers), [y] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), b = m.indexOf(y), v = c ? m.indexOf(c) : -1, x = u.layersWithOutsidePointerEventsDisabled.size > 0, _ = v >= b, E = mfe((C) => {
      const k = C.target, S = [...u.branches].some((B) => B.contains(k));
      !_ || S || (a?.(C), i?.(C), C.defaultPrevented || o?.());
    }, p), w = gfe((C) => {
      const k = C.target;
      [...u.branches].some((B) => B.contains(k)) || (s?.(C), i?.(C), C.defaultPrevented || o?.());
    }, p);
    return Jq((C) => {
      v === u.layers.size - 1 && (n?.(C), !C.defaultPrevented && o && (C.preventDefault(), o()));
    }, p), D.useEffect(() => {
      if (c)
        return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (nL = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), iL(), () => {
          r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = nL);
        };
    }, [c, p, r, u]), D.useEffect(() => () => {
      c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), iL());
    }, [c, u]), D.useEffect(() => {
      const C = () => f({});
      return document.addEventListener(lR, C), () => document.removeEventListener(lR, C);
    }, []), /* @__PURE__ */ K(
      Wr.div,
      {
        ...l,
        ref: h,
        style: {
          pointerEvents: x ? _ ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: nr(e.onFocusCapture, w.onFocusCapture),
        onBlurCapture: nr(e.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: nr(
          e.onPointerDownCapture,
          E.onPointerDownCapture
        )
      }
    );
  }
);
jb.displayName = cfe;
var pfe = "DismissableLayerBranch", hfe = D.forwardRef((e, t) => {
  const r = D.useContext(Qq), n = D.useRef(null), a = sn(t, n);
  return D.useEffect(() => {
    const s = n.current;
    if (s)
      return r.branches.add(s), () => {
        r.branches.delete(s);
      };
  }, [r.branches]), /* @__PURE__ */ K(Wr.div, { ...e, ref: a });
});
hfe.displayName = pfe;
function mfe(e, t = globalThis?.document) {
  const r = si(e), n = D.useRef(!1), a = D.useRef(() => {
  });
  return D.useEffect(() => {
    const s = (o) => {
      if (o.target && !n.current) {
        let l = function() {
          ej(
            dfe,
            r,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: o };
        o.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = l, t.addEventListener("click", a.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", a.current);
      n.current = !1;
    }, i = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(i), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current);
    };
  }, [t, r]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n.current = !0
  };
}
function gfe(e, t = globalThis?.document) {
  const r = si(e), n = D.useRef(!1);
  return D.useEffect(() => {
    const a = (s) => {
      s.target && !n.current && ej(ffe, r, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, r]), {
    onFocusCapture: () => n.current = !0,
    onBlurCapture: () => n.current = !1
  };
}
function iL() {
  const e = new CustomEvent(lR);
  document.dispatchEvent(e);
}
function ej(e, t, r, { discrete: n }) {
  const a = r.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: r });
  t && a.addEventListener(e, t, { once: !0 }), n ? WI(a, s) : a.dispatchEvent(s);
}
var E1 = 0;
function eN() {
  D.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? aL()), document.body.insertAdjacentElement("beforeend", e[1] ?? aL()), E1++, () => {
      E1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), E1--;
    };
  }, []);
}
function aL() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var S1 = "focusScope.autoFocusOnMount", _1 = "focusScope.autoFocusOnUnmount", sL = { bubbles: !1, cancelable: !0 }, bfe = "FocusScope", Hb = D.forwardRef((e, t) => {
  const {
    loop: r = !1,
    trapped: n = !1,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s,
    ...i
  } = e, [o, l] = D.useState(null), u = si(a), c = si(s), d = D.useRef(null), p = sn(t, (m) => l(m)), f = D.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  D.useEffect(() => {
    if (n) {
      let m = function(x) {
        if (f.paused || !o) return;
        const _ = x.target;
        o.contains(_) ? d.current = _ : Sl(d.current, { select: !0 });
      }, y = function(x) {
        if (f.paused || !o) return;
        const _ = x.relatedTarget;
        _ !== null && (o.contains(_) || Sl(d.current, { select: !0 }));
      }, b = function(x) {
        if (document.activeElement === document.body)
          for (const E of x)
            E.removedNodes.length > 0 && Sl(o);
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", y);
      const v = new MutationObserver(b);
      return o && v.observe(o, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", y), v.disconnect();
      };
    }
  }, [n, o, f.paused]), D.useEffect(() => {
    if (o) {
      lL.add(f);
      const m = document.activeElement;
      if (!o.contains(m)) {
        const b = new CustomEvent(S1, sL);
        o.addEventListener(S1, u), o.dispatchEvent(b), b.defaultPrevented || (yfe(Sfe(tj(o)), { select: !0 }), document.activeElement === m && Sl(o));
      }
      return () => {
        o.removeEventListener(S1, u), setTimeout(() => {
          const b = new CustomEvent(_1, sL);
          o.addEventListener(_1, c), o.dispatchEvent(b), b.defaultPrevented || Sl(m ?? document.body, { select: !0 }), o.removeEventListener(_1, c), lL.remove(f);
        }, 0);
      };
    }
  }, [o, u, c, f]);
  const h = D.useCallback(
    (m) => {
      if (!r && !n || f.paused) return;
      const y = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, b = document.activeElement;
      if (y && b) {
        const v = m.currentTarget, [x, _] = vfe(v);
        x && _ ? !m.shiftKey && b === _ ? (m.preventDefault(), r && Sl(x, { select: !0 })) : m.shiftKey && b === x && (m.preventDefault(), r && Sl(_, { select: !0 })) : b === v && m.preventDefault();
      }
    },
    [r, n, f.paused]
  );
  return /* @__PURE__ */ K(Wr.div, { tabIndex: -1, ...i, ref: p, onKeyDown: h });
});
Hb.displayName = bfe;
function yfe(e, { select: t = !1 } = {}) {
  const r = document.activeElement;
  for (const n of e)
    if (Sl(n, { select: t }), document.activeElement !== r) return;
}
function vfe(e) {
  const t = tj(e), r = oL(t, e), n = oL(t.reverse(), e);
  return [r, n];
}
function tj(e) {
  const t = [], r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const a = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || a ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode(); ) t.push(r.currentNode);
  return t;
}
function oL(e, t) {
  for (const r of e)
    if (!wfe(r, { upTo: t })) return r;
}
function wfe(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function xfe(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Sl(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const r = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== r && xfe(e) && t && e.select();
  }
}
var lL = Efe();
function Efe() {
  let e = [];
  return {
    add(t) {
      const r = e[0];
      t !== r && r?.pause(), e = uL(e, t), e.unshift(t);
    },
    remove(t) {
      e = uL(e, t), e[0]?.resume();
    }
  };
}
function uL(e, t) {
  const r = [...e], n = r.indexOf(t);
  return n !== -1 && r.splice(n, 1), r;
}
function Sfe(e) {
  return e.filter((t) => t.tagName !== "A");
}
var _fe = D.useId || (() => {
}), kfe = 0;
function us(e) {
  const [t, r] = D.useState(_fe());
  return Ti(() => {
    r((n) => n ?? String(kfe++));
  }, [e]), t ? `radix-${t}` : "";
}
const Cfe = ["top", "right", "bottom", "left"], zl = Math.min, Ba = Math.max, Bg = Math.round, um = Math.floor, ao = (e) => ({
  x: e,
  y: e
}), Afe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Tfe = {
  start: "end",
  end: "start"
};
function uR(e, t, r) {
  return Ba(e, zl(t, r));
}
function qo(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function jo(e) {
  return e.split("-")[0];
}
function Cd(e) {
  return e.split("-")[1];
}
function tN(e) {
  return e === "x" ? "y" : "x";
}
function rN(e) {
  return e === "y" ? "height" : "width";
}
function ql(e) {
  return ["top", "bottom"].includes(jo(e)) ? "y" : "x";
}
function nN(e) {
  return tN(ql(e));
}
function Rfe(e, t, r) {
  r === void 0 && (r = !1);
  const n = Cd(e), a = nN(e), s = rN(a);
  let i = a === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (i = Ug(i)), [i, Ug(i)];
}
function Ife(e) {
  const t = Ug(e);
  return [cR(e), t, cR(t)];
}
function cR(e) {
  return e.replace(/start|end/g, (t) => Tfe[t]);
}
function Nfe(e, t, r) {
  const n = ["left", "right"], a = ["right", "left"], s = ["top", "bottom"], i = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return r ? t ? a : n : t ? n : a;
    case "left":
    case "right":
      return t ? s : i;
    default:
      return [];
  }
}
function Dfe(e, t, r, n) {
  const a = Cd(e);
  let s = Nfe(jo(e), r === "start", n);
  return a && (s = s.map((i) => i + "-" + a), t && (s = s.concat(s.map(cR)))), s;
}
function Ug(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Afe[t]);
}
function Ofe(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function rj(e) {
  return typeof e != "number" ? Ofe(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function zg(e) {
  const {
    x: t,
    y: r,
    width: n,
    height: a
  } = e;
  return {
    width: n,
    height: a,
    top: r,
    left: t,
    right: t + n,
    bottom: r + a,
    x: t,
    y: r
  };
}
function cL(e, t, r) {
  let {
    reference: n,
    floating: a
  } = e;
  const s = ql(t), i = nN(t), o = rN(i), l = jo(t), u = s === "y", c = n.x + n.width / 2 - a.width / 2, d = n.y + n.height / 2 - a.height / 2, p = n[o] / 2 - a[o] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: c,
        y: n.y - a.height
      };
      break;
    case "bottom":
      f = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      f = {
        x: n.x + n.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: n.x - a.width,
        y: d
      };
      break;
    default:
      f = {
        x: n.x,
        y: n.y
      };
  }
  switch (Cd(t)) {
    case "start":
      f[i] -= p * (r && u ? -1 : 1);
      break;
    case "end":
      f[i] += p * (r && u ? -1 : 1);
      break;
  }
  return f;
}
const Pfe = async (e, t, r) => {
  const {
    placement: n = "bottom",
    strategy: a = "absolute",
    middleware: s = [],
    platform: i
  } = r, o = s.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(t));
  let u = await i.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: c,
    y: d
  } = cL(u, n, l), p = n, f = {}, h = 0;
  for (let m = 0; m < o.length; m++) {
    const {
      name: y,
      fn: b
    } = o[m], {
      x: v,
      y: x,
      data: _,
      reset: E
    } = await b({
      x: c,
      y: d,
      initialPlacement: n,
      placement: p,
      strategy: a,
      middlewareData: f,
      rects: u,
      platform: i,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = v ?? c, d = x ?? d, f = {
      ...f,
      [y]: {
        ...f[y],
        ..._
      }
    }, E && h <= 50 && (h++, typeof E == "object" && (E.placement && (p = E.placement), E.rects && (u = E.rects === !0 ? await i.getElementRects({
      reference: e,
      floating: t,
      strategy: a
    }) : E.rects), {
      x: c,
      y: d
    } = cL(u, p, l)), m = -1);
  }
  return {
    x: c,
    y: d,
    placement: p,
    strategy: a,
    middlewareData: f
  };
};
async function Bp(e, t) {
  var r;
  t === void 0 && (t = {});
  const {
    x: n,
    y: a,
    platform: s,
    rects: i,
    elements: o,
    strategy: l
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: f = 0
  } = qo(t, e), h = rj(f), y = o[p ? d === "floating" ? "reference" : "floating" : d], b = zg(await s.getClippingRect({
    element: (r = await (s.isElement == null ? void 0 : s.isElement(y))) == null || r ? y : y.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(o.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), v = d === "floating" ? {
    x: n,
    y: a,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(o.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(x)) ? await (s.getScale == null ? void 0 : s.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = zg(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: v,
    offsetParent: x,
    strategy: l
  }) : v);
  return {
    top: (b.top - E.top + h.top) / _.y,
    bottom: (E.bottom - b.bottom + h.bottom) / _.y,
    left: (b.left - E.left + h.left) / _.x,
    right: (E.right - b.right + h.right) / _.x
  };
}
const Lfe = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: r,
      y: n,
      placement: a,
      rects: s,
      platform: i,
      elements: o,
      middlewareData: l
    } = t, {
      element: u,
      padding: c = 0
    } = qo(e, t) || {};
    if (u == null)
      return {};
    const d = rj(c), p = {
      x: r,
      y: n
    }, f = nN(a), h = rN(f), m = await i.getDimensions(u), y = f === "y", b = y ? "top" : "left", v = y ? "bottom" : "right", x = y ? "clientHeight" : "clientWidth", _ = s.reference[h] + s.reference[f] - p[f] - s.floating[h], E = p[f] - s.reference[f], w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u));
    let C = w ? w[x] : 0;
    (!C || !await (i.isElement == null ? void 0 : i.isElement(w))) && (C = o.floating[x] || s.floating[h]);
    const k = _ / 2 - E / 2, S = C / 2 - m[h] / 2 - 1, B = zl(d[b], S), U = zl(d[v], S), N = B, O = C - m[h] - U, I = C / 2 - m[h] / 2 + k, q = uR(N, I, O), ae = !l.arrow && Cd(a) != null && I !== q && s.reference[h] / 2 - (I < N ? B : U) - m[h] / 2 < 0, Q = ae ? I < N ? I - N : I - O : 0;
    return {
      [f]: p[f] + Q,
      data: {
        [f]: q,
        centerOffset: I - q - Q,
        ...ae && {
          alignmentOffset: Q
        }
      },
      reset: ae
    };
  }
}), Mfe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var r, n;
      const {
        placement: a,
        middlewareData: s,
        rects: i,
        initialPlacement: o,
        platform: l,
        elements: u
      } = t, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: m = !0,
        ...y
      } = qo(e, t);
      if ((r = s.arrow) != null && r.alignmentOffset)
        return {};
      const b = jo(a), v = ql(o), x = jo(o) === o, _ = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), E = p || (x || !m ? [Ug(o)] : Ife(o)), w = h !== "none";
      !p && w && E.push(...Dfe(o, m, h, _));
      const C = [o, ...E], k = await Bp(t, y), S = [];
      let B = ((n = s.flip) == null ? void 0 : n.overflows) || [];
      if (c && S.push(k[b]), d) {
        const I = Rfe(a, i, _);
        S.push(k[I[0]], k[I[1]]);
      }
      if (B = [...B, {
        placement: a,
        overflows: S
      }], !S.every((I) => I <= 0)) {
        var U, N;
        const I = (((U = s.flip) == null ? void 0 : U.index) || 0) + 1, q = C[I];
        if (q)
          return {
            data: {
              index: I,
              overflows: B
            },
            reset: {
              placement: q
            }
          };
        let ae = (N = B.filter((Q) => Q.overflows[0] <= 0).sort((Q, ne) => Q.overflows[1] - ne.overflows[1])[0]) == null ? void 0 : N.placement;
        if (!ae)
          switch (f) {
            case "bestFit": {
              var O;
              const Q = (O = B.filter((ne) => {
                if (w) {
                  const le = ql(ne.placement);
                  return le === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  le === "y";
                }
                return !0;
              }).map((ne) => [ne.placement, ne.overflows.filter((le) => le > 0).reduce((le, W) => le + W, 0)]).sort((ne, le) => ne[1] - le[1])[0]) == null ? void 0 : O[0];
              Q && (ae = Q);
              break;
            }
            case "initialPlacement":
              ae = o;
              break;
          }
        if (a !== ae)
          return {
            reset: {
              placement: ae
            }
          };
      }
      return {};
    }
  };
};
function dL(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function fL(e) {
  return Cfe.some((t) => e[t] >= 0);
}
const Ffe = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: r
      } = t, {
        strategy: n = "referenceHidden",
        ...a
      } = qo(e, t);
      switch (n) {
        case "referenceHidden": {
          const s = await Bp(t, {
            ...a,
            elementContext: "reference"
          }), i = dL(s, r.reference);
          return {
            data: {
              referenceHiddenOffsets: i,
              referenceHidden: fL(i)
            }
          };
        }
        case "escaped": {
          const s = await Bp(t, {
            ...a,
            altBoundary: !0
          }), i = dL(s, r.floating);
          return {
            data: {
              escapedOffsets: i,
              escaped: fL(i)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function $fe(e, t) {
  const {
    placement: r,
    platform: n,
    elements: a
  } = e, s = await (n.isRTL == null ? void 0 : n.isRTL(a.floating)), i = jo(r), o = Cd(r), l = ql(r) === "y", u = ["left", "top"].includes(i) ? -1 : 1, c = s && l ? -1 : 1, d = qo(t, e);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: h
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return o && typeof h == "number" && (f = o === "end" ? h * -1 : h), l ? {
    x: f * c,
    y: p * u
  } : {
    x: p * u,
    y: f * c
  };
}
const Bfe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var r, n;
      const {
        x: a,
        y: s,
        placement: i,
        middlewareData: o
      } = t, l = await $fe(t, e);
      return i === ((r = o.offset) == null ? void 0 : r.placement) && (n = o.arrow) != null && n.alignmentOffset ? {} : {
        x: a + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, Ufe = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: r,
        y: n,
        placement: a
      } = t, {
        mainAxis: s = !0,
        crossAxis: i = !1,
        limiter: o = {
          fn: (y) => {
            let {
              x: b,
              y: v
            } = y;
            return {
              x: b,
              y: v
            };
          }
        },
        ...l
      } = qo(e, t), u = {
        x: r,
        y: n
      }, c = await Bp(t, l), d = ql(jo(a)), p = tN(d);
      let f = u[p], h = u[d];
      if (s) {
        const y = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", v = f + c[y], x = f - c[b];
        f = uR(v, f, x);
      }
      if (i) {
        const y = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", v = h + c[y], x = h - c[b];
        h = uR(v, h, x);
      }
      const m = o.fn({
        ...t,
        [p]: f,
        [d]: h
      });
      return {
        ...m,
        data: {
          x: m.x - r,
          y: m.y - n,
          enabled: {
            [p]: s,
            [d]: i
          }
        }
      };
    }
  };
}, zfe = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: r,
        y: n,
        placement: a,
        rects: s,
        middlewareData: i
      } = t, {
        offset: o = 0,
        mainAxis: l = !0,
        crossAxis: u = !0
      } = qo(e, t), c = {
        x: r,
        y: n
      }, d = ql(a), p = tN(d);
      let f = c[p], h = c[d];
      const m = qo(o, t), y = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (l) {
        const x = p === "y" ? "height" : "width", _ = s.reference[p] - s.floating[x] + y.mainAxis, E = s.reference[p] + s.reference[x] - y.mainAxis;
        f < _ ? f = _ : f > E && (f = E);
      }
      if (u) {
        var b, v;
        const x = p === "y" ? "width" : "height", _ = ["top", "left"].includes(jo(a)), E = s.reference[d] - s.floating[x] + (_ && ((b = i.offset) == null ? void 0 : b[d]) || 0) + (_ ? 0 : y.crossAxis), w = s.reference[d] + s.reference[x] + (_ ? 0 : ((v = i.offset) == null ? void 0 : v[d]) || 0) - (_ ? y.crossAxis : 0);
        h < E ? h = E : h > w && (h = w);
      }
      return {
        [p]: f,
        [d]: h
      };
    }
  };
}, qfe = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var r, n;
      const {
        placement: a,
        rects: s,
        platform: i,
        elements: o
      } = t, {
        apply: l = () => {
        },
        ...u
      } = qo(e, t), c = await Bp(t, u), d = jo(a), p = Cd(a), f = ql(a) === "y", {
        width: h,
        height: m
      } = s.floating;
      let y, b;
      d === "top" || d === "bottom" ? (y = d, b = p === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (b = d, y = p === "end" ? "top" : "bottom");
      const v = m - c.top - c.bottom, x = h - c.left - c.right, _ = zl(m - c[y], v), E = zl(h - c[b], x), w = !t.middlewareData.shift;
      let C = _, k = E;
      if ((r = t.middlewareData.shift) != null && r.enabled.x && (k = x), (n = t.middlewareData.shift) != null && n.enabled.y && (C = v), w && !p) {
        const B = Ba(c.left, 0), U = Ba(c.right, 0), N = Ba(c.top, 0), O = Ba(c.bottom, 0);
        f ? k = h - 2 * (B !== 0 || U !== 0 ? B + U : Ba(c.left, c.right)) : C = m - 2 * (N !== 0 || O !== 0 ? N + O : Ba(c.top, c.bottom));
      }
      await l({
        ...t,
        availableWidth: k,
        availableHeight: C
      });
      const S = await i.getDimensions(o.floating);
      return h !== S.width || m !== S.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Vb() {
  return typeof window < "u";
}
function Ad(e) {
  return nj(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function za(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function mo(e) {
  var t;
  return (t = (nj(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function nj(e) {
  return Vb() ? e instanceof Node || e instanceof za(e).Node : !1;
}
function Us(e) {
  return Vb() ? e instanceof Element || e instanceof za(e).Element : !1;
}
function uo(e) {
  return Vb() ? e instanceof HTMLElement || e instanceof za(e).HTMLElement : !1;
}
function pL(e) {
  return !Vb() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof za(e).ShadowRoot;
}
function mh(e) {
  const {
    overflow: t,
    overflowX: r,
    overflowY: n,
    display: a
  } = zs(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + r) && !["inline", "contents"].includes(a);
}
function jfe(e) {
  return ["table", "td", "th"].includes(Ad(e));
}
function Gb(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function iN(e) {
  const t = aN(), r = Us(e) ? zs(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((n) => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some((n) => (r.contain || "").includes(n));
}
function Hfe(e) {
  let t = jl(e);
  for (; uo(t) && !sd(t); ) {
    if (iN(t))
      return t;
    if (Gb(t))
      return null;
    t = jl(t);
  }
  return null;
}
function aN() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function sd(e) {
  return ["html", "body", "#document"].includes(Ad(e));
}
function zs(e) {
  return za(e).getComputedStyle(e);
}
function Wb(e) {
  return Us(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function jl(e) {
  if (Ad(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    pL(e) && e.host || // Fallback.
    mo(e)
  );
  return pL(t) ? t.host : t;
}
function ij(e) {
  const t = jl(e);
  return sd(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : uo(t) && mh(t) ? t : ij(t);
}
function Up(e, t, r) {
  var n;
  t === void 0 && (t = []), r === void 0 && (r = !0);
  const a = ij(e), s = a === ((n = e.ownerDocument) == null ? void 0 : n.body), i = za(a);
  if (s) {
    const o = dR(i);
    return t.concat(i, i.visualViewport || [], mh(a) ? a : [], o && r ? Up(o) : []);
  }
  return t.concat(a, Up(a, [], r));
}
function dR(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function aj(e) {
  const t = zs(e);
  let r = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const a = uo(e), s = a ? e.offsetWidth : r, i = a ? e.offsetHeight : n, o = Bg(r) !== s || Bg(n) !== i;
  return o && (r = s, n = i), {
    width: r,
    height: n,
    $: o
  };
}
function sN(e) {
  return Us(e) ? e : e.contextElement;
}
function jc(e) {
  const t = sN(e);
  if (!uo(t))
    return ao(1);
  const r = t.getBoundingClientRect(), {
    width: n,
    height: a,
    $: s
  } = aj(t);
  let i = (s ? Bg(r.width) : r.width) / n, o = (s ? Bg(r.height) : r.height) / a;
  return (!i || !Number.isFinite(i)) && (i = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: i,
    y: o
  };
}
const Vfe = /* @__PURE__ */ ao(0);
function sj(e) {
  const t = za(e);
  return !aN() || !t.visualViewport ? Vfe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Gfe(e, t, r) {
  return t === void 0 && (t = !1), !r || t && r !== za(e) ? !1 : t;
}
function Au(e, t, r, n) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const a = e.getBoundingClientRect(), s = sN(e);
  let i = ao(1);
  t && (n ? Us(n) && (i = jc(n)) : i = jc(e));
  const o = Gfe(s, r, n) ? sj(s) : ao(0);
  let l = (a.left + o.x) / i.x, u = (a.top + o.y) / i.y, c = a.width / i.x, d = a.height / i.y;
  if (s) {
    const p = za(s), f = n && Us(n) ? za(n) : n;
    let h = p, m = dR(h);
    for (; m && n && f !== h; ) {
      const y = jc(m), b = m.getBoundingClientRect(), v = zs(m), x = b.left + (m.clientLeft + parseFloat(v.paddingLeft)) * y.x, _ = b.top + (m.clientTop + parseFloat(v.paddingTop)) * y.y;
      l *= y.x, u *= y.y, c *= y.x, d *= y.y, l += x, u += _, h = za(m), m = dR(h);
    }
  }
  return zg({
    width: c,
    height: d,
    x: l,
    y: u
  });
}
function oN(e, t) {
  const r = Wb(e).scrollLeft;
  return t ? t.left + r : Au(mo(e)).left + r;
}
function oj(e, t, r) {
  r === void 0 && (r = !1);
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - (r ? 0 : (
    // RTL <body> scrollbar.
    oN(e, n)
  )), s = n.top + t.scrollTop;
  return {
    x: a,
    y: s
  };
}
function Wfe(e) {
  let {
    elements: t,
    rect: r,
    offsetParent: n,
    strategy: a
  } = e;
  const s = a === "fixed", i = mo(n), o = t ? Gb(t.floating) : !1;
  if (n === i || o && s)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = ao(1);
  const c = ao(0), d = uo(n);
  if ((d || !d && !s) && ((Ad(n) !== "body" || mh(i)) && (l = Wb(n)), uo(n))) {
    const f = Au(n);
    u = jc(n), c.x = f.x + n.clientLeft, c.y = f.y + n.clientTop;
  }
  const p = i && !d && !s ? oj(i, l, !0) : ao(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + p.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + p.y
  };
}
function Kfe(e) {
  return Array.from(e.getClientRects());
}
function Yfe(e) {
  const t = mo(e), r = Wb(e), n = e.ownerDocument.body, a = Ba(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), s = Ba(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let i = -r.scrollLeft + oN(e);
  const o = -r.scrollTop;
  return zs(n).direction === "rtl" && (i += Ba(t.clientWidth, n.clientWidth) - a), {
    width: a,
    height: s,
    x: i,
    y: o
  };
}
function Xfe(e, t) {
  const r = za(e), n = mo(e), a = r.visualViewport;
  let s = n.clientWidth, i = n.clientHeight, o = 0, l = 0;
  if (a) {
    s = a.width, i = a.height;
    const u = aN();
    (!u || u && t === "fixed") && (o = a.offsetLeft, l = a.offsetTop);
  }
  return {
    width: s,
    height: i,
    x: o,
    y: l
  };
}
function Zfe(e, t) {
  const r = Au(e, !0, t === "fixed"), n = r.top + e.clientTop, a = r.left + e.clientLeft, s = uo(e) ? jc(e) : ao(1), i = e.clientWidth * s.x, o = e.clientHeight * s.y, l = a * s.x, u = n * s.y;
  return {
    width: i,
    height: o,
    x: l,
    y: u
  };
}
function hL(e, t, r) {
  let n;
  if (t === "viewport")
    n = Xfe(e, r);
  else if (t === "document")
    n = Yfe(mo(e));
  else if (Us(t))
    n = Zfe(t, r);
  else {
    const a = sj(e);
    n = {
      x: t.x - a.x,
      y: t.y - a.y,
      width: t.width,
      height: t.height
    };
  }
  return zg(n);
}
function lj(e, t) {
  const r = jl(e);
  return r === t || !Us(r) || sd(r) ? !1 : zs(r).position === "fixed" || lj(r, t);
}
function Jfe(e, t) {
  const r = t.get(e);
  if (r)
    return r;
  let n = Up(e, [], !1).filter((o) => Us(o) && Ad(o) !== "body"), a = null;
  const s = zs(e).position === "fixed";
  let i = s ? jl(e) : e;
  for (; Us(i) && !sd(i); ) {
    const o = zs(i), l = iN(i);
    !l && o.position === "fixed" && (a = null), (s ? !l && !a : !l && o.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || mh(i) && !l && lj(e, i)) ? n = n.filter((c) => c !== i) : a = o, i = jl(i);
  }
  return t.set(e, n), n;
}
function Qfe(e) {
  let {
    element: t,
    boundary: r,
    rootBoundary: n,
    strategy: a
  } = e;
  const i = [...r === "clippingAncestors" ? Gb(t) ? [] : Jfe(t, this._c) : [].concat(r), n], o = i[0], l = i.reduce((u, c) => {
    const d = hL(t, c, a);
    return u.top = Ba(d.top, u.top), u.right = zl(d.right, u.right), u.bottom = zl(d.bottom, u.bottom), u.left = Ba(d.left, u.left), u;
  }, hL(t, o, a));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function epe(e) {
  const {
    width: t,
    height: r
  } = aj(e);
  return {
    width: t,
    height: r
  };
}
function tpe(e, t, r) {
  const n = uo(t), a = mo(t), s = r === "fixed", i = Au(e, !0, s, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ao(0);
  if (n || !n && !s)
    if ((Ad(t) !== "body" || mh(a)) && (o = Wb(t)), n) {
      const p = Au(t, !0, s, t);
      l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop;
    } else a && (l.x = oN(a));
  const u = a && !n && !s ? oj(a, o) : ao(0), c = i.left + o.scrollLeft - l.x - u.x, d = i.top + o.scrollTop - l.y - u.y;
  return {
    x: c,
    y: d,
    width: i.width,
    height: i.height
  };
}
function k1(e) {
  return zs(e).position === "static";
}
function mL(e, t) {
  if (!uo(e) || zs(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let r = e.offsetParent;
  return mo(e) === r && (r = r.ownerDocument.body), r;
}
function uj(e, t) {
  const r = za(e);
  if (Gb(e))
    return r;
  if (!uo(e)) {
    let a = jl(e);
    for (; a && !sd(a); ) {
      if (Us(a) && !k1(a))
        return a;
      a = jl(a);
    }
    return r;
  }
  let n = mL(e, t);
  for (; n && jfe(n) && k1(n); )
    n = mL(n, t);
  return n && sd(n) && k1(n) && !iN(n) ? r : n || Hfe(e) || r;
}
const rpe = async function(e) {
  const t = this.getOffsetParent || uj, r = this.getDimensions, n = await r(e.floating);
  return {
    reference: tpe(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function npe(e) {
  return zs(e).direction === "rtl";
}
const ipe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Wfe,
  getDocumentElement: mo,
  getClippingRect: Qfe,
  getOffsetParent: uj,
  getElementRects: rpe,
  getClientRects: Kfe,
  getDimensions: epe,
  getScale: jc,
  isElement: Us,
  isRTL: npe
};
function cj(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function ape(e, t) {
  let r = null, n;
  const a = mo(e);
  function s() {
    var o;
    clearTimeout(n), (o = r) == null || o.disconnect(), r = null;
  }
  function i(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), s();
    const u = e.getBoundingClientRect(), {
      left: c,
      top: d,
      width: p,
      height: f
    } = u;
    if (o || t(), !p || !f)
      return;
    const h = um(d), m = um(a.clientWidth - (c + p)), y = um(a.clientHeight - (d + f)), b = um(c), x = {
      rootMargin: -h + "px " + -m + "px " + -y + "px " + -b + "px",
      threshold: Ba(0, zl(1, l)) || 1
    };
    let _ = !0;
    function E(w) {
      const C = w[0].intersectionRatio;
      if (C !== l) {
        if (!_)
          return i();
        C ? i(!1, C) : n = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      C === 1 && !cj(u, e.getBoundingClientRect()) && i(), _ = !1;
    }
    try {
      r = new IntersectionObserver(E, {
        ...x,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(E, x);
    }
    r.observe(e);
  }
  return i(!0), s;
}
function spe(e, t, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: s = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = sN(e), c = a || s ? [...u ? Up(u) : [], ...Up(t)] : [];
  c.forEach((b) => {
    a && b.addEventListener("scroll", r, {
      passive: !0
    }), s && b.addEventListener("resize", r);
  });
  const d = u && o ? ape(u, r) : null;
  let p = -1, f = null;
  i && (f = new ResizeObserver((b) => {
    let [v] = b;
    v && v.target === u && f && (f.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var x;
      (x = f) == null || x.observe(t);
    })), r();
  }), u && !l && f.observe(u), f.observe(t));
  let h, m = l ? Au(e) : null;
  l && y();
  function y() {
    const b = Au(e);
    m && !cj(m, b) && r(), m = b, h = requestAnimationFrame(y);
  }
  return r(), () => {
    var b;
    c.forEach((v) => {
      a && v.removeEventListener("scroll", r), s && v.removeEventListener("resize", r);
    }), d?.(), (b = f) == null || b.disconnect(), f = null, l && cancelAnimationFrame(h);
  };
}
const ope = Bfe, lpe = Ufe, upe = Mfe, cpe = qfe, dpe = Ffe, gL = Lfe, fpe = zfe, ppe = (e, t, r) => {
  const n = /* @__PURE__ */ new Map(), a = {
    platform: ipe,
    ...r
  }, s = {
    ...a.platform,
    _c: n
  };
  return Pfe(e, t, {
    ...a,
    platform: s
  });
};
var og = typeof document < "u" ? Sb : Qn;
function qg(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let r, n, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (r = e.length, r !== t.length) return !1;
      for (n = r; n-- !== 0; )
        if (!qg(e[n], t[n]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), r = a.length, r !== Object.keys(t).length)
      return !1;
    for (n = r; n-- !== 0; )
      if (!{}.hasOwnProperty.call(t, a[n]))
        return !1;
    for (n = r; n-- !== 0; ) {
      const s = a[n];
      if (!(s === "_owner" && e.$$typeof) && !qg(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function dj(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function bL(e, t) {
  const r = dj(e);
  return Math.round(t * r) / r;
}
function C1(e) {
  const t = D.useRef(e);
  return og(() => {
    t.current = e;
  }), t;
}
function hpe(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: r = "absolute",
    middleware: n = [],
    platform: a,
    elements: {
      reference: s,
      floating: i
    } = {},
    transform: o = !0,
    whileElementsMounted: l,
    open: u
  } = e, [c, d] = D.useState({
    x: 0,
    y: 0,
    strategy: r,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, f] = D.useState(n);
  qg(p, n) || f(n);
  const [h, m] = D.useState(null), [y, b] = D.useState(null), v = D.useCallback((ne) => {
    ne !== w.current && (w.current = ne, m(ne));
  }, []), x = D.useCallback((ne) => {
    ne !== C.current && (C.current = ne, b(ne));
  }, []), _ = s || h, E = i || y, w = D.useRef(null), C = D.useRef(null), k = D.useRef(c), S = l != null, B = C1(l), U = C1(a), N = C1(u), O = D.useCallback(() => {
    if (!w.current || !C.current)
      return;
    const ne = {
      placement: t,
      strategy: r,
      middleware: p
    };
    U.current && (ne.platform = U.current), ppe(w.current, C.current, ne).then((le) => {
      const W = {
        ...le,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: N.current !== !1
      };
      I.current && !qg(k.current, W) && (k.current = W, _b.flushSync(() => {
        d(W);
      }));
    });
  }, [p, t, r, U, N]);
  og(() => {
    u === !1 && k.current.isPositioned && (k.current.isPositioned = !1, d((ne) => ({
      ...ne,
      isPositioned: !1
    })));
  }, [u]);
  const I = D.useRef(!1);
  og(() => (I.current = !0, () => {
    I.current = !1;
  }), []), og(() => {
    if (_ && (w.current = _), E && (C.current = E), _ && E) {
      if (B.current)
        return B.current(_, E, O);
      O();
    }
  }, [_, E, O, B, S]);
  const q = D.useMemo(() => ({
    reference: w,
    floating: C,
    setReference: v,
    setFloating: x
  }), [v, x]), ae = D.useMemo(() => ({
    reference: _,
    floating: E
  }), [_, E]), Q = D.useMemo(() => {
    const ne = {
      position: r,
      left: 0,
      top: 0
    };
    if (!ae.floating)
      return ne;
    const le = bL(ae.floating, c.x), W = bL(ae.floating, c.y);
    return o ? {
      ...ne,
      transform: "translate(" + le + "px, " + W + "px)",
      ...dj(ae.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r,
      left: le,
      top: W
    };
  }, [r, o, ae.floating, c.x, c.y]);
  return D.useMemo(() => ({
    ...c,
    update: O,
    refs: q,
    elements: ae,
    floatingStyles: Q
  }), [c, O, q, ae, Q]);
}
const mpe = (e) => {
  function t(r) {
    return {}.hasOwnProperty.call(r, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(r) {
      const {
        element: n,
        padding: a
      } = typeof e == "function" ? e(r) : e;
      return n && t(n) ? n.current != null ? gL({
        element: n.current,
        padding: a
      }).fn(r) : {} : n ? gL({
        element: n,
        padding: a
      }).fn(r) : {};
    }
  };
}, gpe = (e, t) => ({
  ...ope(e),
  options: [e, t]
}), bpe = (e, t) => ({
  ...lpe(e),
  options: [e, t]
}), ype = (e, t) => ({
  ...fpe(e),
  options: [e, t]
}), vpe = (e, t) => ({
  ...upe(e),
  options: [e, t]
}), wpe = (e, t) => ({
  ...cpe(e),
  options: [e, t]
}), xpe = (e, t) => ({
  ...dpe(e),
  options: [e, t]
}), Epe = (e, t) => ({
  ...mpe(e),
  options: [e, t]
});
var Spe = "Arrow", fj = D.forwardRef((e, t) => {
  const { children: r, width: n = 10, height: a = 5, ...s } = e;
  return /* @__PURE__ */ K(
    Wr.svg,
    {
      ...s,
      ref: t,
      width: n,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? r : /* @__PURE__ */ K("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
fj.displayName = Spe;
var _pe = fj;
function kpe(e) {
  const [t, r] = D.useState(void 0);
  return Ti(() => {
    if (e) {
      r({ width: e.offsetWidth, height: e.offsetHeight });
      const n = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let i, o;
        if ("borderBoxSize" in s) {
          const l = s.borderBoxSize, u = Array.isArray(l) ? l[0] : l;
          i = u.inlineSize, o = u.blockSize;
        } else
          i = e.offsetWidth, o = e.offsetHeight;
        r({ width: i, height: o });
      });
      return n.observe(e, { box: "border-box" }), () => n.unobserve(e);
    } else
      r(void 0);
  }, [e]), t;
}
var lN = "Popper", [pj, Wl] = ds(lN), [Cpe, hj] = pj(lN), mj = (e) => {
  const { __scopePopper: t, children: r } = e, [n, a] = D.useState(null);
  return /* @__PURE__ */ K(Cpe, { scope: t, anchor: n, onAnchorChange: a, children: r });
};
mj.displayName = lN;
var gj = "PopperAnchor", bj = D.forwardRef(
  (e, t) => {
    const { __scopePopper: r, virtualRef: n, ...a } = e, s = hj(gj, r), i = D.useRef(null), o = sn(t, i);
    return D.useEffect(() => {
      s.onAnchorChange(n?.current || i.current);
    }), n ? null : /* @__PURE__ */ K(Wr.div, { ...a, ref: o });
  }
);
bj.displayName = gj;
var uN = "PopperContent", [Ape, Tpe] = pj(uN), yj = D.forwardRef(
  (e, t) => {
    const {
      __scopePopper: r,
      side: n = "bottom",
      sideOffset: a = 0,
      align: s = "center",
      alignOffset: i = 0,
      arrowPadding: o = 0,
      avoidCollisions: l = !0,
      collisionBoundary: u = [],
      collisionPadding: c = 0,
      sticky: d = "partial",
      hideWhenDetached: p = !1,
      updatePositionStrategy: f = "optimized",
      onPlaced: h,
      ...m
    } = e, y = hj(uN, r), [b, v] = D.useState(null), x = sn(t, ($) => v($)), [_, E] = D.useState(null), w = kpe(_), C = w?.width ?? 0, k = w?.height ?? 0, S = n + (s !== "center" ? "-" + s : ""), B = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c }, U = Array.isArray(u) ? u : [u], N = U.length > 0, O = {
      padding: B,
      boundary: U.filter(Ipe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: N
    }, { refs: I, floatingStyles: q, placement: ae, isPositioned: Q, middlewareData: ne } = hpe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: S,
      whileElementsMounted: (...$) => spe(...$, {
        animationFrame: f === "always"
      }),
      elements: {
        reference: y.anchor
      },
      middleware: [
        gpe({ mainAxis: a + k, alignmentAxis: i }),
        l && bpe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? ype() : void 0,
          ...O
        }),
        l && vpe({ ...O }),
        wpe({
          ...O,
          apply: ({ elements: $, rects: F, availableWidth: ge, availableHeight: ce }) => {
            const { width: ie, height: re } = F.reference, Te = $.floating.style;
            Te.setProperty("--radix-popper-available-width", `${ge}px`), Te.setProperty("--radix-popper-available-height", `${ce}px`), Te.setProperty("--radix-popper-anchor-width", `${ie}px`), Te.setProperty("--radix-popper-anchor-height", `${re}px`);
          }
        }),
        _ && Epe({ element: _, padding: o }),
        Npe({ arrowWidth: C, arrowHeight: k }),
        p && xpe({ strategy: "referenceHidden", ...O })
      ]
    }), [le, W] = xj(ae), X = si(h);
    Ti(() => {
      Q && X?.();
    }, [Q, X]);
    const G = ne.arrow?.x, P = ne.arrow?.y, he = ne.arrow?.centerOffset !== 0, [ye, pe] = D.useState();
    return Ti(() => {
      b && pe(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ K(
      "div",
      {
        ref: I.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...q,
          transform: Q ? q.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ye,
          "--radix-popper-transform-origin": [
            ne.transformOrigin?.x,
            ne.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...ne.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ K(
          Ape,
          {
            scope: r,
            placedSide: le,
            onArrowChange: E,
            arrowX: G,
            arrowY: P,
            shouldHideArrow: he,
            children: /* @__PURE__ */ K(
              Wr.div,
              {
                "data-side": le,
                "data-align": W,
                ...m,
                ref: x,
                style: {
                  ...m.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Q ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
yj.displayName = uN;
var vj = "PopperArrow", Rpe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, wj = D.forwardRef(function(t, r) {
  const { __scopePopper: n, ...a } = t, s = Tpe(vj, n), i = Rpe[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ K(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [i]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ K(
          _pe,
          {
            ...a,
            ref: r,
            style: {
              ...a.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
wj.displayName = vj;
function Ipe(e) {
  return e !== null;
}
var Npe = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: r, rects: n, middlewareData: a } = t, i = a.arrow?.centerOffset !== 0, o = i ? 0 : e.arrowWidth, l = i ? 0 : e.arrowHeight, [u, c] = xj(r), d = { start: "0%", center: "50%", end: "100%" }[c], p = (a.arrow?.x ?? 0) + o / 2, f = (a.arrow?.y ?? 0) + l / 2;
    let h = "", m = "";
    return u === "bottom" ? (h = i ? d : `${p}px`, m = `${-l}px`) : u === "top" ? (h = i ? d : `${p}px`, m = `${n.floating.height + l}px`) : u === "right" ? (h = `${-l}px`, m = i ? d : `${f}px`) : u === "left" && (h = `${n.floating.width + l}px`, m = i ? d : `${f}px`), { data: { x: h, y: m } };
  }
});
function xj(e) {
  const [t, r = "center"] = e.split("-");
  return [t, r];
}
var gh = mj, bh = bj, Kb = yj, Yb = wj, Dpe = "Portal", Xb = D.forwardRef((e, t) => {
  const { container: r, ...n } = e, [a, s] = D.useState(!1);
  Ti(() => s(!0), []);
  const i = r || a && globalThis?.document?.body;
  return i ? iee.createPortal(/* @__PURE__ */ K(Wr.div, { ...n, ref: t }), i) : null;
});
Xb.displayName = Dpe;
var A1 = "rovingFocusGroup.onEntryFocus", Ope = { bubbles: !1, cancelable: !0 }, Zb = "RovingFocusGroup", [fR, Ej, Ppe] = qb(Zb), [Lpe, Sj] = ds(
  Zb,
  [Ppe]
), [Mpe, Fpe] = Lpe(Zb), _j = D.forwardRef(
  (e, t) => /* @__PURE__ */ K(fR.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ K(fR.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ K($pe, { ...e, ref: t }) }) })
);
_j.displayName = Zb;
var $pe = D.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: r,
    orientation: n,
    loop: a = !1,
    dir: s,
    currentTabStopId: i,
    defaultCurrentTabStopId: o,
    onCurrentTabStopIdChange: l,
    onEntryFocus: u,
    preventScrollOnEntryFocus: c = !1,
    ...d
  } = e, p = D.useRef(null), f = sn(t, p), h = hh(s), [m = null, y] = Bs({
    prop: i,
    defaultProp: o,
    onChange: l
  }), [b, v] = D.useState(!1), x = si(u), _ = Ej(r), E = D.useRef(!1), [w, C] = D.useState(0);
  return D.useEffect(() => {
    const k = p.current;
    if (k)
      return k.addEventListener(A1, x), () => k.removeEventListener(A1, x);
  }, [x]), /* @__PURE__ */ K(
    Mpe,
    {
      scope: r,
      orientation: n,
      dir: h,
      loop: a,
      currentTabStopId: m,
      onItemFocus: D.useCallback(
        (k) => y(k),
        [y]
      ),
      onItemShiftTab: D.useCallback(() => v(!0), []),
      onFocusableItemAdd: D.useCallback(
        () => C((k) => k + 1),
        []
      ),
      onFocusableItemRemove: D.useCallback(
        () => C((k) => k - 1),
        []
      ),
      children: /* @__PURE__ */ K(
        Wr.div,
        {
          tabIndex: b || w === 0 ? -1 : 0,
          "data-orientation": n,
          ...d,
          ref: f,
          style: { outline: "none", ...e.style },
          onMouseDown: nr(e.onMouseDown, () => {
            E.current = !0;
          }),
          onFocus: nr(e.onFocus, (k) => {
            const S = !E.current;
            if (k.target === k.currentTarget && S && !b) {
              const B = new CustomEvent(A1, Ope);
              if (k.currentTarget.dispatchEvent(B), !B.defaultPrevented) {
                const U = _().filter((ae) => ae.focusable), N = U.find((ae) => ae.active), O = U.find((ae) => ae.id === m), q = [N, O, ...U].filter(
                  Boolean
                ).map((ae) => ae.ref.current);
                Aj(q, c);
              }
            }
            E.current = !1;
          }),
          onBlur: nr(e.onBlur, () => v(!1))
        }
      )
    }
  );
}), kj = "RovingFocusGroupItem", Cj = D.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: r,
      focusable: n = !0,
      active: a = !1,
      tabStopId: s,
      ...i
    } = e, o = us(), l = s || o, u = Fpe(kj, r), c = u.currentTabStopId === l, d = Ej(r), { onFocusableItemAdd: p, onFocusableItemRemove: f } = u;
    return D.useEffect(() => {
      if (n)
        return p(), () => f();
    }, [n, p, f]), /* @__PURE__ */ K(
      fR.ItemSlot,
      {
        scope: r,
        id: l,
        focusable: n,
        active: a,
        children: /* @__PURE__ */ K(
          Wr.span,
          {
            tabIndex: c ? 0 : -1,
            "data-orientation": u.orientation,
            ...i,
            ref: t,
            onMouseDown: nr(e.onMouseDown, (h) => {
              n ? u.onItemFocus(l) : h.preventDefault();
            }),
            onFocus: nr(e.onFocus, () => u.onItemFocus(l)),
            onKeyDown: nr(e.onKeyDown, (h) => {
              if (h.key === "Tab" && h.shiftKey) {
                u.onItemShiftTab();
                return;
              }
              if (h.target !== h.currentTarget) return;
              const m = zpe(h, u.orientation, u.dir);
              if (m !== void 0) {
                if (h.metaKey || h.ctrlKey || h.altKey || h.shiftKey) return;
                h.preventDefault();
                let b = d().filter((v) => v.focusable).map((v) => v.ref.current);
                if (m === "last") b.reverse();
                else if (m === "prev" || m === "next") {
                  m === "prev" && b.reverse();
                  const v = b.indexOf(h.currentTarget);
                  b = u.loop ? qpe(b, v + 1) : b.slice(v + 1);
                }
                setTimeout(() => Aj(b));
              }
            })
          }
        )
      }
    );
  }
);
Cj.displayName = kj;
var Bpe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Upe(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function zpe(e, t, r) {
  const n = Upe(e.key, r);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Bpe[n];
}
function Aj(e, t = !1) {
  const r = document.activeElement;
  for (const n of e)
    if (n === r || (n.focus({ preventScroll: t }), document.activeElement !== r)) return;
}
function qpe(e, t) {
  return e.map((r, n) => e[(t + n) % e.length]);
}
var jpe = _j, Hpe = Cj, Vpe = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, cc = /* @__PURE__ */ new WeakMap(), cm = /* @__PURE__ */ new WeakMap(), dm = {}, T1 = 0, Tj = function(e) {
  return e && (e.host || Tj(e.parentNode));
}, Gpe = function(e, t) {
  return t.map(function(r) {
    if (e.contains(r))
      return r;
    var n = Tj(r);
    return n && e.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(r) {
    return !!r;
  });
}, Wpe = function(e, t, r, n) {
  var a = Gpe(t, Array.isArray(e) ? e : [e]);
  dm[r] || (dm[r] = /* @__PURE__ */ new WeakMap());
  var s = dm[r], i = [], o = /* @__PURE__ */ new Set(), l = new Set(a), u = function(d) {
    !d || o.has(d) || (o.add(d), u(d.parentNode));
  };
  a.forEach(u);
  var c = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (o.has(p))
        c(p);
      else
        try {
          var f = p.getAttribute(n), h = f !== null && f !== "false", m = (cc.get(p) || 0) + 1, y = (s.get(p) || 0) + 1;
          cc.set(p, m), s.set(p, y), i.push(p), m === 1 && h && cm.set(p, !0), y === 1 && p.setAttribute(r, "true"), h || p.setAttribute(n, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", p, b);
        }
    });
  };
  return c(t), o.clear(), T1++, function() {
    i.forEach(function(d) {
      var p = cc.get(d) - 1, f = s.get(d) - 1;
      cc.set(d, p), s.set(d, f), p || (cm.has(d) || d.removeAttribute(n), cm.delete(d)), f || d.removeAttribute(r);
    }), T1--, T1 || (cc = /* @__PURE__ */ new WeakMap(), cc = /* @__PURE__ */ new WeakMap(), cm = /* @__PURE__ */ new WeakMap(), dm = {});
  };
}, cN = function(e, t, r) {
  r === void 0 && (r = "data-aria-hidden");
  var n = Array.from(Array.isArray(e) ? e : [e]), a = Vpe(e);
  return a ? (n.push.apply(n, Array.from(a.querySelectorAll("[aria-live]"))), Wpe(n, a, r, "aria-hidden")) : function() {
    return null;
  };
}, ro = function() {
  return ro = Object.assign || function(t) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, ro.apply(this, arguments);
};
function Rj(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, n = Object.getOwnPropertySymbols(e); a < n.length; a++)
      t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (r[n[a]] = e[n[a]]);
  return r;
}
function Kpe(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, a = t.length, s; n < a; n++)
    (s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var lg = "right-scroll-bar-position", ug = "width-before-scroll-bar", Ype = "with-scroll-bars-hidden", Xpe = "--removed-body-scroll-bar-size";
function R1(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Zpe(e, t) {
  var r = Wn(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return r.value;
        },
        set current(n) {
          var a = r.value;
          a !== n && (r.value = n, r.callback(n, a));
        }
      }
    };
  })[0];
  return r.callback = t, r.facade;
}
var Jpe = typeof window < "u" ? D.useLayoutEffect : D.useEffect, yL = /* @__PURE__ */ new WeakMap();
function Qpe(e, t) {
  var r = Zpe(null, function(n) {
    return e.forEach(function(a) {
      return R1(a, n);
    });
  });
  return Jpe(function() {
    var n = yL.get(r);
    if (n) {
      var a = new Set(n), s = new Set(e), i = r.current;
      a.forEach(function(o) {
        s.has(o) || R1(o, null);
      }), s.forEach(function(o) {
        a.has(o) || R1(o, i);
      });
    }
    yL.set(r, e);
  }, [e]), r;
}
function ehe(e) {
  return e;
}
function the(e, t) {
  t === void 0 && (t = ehe);
  var r = [], n = !1, a = {
    read: function() {
      if (n)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r.length ? r[r.length - 1] : e;
    },
    useMedium: function(s) {
      var i = t(s, n);
      return r.push(i), function() {
        r = r.filter(function(o) {
          return o !== i;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (n = !0; r.length; ) {
        var i = r;
        r = [], i.forEach(s);
      }
      r = {
        push: function(o) {
          return s(o);
        },
        filter: function() {
          return r;
        }
      };
    },
    assignMedium: function(s) {
      n = !0;
      var i = [];
      if (r.length) {
        var o = r;
        r = [], o.forEach(s), i = r;
      }
      var l = function() {
        var c = i;
        i = [], c.forEach(s);
      }, u = function() {
        return Promise.resolve().then(l);
      };
      u(), r = {
        push: function(c) {
          i.push(c), u();
        },
        filter: function(c) {
          return i = i.filter(c), r;
        }
      };
    }
  };
  return a;
}
function rhe(e) {
  e === void 0 && (e = {});
  var t = the(null);
  return t.options = ro({ async: !0, ssr: !1 }, e), t;
}
var Ij = function(e) {
  var t = e.sideCar, r = Rj(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var n = t.read();
  if (!n)
    throw new Error("Sidecar medium not found");
  return D.createElement(n, ro({}, r));
};
Ij.isSideCarExport = !0;
function nhe(e, t) {
  return e.useMedium(t), Ij;
}
var Nj = rhe(), I1 = function() {
}, Jb = D.forwardRef(function(e, t) {
  var r = D.useRef(null), n = D.useState({
    onScrollCapture: I1,
    onWheelCapture: I1,
    onTouchMoveCapture: I1
  }), a = n[0], s = n[1], i = e.forwardProps, o = e.children, l = e.className, u = e.removeScrollBar, c = e.enabled, d = e.shards, p = e.sideCar, f = e.noIsolation, h = e.inert, m = e.allowPinchZoom, y = e.as, b = y === void 0 ? "div" : y, v = e.gapMode, x = Rj(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), _ = p, E = Qpe([r, t]), w = ro(ro({}, x), a);
  return D.createElement(
    D.Fragment,
    null,
    c && D.createElement(_, { sideCar: Nj, removeScrollBar: u, shards: d, noIsolation: f, inert: h, setCallbacks: s, allowPinchZoom: !!m, lockRef: r, gapMode: v }),
    i ? D.cloneElement(D.Children.only(o), ro(ro({}, w), { ref: E })) : D.createElement(b, ro({}, w, { className: l, ref: E }), o)
  );
});
Jb.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Jb.classNames = {
  fullWidth: ug,
  zeroRight: lg
};
var ihe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function ahe() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = ihe();
  return t && e.setAttribute("nonce", t), e;
}
function she(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function ohe(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var lhe = function() {
  var e = 0, t = null;
  return {
    add: function(r) {
      e == 0 && (t = ahe()) && (she(t, r), ohe(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, uhe = function() {
  var e = lhe();
  return function(t, r) {
    D.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && r]);
  };
}, Dj = function() {
  var e = uhe(), t = function(r) {
    var n = r.styles, a = r.dynamic;
    return e(n, a), null;
  };
  return t;
}, che = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, N1 = function(e) {
  return parseInt(e || "", 10) || 0;
}, dhe = function(e) {
  var t = window.getComputedStyle(document.body), r = t[e === "padding" ? "paddingLeft" : "marginLeft"], n = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [N1(r), N1(n), N1(a)];
}, fhe = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return che;
  var t = dhe(e), r = document.documentElement.clientWidth, n = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, n - r + t[2] - t[0])
  };
}, phe = Dj(), Hc = "data-scroll-locked", hhe = function(e, t, r, n) {
  var a = e.left, s = e.top, i = e.right, o = e.gap;
  return r === void 0 && (r = "margin"), `
  .`.concat(Ype, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(o, "px ").concat(n, `;
  }
  body[`).concat(Hc, `] {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(n, ";"),
    r === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(o, "px ").concat(n, `;
    `),
    r === "padding" && "padding-right: ".concat(o, "px ").concat(n, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(lg, ` {
    right: `).concat(o, "px ").concat(n, `;
  }
  
  .`).concat(ug, ` {
    margin-right: `).concat(o, "px ").concat(n, `;
  }
  
  .`).concat(lg, " .").concat(lg, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(ug, " .").concat(ug, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body[`).concat(Hc, `] {
    `).concat(Xpe, ": ").concat(o, `px;
  }
`);
}, vL = function() {
  var e = parseInt(document.body.getAttribute(Hc) || "0", 10);
  return isFinite(e) ? e : 0;
}, mhe = function() {
  D.useEffect(function() {
    return document.body.setAttribute(Hc, (vL() + 1).toString()), function() {
      var e = vL() - 1;
      e <= 0 ? document.body.removeAttribute(Hc) : document.body.setAttribute(Hc, e.toString());
    };
  }, []);
}, ghe = function(e) {
  var t = e.noRelative, r = e.noImportant, n = e.gapMode, a = n === void 0 ? "margin" : n;
  mhe();
  var s = D.useMemo(function() {
    return fhe(a);
  }, [a]);
  return D.createElement(phe, { styles: hhe(s, !t, a, r ? "" : "!important") });
}, pR = !1;
if (typeof window < "u")
  try {
    var fm = Object.defineProperty({}, "passive", {
      get: function() {
        return pR = !0, !0;
      }
    });
    window.addEventListener("test", fm, fm), window.removeEventListener("test", fm, fm);
  } catch {
    pR = !1;
  }
var dc = pR ? { passive: !1 } : !1, bhe = function(e) {
  return e.tagName === "TEXTAREA";
}, Oj = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var r = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    r[t] !== "hidden" && // contains scroll inside self
    !(r.overflowY === r.overflowX && !bhe(e) && r[t] === "visible")
  );
}, yhe = function(e) {
  return Oj(e, "overflowY");
}, vhe = function(e) {
  return Oj(e, "overflowX");
}, wL = function(e, t) {
  var r = t.ownerDocument, n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var a = Pj(e, n);
    if (a) {
      var s = Lj(e, n), i = s[1], o = s[2];
      if (i > o)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== r.body);
  return !1;
}, whe = function(e) {
  var t = e.scrollTop, r = e.scrollHeight, n = e.clientHeight;
  return [
    t,
    r,
    n
  ];
}, xhe = function(e) {
  var t = e.scrollLeft, r = e.scrollWidth, n = e.clientWidth;
  return [
    t,
    r,
    n
  ];
}, Pj = function(e, t) {
  return e === "v" ? yhe(t) : vhe(t);
}, Lj = function(e, t) {
  return e === "v" ? whe(t) : xhe(t);
}, Ehe = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, She = function(e, t, r, n, a) {
  var s = Ehe(e, window.getComputedStyle(t).direction), i = s * n, o = r.target, l = t.contains(o), u = !1, c = i > 0, d = 0, p = 0;
  do {
    var f = Lj(e, o), h = f[0], m = f[1], y = f[2], b = m - y - s * h;
    (h || b) && Pj(e, o) && (d += b, p += h), o instanceof ShadowRoot ? o = o.host : o = o.parentNode;
  } while (
    // portaled content
    !l && o !== document.body || // self content
    l && (t.contains(o) || t === o)
  );
  return (c && Math.abs(d) < 1 || !c && Math.abs(p) < 1) && (u = !0), u;
}, pm = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, xL = function(e) {
  return [e.deltaX, e.deltaY];
}, EL = function(e) {
  return e && "current" in e ? e.current : e;
}, _he = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, khe = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Che = 0, fc = [];
function Ahe(e) {
  var t = D.useRef([]), r = D.useRef([0, 0]), n = D.useRef(), a = D.useState(Che++)[0], s = D.useState(Dj)[0], i = D.useRef(e);
  D.useEffect(function() {
    i.current = e;
  }, [e]), D.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var m = Kpe([e.lockRef.current], (e.shards || []).map(EL), !0).filter(Boolean);
      return m.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), m.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var o = D.useCallback(function(m, y) {
    if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
      return !i.current.allowPinchZoom;
    var b = pm(m), v = r.current, x = "deltaX" in m ? m.deltaX : v[0] - b[0], _ = "deltaY" in m ? m.deltaY : v[1] - b[1], E, w = m.target, C = Math.abs(x) > Math.abs(_) ? "h" : "v";
    if ("touches" in m && C === "h" && w.type === "range")
      return !1;
    var k = wL(C, w);
    if (!k)
      return !0;
    if (k ? E = C : (E = C === "v" ? "h" : "v", k = wL(C, w)), !k)
      return !1;
    if (!n.current && "changedTouches" in m && (x || _) && (n.current = E), !E)
      return !0;
    var S = n.current || E;
    return She(S, y, m, S === "h" ? x : _);
  }, []), l = D.useCallback(function(m) {
    var y = m;
    if (!(!fc.length || fc[fc.length - 1] !== s)) {
      var b = "deltaY" in y ? xL(y) : pm(y), v = t.current.filter(function(E) {
        return E.name === y.type && (E.target === y.target || y.target === E.shadowParent) && _he(E.delta, b);
      })[0];
      if (v && v.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!v) {
        var x = (i.current.shards || []).map(EL).filter(Boolean).filter(function(E) {
          return E.contains(y.target);
        }), _ = x.length > 0 ? o(y, x[0]) : !i.current.noIsolation;
        _ && y.cancelable && y.preventDefault();
      }
    }
  }, []), u = D.useCallback(function(m, y, b, v) {
    var x = { name: m, delta: y, target: b, should: v, shadowParent: The(b) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(_) {
        return _ !== x;
      });
    }, 1);
  }, []), c = D.useCallback(function(m) {
    r.current = pm(m), n.current = void 0;
  }, []), d = D.useCallback(function(m) {
    u(m.type, xL(m), m.target, o(m, e.lockRef.current));
  }, []), p = D.useCallback(function(m) {
    u(m.type, pm(m), m.target, o(m, e.lockRef.current));
  }, []);
  D.useEffect(function() {
    return fc.push(s), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", l, dc), document.addEventListener("touchmove", l, dc), document.addEventListener("touchstart", c, dc), function() {
      fc = fc.filter(function(m) {
        return m !== s;
      }), document.removeEventListener("wheel", l, dc), document.removeEventListener("touchmove", l, dc), document.removeEventListener("touchstart", c, dc);
    };
  }, []);
  var f = e.removeScrollBar, h = e.inert;
  return D.createElement(
    D.Fragment,
    null,
    h ? D.createElement(s, { styles: khe(a) }) : null,
    f ? D.createElement(ghe, { gapMode: e.gapMode }) : null
  );
}
function The(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Rhe = nhe(Nj, Ahe);
var Qb = D.forwardRef(function(e, t) {
  return D.createElement(Jb, ro({}, e, { ref: t, sideCar: Rhe }));
});
Qb.classNames = Jb.classNames;
var hR = ["Enter", " "], Ihe = ["ArrowDown", "PageUp", "Home"], Mj = ["ArrowUp", "PageDown", "End"], Nhe = [...Ihe, ...Mj], Dhe = {
  ltr: [...hR, "ArrowRight"],
  rtl: [...hR, "ArrowLeft"]
}, Ohe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, yh = "Menu", [zp, Phe, Lhe] = qb(yh), [qu, Fj] = ds(yh, [
  Lhe,
  Wl,
  Sj
]), vh = Wl(), $j = Sj(), [Bj, Kl] = qu(yh), [Mhe, wh] = qu(yh), Uj = (e) => {
  const { __scopeMenu: t, open: r = !1, children: n, dir: a, onOpenChange: s, modal: i = !0 } = e, o = vh(t), [l, u] = D.useState(null), c = D.useRef(!1), d = si(s), p = hh(a);
  return D.useEffect(() => {
    const f = () => {
      c.current = !0, document.addEventListener("pointerdown", h, { capture: !0, once: !0 }), document.addEventListener("pointermove", h, { capture: !0, once: !0 });
    }, h = () => c.current = !1;
    return document.addEventListener("keydown", f, { capture: !0 }), () => {
      document.removeEventListener("keydown", f, { capture: !0 }), document.removeEventListener("pointerdown", h, { capture: !0 }), document.removeEventListener("pointermove", h, { capture: !0 });
    };
  }, []), /* @__PURE__ */ K(gh, { ...o, children: /* @__PURE__ */ K(
    Bj,
    {
      scope: t,
      open: r,
      onOpenChange: d,
      content: l,
      onContentChange: u,
      children: /* @__PURE__ */ K(
        Mhe,
        {
          scope: t,
          onClose: D.useCallback(() => d(!1), [d]),
          isUsingKeyboardRef: c,
          dir: p,
          modal: i,
          children: n
        }
      )
    }
  ) });
};
Uj.displayName = yh;
var Fhe = "MenuAnchor", dN = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e, a = vh(r);
    return /* @__PURE__ */ K(bh, { ...a, ...n, ref: t });
  }
);
dN.displayName = Fhe;
var fN = "MenuPortal", [$he, zj] = qu(fN, {
  forceMount: void 0
}), qj = (e) => {
  const { __scopeMenu: t, forceMount: r, children: n, container: a } = e, s = Kl(fN, t);
  return /* @__PURE__ */ K($he, { scope: t, forceMount: r, children: /* @__PURE__ */ K(Ra, { present: r || s.open, children: /* @__PURE__ */ K(Xb, { asChild: !0, container: a, children: n }) }) });
};
qj.displayName = fN;
var ls = "MenuContent", [Bhe, pN] = qu(ls), jj = D.forwardRef(
  (e, t) => {
    const r = zj(ls, e.__scopeMenu), { forceMount: n = r.forceMount, ...a } = e, s = Kl(ls, e.__scopeMenu), i = wh(ls, e.__scopeMenu);
    return /* @__PURE__ */ K(zp.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ K(Ra, { present: n || s.open, children: /* @__PURE__ */ K(zp.Slot, { scope: e.__scopeMenu, children: i.modal ? /* @__PURE__ */ K(Uhe, { ...a, ref: t }) : /* @__PURE__ */ K(zhe, { ...a, ref: t }) }) }) });
  }
), Uhe = D.forwardRef(
  (e, t) => {
    const r = Kl(ls, e.__scopeMenu), n = D.useRef(null), a = sn(t, n);
    return D.useEffect(() => {
      const s = n.current;
      if (s) return cN(s);
    }, []), /* @__PURE__ */ K(
      hN,
      {
        ...e,
        ref: a,
        trapFocus: r.open,
        disableOutsidePointerEvents: r.open,
        disableOutsideScroll: !0,
        onFocusOutside: nr(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => r.onOpenChange(!1)
      }
    );
  }
), zhe = D.forwardRef((e, t) => {
  const r = Kl(ls, e.__scopeMenu);
  return /* @__PURE__ */ K(
    hN,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => r.onOpenChange(!1)
    }
  );
}), hN = D.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: r,
      loop: n = !1,
      trapFocus: a,
      onOpenAutoFocus: s,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: o,
      onEntryFocus: l,
      onEscapeKeyDown: u,
      onPointerDownOutside: c,
      onFocusOutside: d,
      onInteractOutside: p,
      onDismiss: f,
      disableOutsideScroll: h,
      ...m
    } = e, y = Kl(ls, r), b = wh(ls, r), v = vh(r), x = $j(r), _ = Phe(r), [E, w] = D.useState(null), C = D.useRef(null), k = sn(t, C, y.onContentChange), S = D.useRef(0), B = D.useRef(""), U = D.useRef(0), N = D.useRef(null), O = D.useRef("right"), I = D.useRef(0), q = h ? Qb : D.Fragment, ae = h ? { as: zo, allowPinchZoom: !0 } : void 0, Q = (le) => {
      const W = B.current + le, X = _().filter(($) => !$.disabled), G = document.activeElement, P = X.find(($) => $.ref.current === G)?.textValue, he = X.map(($) => $.textValue), ye = Qhe(he, W, P), pe = X.find(($) => $.textValue === ye)?.ref.current;
      (function $(F) {
        B.current = F, window.clearTimeout(S.current), F !== "" && (S.current = window.setTimeout(() => $(""), 1e3));
      })(W), pe && setTimeout(() => pe.focus());
    };
    D.useEffect(() => () => window.clearTimeout(S.current), []), eN();
    const ne = D.useCallback((le) => O.current === N.current?.side && tme(le, N.current?.area), []);
    return /* @__PURE__ */ K(
      Bhe,
      {
        scope: r,
        searchRef: B,
        onItemEnter: D.useCallback(
          (le) => {
            ne(le) && le.preventDefault();
          },
          [ne]
        ),
        onItemLeave: D.useCallback(
          (le) => {
            ne(le) || (C.current?.focus(), w(null));
          },
          [ne]
        ),
        onTriggerLeave: D.useCallback(
          (le) => {
            ne(le) && le.preventDefault();
          },
          [ne]
        ),
        pointerGraceTimerRef: U,
        onPointerGraceIntentChange: D.useCallback((le) => {
          N.current = le;
        }, []),
        children: /* @__PURE__ */ K(q, { ...ae, children: /* @__PURE__ */ K(
          Hb,
          {
            asChild: !0,
            trapped: a,
            onMountAutoFocus: nr(s, (le) => {
              le.preventDefault(), C.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: i,
            children: /* @__PURE__ */ K(
              jb,
              {
                asChild: !0,
                disableOutsidePointerEvents: o,
                onEscapeKeyDown: u,
                onPointerDownOutside: c,
                onFocusOutside: d,
                onInteractOutside: p,
                onDismiss: f,
                children: /* @__PURE__ */ K(
                  jpe,
                  {
                    asChild: !0,
                    ...x,
                    dir: b.dir,
                    orientation: "vertical",
                    loop: n,
                    currentTabStopId: E,
                    onCurrentTabStopIdChange: w,
                    onEntryFocus: nr(l, (le) => {
                      b.isUsingKeyboardRef.current || le.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ K(
                      Kb,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": sH(y.open),
                        "data-radix-menu-content": "",
                        dir: b.dir,
                        ...v,
                        ...m,
                        ref: k,
                        style: { outline: "none", ...m.style },
                        onKeyDown: nr(m.onKeyDown, (le) => {
                          const X = le.target.closest("[data-radix-menu-content]") === le.currentTarget, G = le.ctrlKey || le.altKey || le.metaKey, P = le.key.length === 1;
                          X && (le.key === "Tab" && le.preventDefault(), !G && P && Q(le.key));
                          const he = C.current;
                          if (le.target !== he || !Nhe.includes(le.key)) return;
                          le.preventDefault();
                          const pe = _().filter(($) => !$.disabled).map(($) => $.ref.current);
                          Mj.includes(le.key) && pe.reverse(), Zhe(pe);
                        }),
                        onBlur: nr(e.onBlur, (le) => {
                          le.currentTarget.contains(le.target) || (window.clearTimeout(S.current), B.current = "");
                        }),
                        onPointerMove: nr(
                          e.onPointerMove,
                          qp((le) => {
                            const W = le.target, X = I.current !== le.clientX;
                            if (le.currentTarget.contains(W) && X) {
                              const G = le.clientX > I.current ? "right" : "left";
                              O.current = G, I.current = le.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
jj.displayName = ls;
var qhe = "MenuGroup", mN = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ K(Wr.div, { role: "group", ...n, ref: t });
  }
);
mN.displayName = qhe;
var jhe = "MenuLabel", Hj = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ K(Wr.div, { ...n, ref: t });
  }
);
Hj.displayName = jhe;
var jg = "MenuItem", SL = "menu.itemSelect", ey = D.forwardRef(
  (e, t) => {
    const { disabled: r = !1, onSelect: n, ...a } = e, s = D.useRef(null), i = wh(jg, e.__scopeMenu), o = pN(jg, e.__scopeMenu), l = sn(t, s), u = D.useRef(!1), c = () => {
      const d = s.current;
      if (!r && d) {
        const p = new CustomEvent(SL, { bubbles: !0, cancelable: !0 });
        d.addEventListener(SL, (f) => n?.(f), { once: !0 }), WI(d, p), p.defaultPrevented ? u.current = !1 : i.onClose();
      }
    };
    return /* @__PURE__ */ K(
      Vj,
      {
        ...a,
        ref: l,
        disabled: r,
        onClick: nr(e.onClick, c),
        onPointerDown: (d) => {
          e.onPointerDown?.(d), u.current = !0;
        },
        onPointerUp: nr(e.onPointerUp, (d) => {
          u.current || d.currentTarget?.click();
        }),
        onKeyDown: nr(e.onKeyDown, (d) => {
          const p = o.searchRef.current !== "";
          r || p && d.key === " " || hR.includes(d.key) && (d.currentTarget.click(), d.preventDefault());
        })
      }
    );
  }
);
ey.displayName = jg;
var Vj = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, disabled: n = !1, textValue: a, ...s } = e, i = pN(jg, r), o = $j(r), l = D.useRef(null), u = sn(t, l), [c, d] = D.useState(!1), [p, f] = D.useState("");
    return D.useEffect(() => {
      const h = l.current;
      h && f((h.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ K(
      zp.ItemSlot,
      {
        scope: r,
        disabled: n,
        textValue: a ?? p,
        children: /* @__PURE__ */ K(Hpe, { asChild: !0, ...o, focusable: !n, children: /* @__PURE__ */ K(
          Wr.div,
          {
            role: "menuitem",
            "data-highlighted": c ? "" : void 0,
            "aria-disabled": n || void 0,
            "data-disabled": n ? "" : void 0,
            ...s,
            ref: u,
            onPointerMove: nr(
              e.onPointerMove,
              qp((h) => {
                n ? i.onItemLeave(h) : (i.onItemEnter(h), h.defaultPrevented || h.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: nr(
              e.onPointerLeave,
              qp((h) => i.onItemLeave(h))
            ),
            onFocus: nr(e.onFocus, () => d(!0)),
            onBlur: nr(e.onBlur, () => d(!1))
          }
        ) })
      }
    );
  }
), Hhe = "MenuCheckboxItem", Gj = D.forwardRef(
  (e, t) => {
    const { checked: r = !1, onCheckedChange: n, ...a } = e;
    return /* @__PURE__ */ K(Zj, { scope: e.__scopeMenu, checked: r, children: /* @__PURE__ */ K(
      ey,
      {
        role: "menuitemcheckbox",
        "aria-checked": Hg(r) ? "mixed" : r,
        ...a,
        ref: t,
        "data-state": yN(r),
        onSelect: nr(
          a.onSelect,
          () => n?.(Hg(r) ? !0 : !r),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Gj.displayName = Hhe;
var Wj = "MenuRadioGroup", [Vhe, Ghe] = qu(
  Wj,
  { value: void 0, onValueChange: () => {
  } }
), Kj = D.forwardRef(
  (e, t) => {
    const { value: r, onValueChange: n, ...a } = e, s = si(n);
    return /* @__PURE__ */ K(Vhe, { scope: e.__scopeMenu, value: r, onValueChange: s, children: /* @__PURE__ */ K(mN, { ...a, ref: t }) });
  }
);
Kj.displayName = Wj;
var Yj = "MenuRadioItem", Xj = D.forwardRef(
  (e, t) => {
    const { value: r, ...n } = e, a = Ghe(Yj, e.__scopeMenu), s = r === a.value;
    return /* @__PURE__ */ K(Zj, { scope: e.__scopeMenu, checked: s, children: /* @__PURE__ */ K(
      ey,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...n,
        ref: t,
        "data-state": yN(s),
        onSelect: nr(
          n.onSelect,
          () => a.onValueChange?.(r),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Xj.displayName = Yj;
var gN = "MenuItemIndicator", [Zj, Whe] = qu(
  gN,
  { checked: !1 }
), Jj = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, forceMount: n, ...a } = e, s = Whe(gN, r);
    return /* @__PURE__ */ K(
      Ra,
      {
        present: n || Hg(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ K(
          Wr.span,
          {
            ...a,
            ref: t,
            "data-state": yN(s.checked)
          }
        )
      }
    );
  }
);
Jj.displayName = gN;
var Khe = "MenuSeparator", Qj = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ K(
      Wr.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...n,
        ref: t
      }
    );
  }
);
Qj.displayName = Khe;
var Yhe = "MenuArrow", eH = D.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e, a = vh(r);
    return /* @__PURE__ */ K(Yb, { ...a, ...n, ref: t });
  }
);
eH.displayName = Yhe;
var bN = "MenuSub", [Xhe, tH] = qu(bN), rH = (e) => {
  const { __scopeMenu: t, children: r, open: n = !1, onOpenChange: a } = e, s = Kl(bN, t), i = vh(t), [o, l] = D.useState(null), [u, c] = D.useState(null), d = si(a);
  return D.useEffect(() => (s.open === !1 && d(!1), () => d(!1)), [s.open, d]), /* @__PURE__ */ K(gh, { ...i, children: /* @__PURE__ */ K(
    Bj,
    {
      scope: t,
      open: n,
      onOpenChange: d,
      content: u,
      onContentChange: c,
      children: /* @__PURE__ */ K(
        Xhe,
        {
          scope: t,
          contentId: us(),
          triggerId: us(),
          trigger: o,
          onTriggerChange: l,
          children: r
        }
      )
    }
  ) });
};
rH.displayName = bN;
var $f = "MenuSubTrigger", nH = D.forwardRef(
  (e, t) => {
    const r = Kl($f, e.__scopeMenu), n = wh($f, e.__scopeMenu), a = tH($f, e.__scopeMenu), s = pN($f, e.__scopeMenu), i = D.useRef(null), { pointerGraceTimerRef: o, onPointerGraceIntentChange: l } = s, u = { __scopeMenu: e.__scopeMenu }, c = D.useCallback(() => {
      i.current && window.clearTimeout(i.current), i.current = null;
    }, []);
    return D.useEffect(() => c, [c]), D.useEffect(() => {
      const d = o.current;
      return () => {
        window.clearTimeout(d), l(null);
      };
    }, [o, l]), /* @__PURE__ */ K(dN, { asChild: !0, ...u, children: /* @__PURE__ */ K(
      Vj,
      {
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": r.open,
        "aria-controls": a.contentId,
        "data-state": sH(r.open),
        ...e,
        ref: ph(t, a.onTriggerChange),
        onClick: (d) => {
          e.onClick?.(d), !(e.disabled || d.defaultPrevented) && (d.currentTarget.focus(), r.open || r.onOpenChange(!0));
        },
        onPointerMove: nr(
          e.onPointerMove,
          qp((d) => {
            s.onItemEnter(d), !d.defaultPrevented && !e.disabled && !r.open && !i.current && (s.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => {
              r.onOpenChange(!0), c();
            }, 100));
          })
        ),
        onPointerLeave: nr(
          e.onPointerLeave,
          qp((d) => {
            c();
            const p = r.content?.getBoundingClientRect();
            if (p) {
              const f = r.content?.dataset.side, h = f === "right", m = h ? -5 : 5, y = p[h ? "left" : "right"], b = p[h ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: d.clientX + m, y: d.clientY },
                  { x: y, y: p.top },
                  { x: b, y: p.top },
                  { x: b, y: p.bottom },
                  { x: y, y: p.bottom }
                ],
                side: f
              }), window.clearTimeout(o.current), o.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(d), d.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: nr(e.onKeyDown, (d) => {
          const p = s.searchRef.current !== "";
          e.disabled || p && d.key === " " || Dhe[n.dir].includes(d.key) && (r.onOpenChange(!0), r.content?.focus(), d.preventDefault());
        })
      }
    ) });
  }
);
nH.displayName = $f;
var iH = "MenuSubContent", aH = D.forwardRef(
  (e, t) => {
    const r = zj(ls, e.__scopeMenu), { forceMount: n = r.forceMount, ...a } = e, s = Kl(ls, e.__scopeMenu), i = wh(ls, e.__scopeMenu), o = tH(iH, e.__scopeMenu), l = D.useRef(null), u = sn(t, l);
    return /* @__PURE__ */ K(zp.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ K(Ra, { present: n || s.open, children: /* @__PURE__ */ K(zp.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ K(
      hN,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...a,
        ref: u,
        align: "start",
        side: i.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (c) => {
          i.isUsingKeyboardRef.current && l.current?.focus(), c.preventDefault();
        },
        onCloseAutoFocus: (c) => c.preventDefault(),
        onFocusOutside: nr(e.onFocusOutside, (c) => {
          c.target !== o.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: nr(e.onEscapeKeyDown, (c) => {
          i.onClose(), c.preventDefault();
        }),
        onKeyDown: nr(e.onKeyDown, (c) => {
          const d = c.currentTarget.contains(c.target), p = Ohe[i.dir].includes(c.key);
          d && p && (s.onOpenChange(!1), o.trigger?.focus(), c.preventDefault());
        })
      }
    ) }) }) });
  }
);
aH.displayName = iH;
function sH(e) {
  return e ? "open" : "closed";
}
function Hg(e) {
  return e === "indeterminate";
}
function yN(e) {
  return Hg(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function Zhe(e) {
  const t = document.activeElement;
  for (const r of e)
    if (r === t || (r.focus(), document.activeElement !== t)) return;
}
function Jhe(e, t) {
  return e.map((r, n) => e[(t + n) % e.length]);
}
function Qhe(e, t, r) {
  const a = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, s = r ? e.indexOf(r) : -1;
  let i = Jhe(e, Math.max(s, 0));
  a.length === 1 && (i = i.filter((u) => u !== r));
  const l = i.find(
    (u) => u.toLowerCase().startsWith(a.toLowerCase())
  );
  return l !== r ? l : void 0;
}
function eme(e, t) {
  const { x: r, y: n } = e;
  let a = !1;
  for (let s = 0, i = t.length - 1; s < t.length; i = s++) {
    const o = t[s].x, l = t[s].y, u = t[i].x, c = t[i].y;
    l > n != c > n && r < (u - o) * (n - l) / (c - l) + o && (a = !a);
  }
  return a;
}
function tme(e, t) {
  if (!t) return !1;
  const r = { x: e.clientX, y: e.clientY };
  return eme(r, t);
}
function qp(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var rme = Uj, nme = dN, ime = qj, ame = jj, sme = mN, ome = Hj, lme = ey, ume = Gj, cme = Kj, dme = Xj, fme = Jj, pme = Qj, hme = eH, mme = rH, gme = nH, bme = aH, vN = "DropdownMenu", [yme, Lze] = ds(
  vN,
  [Fj]
), Ki = Fj(), [vme, oH] = yme(vN), lH = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: r,
    dir: n,
    open: a,
    defaultOpen: s,
    onOpenChange: i,
    modal: o = !0
  } = e, l = Ki(t), u = D.useRef(null), [c = !1, d] = Bs({
    prop: a,
    defaultProp: s,
    onChange: i
  });
  return /* @__PURE__ */ K(
    vme,
    {
      scope: t,
      triggerId: us(),
      triggerRef: u,
      contentId: us(),
      open: c,
      onOpenChange: d,
      onOpenToggle: D.useCallback(() => d((p) => !p), [d]),
      modal: o,
      children: /* @__PURE__ */ K(rme, { ...l, open: c, onOpenChange: d, dir: n, modal: o, children: r })
    }
  );
};
lH.displayName = vN;
var uH = "DropdownMenuTrigger", cH = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, disabled: n = !1, ...a } = e, s = oH(uH, r), i = Ki(r);
    return /* @__PURE__ */ K(nme, { asChild: !0, ...i, children: /* @__PURE__ */ K(
      Wr.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": n ? "" : void 0,
        disabled: n,
        ...a,
        ref: ph(t, s.triggerRef),
        onPointerDown: nr(e.onPointerDown, (o) => {
          !n && o.button === 0 && o.ctrlKey === !1 && (s.onOpenToggle(), s.open || o.preventDefault());
        }),
        onKeyDown: nr(e.onKeyDown, (o) => {
          n || (["Enter", " "].includes(o.key) && s.onOpenToggle(), o.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(o.key) && o.preventDefault());
        })
      }
    ) });
  }
);
cH.displayName = uH;
var wme = "DropdownMenuPortal", dH = (e) => {
  const { __scopeDropdownMenu: t, ...r } = e, n = Ki(t);
  return /* @__PURE__ */ K(ime, { ...n, ...r });
};
dH.displayName = wme;
var fH = "DropdownMenuContent", pH = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, a = oH(fH, r), s = Ki(r), i = D.useRef(!1);
    return /* @__PURE__ */ K(
      ame,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...s,
        ...n,
        ref: t,
        onCloseAutoFocus: nr(e.onCloseAutoFocus, (o) => {
          i.current || a.triggerRef.current?.focus(), i.current = !1, o.preventDefault();
        }),
        onInteractOutside: nr(e.onInteractOutside, (o) => {
          const l = o.detail.originalEvent, u = l.button === 0 && l.ctrlKey === !0, c = l.button === 2 || u;
          (!a.modal || c) && (i.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
pH.displayName = fH;
var xme = "DropdownMenuGroup", hH = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
    return /* @__PURE__ */ K(sme, { ...a, ...n, ref: t });
  }
);
hH.displayName = xme;
var Eme = "DropdownMenuLabel", mH = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
    return /* @__PURE__ */ K(ome, { ...a, ...n, ref: t });
  }
);
mH.displayName = Eme;
var Sme = "DropdownMenuItem", gH = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
    return /* @__PURE__ */ K(lme, { ...a, ...n, ref: t });
  }
);
gH.displayName = Sme;
var _me = "DropdownMenuCheckboxItem", bH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(ume, { ...a, ...n, ref: t });
});
bH.displayName = _me;
var kme = "DropdownMenuRadioGroup", yH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(cme, { ...a, ...n, ref: t });
});
yH.displayName = kme;
var Cme = "DropdownMenuRadioItem", Ame = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(dme, { ...a, ...n, ref: t });
});
Ame.displayName = Cme;
var Tme = "DropdownMenuItemIndicator", vH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(fme, { ...a, ...n, ref: t });
});
vH.displayName = Tme;
var Rme = "DropdownMenuSeparator", wH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(pme, { ...a, ...n, ref: t });
});
wH.displayName = Rme;
var Ime = "DropdownMenuArrow", Nme = D.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
    return /* @__PURE__ */ K(hme, { ...a, ...n, ref: t });
  }
);
Nme.displayName = Ime;
var Dme = (e) => {
  const { __scopeDropdownMenu: t, children: r, open: n, onOpenChange: a, defaultOpen: s } = e, i = Ki(t), [o = !1, l] = Bs({
    prop: n,
    defaultProp: s,
    onChange: a
  });
  return /* @__PURE__ */ K(mme, { ...i, open: o, onOpenChange: l, children: r });
}, Ome = "DropdownMenuSubTrigger", xH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(gme, { ...a, ...n, ref: t });
});
xH.displayName = Ome;
var Pme = "DropdownMenuSubContent", EH = D.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, a = Ki(r);
  return /* @__PURE__ */ K(
    bme,
    {
      ...a,
      ...n,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
EH.displayName = Pme;
var Lme = lH, Mme = cH, SH = dH, Fme = pH, $me = hH, Bme = mH, Ume = gH, zme = bH, qme = yH, jme = vH, Hme = wH, Vme = Dme, Gme = xH, Wme = EH;
const wN = Lme;
wN.displayName = "DropdownMenu";
const xN = Mme;
xN.displayName = "DropdownMenuTrigger";
const Kme = $me;
Kme.displayName = "DropdownMenuGroup";
const Yme = Vme;
Yme.displayName = "DropdownMenuSubMenu";
const Xme = qme;
Xme.displayName = "DropdownMenuRadioGroup";
const Zme = D.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ $t(
  Gme,
  {
    ref: n,
    className: gr(
      // base
      "relative flex cursor-default select-none items-center rounded py-1.5 pl-2 pr-1 outline-none transition-colors data-[state=checked]:font-semibold sm:text-sm",
      // text color
      "text-gray-900 dark:text-gray-50",
      // disabled
      "data-[disabled]:pointer-events-none data-[disabled]:text-gray-400 data-[disabled]:hover:bg-none dark:data-[disabled]:text-gray-600",
      // focus
      "focus-visible:bg-gray-100 data-[state=open]:bg-gray-100 focus-visible:dark:bg-gray-900 data-[state=open]:dark:bg-gray-900",
      // hover
      "hover:bg-gray-100 hover:dark:bg-gray-900",
      //
      e
    ),
    ...r,
    children: [
      t,
      /* @__PURE__ */ K(
        WT,
        {
          className: "ml-auto size-4 shrink-0",
          "aria-hidden": "true"
        }
      )
    ]
  }
));
Zme.displayName = "DropdownMenuSubMenuTrigger";
const Jme = D.forwardRef(({ className: e, collisionPadding: t = 8, ...r }, n) => /* @__PURE__ */ K(SH, { children: /* @__PURE__ */ K(
  Wme,
  {
    ref: n,
    collisionPadding: t,
    className: gr(
      // base
      "relative z-50 overflow-hidden rounded-md border p-1 shadow-xl shadow-black/[2.5%]",
      // widths
      "min-w-32",
      // heights
      "max-h-[var(--radix-popper-available-height)]",
      // background color
      "bg-white dark:bg-gray-950",
      // text color
      "text-gray-900 dark:text-gray-50",
      // border color
      "border-gray-200 dark:border-gray-800",
      // transition
      "will-change-[transform,opacity]",
      // "data-[state=open]:animate-slideDownAndFade",
      "data-[state=closed]:animate-hide",
      "data-[side=bottom]:animate-slideDownAndFade data-[side=left]:animate-slideLeftAndFade data-[side=right]:animate-slideRightAndFade data-[side=top]:animate-slideUpAndFade",
      e
    ),
    ...r
  }
) }));
Jme.displayName = "DropdownMenuSubMenuContent";
const EN = D.forwardRef(
  ({
    className: e,
    sideOffset: t = 8,
    collisionPadding: r = 8,
    align: n = "center",
    loop: a = !0,
    ...s
  }, i) => /* @__PURE__ */ K(SH, { children: /* @__PURE__ */ K(
    Fme,
    {
      ref: i,
      className: gr(
        // base
        "relative z-50 overflow-hidden rounded-md border p-1 shadow-xl shadow-black/[2.5%]",
        // widths
        "min-w-48",
        // heights
        "max-h-[var(--radix-popper-available-height)]",
        // background color
        "bg-white dark:bg-gray-950",
        // text color
        "text-gray-900 dark:text-gray-50",
        // border color
        "border-gray-200 dark:border-gray-800",
        // transition
        "will-change-[transform,opacity]",
        "data-[state=closed]:animate-hide",
        "data-[side=bottom]:animate-slideDownAndFade data-[side=left]:animate-slideLeftAndFade data-[side=right]:animate-slideRightAndFade data-[side=top]:animate-slideUpAndFade",
        e
      ),
      sideOffset: t,
      align: n,
      collisionPadding: r,
      loop: a,
      ...s
    }
  ) })
);
EN.displayName = "DropdownMenuContent";
const Jf = D.forwardRef(({ className: e, shortcut: t, hint: r, children: n, ...a }, s) => /* @__PURE__ */ $t(
  Ume,
  {
    ref: s,
    className: gr(
      // base
      "group/DropdownMenuItem relative flex cursor-pointer select-none items-center rounded py-1.5 pl-2 pr-1 outline-none transition-colors data-[state=checked]:font-semibold sm:text-sm",
      // text color
      "text-gray-900 dark:text-gray-50",
      // disabled
      "data-[disabled]:pointer-events-none data-[disabled]:text-gray-400 data-[disabled]:hover:bg-none dark:data-[disabled]:text-gray-600",
      // focus
      "focus-visible:bg-gray-100 focus-visible:dark:bg-gray-900",
      // hover
      "hover:bg-gray-100 hover:dark:bg-gray-900",
      e
    ),
    "tremor-id": "tremor-raw",
    ...a,
    children: [
      n,
      r && /* @__PURE__ */ K(
        "span",
        {
          className: gr("ml-auto pl-2 text-sm text-gray-400 dark:text-gray-600"),
          children: r
        }
      ),
      t && /* @__PURE__ */ K(
        "span",
        {
          className: gr("ml-auto pl-2 text-sm text-gray-400 dark:text-gray-600"),
          children: t
        }
      )
    ]
  }
));
Jf.displayName = "DropdownMenuItem";
const Qme = D.forwardRef(
  ({ className: e, hint: t, shortcut: r, children: n, checked: a, ...s }, i) => /* @__PURE__ */ $t(
    zme,
    {
      ref: i,
      className: gr(
        // base
        "relative flex cursor-pointer select-none items-center gap-x-2 rounded py-1.5 pl-8 pr-1 outline-none transition-colors data-[state=checked]:font-semibold sm:text-sm",
        // text color
        "text-gray-900 dark:text-gray-50",
        // disabled
        "data-[disabled]:pointer-events-none data-[disabled]:text-gray-400 data-[disabled]:hover:bg-none dark:data-[disabled]:text-gray-600",
        // focus
        "focus-visible:bg-gray-100 focus-visible:dark:bg-gray-900",
        // hover
        "hover:bg-gray-100 hover:dark:bg-gray-900",
        e
      ),
      checked: a,
      ...s,
      children: [
        /* @__PURE__ */ K("span", { className: "absolute left-2 flex size-4 items-center justify-center", children: /* @__PURE__ */ K(jme, { children: /* @__PURE__ */ K(
          Qz,
          {
            "aria-hidden": "true",
            className: "size-full shrink-0 text-gray-800 dark:text-gray-200"
          }
        ) }) }),
        n,
        t && /* @__PURE__ */ K(
          "span",
          {
            className: gr(
              "ml-auto text-sm font-normal text-gray-400 dark:text-gray-600"
            ),
            children: t
          }
        ),
        r && /* @__PURE__ */ K(
          "span",
          {
            className: gr(
              "ml-auto text-sm font-normal tracking-widest text-gray-400 dark:border-gray-800 dark:text-gray-600"
            ),
            children: r
          }
        )
      ]
    }
  )
);
Qme.displayName = "DropdownMenuCheckboxItem";
const ege = D.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  Bme,
  {
    ref: r,
    className: gr(
      // base
      "px-2 py-2 text-xs font-medium tracking-wide",
      // text color
      "text-gray-500 dark:text-gray-500",
      e
    ),
    ...t
  }
));
ege.displayName = "DropdownMenuLabel";
const tge = D.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  Hme,
  {
    ref: r,
    className: gr(
      "-mx-1 my-1 h-px border-t border-gray-200 dark:border-gray-800",
      e
    ),
    ...t
  }
));
tge.displayName = "DropdownMenuSeparator";
const rge = ({
  className: e,
  ...t
}) => /* @__PURE__ */ K(
  "div",
  {
    className: gr(
      // text color
      "text-gray-600 dark:text-gray-400",
      // disabled
      "group-data-[disabled]/DropdownMenuItem:text-gray-400 group-data-[disabled]/DropdownMenuItem:dark:text-gray-700",
      e
    ),
    ...t
  }
);
rge.displayName = "DropdownMenuIconWrapper";
const nge = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
class xh {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, r, n) {
    this.property = t, this.normal = r, n && (this.space = n);
  }
}
xh.prototype.property = {};
xh.prototype.normal = {};
xh.prototype.space = null;
function _H(e, t) {
  const r = {}, n = {};
  let a = -1;
  for (; ++a < e.length; )
    Object.assign(r, e[a].property), Object.assign(n, e[a].normal);
  return new xh(r, n, t);
}
function mR(e) {
  return e.toLowerCase();
}
class ps {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, r) {
    this.property = t, this.attribute = r;
  }
}
ps.prototype.space = null;
ps.prototype.boolean = !1;
ps.prototype.booleanish = !1;
ps.prototype.overloadedBoolean = !1;
ps.prototype.number = !1;
ps.prototype.commaSeparated = !1;
ps.prototype.spaceSeparated = !1;
ps.prototype.commaOrSpaceSeparated = !1;
ps.prototype.mustUseProperty = !1;
ps.prototype.defined = !1;
let ige = 0;
const Kr = ju(), gi = ju(), kH = ju(), zt = ju(), Gn = ju(), Vc = ju(), Pa = ju();
function ju() {
  return 2 ** ++ige;
}
const gR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Kr,
  booleanish: gi,
  commaOrSpaceSeparated: Pa,
  commaSeparated: Vc,
  number: zt,
  overloadedBoolean: kH,
  spaceSeparated: Gn
}, Symbol.toStringTag, { value: "Module" })), D1 = Object.keys(gR);
class SN extends ps {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, r, n, a) {
    let s = -1;
    if (super(t, r), _L(this, "space", a), typeof n == "number")
      for (; ++s < D1.length; ) {
        const i = D1[s];
        _L(this, D1[s], (n & gR[i]) === gR[i]);
      }
  }
}
SN.prototype.defined = !0;
function _L(e, t, r) {
  r && (e[t] = r);
}
const age = {}.hasOwnProperty;
function Td(e) {
  const t = {}, r = {};
  let n;
  for (n in e.properties)
    if (age.call(e.properties, n)) {
      const a = e.properties[n], s = new SN(
        n,
        e.transform(e.attributes || {}, n),
        a,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(n) && (s.mustUseProperty = !0), t[n] = s, r[mR(n)] = n, r[mR(s.attribute)] = n;
    }
  return new xh(t, r, e.space);
}
const CH = Td({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), AH = Td({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function TH(e, t) {
  return t in e ? e[t] : t;
}
function RH(e, t) {
  return TH(e, t.toLowerCase());
}
const IH = Td({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: RH,
  properties: { xmlns: null, xmlnsXLink: null }
}), NH = Td({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: gi,
    ariaAutoComplete: null,
    ariaBusy: gi,
    ariaChecked: gi,
    ariaColCount: zt,
    ariaColIndex: zt,
    ariaColSpan: zt,
    ariaControls: Gn,
    ariaCurrent: null,
    ariaDescribedBy: Gn,
    ariaDetails: null,
    ariaDisabled: gi,
    ariaDropEffect: Gn,
    ariaErrorMessage: null,
    ariaExpanded: gi,
    ariaFlowTo: Gn,
    ariaGrabbed: gi,
    ariaHasPopup: null,
    ariaHidden: gi,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Gn,
    ariaLevel: zt,
    ariaLive: null,
    ariaModal: gi,
    ariaMultiLine: gi,
    ariaMultiSelectable: gi,
    ariaOrientation: null,
    ariaOwns: Gn,
    ariaPlaceholder: null,
    ariaPosInSet: zt,
    ariaPressed: gi,
    ariaReadOnly: gi,
    ariaRelevant: null,
    ariaRequired: gi,
    ariaRoleDescription: Gn,
    ariaRowCount: zt,
    ariaRowIndex: zt,
    ariaRowSpan: zt,
    ariaSelected: gi,
    ariaSetSize: zt,
    ariaSort: null,
    ariaValueMax: zt,
    ariaValueMin: zt,
    ariaValueNow: zt,
    ariaValueText: null,
    role: null
  }
}), sge = Td({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: RH,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Vc,
    acceptCharset: Gn,
    accessKey: Gn,
    action: null,
    allow: null,
    allowFullScreen: Kr,
    allowPaymentRequest: Kr,
    allowUserMedia: Kr,
    alt: null,
    as: null,
    async: Kr,
    autoCapitalize: null,
    autoComplete: Gn,
    autoFocus: Kr,
    autoPlay: Kr,
    blocking: Gn,
    capture: null,
    charSet: null,
    checked: Kr,
    cite: null,
    className: Gn,
    cols: zt,
    colSpan: null,
    content: null,
    contentEditable: gi,
    controls: Kr,
    controlsList: Gn,
    coords: zt | Vc,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Kr,
    defer: Kr,
    dir: null,
    dirName: null,
    disabled: Kr,
    download: kH,
    draggable: gi,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Kr,
    formTarget: null,
    headers: Gn,
    height: zt,
    hidden: Kr,
    high: zt,
    href: null,
    hrefLang: null,
    htmlFor: Gn,
    httpEquiv: Gn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Kr,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Kr,
    itemId: null,
    itemProp: Gn,
    itemRef: Gn,
    itemScope: Kr,
    itemType: Gn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Kr,
    low: zt,
    manifest: null,
    max: null,
    maxLength: zt,
    media: null,
    method: null,
    min: null,
    minLength: zt,
    multiple: Kr,
    muted: Kr,
    name: null,
    nonce: null,
    noModule: Kr,
    noValidate: Kr,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Kr,
    optimum: zt,
    pattern: null,
    ping: Gn,
    placeholder: null,
    playsInline: Kr,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Kr,
    referrerPolicy: null,
    rel: Gn,
    required: Kr,
    reversed: Kr,
    rows: zt,
    rowSpan: zt,
    sandbox: Gn,
    scope: null,
    scoped: Kr,
    seamless: Kr,
    selected: Kr,
    shadowRootClonable: Kr,
    shadowRootDelegatesFocus: Kr,
    shadowRootMode: null,
    shape: null,
    size: zt,
    sizes: null,
    slot: null,
    span: zt,
    spellCheck: gi,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: zt,
    step: null,
    style: null,
    tabIndex: zt,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Kr,
    useMap: null,
    value: gi,
    width: zt,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Gn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: zt,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: zt,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Kr,
    // Lists. Use CSS to reduce space between items instead
    declare: Kr,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: zt,
    // `<img>` and `<object>`
    leftMargin: zt,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: zt,
    // `<body>`
    marginWidth: zt,
    // `<body>`
    noResize: Kr,
    // `<frame>`
    noHref: Kr,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Kr,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Kr,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: zt,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: gi,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: zt,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: zt,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Kr,
    disableRemotePlayback: Kr,
    prefix: null,
    property: null,
    results: zt,
    security: null,
    unselectable: null
  }
}), oge = Td({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: TH,
  properties: {
    about: Pa,
    accentHeight: zt,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: zt,
    amplitude: zt,
    arabicForm: null,
    ascent: zt,
    attributeName: null,
    attributeType: null,
    azimuth: zt,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: zt,
    by: null,
    calcMode: null,
    capHeight: zt,
    className: Gn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: zt,
    diffuseConstant: zt,
    direction: null,
    display: null,
    dur: null,
    divisor: zt,
    dominantBaseline: null,
    download: Kr,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: zt,
    enableBackground: null,
    end: null,
    event: null,
    exponent: zt,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: zt,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Vc,
    g2: Vc,
    glyphName: Vc,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: zt,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: zt,
    horizOriginX: zt,
    horizOriginY: zt,
    id: null,
    ideographic: zt,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: zt,
    k: zt,
    k1: zt,
    k2: zt,
    k3: zt,
    k4: zt,
    kernelMatrix: Pa,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: zt,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: zt,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: zt,
    overlineThickness: zt,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: zt,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Gn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: zt,
    pointsAtY: zt,
    pointsAtZ: zt,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Pa,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Pa,
    rev: Pa,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Pa,
    requiredFeatures: Pa,
    requiredFonts: Pa,
    requiredFormats: Pa,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: zt,
    specularExponent: zt,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: zt,
    strikethroughThickness: zt,
    string: null,
    stroke: null,
    strokeDashArray: Pa,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: zt,
    strokeOpacity: zt,
    strokeWidth: null,
    style: null,
    surfaceScale: zt,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Pa,
    tabIndex: zt,
    tableValues: null,
    target: null,
    targetX: zt,
    targetY: zt,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Pa,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: zt,
    underlineThickness: zt,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: zt,
    values: null,
    vAlphabetic: zt,
    vMathematical: zt,
    vectorEffect: null,
    vHanging: zt,
    vIdeographic: zt,
    version: null,
    vertAdvY: zt,
    vertOriginX: zt,
    vertOriginY: zt,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: zt,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), lge = /^data[-\w.:]+$/i, kL = /-[a-z]/g, uge = /[A-Z]/g;
function DH(e, t) {
  const r = mR(t);
  let n = t, a = ps;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && lge.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(kL, dge);
      n = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!kL.test(s)) {
        let i = s.replace(uge, cge);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    a = SN;
  }
  return new a(n, t);
}
function cge(e) {
  return "-" + e.toLowerCase();
}
function dge(e) {
  return e.charAt(1).toUpperCase();
}
const fge = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, OH = _H([AH, CH, IH, NH, sge], "html"), Eh = _H([AH, CH, IH, NH, oge], "svg"), CL = {}.hasOwnProperty;
function PH(e, t) {
  const r = t || {};
  function n(a, ...s) {
    let i = n.invalid;
    const o = n.handlers;
    if (a && CL.call(a, e)) {
      const l = String(a[e]);
      i = CL.call(o, l) ? o[l] : n.unknown;
    }
    if (i)
      return i.call(this, a, ...s);
  }
  return n.handlers = r.handlers || {}, n.invalid = r.invalid, n.unknown = r.unknown, n;
}
const pge = /["&'<>`]/g, hge = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, mge = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), gge = /[|\\{}()[\]^$+*?.]/g, AL = /* @__PURE__ */ new WeakMap();
function LH(e, t) {
  if (e = e.replace(
    t.subset ? bge(t.subset) : pge,
    n
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(hge, r).replace(mge, n);
  function r(a, s, i) {
    return t.format(
      (a.charCodeAt(0) - 55296) * 1024 + a.charCodeAt(1) - 56320 + 65536,
      i.charCodeAt(s + 2),
      t
    );
  }
  function n(a, s, i) {
    return t.format(
      a.charCodeAt(0),
      i.charCodeAt(s + 1),
      t
    );
  }
}
function bge(e) {
  let t = AL.get(e);
  return t || (t = yge(e), AL.set(e, t)), t;
}
function yge(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t.push(e[r].replace(gge, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const vge = /[\dA-Fa-f]/;
function wge(e, t, r) {
  const n = "&#x" + e.toString(16).toUpperCase();
  return r && t && !vge.test(String.fromCharCode(t)) ? n : n + ";";
}
const xge = /\d/;
function Ege(e, t, r) {
  const n = "&#" + String(e);
  return r && t && !xge.test(String.fromCharCode(t)) ? n : n + ";";
}
const MH = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], O1 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, Sge = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], FH = {}.hasOwnProperty, bR = {};
let hm;
for (hm in O1)
  FH.call(O1, hm) && (bR[O1[hm]] = hm);
const _ge = /[^\dA-Za-z]/;
function kge(e, t, r, n) {
  const a = String.fromCharCode(e);
  if (FH.call(bR, a)) {
    const s = bR[a], i = "&" + s;
    return r && MH.includes(s) && !Sge.includes(s) && (!n || t && t !== 61 && _ge.test(String.fromCharCode(t))) ? i : i + ";";
  }
  return "";
}
function Cge(e, t, r) {
  let n = wge(e, t, r.omitOptionalSemicolons), a;
  if ((r.useNamedReferences || r.useShortestReferences) && (a = kge(
    e,
    t,
    r.omitOptionalSemicolons,
    r.attribute
  )), (r.useShortestReferences || !a) && r.useShortestReferences) {
    const s = Ege(e, t, r.omitOptionalSemicolons);
    s.length < n.length && (n = s);
  }
  return a && (!r.useShortestReferences || a.length < n.length) ? a : n;
}
function Age(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Gc(e, t) {
  return LH(e, Object.assign({ format: Cge }, t));
}
function Tge(e, t) {
  return LH(e, Object.assign({ format: Age }, t));
}
const Rge = /^>|^->|<!--|-->|--!>|<!-$/g, Ige = [">"], Nge = ["<", ">"];
function Dge(e, t, r, n) {
  return n.settings.bogusComments ? "<?" + Gc(
    e.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: Ige
    })
  ) + ">" : "<!--" + e.value.replace(Rge, a) + "-->";
  function a(s) {
    return Gc(
      s,
      Object.assign({}, n.settings.characterReferences, {
        subset: Nge
      })
    );
  }
}
function Oge(e, t, r, n) {
  return "<!" + (n.settings.upperDoctype ? "DOCTYPE" : "doctype") + (n.settings.tightDoctype ? "" : " ") + "html>";
}
function od(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let n = 0, a = r.indexOf(t);
  for (; a !== -1; )
    n++, a = r.indexOf(t, a + t.length);
  return n;
}
function $H(e, t) {
  const r = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
function BH(e) {
  return e.join(" ").trim();
}
const Pge = /[ \t\n\f\r]/g;
function ty(e) {
  return typeof e == "object" ? e.type === "text" ? TL(e.value) : !1 : TL(e);
}
function TL(e) {
  return e.replace(Pge, "") === "";
}
const Si = zH(1), UH = zH(-1), Lge = [];
function zH(e) {
  return t;
  function t(r, n, a) {
    const s = r ? r.children : Lge;
    let i = (n || 0) + e, o = s[i];
    if (!a)
      for (; o && ty(o); )
        i += e, o = s[i];
    return o;
  }
}
const Mge = {}.hasOwnProperty;
function qH(e) {
  return t;
  function t(r, n, a) {
    return Mge.call(e, r.tagName) && e[r.tagName](r, n, a);
  }
}
const _N = qH({
  body: $ge,
  caption: P1,
  colgroup: P1,
  dd: qge,
  dt: zge,
  head: P1,
  html: Fge,
  li: Uge,
  optgroup: jge,
  option: Hge,
  p: Bge,
  rp: RL,
  rt: RL,
  tbody: Gge,
  td: IL,
  tfoot: Wge,
  th: IL,
  thead: Vge,
  tr: Kge
});
function P1(e, t, r) {
  const n = Si(r, t, !0);
  return !n || n.type !== "comment" && !(n.type === "text" && ty(n.value.charAt(0)));
}
function Fge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type !== "comment";
}
function $ge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type !== "comment";
}
function Bge(e, t, r) {
  const n = Si(r, t);
  return n ? n.type === "element" && (n.tagName === "address" || n.tagName === "article" || n.tagName === "aside" || n.tagName === "blockquote" || n.tagName === "details" || n.tagName === "div" || n.tagName === "dl" || n.tagName === "fieldset" || n.tagName === "figcaption" || n.tagName === "figure" || n.tagName === "footer" || n.tagName === "form" || n.tagName === "h1" || n.tagName === "h2" || n.tagName === "h3" || n.tagName === "h4" || n.tagName === "h5" || n.tagName === "h6" || n.tagName === "header" || n.tagName === "hgroup" || n.tagName === "hr" || n.tagName === "main" || n.tagName === "menu" || n.tagName === "nav" || n.tagName === "ol" || n.tagName === "p" || n.tagName === "pre" || n.tagName === "section" || n.tagName === "table" || n.tagName === "ul") : !r || // Confusing parent.
  !(r.type === "element" && (r.tagName === "a" || r.tagName === "audio" || r.tagName === "del" || r.tagName === "ins" || r.tagName === "map" || r.tagName === "noscript" || r.tagName === "video"));
}
function Uge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && n.tagName === "li";
}
function zge(e, t, r) {
  const n = Si(r, t);
  return !!(n && n.type === "element" && (n.tagName === "dt" || n.tagName === "dd"));
}
function qge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && (n.tagName === "dt" || n.tagName === "dd");
}
function RL(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && (n.tagName === "rp" || n.tagName === "rt");
}
function jge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && n.tagName === "optgroup";
}
function Hge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && (n.tagName === "option" || n.tagName === "optgroup");
}
function Vge(e, t, r) {
  const n = Si(r, t);
  return !!(n && n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot"));
}
function Gge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && (n.tagName === "tbody" || n.tagName === "tfoot");
}
function Wge(e, t, r) {
  return !Si(r, t);
}
function Kge(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && n.tagName === "tr";
}
function IL(e, t, r) {
  const n = Si(r, t);
  return !n || n.type === "element" && (n.tagName === "td" || n.tagName === "th");
}
const Yge = qH({
  body: Jge,
  colgroup: Qge,
  head: Zge,
  html: Xge,
  tbody: ebe
});
function Xge(e) {
  const t = Si(e, -1);
  return !t || t.type !== "comment";
}
function Zge(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e.children)
    if (n.type === "element" && (n.tagName === "base" || n.tagName === "title")) {
      if (t.has(n.tagName)) return !1;
      t.add(n.tagName);
    }
  const r = e.children[0];
  return !r || r.type === "element";
}
function Jge(e) {
  const t = Si(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && ty(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function Qge(e, t, r) {
  const n = UH(r, t), a = Si(e, -1, !0);
  return r && n && n.type === "element" && n.tagName === "colgroup" && _N(n, r.children.indexOf(n), r) ? !1 : !!(a && a.type === "element" && a.tagName === "col");
}
function ebe(e, t, r) {
  const n = UH(r, t), a = Si(e, -1);
  return r && n && n.type === "element" && (n.tagName === "thead" || n.tagName === "tbody") && _N(n, r.children.indexOf(n), r) ? !1 : !!(a && a.type === "element" && a.tagName === "tr");
}
const mm = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function tbe(e, t, r, n) {
  const a = n.schema, s = a.space === "svg" ? !1 : n.settings.omitOptionalTags;
  let i = a.space === "svg" ? n.settings.closeEmptyElements : n.settings.voids.includes(e.tagName.toLowerCase());
  const o = [];
  let l;
  a.space === "html" && e.tagName === "svg" && (n.schema = Eh);
  const u = rbe(n, e.properties), c = n.all(
    a.space === "html" && e.tagName === "template" ? e.content : e
  );
  return n.schema = a, c && (i = !1), (u || !s || !Yge(e, t, r)) && (o.push("<", e.tagName, u ? " " + u : ""), i && (a.space === "svg" || n.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!n.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && o.push(" "), o.push("/")), o.push(">")), o.push(c), !i && (!s || !_N(e, t, r)) && o.push("</" + e.tagName + ">"), o.join("");
}
function rbe(e, t) {
  const r = [];
  let n = -1, a;
  if (t) {
    for (a in t)
      if (t[a] !== null && t[a] !== void 0) {
        const s = nbe(e, a, t[a]);
        s && r.push(s);
      }
  }
  for (; ++n < r.length; ) {
    const s = e.settings.tightAttributes ? r[n].charAt(r[n].length - 1) : void 0;
    n !== r.length - 1 && s !== '"' && s !== "'" && (r[n] += " ");
  }
  return r.join("");
}
function nbe(e, t, r) {
  const n = DH(e.schema, t), a = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, s = e.settings.allowDangerousCharacters ? 0 : 1;
  let i = e.quote, o;
  if (n.overloadedBoolean && (r === n.attribute || r === "") ? r = !0 : (n.boolean || n.overloadedBoolean) && (typeof r != "string" || r === n.attribute || r === "") && (r = !!r), r == null || r === !1 || typeof r == "number" && Number.isNaN(r))
    return "";
  const l = Gc(
    n.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: mm.name[a][s]
    })
  );
  return r === !0 || (r = Array.isArray(r) ? (n.commaSeparated ? $H : BH)(r, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(r), e.settings.collapseEmptyAttributes && !r) ? l : (e.settings.preferUnquoted && (o = Gc(
    r,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: mm.unquoted[a][s]
    })
  )), o !== r && (e.settings.quoteSmart && od(r, i) > od(r, e.alternative) && (i = e.alternative), o = i + Gc(
    r,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (i === "'" ? mm.single : mm.double)[a][s],
      attribute: !0
    })
  ) + i), l + (o && "=" + o));
}
const ibe = ["<", "&"];
function jH(e, t, r, n) {
  return r && r.type === "element" && (r.tagName === "script" || r.tagName === "style") ? e.value : Gc(
    e.value,
    Object.assign({}, n.settings.characterReferences, {
      subset: ibe
    })
  );
}
function abe(e, t, r, n) {
  return n.settings.allowDangerousHtml ? e.value : jH(e, t, r, n);
}
function sbe(e, t, r, n) {
  return n.all(e);
}
const obe = PH("type", {
  invalid: lbe,
  unknown: ube,
  handlers: { comment: Dge, doctype: Oge, element: tbe, raw: abe, root: sbe, text: jH }
});
function lbe(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function ube(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const cbe = {}, dbe = [];
function fbe(e, t) {
  const r = t, n = r.quote || '"', a = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Invalid quote `" + n + "`, expected `'` or `\"`");
  return {
    one: pbe,
    all: hbe,
    settings: {
      omitOptionalTags: r.omitOptionalTags || !1,
      allowParseErrors: r.allowParseErrors || !1,
      allowDangerousCharacters: r.allowDangerousCharacters || !1,
      quoteSmart: r.quoteSmart || !1,
      preferUnquoted: r.preferUnquoted || !1,
      tightAttributes: r.tightAttributes || !1,
      upperDoctype: r.upperDoctype || !1,
      tightDoctype: r.tightDoctype || !1,
      bogusComments: r.bogusComments || !1,
      tightCommaSeparatedLists: r.tightCommaSeparatedLists || !1,
      tightSelfClosing: r.tightSelfClosing || !1,
      collapseEmptyAttributes: r.collapseEmptyAttributes || !1,
      allowDangerousHtml: r.allowDangerousHtml || !1,
      voids: r.voids || nge,
      characterReferences: r.characterReferences || cbe,
      closeSelfClosing: r.closeSelfClosing || !1,
      closeEmptyElements: r.closeEmptyElements || !1
    },
    schema: r.space === "svg" ? Eh : OH,
    quote: n,
    alternative: a
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function pbe(e, t, r) {
  return obe(e, t, r, this);
}
function hbe(e) {
  const t = [], r = e && e.children || dbe;
  let n = -1;
  for (; ++n < r.length; )
    t[n] = this.one(r[n], n, e);
  return t.join("");
}
function mbe(e) {
  const t = this, r = { ...t.data("settings"), ...e };
  t.compiler = n;
  function n(a) {
    return fbe(a, r);
  }
}
const Ui = Yl(/[A-Za-z]/), qi = Yl(/[\dA-Za-z]/), gbe = Yl(/[#-'*+\--9=?A-Z^-~]/);
function Vg(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const yR = Yl(/\d/), bbe = Yl(/[\dA-Fa-f]/), ybe = Yl(/[!-/:-@[-`{-~]/);
function _r(e) {
  return e !== null && e < -2;
}
function pn(e) {
  return e !== null && (e < 0 || e === 32);
}
function Yr(e) {
  return e === -2 || e === -1 || e === 32;
}
const ry = Yl(/\p{P}|\p{S}/u), ia = Yl(/\s/);
function Yl(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function vbe(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const ny = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Sbe;
    if (typeof e == "function")
      return iy(e);
    if (typeof e == "object")
      return Array.isArray(e) ? wbe(e) : xbe(e);
    if (typeof e == "string")
      return Ebe(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function wbe(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = ny(e[r]);
  return iy(n);
  function n(...a) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, a)) return !0;
    return !1;
  }
}
function xbe(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return iy(r);
  function r(n) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      n
    );
    let s;
    for (s in e)
      if (a[s] !== t[s]) return !1;
    return !0;
  }
}
function Ebe(e) {
  return iy(t);
  function t(r) {
    return r && r.type === e;
  }
}
function iy(e) {
  return t;
  function t(r, n, a) {
    return !!(_be(r) && e.call(
      this,
      r,
      typeof n == "number" ? n : void 0,
      a || void 0
    ));
  }
}
function Sbe() {
  return !0;
}
function _be(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const HH = [], kbe = !0, vR = !1, Cbe = "skip";
function VH(e, t, r, n) {
  let a;
  typeof t == "function" && typeof r != "function" ? (n = r, r = t) : a = t;
  const s = ny(a), i = n ? -1 : 1;
  o(e, void 0, [])();
  function o(l, u, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const f = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let f = HH, h, m, y;
      if ((!t || s(l, u, c[c.length - 1] || void 0)) && (f = Abe(r(l, c)), f[0] === vR))
        return f;
      if ("children" in l && l.children) {
        const b = (
          /** @type {UnistParent} */
          l
        );
        if (b.children && f[0] !== Cbe)
          for (m = (n ? b.children.length : -1) + i, y = c.concat(b); m > -1 && m < b.children.length; ) {
            const v = b.children[m];
            if (h = o(v, m, y)(), h[0] === vR)
              return h;
            m = typeof h[1] == "number" ? h[1] : m + i;
          }
      }
      return f;
    }
  }
}
function Abe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [kbe, e] : e == null ? HH : [e];
}
function Tbe(e, t, r) {
  const a = ny(r.ignore || []), s = Rbe(t);
  let i = -1;
  for (; ++i < s.length; )
    VH(e, "text", o);
  function o(u, c) {
    let d = -1, p;
    for (; ++d < c.length; ) {
      const f = c[d], h = p ? p.children : void 0;
      if (a(
        f,
        h ? h.indexOf(f) : void 0,
        p
      ))
        return;
      p = f;
    }
    if (p)
      return l(u, c);
  }
  function l(u, c) {
    const d = c[c.length - 1], p = s[i][0], f = s[i][1];
    let h = 0;
    const y = d.children.indexOf(u);
    let b = !1, v = [];
    p.lastIndex = 0;
    let x = p.exec(u.value);
    for (; x; ) {
      const _ = x.index, E = {
        index: x.index,
        input: x.input,
        stack: [...c, u]
      };
      let w = f(...x, E);
      if (typeof w == "string" && (w = w.length > 0 ? { type: "text", value: w } : void 0), w === !1 ? p.lastIndex = _ + 1 : (h !== _ && v.push({
        type: "text",
        value: u.value.slice(h, _)
      }), Array.isArray(w) ? v.push(...w) : w && v.push(w), h = _ + x[0].length, b = !0), !p.global)
        break;
      x = p.exec(u.value);
    }
    return b ? (h < u.value.length && v.push({ type: "text", value: u.value.slice(h) }), d.children.splice(y, 1, ...v)) : v = [u], y + v.length;
  }
}
function Rbe(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let n = -1;
  for (; ++n < r.length; ) {
    const a = r[n];
    t.push([Ibe(a[0]), Nbe(a[1])]);
  }
  return t;
}
function Ibe(e) {
  return typeof e == "string" ? new RegExp(vbe(e), "g") : e;
}
function Nbe(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const L1 = "phrasing", M1 = ["autolink", "link", "image", "label"];
function Dbe() {
  return {
    transforms: [Bbe],
    enter: {
      literalAutolink: Pbe,
      literalAutolinkEmail: F1,
      literalAutolinkHttp: F1,
      literalAutolinkWww: F1
    },
    exit: {
      literalAutolink: $be,
      literalAutolinkEmail: Fbe,
      literalAutolinkHttp: Lbe,
      literalAutolinkWww: Mbe
    }
  };
}
function Obe() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: L1,
        notInConstruct: M1
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: L1,
        notInConstruct: M1
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: L1,
        notInConstruct: M1
      }
    ]
  };
}
function Pbe(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function F1(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Lbe(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Mbe(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function Fbe(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function $be(e) {
  this.exit(e);
}
function Bbe(e) {
  Tbe(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Ube],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, zbe]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Ube(e, t, r, n, a) {
  let s = "";
  if (!GH(a) || (/^w/i.test(t) && (r = t + r, t = "", s = "http://"), !qbe(r)))
    return !1;
  const i = jbe(r + n);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: s + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function zbe(e, t, r, n) {
  return (
    // Not an expected previous character.
    !GH(n, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{ type: "text", value: t + "@" + r }]
    }
  );
}
function qbe(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function jbe(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], n = r.indexOf(")");
  const a = od(e, "(");
  let s = od(e, ")");
  for (; n !== -1 && a > s; )
    e += r.slice(0, n + 1), r = r.slice(n + 1), n = r.indexOf(")"), s++;
  return [e, r];
}
function GH(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || ia(r) || ry(r)) && // If it’s an email, the previous character should not be a slash.
  (!t || r !== 47);
}
function Ms(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
WH.peek = eye;
function Hbe() {
  return {
    enter: {
      gfmFootnoteDefinition: Gbe,
      gfmFootnoteDefinitionLabelString: Wbe,
      gfmFootnoteCall: Xbe,
      gfmFootnoteCallString: Zbe
    },
    exit: {
      gfmFootnoteDefinition: Ybe,
      gfmFootnoteDefinitionLabelString: Kbe,
      gfmFootnoteCall: Qbe,
      gfmFootnoteCallString: Jbe
    }
  };
}
function Vbe() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: tye, footnoteReference: WH }
  };
}
function Gbe(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Wbe() {
  this.buffer();
}
function Kbe(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.label = t, r.identifier = Ms(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function Ybe(e) {
  this.exit(e);
}
function Xbe(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Zbe() {
  this.buffer();
}
function Jbe(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.label = t, r.identifier = Ms(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function Qbe(e) {
  this.exit(e);
}
function WH(e, t, r, n) {
  const a = r.createTracker(n);
  let s = a.move("[^");
  const i = r.enter("footnoteReference"), o = r.enter("reference");
  return s += a.move(
    r.safe(r.associationId(e), {
      ...a.current(),
      before: s,
      after: "]"
    })
  ), o(), i(), s += a.move("]"), s;
}
function eye() {
  return "[";
}
function tye(e, t, r, n) {
  const a = r.createTracker(n);
  let s = a.move("[^");
  const i = r.enter("footnoteDefinition"), o = r.enter("label");
  return s += a.move(
    r.safe(r.associationId(e), {
      ...a.current(),
      before: s,
      after: "]"
    })
  ), o(), s += a.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), a.shift(4), s += a.move(
    r.indentLines(r.containerFlow(e, a.current()), rye)
  ), i(), s;
}
function rye(e, t, r) {
  return t === 0 ? e : (r ? "" : "    ") + e;
}
const nye = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
KH.peek = lye;
function iye() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: sye },
    exit: { strikethrough: oye }
  };
}
function aye() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: nye
      }
    ],
    handlers: { delete: KH }
  };
}
function sye(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function oye(e) {
  this.exit(e);
}
function KH(e, t, r, n) {
  const a = r.createTracker(n), s = r.enter("strikethrough");
  let i = a.move("~~");
  return i += r.containerPhrasing(e, {
    ...a.current(),
    before: i,
    after: "~"
  }), i += a.move("~~"), s(), i;
}
function lye() {
  return "~";
}
function uye(e) {
  return e.length;
}
function cye(e, t) {
  const r = t, n = (r.align || []).concat(), a = r.stringLength || uye, s = [], i = [], o = [], l = [];
  let u = 0, c = -1;
  for (; ++c < e.length; ) {
    const m = [], y = [];
    let b = -1;
    for (e[c].length > u && (u = e[c].length); ++b < e[c].length; ) {
      const v = dye(e[c][b]);
      if (r.alignDelimiters !== !1) {
        const x = a(v);
        y[b] = x, (l[b] === void 0 || x > l[b]) && (l[b] = x);
      }
      m.push(v);
    }
    i[c] = m, o[c] = y;
  }
  let d = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++d < u; )
      s[d] = NL(n[d]);
  else {
    const m = NL(n);
    for (; ++d < u; )
      s[d] = m;
  }
  d = -1;
  const p = [], f = [];
  for (; ++d < u; ) {
    const m = s[d];
    let y = "", b = "";
    m === 99 ? (y = ":", b = ":") : m === 108 ? y = ":" : m === 114 && (b = ":");
    let v = r.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[d] - y.length - b.length
    );
    const x = y + "-".repeat(v) + b;
    r.alignDelimiters !== !1 && (v = y.length + v + b.length, v > l[d] && (l[d] = v), f[d] = v), p[d] = x;
  }
  i.splice(1, 0, p), o.splice(1, 0, f), c = -1;
  const h = [];
  for (; ++c < i.length; ) {
    const m = i[c], y = o[c];
    d = -1;
    const b = [];
    for (; ++d < u; ) {
      const v = m[d] || "";
      let x = "", _ = "";
      if (r.alignDelimiters !== !1) {
        const E = l[d] - (y[d] || 0), w = s[d];
        w === 114 ? x = " ".repeat(E) : w === 99 ? E % 2 ? (x = " ".repeat(E / 2 + 0.5), _ = " ".repeat(E / 2 - 0.5)) : (x = " ".repeat(E / 2), _ = x) : _ = " ".repeat(E);
      }
      r.delimiterStart !== !1 && !d && b.push("|"), r.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && v === "") && (r.delimiterStart !== !1 || d) && b.push(" "), r.alignDelimiters !== !1 && b.push(x), b.push(v), r.alignDelimiters !== !1 && b.push(_), r.padding !== !1 && b.push(" "), (r.delimiterEnd !== !1 || d !== u - 1) && b.push("|");
    }
    h.push(
      r.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return h.join(`
`);
}
function dye(e) {
  return e == null ? "" : String(e);
}
function NL(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function fye(e, t, r, n) {
  const a = r.enter("blockquote"), s = r.createTracker(n);
  s.move("> "), s.shift(2);
  const i = r.indentLines(
    r.containerFlow(e, s.current()),
    pye
  );
  return a(), i;
}
function pye(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function hye(e, t) {
  return DL(e, t.inConstruct, !0) && !DL(e, t.notInConstruct, !1);
}
function DL(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let n = -1;
  for (; ++n < t.length; )
    if (e.includes(t[n]))
      return !0;
  return !1;
}
function OL(e, t, r, n) {
  let a = -1;
  for (; ++a < r.unsafe.length; )
    if (r.unsafe[a].character === `
` && hye(r.stack, r.unsafe[a]))
      return /[ \t]/.test(n.before) ? "" : " ";
  return `\\
`;
}
function mye(e, t) {
  const r = String(e);
  let n = r.indexOf(t), a = n, s = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; n !== -1; )
    n === a ? ++s > i && (i = s) : s = 1, a = n + t.length, n = r.indexOf(t, a);
  return i;
}
function gye(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function bye(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function yye(e, t, r, n) {
  const a = bye(r), s = e.value || "", i = a === "`" ? "GraveAccent" : "Tilde";
  if (gye(e, r)) {
    const d = r.enter("codeIndented"), p = r.indentLines(s, vye);
    return d(), p;
  }
  const o = r.createTracker(n), l = a.repeat(Math.max(mye(s, a) + 1, 3)), u = r.enter("codeFenced");
  let c = o.move(l);
  if (e.lang) {
    const d = r.enter(`codeFencedLang${i}`);
    c += o.move(
      r.safe(e.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = r.enter(`codeFencedMeta${i}`);
    c += o.move(" "), c += o.move(
      r.safe(e.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), s && (c += o.move(s + `
`)), c += o.move(l), u(), c;
}
function vye(e, t, r) {
  return (r ? "" : "    ") + e;
}
function kN(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function wye(e, t, r, n) {
  const a = kN(r), s = a === '"' ? "Quote" : "Apostrophe", i = r.enter("definition");
  let o = r.enter("label");
  const l = r.createTracker(n);
  let u = l.move("[");
  return u += l.move(
    r.safe(r.associationId(e), {
      before: u,
      after: "]",
      ...l.current()
    })
  ), u += l.move("]: "), o(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = r.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    r.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (o = r.enter("destinationRaw"), u += l.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = r.enter(`title${s}`), u += l.move(" " + a), u += l.move(
    r.safe(e.title, {
      before: u,
      after: a,
      ...l.current()
    })
  ), u += l.move(a), o()), i(), u;
}
function xye(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function jp(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function ld(e) {
  if (e === null || pn(e) || ia(e))
    return 1;
  if (ry(e))
    return 2;
}
function Gg(e, t, r) {
  const n = ld(e), a = ld(t);
  return n === void 0 ? a === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : n === 1 ? a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
YH.peek = Eye;
function YH(e, t, r, n) {
  const a = xye(r), s = r.enter("emphasis"), i = r.createTracker(n), o = i.move(a);
  let l = i.move(
    r.containerPhrasing(e, {
      after: a,
      before: o,
      ...i.current()
    })
  );
  const u = l.charCodeAt(0), c = Gg(
    n.before.charCodeAt(n.before.length - 1),
    u,
    a
  );
  c.inside && (l = jp(u) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), p = Gg(n.after.charCodeAt(0), d, a);
  p.inside && (l = l.slice(0, -1) + jp(d));
  const f = i.move(a);
  return s(), r.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: c.outside
  }, o + l + f;
}
function Eye(e, t, r) {
  return r.options.emphasis || "*";
}
function ay(e, t, r, n) {
  let a, s, i;
  typeof t == "function" && typeof r != "function" ? (s = void 0, i = t, a = r) : (s = t, i = r, a = n), VH(e, s, o, a);
  function o(l, u) {
    const c = u[u.length - 1], d = c ? c.children.indexOf(l) : void 0;
    return i(l, d, c);
  }
}
const Sye = {};
function CN(e, t) {
  const r = Sye, n = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, a = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return XH(e, n, a);
}
function XH(e, t, r) {
  if (_ye(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return PL(e.children, t, r);
  }
  return Array.isArray(e) ? PL(e, t, r) : "";
}
function PL(e, t, r) {
  const n = [];
  let a = -1;
  for (; ++a < e.length; )
    n[a] = XH(e[a], t, r);
  return n.join("");
}
function _ye(e) {
  return !!(e && typeof e == "object");
}
function kye(e, t) {
  let r = !1;
  return ay(e, function(n) {
    if ("value" in n && /\r?\n|\r/.test(n.value) || n.type === "break")
      return r = !0, vR;
  }), !!((!e.depth || e.depth < 3) && CN(e) && (t.options.setext || r));
}
function Cye(e, t, r, n) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), s = r.createTracker(n);
  if (kye(e, r)) {
    const c = r.enter("headingSetext"), d = r.enter("phrasing"), p = r.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), p + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size…
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(a), o = r.enter("headingAtx"), l = r.enter("phrasing");
  s.move(i + " ");
  let u = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(u) && (u = jp(u.charCodeAt(0)) + u.slice(1)), u = u ? i + " " + u : i, r.options.closeAtx && (u += " " + i), l(), o(), u;
}
ZH.peek = Aye;
function ZH(e) {
  return e.value || "";
}
function Aye() {
  return "<";
}
JH.peek = Tye;
function JH(e, t, r, n) {
  const a = kN(r), s = a === '"' ? "Quote" : "Apostrophe", i = r.enter("image");
  let o = r.enter("label");
  const l = r.createTracker(n);
  let u = l.move("![");
  return u += l.move(
    r.safe(e.alt, { before: u, after: "]", ...l.current() })
  ), u += l.move("]("), o(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = r.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    r.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (o = r.enter("destinationRaw"), u += l.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = r.enter(`title${s}`), u += l.move(" " + a), u += l.move(
    r.safe(e.title, {
      before: u,
      after: a,
      ...l.current()
    })
  ), u += l.move(a), o()), u += l.move(")"), i(), u;
}
function Tye() {
  return "!";
}
QH.peek = Rye;
function QH(e, t, r, n) {
  const a = e.referenceType, s = r.enter("imageReference");
  let i = r.enter("label");
  const o = r.createTracker(n);
  let l = o.move("![");
  const u = r.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(u + "]["), i();
  const c = r.stack;
  r.stack = [], i = r.enter("reference");
  const d = r.safe(r.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), r.stack = c, s(), a === "full" || !u || u !== d ? l += o.move(d + "]") : a === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function Rye() {
  return "!";
}
eV.peek = Iye;
function eV(e, t, r) {
  let n = e.value || "", a = "`", s = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(n); )
    a += "`";
  for (/[^ \r\n]/.test(n) && (/^[ \r\n]/.test(n) && /[ \r\n]$/.test(n) || /^`|`$/.test(n)) && (n = " " + n + " "); ++s < r.unsafe.length; ) {
    const i = r.unsafe[s], o = r.compilePattern(i);
    let l;
    if (i.atBreak)
      for (; l = o.exec(n); ) {
        let u = l.index;
        n.charCodeAt(u) === 10 && n.charCodeAt(u - 1) === 13 && u--, n = n.slice(0, u) + " " + n.slice(l.index + 1);
      }
  }
  return a + n + a;
}
function Iye() {
  return "`";
}
function tV(e, t) {
  const r = CN(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
rV.peek = Nye;
function rV(e, t, r, n) {
  const a = kN(r), s = a === '"' ? "Quote" : "Apostrophe", i = r.createTracker(n);
  let o, l;
  if (tV(e, r)) {
    const c = r.stack;
    r.stack = [], o = r.enter("autolink");
    let d = i.move("<");
    return d += i.move(
      r.containerPhrasing(e, {
        before: d,
        after: ">",
        ...i.current()
      })
    ), d += i.move(">"), o(), r.stack = c, d;
  }
  o = r.enter("link"), l = r.enter("label");
  let u = i.move("[");
  return u += i.move(
    r.containerPhrasing(e, {
      before: u,
      after: "](",
      ...i.current()
    })
  ), u += i.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = r.enter("destinationLiteral"), u += i.move("<"), u += i.move(
    r.safe(e.url, { before: u, after: ">", ...i.current() })
  ), u += i.move(">")) : (l = r.enter("destinationRaw"), u += i.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), l(), e.title && (l = r.enter(`title${s}`), u += i.move(" " + a), u += i.move(
    r.safe(e.title, {
      before: u,
      after: a,
      ...i.current()
    })
  ), u += i.move(a), l()), u += i.move(")"), o(), u;
}
function Nye(e, t, r) {
  return tV(e, r) ? "<" : "[";
}
nV.peek = Dye;
function nV(e, t, r, n) {
  const a = e.referenceType, s = r.enter("linkReference");
  let i = r.enter("label");
  const o = r.createTracker(n);
  let l = o.move("[");
  const u = r.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(u + "]["), i();
  const c = r.stack;
  r.stack = [], i = r.enter("reference");
  const d = r.safe(r.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), r.stack = c, s(), a === "full" || !u || u !== d ? l += o.move(d + "]") : a === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function Dye() {
  return "[";
}
function AN(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Oye(e) {
  const t = AN(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error(
      "Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (r === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different"
    );
  return r;
}
function Pye(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function iV(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Lye(e, t, r, n) {
  const a = r.enter("list"), s = r.bulletCurrent;
  let i = e.ordered ? Pye(r) : AN(r);
  const o = e.ordered ? i === "." ? ")" : "." : Oye(r);
  let l = t && r.bulletLastUsed ? i === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (l = !0), iV(r) === i && c
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const p = e.children[d];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (i = o), r.bulletCurrent = i;
  const u = r.containerFlow(e, n);
  return r.bulletLastUsed = i, r.bulletCurrent = s, a(), u;
}
function Mye(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Fye(e, t, r, n) {
  const a = Mye(r);
  let s = r.bulletCurrent || AN(r);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let i = s.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = r.createTracker(n);
  o.move(s + " ".repeat(i - s.length)), o.shift(i);
  const l = r.enter("listItem"), u = r.indentLines(
    r.containerFlow(e, o.current()),
    c
  );
  return l(), u;
  function c(d, p, f) {
    return p ? (f ? "" : " ".repeat(i)) + d : (f ? s : s + " ".repeat(i - s.length)) + d;
  }
}
function $ye(e, t, r, n) {
  const a = r.enter("paragraph"), s = r.enter("phrasing"), i = r.containerPhrasing(e, n);
  return s(), a(), i;
}
const Bye = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  ny([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Uye(e, t, r, n) {
  return (e.children.some(function(i) {
    return Bye(i);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, n);
}
function zye(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
aV.peek = qye;
function aV(e, t, r, n) {
  const a = zye(r), s = r.enter("strong"), i = r.createTracker(n), o = i.move(a + a);
  let l = i.move(
    r.containerPhrasing(e, {
      after: a,
      before: o,
      ...i.current()
    })
  );
  const u = l.charCodeAt(0), c = Gg(
    n.before.charCodeAt(n.before.length - 1),
    u,
    a
  );
  c.inside && (l = jp(u) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), p = Gg(n.after.charCodeAt(0), d, a);
  p.inside && (l = l.slice(0, -1) + jp(d));
  const f = i.move(a + a);
  return s(), r.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: c.outside
  }, o + l + f;
}
function qye(e, t, r) {
  return r.options.strong || "*";
}
function jye(e, t, r, n) {
  return r.safe(e.value, n);
}
function Hye(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Vye(e, t, r) {
  const n = (iV(r) + (r.options.ruleSpaces ? " " : "")).repeat(Hye(r));
  return r.options.ruleSpaces ? n.slice(0, -1) : n;
}
const sV = {
  blockquote: fye,
  break: OL,
  code: yye,
  definition: wye,
  emphasis: YH,
  hardBreak: OL,
  heading: Cye,
  html: ZH,
  image: JH,
  imageReference: QH,
  inlineCode: eV,
  link: rV,
  linkReference: nV,
  list: Lye,
  listItem: Fye,
  paragraph: $ye,
  root: Uye,
  strong: aV,
  text: jye,
  thematicBreak: Vye
}, LL = document.createElement("i");
function Hp(e) {
  const t = "&" + e + ";";
  LL.innerHTML = t;
  const r = LL.textContent;
  return r.charCodeAt(r.length - 1) === 59 && e !== "semi" || r === t ? !1 : r;
}
function oV(e, t) {
  const r = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    r < 9 || r === 11 || r > 13 && r < 32 || // Control character (DEL) of C0, and C1 controls.
    r > 126 && r < 160 || // Lone high surrogates and low surrogates.
    r > 55295 && r < 57344 || // Noncharacters.
    r > 64975 && r < 65008 || /* eslint-disable no-bitwise */
    (r & 65535) === 65535 || (r & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    r > 1114111 ? "�" : String.fromCodePoint(r)
  );
}
const Gye = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Wye(e) {
  return e.replace(Gye, Kye);
}
function Kye(e, t, r) {
  if (t)
    return t;
  if (r.charCodeAt(0) === 35) {
    const a = r.charCodeAt(1), s = a === 120 || a === 88;
    return oV(r.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Hp(r) || e;
}
function Yye() {
  return {
    enter: {
      table: Xye,
      tableData: ML,
      tableHeader: ML,
      tableRow: Jye
    },
    exit: {
      codeText: Qye,
      table: Zye,
      tableData: $1,
      tableHeader: $1,
      tableRow: $1
    }
  };
}
function Xye(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(r) {
        return r === "none" ? null : r;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Zye(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Jye(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function $1(e) {
  this.exit(e);
}
function ML(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Qye(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, eve));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function eve(e, t) {
  return t === "|" ? t : e;
}
function tve(e) {
  const t = e, r = t.tableCellPadding, n = t.tablePipeAlign, a = t.stringLength, s = r ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: i,
      tableCell: l,
      tableRow: o
    }
  };
  function i(f, h, m, y) {
    return u(c(f, m, y), f.align);
  }
  function o(f, h, m, y) {
    const b = d(f, m, y), v = u([b]);
    return v.slice(0, v.indexOf(`
`));
  }
  function l(f, h, m, y) {
    const b = m.enter("tableCell"), v = m.enter("phrasing"), x = m.containerPhrasing(f, {
      ...y,
      before: s,
      after: s
    });
    return v(), b(), x;
  }
  function u(f, h) {
    return cye(f, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function c(f, h, m) {
    const y = f.children;
    let b = -1;
    const v = [], x = h.enter("table");
    for (; ++b < y.length; )
      v[b] = d(y[b], h, m);
    return x(), v;
  }
  function d(f, h, m) {
    const y = f.children;
    let b = -1;
    const v = [], x = h.enter("tableRow");
    for (; ++b < y.length; )
      v[b] = l(y[b], f, h, m);
    return x(), v;
  }
  function p(f, h, m) {
    let y = sV.inlineCode(f, h, m);
    return m.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function rve() {
  return {
    exit: {
      taskListCheckValueChecked: FL,
      taskListCheckValueUnchecked: FL,
      paragraph: ive
    }
  };
}
function nve() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: ave }
  };
}
function FL(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function ive(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const n = r.children[0];
    if (n && n.type === "text") {
      const a = t.children;
      let s = -1, i;
      for (; ++s < a.length; ) {
        const o = a[s];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === r && (n.value = n.value.slice(1), n.value.length === 0 ? r.children.shift() : r.position && n.position && typeof n.position.start.offset == "number" && (n.position.start.column++, n.position.start.offset++, r.position.start = Object.assign({}, n.position.start)));
    }
  }
  this.exit(e);
}
function ave(e, t, r, n) {
  const a = e.children[0], s = typeof e.checked == "boolean" && a && a.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = r.createTracker(n);
  s && o.move(i);
  let l = sV.listItem(e, t, r, {
    ...n,
    ...o.current()
  });
  return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l;
  function u(c) {
    return c + i;
  }
}
function sve() {
  return [
    Dbe(),
    Hbe(),
    iye(),
    Yye(),
    rve()
  ];
}
function ove(e) {
  return {
    extensions: [
      Obe(),
      Vbe(),
      aye(),
      tve(e),
      nve()
    ]
  };
}
function qa(e, t, r, n) {
  const a = e.length;
  let s = 0, i;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, r = r > 0 ? r : 0, n.length < 1e4)
    i = Array.from(n), i.unshift(t, r), e.splice(...i);
  else
    for (r && e.splice(t, r); s < n.length; )
      i = n.slice(s, s + 1e4), i.unshift(t, 0), e.splice(...i), s += 1e4, t += 1e4;
}
function es(e, t) {
  return e.length > 0 ? (qa(e, e.length, 0, t), e) : t;
}
const $L = {}.hasOwnProperty;
function TN(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    lve(t, e[r]);
  return t;
}
function lve(e, t) {
  let r;
  for (r in t) {
    const a = ($L.call(e, r) ? e[r] : void 0) || (e[r] = {}), s = t[r];
    let i;
    if (s)
      for (i in s) {
        $L.call(a, i) || (a[i] = []);
        const o = s[i];
        uve(
          // @ts-expect-error Looks like a list.
          a[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function uve(e, t) {
  let r = -1;
  const n = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : n).push(t[r]);
  qa(e, 0, 0, n);
}
const cve = {
  tokenize: gve,
  partial: !0
}, lV = {
  tokenize: bve,
  partial: !0
}, uV = {
  tokenize: yve,
  partial: !0
}, cV = {
  tokenize: vve,
  partial: !0
}, dve = {
  tokenize: wve,
  partial: !0
}, dV = {
  name: "wwwAutolink",
  tokenize: hve,
  previous: pV
}, fV = {
  name: "protocolAutolink",
  tokenize: mve,
  previous: hV
}, Xo = {
  name: "emailAutolink",
  tokenize: pve,
  previous: mV
}, go = {};
function fve() {
  return {
    text: go
  };
}
let uu = 48;
for (; uu < 123; )
  go[uu] = Xo, uu++, uu === 58 ? uu = 65 : uu === 91 && (uu = 97);
go[43] = Xo;
go[45] = Xo;
go[46] = Xo;
go[95] = Xo;
go[72] = [Xo, fV];
go[104] = [Xo, fV];
go[87] = [Xo, dV];
go[119] = [Xo, dV];
function pve(e, t, r) {
  const n = this;
  let a, s;
  return i;
  function i(d) {
    return !wR(d) || !mV.call(n, n.previous) || RN(n.events) ? r(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return wR(d) ? (e.consume(d), o) : d === 64 ? (e.consume(d), l) : r(d);
  }
  function l(d) {
    return d === 46 ? e.check(dve, c, u)(d) : d === 45 || d === 95 || qi(d) ? (s = !0, e.consume(d), l) : c(d);
  }
  function u(d) {
    return e.consume(d), a = !0, l;
  }
  function c(d) {
    return s && a && Ui(n.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : r(d);
  }
}
function hve(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return i !== 87 && i !== 119 || !pV.call(n, n.previous) || RN(n.events) ? r(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(cve, e.attempt(lV, e.attempt(uV, s), r), r)(i));
  }
  function s(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function mve(e, t, r) {
  const n = this;
  let a = "", s = !1;
  return i;
  function i(d) {
    return (d === 72 || d === 104) && hV.call(n, n.previous) && !RN(n.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(d), e.consume(d), o) : r(d);
  }
  function o(d) {
    if (Ui(d) && a.length < 5)
      return a += String.fromCodePoint(d), e.consume(d), o;
    if (d === 58) {
      const p = a.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(d), l;
    }
    return r(d);
  }
  function l(d) {
    return d === 47 ? (e.consume(d), s ? u : (s = !0, l)) : r(d);
  }
  function u(d) {
    return d === null || Vg(d) || pn(d) || ia(d) || ry(d) ? r(d) : e.attempt(lV, e.attempt(uV, c), r)(d);
  }
  function c(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function gve(e, t, r) {
  let n = 0;
  return a;
  function a(i) {
    return (i === 87 || i === 119) && n < 3 ? (n++, e.consume(i), a) : i === 46 && n === 3 ? (e.consume(i), s) : r(i);
  }
  function s(i) {
    return i === null ? r(i) : t(i);
  }
}
function bve(e, t, r) {
  let n, a, s;
  return i;
  function i(u) {
    return u === 46 || u === 95 ? e.check(cV, l, o)(u) : u === null || pn(u) || ia(u) || u !== 45 && ry(u) ? l(u) : (s = !0, e.consume(u), i);
  }
  function o(u) {
    return u === 95 ? n = !0 : (a = n, n = void 0), e.consume(u), i;
  }
  function l(u) {
    return a || n || !s ? r(u) : t(u);
  }
}
function yve(e, t) {
  let r = 0, n = 0;
  return a;
  function a(i) {
    return i === 40 ? (r++, e.consume(i), a) : i === 41 && n < r ? s(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(cV, t, s)(i) : i === null || pn(i) || ia(i) ? t(i) : (e.consume(i), a);
  }
  function s(i) {
    return i === 41 && n++, e.consume(i), a;
  }
}
function vve(e, t, r) {
  return n;
  function n(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), n) : o === 38 ? (e.consume(o), s) : o === 93 ? (e.consume(o), a) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || pn(o) || ia(o) ? t(o) : r(o)
    );
  }
  function a(o) {
    return o === null || o === 40 || o === 91 || pn(o) || ia(o) ? t(o) : n(o);
  }
  function s(o) {
    return Ui(o) ? i(o) : r(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), n) : Ui(o) ? (e.consume(o), i) : r(o);
  }
}
function wve(e, t, r) {
  return n;
  function n(s) {
    return e.consume(s), a;
  }
  function a(s) {
    return qi(s) ? r(s) : t(s);
  }
}
function pV(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || pn(e);
}
function hV(e) {
  return !Ui(e);
}
function mV(e) {
  return !(e === 47 || wR(e));
}
function wR(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || qi(e);
}
function RN(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const n = e[t][1];
    if ((n.type === "labelLink" || n.type === "labelImage") && !n._balanced) {
      r = !0;
      break;
    }
    if (n._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
function Rd(e) {
  const t = [];
  let r = -1, n = 0, a = 0;
  for (; ++r < e.length; ) {
    const s = e.charCodeAt(r);
    let i = "";
    if (s === 37 && qi(e.charCodeAt(r + 1)) && qi(e.charCodeAt(r + 2)))
      a = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (i = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const o = e.charCodeAt(r + 1);
      s < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(s, o), a = 1) : i = "�";
    } else
      i = String.fromCharCode(s);
    i && (t.push(e.slice(n, r), encodeURIComponent(i)), n = r + a + 1, i = ""), a && (r += a, a = 0);
  }
  return t.join("") + e.slice(n);
}
function sy(e, t, r) {
  const n = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const s = e[a].resolveAll;
    s && !n.includes(s) && (t = s(t, r), n.push(s));
  }
  return t;
}
const xR = {
  name: "attention",
  resolveAll: xve,
  tokenize: Eve
};
function xve(e, t) {
  let r = -1, n, a, s, i, o, l, u, c;
  for (; ++r < e.length; )
    if (e[r][0] === "enter" && e[r][1].type === "attentionSequence" && e[r][1]._close) {
      for (n = r; n--; )
        if (e[n][0] === "exit" && e[n][1].type === "attentionSequence" && e[n][1]._open && // If the markers are the same:
        t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)) {
          if ((e[n][1]._close || e[r][1]._open) && (e[r][1].end.offset - e[r][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[r][1].end.offset - e[r][1].start.offset) % 3))
            continue;
          l = e[n][1].end.offset - e[n][1].start.offset > 1 && e[r][1].end.offset - e[r][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...e[n][1].end
          }, p = {
            ...e[r][1].start
          };
          BL(d, -l), BL(p, l), i = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...e[n][1].end
            }
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[r][1].start
            },
            end: p
          }, s = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[n][1].end
            },
            end: {
              ...e[r][1].start
            }
          }, a = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...i.start
            },
            end: {
              ...o.end
            }
          }, e[n][1].end = {
            ...i.start
          }, e[r][1].start = {
            ...o.end
          }, u = [], e[n][1].end.offset - e[n][1].start.offset && (u = es(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])), u = es(u, [["enter", a, t], ["enter", i, t], ["exit", i, t], ["enter", s, t]]), u = es(u, sy(t.parser.constructs.insideSpan.null, e.slice(n + 1, r), t)), u = es(u, [["exit", s, t], ["enter", o, t], ["exit", o, t], ["exit", a, t]]), e[r][1].end.offset - e[r][1].start.offset ? (c = 2, u = es(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])) : c = 0, qa(e, n - 1, r - n + 3, u), r = n + u.length - c - 2;
          break;
        }
    }
  for (r = -1; ++r < e.length; )
    e[r][1].type === "attentionSequence" && (e[r][1].type = "data");
  return e;
}
function Eve(e, t) {
  const r = this.parser.constructs.attentionMarkers.null, n = this.previous, a = ld(n);
  let s;
  return i;
  function i(l) {
    return s = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === s)
      return e.consume(l), o;
    const u = e.exit("attentionSequence"), c = ld(l), d = !c || c === 2 && a || r.includes(l), p = !a || a === 2 && c || r.includes(n);
    return u._open = !!(s === 42 ? d : d && (a || !p)), u._close = !!(s === 42 ? p : p && (c || !d)), t(l);
  }
}
function BL(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Sve = {
  name: "autolink",
  tokenize: _ve
};
function _ve(e, t, r) {
  let n = 0;
  return a;
  function a(f) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(f) {
    return Ui(f) ? (e.consume(f), i) : f === 64 ? r(f) : u(f);
  }
  function i(f) {
    return f === 43 || f === 45 || f === 46 || qi(f) ? (n = 1, o(f)) : u(f);
  }
  function o(f) {
    return f === 58 ? (e.consume(f), n = 0, l) : (f === 43 || f === 45 || f === 46 || qi(f)) && n++ < 32 ? (e.consume(f), o) : (n = 0, u(f));
  }
  function l(f) {
    return f === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : f === null || f === 32 || f === 60 || Vg(f) ? r(f) : (e.consume(f), l);
  }
  function u(f) {
    return f === 64 ? (e.consume(f), c) : gbe(f) ? (e.consume(f), u) : r(f);
  }
  function c(f) {
    return qi(f) ? d(f) : r(f);
  }
  function d(f) {
    return f === 46 ? (e.consume(f), n = 0, c) : f === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(f);
  }
  function p(f) {
    if ((f === 45 || qi(f)) && n++ < 63) {
      const h = f === 45 ? p : d;
      return e.consume(f), h;
    }
    return r(f);
  }
}
function on(e, t, r, n) {
  const a = n ? n - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return i;
  function i(l) {
    return Yr(l) ? (e.enter(r), o(l)) : t(l);
  }
  function o(l) {
    return Yr(l) && s++ < a ? (e.consume(l), o) : (e.exit(r), t(l));
  }
}
const Id = {
  partial: !0,
  tokenize: kve
};
function kve(e, t, r) {
  return n;
  function n(s) {
    return Yr(s) ? on(e, a, "linePrefix")(s) : a(s);
  }
  function a(s) {
    return s === null || _r(s) ? t(s) : r(s);
  }
}
const gV = {
  continuation: {
    tokenize: Ave
  },
  exit: Tve,
  name: "blockQuote",
  tokenize: Cve
};
function Cve(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    if (i === 62) {
      const o = n.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), s;
    }
    return r(i);
  }
  function s(i) {
    return Yr(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function Ave(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return Yr(i) ? on(e, s, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) : s(i);
  }
  function s(i) {
    return e.attempt(gV, t, r)(i);
  }
}
function Tve(e) {
  e.exit("blockQuote");
}
const bV = {
  name: "characterEscape",
  tokenize: Rve
};
function Rve(e, t, r) {
  return n;
  function n(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), a;
  }
  function a(s) {
    return ybe(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : r(s);
  }
}
const yV = {
  name: "characterReference",
  tokenize: Ive
};
function Ive(e, t, r) {
  const n = this;
  let a = 0, s, i;
  return o;
  function o(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), s = 31, i = qi, c(d));
  }
  function u(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, i = bbe, c) : (e.enter("characterReferenceValue"), s = 7, i = yR, c(d));
  }
  function c(d) {
    if (d === 59 && a) {
      const p = e.exit("characterReferenceValue");
      return i === qi && !Hp(n.sliceSerialize(p)) ? r(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(d) && a++ < s ? (e.consume(d), c) : r(d);
  }
}
const UL = {
  partial: !0,
  tokenize: Dve
}, zL = {
  concrete: !0,
  name: "codeFenced",
  tokenize: Nve
};
function Nve(e, t, r) {
  const n = this, a = {
    partial: !0,
    tokenize: E
  };
  let s = 0, i = 0, o;
  return l;
  function l(w) {
    return u(w);
  }
  function u(w) {
    const C = n.events[n.events.length - 1];
    return s = C && C[1].type === "linePrefix" ? C[2].sliceSerialize(C[1], !0).length : 0, o = w, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(w);
  }
  function c(w) {
    return w === o ? (i++, e.consume(w), c) : i < 3 ? r(w) : (e.exit("codeFencedFenceSequence"), Yr(w) ? on(e, d, "whitespace")(w) : d(w));
  }
  function d(w) {
    return w === null || _r(w) ? (e.exit("codeFencedFence"), n.interrupt ? t(w) : e.check(UL, m, _)(w)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(w));
  }
  function p(w) {
    return w === null || _r(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(w)) : Yr(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), on(e, f, "whitespace")(w)) : w === 96 && w === o ? r(w) : (e.consume(w), p);
  }
  function f(w) {
    return w === null || _r(w) ? d(w) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(w));
  }
  function h(w) {
    return w === null || _r(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(w)) : w === 96 && w === o ? r(w) : (e.consume(w), h);
  }
  function m(w) {
    return e.attempt(a, _, y)(w);
  }
  function y(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), b;
  }
  function b(w) {
    return s > 0 && Yr(w) ? on(e, v, "linePrefix", s + 1)(w) : v(w);
  }
  function v(w) {
    return w === null || _r(w) ? e.check(UL, m, _)(w) : (e.enter("codeFlowValue"), x(w));
  }
  function x(w) {
    return w === null || _r(w) ? (e.exit("codeFlowValue"), v(w)) : (e.consume(w), x);
  }
  function _(w) {
    return e.exit("codeFenced"), t(w);
  }
  function E(w, C, k) {
    let S = 0;
    return B;
    function B(q) {
      return w.enter("lineEnding"), w.consume(q), w.exit("lineEnding"), U;
    }
    function U(q) {
      return w.enter("codeFencedFence"), Yr(q) ? on(w, N, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(q) : N(q);
    }
    function N(q) {
      return q === o ? (w.enter("codeFencedFenceSequence"), O(q)) : k(q);
    }
    function O(q) {
      return q === o ? (S++, w.consume(q), O) : S >= i ? (w.exit("codeFencedFenceSequence"), Yr(q) ? on(w, I, "whitespace")(q) : I(q)) : k(q);
    }
    function I(q) {
      return q === null || _r(q) ? (w.exit("codeFencedFence"), C(q)) : k(q);
    }
  }
}
function Dve(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return i === null ? r(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), s);
  }
  function s(i) {
    return n.parser.lazy[n.now().line] ? r(i) : t(i);
  }
}
const B1 = {
  name: "codeIndented",
  tokenize: Pve
}, Ove = {
  partial: !0,
  tokenize: Lve
};
function Pve(e, t, r) {
  const n = this;
  return a;
  function a(u) {
    return e.enter("codeIndented"), on(e, s, "linePrefix", 5)(u);
  }
  function s(u) {
    const c = n.events[n.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? i(u) : r(u);
  }
  function i(u) {
    return u === null ? l(u) : _r(u) ? e.attempt(Ove, i, l)(u) : (e.enter("codeFlowValue"), o(u));
  }
  function o(u) {
    return u === null || _r(u) ? (e.exit("codeFlowValue"), i(u)) : (e.consume(u), o);
  }
  function l(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function Lve(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return n.parser.lazy[n.now().line] ? r(i) : _r(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : on(e, s, "linePrefix", 5)(i);
  }
  function s(i) {
    const o = n.events[n.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : _r(i) ? a(i) : r(i);
  }
}
const Mve = {
  name: "codeText",
  previous: $ve,
  resolve: Fve,
  tokenize: Bve
};
function Fve(e) {
  let t = e.length - 4, r = 3, n, a;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (n = r; ++n < t; )
      if (e[n][1].type === "codeTextData") {
        e[r][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (n = r - 1, t++; ++n <= t; )
    a === void 0 ? n !== t && e[n][1].type !== "lineEnding" && (a = n) : (n === t || e[n][1].type === "lineEnding") && (e[a][1].type = "codeTextData", n !== a + 2 && (e[a][1].end = e[n - 1][1].end, e.splice(a + 2, n - a - 2), t -= n - a - 2, n = a + 2), a = void 0);
  return e;
}
function $ve(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Bve(e, t, r) {
  let n = 0, a, s;
  return i;
  function i(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (e.consume(d), n++, o) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? r(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (s = e.enter("codeTextSequence"), a = 0, c(d)) : _r(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(d));
  }
  function u(d) {
    return d === null || d === 32 || d === 96 || _r(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), u);
  }
  function c(d) {
    return d === 96 ? (e.consume(d), a++, c) : a === n ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (s.type = "codeTextData", u(d));
  }
}
class Uve {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, r) {
    const n = r ?? Number.POSITIVE_INFINITY;
    return n < this.left.length ? this.left.slice(t, n) : t > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - n + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, r, n) {
    const a = r || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - a, Number.POSITIVE_INFINITY);
    return n && hf(this.left, n), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), hf(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), hf(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const r = this.left.splice(t, Number.POSITIVE_INFINITY);
        hf(this.right, r.reverse());
      } else {
        const r = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        hf(this.left, r.reverse());
      }
  }
}
function hf(e, t) {
  let r = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; r < t.length; )
      e.push(...t.slice(r, r + 1e4)), r += 1e4;
}
function vV(e) {
  const t = {};
  let r = -1, n, a, s, i, o, l, u;
  const c = new Uve(e);
  for (; ++r < c.length; ) {
    for (; r in t; )
      r = t[r];
    if (n = c.get(r), r && n[1].type === "chunkFlow" && c.get(r - 1)[1].type === "listItemPrefix" && (l = n[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content"))
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++);
    if (n[0] === "enter")
      n[1].contentType && (Object.assign(t, zve(c, r)), r = t[r], u = !0);
    else if (n[1]._container) {
      for (s = r, a = void 0; s-- && (i = c.get(s), i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (a && (c.get(a)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", a = s);
      a && (n[1].end = {
        ...c.get(a)[1].start
      }, o = c.slice(a, r), o.unshift(n), c.splice(a, r - a + 1, o));
    }
  }
  return qa(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function zve(e, t) {
  const r = e.get(t)[1], n = e.get(t)[2];
  let a = t - 1;
  const s = [], i = r._tokenizer || n.parser[r.contentType](r.start), o = i.events, l = [], u = {};
  let c, d, p = -1, f = r, h = 0, m = 0;
  const y = [m];
  for (; f; ) {
    for (; e.get(++a)[1] !== f; )
      ;
    s.push(a), f._tokenizer || (c = n.sliceStream(f), f.next || c.push(null), d && i.defineSkip(f.start), f._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(c), f._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next;
  }
  for (f = r; ++p < o.length; )
    // Find a void token that includes a break.
    o[p][0] === "exit" && o[p - 1][0] === "enter" && o[p][1].type === o[p - 1][1].type && o[p][1].start.line !== o[p][1].end.line && (m = p + 1, y.push(m), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (i.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : y.pop(), p = y.length; p--; ) {
    const b = o.slice(y[p], y[p + 1]), v = s.pop();
    l.push([v, v + b.length - 1]), e.splice(v, 2, b);
  }
  for (l.reverse(), p = -1; ++p < l.length; )
    u[h + l[p][0]] = h + l[p][1], h += l[p][1] - l[p][0] - 1;
  return u;
}
const qve = {
  resolve: Hve,
  tokenize: Vve
}, jve = {
  partial: !0,
  tokenize: Gve
};
function Hve(e) {
  return vV(e), e;
}
function Vve(e, t) {
  let r;
  return n;
  function n(o) {
    return e.enter("content"), r = e.enter("chunkContent", {
      contentType: "content"
    }), a(o);
  }
  function a(o) {
    return o === null ? s(o) : _r(o) ? e.check(jve, i, s)(o) : (e.consume(o), a);
  }
  function s(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), r.next = e.enter("chunkContent", {
      contentType: "content",
      previous: r
    }), r = r.next, a;
  }
}
function Gve(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), on(e, s, "linePrefix");
  }
  function s(i) {
    if (i === null || _r(i))
      return r(i);
    const o = n.events[n.events.length - 1];
    return !n.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(n.parser.constructs.flow, r, t)(i);
  }
}
function wV(e, t, r, n, a, s, i, o, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(b) {
    return b === 60 ? (e.enter(n), e.enter(a), e.enter(s), e.consume(b), e.exit(s), p) : b === null || b === 32 || b === 41 || Vg(b) ? r(b) : (e.enter(n), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function p(b) {
    return b === 62 ? (e.enter(s), e.consume(b), e.exit(s), e.exit(a), e.exit(n), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), f(b));
  }
  function f(b) {
    return b === 62 ? (e.exit("chunkString"), e.exit(o), p(b)) : b === null || b === 60 || _r(b) ? r(b) : (e.consume(b), b === 92 ? h : f);
  }
  function h(b) {
    return b === 60 || b === 62 || b === 92 ? (e.consume(b), f) : f(b);
  }
  function m(b) {
    return !c && (b === null || b === 41 || pn(b)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(n), t(b)) : c < u && b === 40 ? (e.consume(b), c++, m) : b === 41 ? (e.consume(b), c--, m) : b === null || b === 32 || b === 40 || Vg(b) ? r(b) : (e.consume(b), b === 92 ? y : m);
  }
  function y(b) {
    return b === 40 || b === 41 || b === 92 ? (e.consume(b), m) : m(b);
  }
}
function xV(e, t, r, n, a, s) {
  const i = this;
  let o = 0, l;
  return u;
  function u(f) {
    return e.enter(n), e.enter(a), e.consume(f), e.exit(a), e.enter(s), c;
  }
  function c(f) {
    return o > 999 || f === null || f === 91 || f === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? r(f) : f === 93 ? (e.exit(s), e.enter(a), e.consume(f), e.exit(a), e.exit(n), t) : _r(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), d(f));
  }
  function d(f) {
    return f === null || f === 91 || f === 93 || _r(f) || o++ > 999 ? (e.exit("chunkString"), c(f)) : (e.consume(f), l || (l = !Yr(f)), f === 92 ? p : d);
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), o++, d) : d(f);
  }
}
function EV(e, t, r, n, a, s) {
  let i;
  return o;
  function o(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(n), e.enter(a), e.consume(p), e.exit(a), i = p === 40 ? 41 : p, l) : r(p);
  }
  function l(p) {
    return p === i ? (e.enter(a), e.consume(p), e.exit(a), e.exit(n), t) : (e.enter(s), u(p));
  }
  function u(p) {
    return p === i ? (e.exit(s), l(i)) : p === null ? r(p) : _r(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), on(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(p));
  }
  function c(p) {
    return p === i || p === null || _r(p) ? (e.exit("chunkString"), u(p)) : (e.consume(p), p === 92 ? d : c);
  }
  function d(p) {
    return p === i || p === 92 ? (e.consume(p), c) : c(p);
  }
}
function Qf(e, t) {
  let r;
  return n;
  function n(a) {
    return _r(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), r = !0, n) : Yr(a) ? on(e, n, r ? "linePrefix" : "lineSuffix")(a) : t(a);
  }
}
const Wve = {
  name: "definition",
  tokenize: Yve
}, Kve = {
  partial: !0,
  tokenize: Xve
};
function Yve(e, t, r) {
  const n = this;
  let a;
  return s;
  function s(f) {
    return e.enter("definition"), i(f);
  }
  function i(f) {
    return xV.call(
      n,
      e,
      o,
      // Note: we don’t need to reset the way `markdown-rs` does.
      r,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function o(f) {
    return a = Ms(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)), f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), l) : r(f);
  }
  function l(f) {
    return pn(f) ? Qf(e, u)(f) : u(f);
  }
  function u(f) {
    return wV(
      e,
      c,
      // Note: we don’t need to reset the way `markdown-rs` does.
      r,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function c(f) {
    return e.attempt(Kve, d, d)(f);
  }
  function d(f) {
    return Yr(f) ? on(e, p, "whitespace")(f) : p(f);
  }
  function p(f) {
    return f === null || _r(f) ? (e.exit("definition"), n.parser.defined.push(a), t(f)) : r(f);
  }
}
function Xve(e, t, r) {
  return n;
  function n(o) {
    return pn(o) ? Qf(e, a)(o) : r(o);
  }
  function a(o) {
    return EV(e, s, r, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function s(o) {
    return Yr(o) ? on(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || _r(o) ? t(o) : r(o);
  }
}
const Zve = {
  name: "hardBreakEscape",
  tokenize: Jve
};
function Jve(e, t, r) {
  return n;
  function n(s) {
    return e.enter("hardBreakEscape"), e.consume(s), a;
  }
  function a(s) {
    return _r(s) ? (e.exit("hardBreakEscape"), t(s)) : r(s);
  }
}
const Qve = {
  name: "headingAtx",
  resolve: e0e,
  tokenize: t0e
};
function e0e(e, t) {
  let r = e.length - 2, n = 3, a, s;
  return e[n][1].type === "whitespace" && (n += 2), r - 2 > n && e[r][1].type === "whitespace" && (r -= 2), e[r][1].type === "atxHeadingSequence" && (n === r - 1 || r - 4 > n && e[r - 2][1].type === "whitespace") && (r -= n + 1 === r ? 2 : 4), r > n && (a = {
    type: "atxHeadingText",
    start: e[n][1].start,
    end: e[r][1].end
  }, s = {
    type: "chunkText",
    start: e[n][1].start,
    end: e[r][1].end,
    contentType: "text"
  }, qa(e, n, r - n + 1, [["enter", a, t], ["enter", s, t], ["exit", s, t], ["exit", a, t]])), e;
}
function t0e(e, t, r) {
  let n = 0;
  return a;
  function a(c) {
    return e.enter("atxHeading"), s(c);
  }
  function s(c) {
    return e.enter("atxHeadingSequence"), i(c);
  }
  function i(c) {
    return c === 35 && n++ < 6 ? (e.consume(c), i) : c === null || pn(c) ? (e.exit("atxHeadingSequence"), o(c)) : r(c);
  }
  function o(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), l(c)) : c === null || _r(c) ? (e.exit("atxHeading"), t(c)) : Yr(c) ? on(e, o, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (e.consume(c), l) : (e.exit("atxHeadingSequence"), o(c));
  }
  function u(c) {
    return c === null || c === 35 || pn(c) ? (e.exit("atxHeadingText"), o(c)) : (e.consume(c), u);
  }
}
const r0e = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], qL = ["pre", "script", "style", "textarea"], n0e = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: s0e,
  tokenize: o0e
}, i0e = {
  partial: !0,
  tokenize: u0e
}, a0e = {
  partial: !0,
  tokenize: l0e
};
function s0e(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function o0e(e, t, r) {
  const n = this;
  let a, s, i, o, l;
  return u;
  function u(P) {
    return c(P);
  }
  function c(P) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(P), d;
  }
  function d(P) {
    return P === 33 ? (e.consume(P), p) : P === 47 ? (e.consume(P), s = !0, m) : P === 63 ? (e.consume(P), a = 3, n.interrupt ? t : W) : Ui(P) ? (e.consume(P), i = String.fromCharCode(P), y) : r(P);
  }
  function p(P) {
    return P === 45 ? (e.consume(P), a = 2, f) : P === 91 ? (e.consume(P), a = 5, o = 0, h) : Ui(P) ? (e.consume(P), a = 4, n.interrupt ? t : W) : r(P);
  }
  function f(P) {
    return P === 45 ? (e.consume(P), n.interrupt ? t : W) : r(P);
  }
  function h(P) {
    const he = "CDATA[";
    return P === he.charCodeAt(o++) ? (e.consume(P), o === he.length ? n.interrupt ? t : N : h) : r(P);
  }
  function m(P) {
    return Ui(P) ? (e.consume(P), i = String.fromCharCode(P), y) : r(P);
  }
  function y(P) {
    if (P === null || P === 47 || P === 62 || pn(P)) {
      const he = P === 47, ye = i.toLowerCase();
      return !he && !s && qL.includes(ye) ? (a = 1, n.interrupt ? t(P) : N(P)) : r0e.includes(i.toLowerCase()) ? (a = 6, he ? (e.consume(P), b) : n.interrupt ? t(P) : N(P)) : (a = 7, n.interrupt && !n.parser.lazy[n.now().line] ? r(P) : s ? v(P) : x(P));
    }
    return P === 45 || qi(P) ? (e.consume(P), i += String.fromCharCode(P), y) : r(P);
  }
  function b(P) {
    return P === 62 ? (e.consume(P), n.interrupt ? t : N) : r(P);
  }
  function v(P) {
    return Yr(P) ? (e.consume(P), v) : B(P);
  }
  function x(P) {
    return P === 47 ? (e.consume(P), B) : P === 58 || P === 95 || Ui(P) ? (e.consume(P), _) : Yr(P) ? (e.consume(P), x) : B(P);
  }
  function _(P) {
    return P === 45 || P === 46 || P === 58 || P === 95 || qi(P) ? (e.consume(P), _) : E(P);
  }
  function E(P) {
    return P === 61 ? (e.consume(P), w) : Yr(P) ? (e.consume(P), E) : x(P);
  }
  function w(P) {
    return P === null || P === 60 || P === 61 || P === 62 || P === 96 ? r(P) : P === 34 || P === 39 ? (e.consume(P), l = P, C) : Yr(P) ? (e.consume(P), w) : k(P);
  }
  function C(P) {
    return P === l ? (e.consume(P), l = null, S) : P === null || _r(P) ? r(P) : (e.consume(P), C);
  }
  function k(P) {
    return P === null || P === 34 || P === 39 || P === 47 || P === 60 || P === 61 || P === 62 || P === 96 || pn(P) ? E(P) : (e.consume(P), k);
  }
  function S(P) {
    return P === 47 || P === 62 || Yr(P) ? x(P) : r(P);
  }
  function B(P) {
    return P === 62 ? (e.consume(P), U) : r(P);
  }
  function U(P) {
    return P === null || _r(P) ? N(P) : Yr(P) ? (e.consume(P), U) : r(P);
  }
  function N(P) {
    return P === 45 && a === 2 ? (e.consume(P), ae) : P === 60 && a === 1 ? (e.consume(P), Q) : P === 62 && a === 4 ? (e.consume(P), X) : P === 63 && a === 3 ? (e.consume(P), W) : P === 93 && a === 5 ? (e.consume(P), le) : _r(P) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(i0e, G, O)(P)) : P === null || _r(P) ? (e.exit("htmlFlowData"), O(P)) : (e.consume(P), N);
  }
  function O(P) {
    return e.check(a0e, I, G)(P);
  }
  function I(P) {
    return e.enter("lineEnding"), e.consume(P), e.exit("lineEnding"), q;
  }
  function q(P) {
    return P === null || _r(P) ? O(P) : (e.enter("htmlFlowData"), N(P));
  }
  function ae(P) {
    return P === 45 ? (e.consume(P), W) : N(P);
  }
  function Q(P) {
    return P === 47 ? (e.consume(P), i = "", ne) : N(P);
  }
  function ne(P) {
    if (P === 62) {
      const he = i.toLowerCase();
      return qL.includes(he) ? (e.consume(P), X) : N(P);
    }
    return Ui(P) && i.length < 8 ? (e.consume(P), i += String.fromCharCode(P), ne) : N(P);
  }
  function le(P) {
    return P === 93 ? (e.consume(P), W) : N(P);
  }
  function W(P) {
    return P === 62 ? (e.consume(P), X) : P === 45 && a === 2 ? (e.consume(P), W) : N(P);
  }
  function X(P) {
    return P === null || _r(P) ? (e.exit("htmlFlowData"), G(P)) : (e.consume(P), X);
  }
  function G(P) {
    return e.exit("htmlFlow"), t(P);
  }
}
function l0e(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return _r(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), s) : r(i);
  }
  function s(i) {
    return n.parser.lazy[n.now().line] ? r(i) : t(i);
  }
}
function u0e(e, t, r) {
  return n;
  function n(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(Id, t, r);
  }
}
const c0e = {
  name: "htmlText",
  tokenize: d0e
};
function d0e(e, t, r) {
  const n = this;
  let a, s, i;
  return o;
  function o(W) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(W), l;
  }
  function l(W) {
    return W === 33 ? (e.consume(W), u) : W === 47 ? (e.consume(W), E) : W === 63 ? (e.consume(W), x) : Ui(W) ? (e.consume(W), k) : r(W);
  }
  function u(W) {
    return W === 45 ? (e.consume(W), c) : W === 91 ? (e.consume(W), s = 0, h) : Ui(W) ? (e.consume(W), v) : r(W);
  }
  function c(W) {
    return W === 45 ? (e.consume(W), f) : r(W);
  }
  function d(W) {
    return W === null ? r(W) : W === 45 ? (e.consume(W), p) : _r(W) ? (i = d, Q(W)) : (e.consume(W), d);
  }
  function p(W) {
    return W === 45 ? (e.consume(W), f) : d(W);
  }
  function f(W) {
    return W === 62 ? ae(W) : W === 45 ? p(W) : d(W);
  }
  function h(W) {
    const X = "CDATA[";
    return W === X.charCodeAt(s++) ? (e.consume(W), s === X.length ? m : h) : r(W);
  }
  function m(W) {
    return W === null ? r(W) : W === 93 ? (e.consume(W), y) : _r(W) ? (i = m, Q(W)) : (e.consume(W), m);
  }
  function y(W) {
    return W === 93 ? (e.consume(W), b) : m(W);
  }
  function b(W) {
    return W === 62 ? ae(W) : W === 93 ? (e.consume(W), b) : m(W);
  }
  function v(W) {
    return W === null || W === 62 ? ae(W) : _r(W) ? (i = v, Q(W)) : (e.consume(W), v);
  }
  function x(W) {
    return W === null ? r(W) : W === 63 ? (e.consume(W), _) : _r(W) ? (i = x, Q(W)) : (e.consume(W), x);
  }
  function _(W) {
    return W === 62 ? ae(W) : x(W);
  }
  function E(W) {
    return Ui(W) ? (e.consume(W), w) : r(W);
  }
  function w(W) {
    return W === 45 || qi(W) ? (e.consume(W), w) : C(W);
  }
  function C(W) {
    return _r(W) ? (i = C, Q(W)) : Yr(W) ? (e.consume(W), C) : ae(W);
  }
  function k(W) {
    return W === 45 || qi(W) ? (e.consume(W), k) : W === 47 || W === 62 || pn(W) ? S(W) : r(W);
  }
  function S(W) {
    return W === 47 ? (e.consume(W), ae) : W === 58 || W === 95 || Ui(W) ? (e.consume(W), B) : _r(W) ? (i = S, Q(W)) : Yr(W) ? (e.consume(W), S) : ae(W);
  }
  function B(W) {
    return W === 45 || W === 46 || W === 58 || W === 95 || qi(W) ? (e.consume(W), B) : U(W);
  }
  function U(W) {
    return W === 61 ? (e.consume(W), N) : _r(W) ? (i = U, Q(W)) : Yr(W) ? (e.consume(W), U) : S(W);
  }
  function N(W) {
    return W === null || W === 60 || W === 61 || W === 62 || W === 96 ? r(W) : W === 34 || W === 39 ? (e.consume(W), a = W, O) : _r(W) ? (i = N, Q(W)) : Yr(W) ? (e.consume(W), N) : (e.consume(W), I);
  }
  function O(W) {
    return W === a ? (e.consume(W), a = void 0, q) : W === null ? r(W) : _r(W) ? (i = O, Q(W)) : (e.consume(W), O);
  }
  function I(W) {
    return W === null || W === 34 || W === 39 || W === 60 || W === 61 || W === 96 ? r(W) : W === 47 || W === 62 || pn(W) ? S(W) : (e.consume(W), I);
  }
  function q(W) {
    return W === 47 || W === 62 || pn(W) ? S(W) : r(W);
  }
  function ae(W) {
    return W === 62 ? (e.consume(W), e.exit("htmlTextData"), e.exit("htmlText"), t) : r(W);
  }
  function Q(W) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(W), e.exit("lineEnding"), ne;
  }
  function ne(W) {
    return Yr(W) ? on(e, le, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(W) : le(W);
  }
  function le(W) {
    return e.enter("htmlTextData"), i(W);
  }
}
const IN = {
  name: "labelEnd",
  resolveAll: m0e,
  resolveTo: g0e,
  tokenize: b0e
}, f0e = {
  tokenize: y0e
}, p0e = {
  tokenize: v0e
}, h0e = {
  tokenize: w0e
};
function m0e(e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; ) {
    const n = e[t][1];
    if (r.push(e[t]), n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") {
      const a = n.type === "labelImage" ? 4 : 2;
      n.type = "data", t += a;
    }
  }
  return e.length !== r.length && qa(e, 0, e.length, r), e;
}
function g0e(e, t) {
  let r = e.length, n = 0, a, s, i, o;
  for (; r--; )
    if (a = e[r][1], s) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[r][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (i) {
      if (e[r][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (s = r, a.type !== "labelLink")) {
        n = 2;
        break;
      }
    } else a.type === "labelEnd" && (i = r);
  const l = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, u = {
    type: "label",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[i][1].end
    }
  }, c = {
    type: "labelText",
    start: {
      ...e[s + n + 2][1].end
    },
    end: {
      ...e[i - 2][1].start
    }
  };
  return o = [["enter", l, t], ["enter", u, t]], o = es(o, e.slice(s + 1, s + n + 3)), o = es(o, [["enter", c, t]]), o = es(o, sy(t.parser.constructs.insideSpan.null, e.slice(s + n + 4, i - 3), t)), o = es(o, [["exit", c, t], e[i - 2], e[i - 1], ["exit", u, t]]), o = es(o, e.slice(i + 1)), o = es(o, [["exit", l, t]]), qa(e, s, e.length, o), e;
}
function b0e(e, t, r) {
  const n = this;
  let a = n.events.length, s, i;
  for (; a--; )
    if ((n.events[a][1].type === "labelImage" || n.events[a][1].type === "labelLink") && !n.events[a][1]._balanced) {
      s = n.events[a][1];
      break;
    }
  return o;
  function o(p) {
    return s ? s._inactive ? d(p) : (i = n.parser.defined.includes(Ms(n.sliceSerialize({
      start: s.end,
      end: n.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : r(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(f0e, c, i ? c : d)(p) : p === 91 ? e.attempt(p0e, c, i ? u : d)(p) : i ? c(p) : d(p);
  }
  function u(p) {
    return e.attempt(h0e, c, d)(p);
  }
  function c(p) {
    return t(p);
  }
  function d(p) {
    return s._balanced = !0, r(p);
  }
}
function y0e(e, t, r) {
  return n;
  function n(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), a;
  }
  function a(d) {
    return pn(d) ? Qf(e, s)(d) : s(d);
  }
  function s(d) {
    return d === 41 ? c(d) : wV(e, i, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function i(d) {
    return pn(d) ? Qf(e, l)(d) : c(d);
  }
  function o(d) {
    return r(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? EV(e, u, r, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function u(d) {
    return pn(d) ? Qf(e, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : r(d);
  }
}
function v0e(e, t, r) {
  const n = this;
  return a;
  function a(o) {
    return xV.call(n, e, s, i, "reference", "referenceMarker", "referenceString")(o);
  }
  function s(o) {
    return n.parser.defined.includes(Ms(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1))) ? t(o) : r(o);
  }
  function i(o) {
    return r(o);
  }
}
function w0e(e, t, r) {
  return n;
  function n(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), a;
  }
  function a(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : r(s);
  }
}
const x0e = {
  name: "labelStartImage",
  resolveAll: IN.resolveAll,
  tokenize: E0e
};
function E0e(e, t, r) {
  const n = this;
  return a;
  function a(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), s;
  }
  function s(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : r(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(o) : t(o);
  }
}
const S0e = {
  name: "labelStartLink",
  resolveAll: IN.resolveAll,
  tokenize: _0e
};
function _0e(e, t, r) {
  const n = this;
  return a;
  function a(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(i) {
    return i === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(i) : t(i);
  }
}
const U1 = {
  name: "lineEnding",
  tokenize: k0e
};
function k0e(e, t) {
  return r;
  function r(n) {
    return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), on(e, t, "linePrefix");
  }
}
const cg = {
  name: "thematicBreak",
  tokenize: C0e
};
function C0e(e, t, r) {
  let n = 0, a;
  return s;
  function s(u) {
    return e.enter("thematicBreak"), i(u);
  }
  function i(u) {
    return a = u, o(u);
  }
  function o(u) {
    return u === a ? (e.enter("thematicBreakSequence"), l(u)) : n >= 3 && (u === null || _r(u)) ? (e.exit("thematicBreak"), t(u)) : r(u);
  }
  function l(u) {
    return u === a ? (e.consume(u), n++, l) : (e.exit("thematicBreakSequence"), Yr(u) ? on(e, o, "whitespace")(u) : o(u));
  }
}
const wa = {
  continuation: {
    tokenize: I0e
  },
  exit: D0e,
  name: "list",
  tokenize: R0e
}, A0e = {
  partial: !0,
  tokenize: O0e
}, T0e = {
  partial: !0,
  tokenize: N0e
};
function R0e(e, t, r) {
  const n = this, a = n.events[n.events.length - 1];
  let s = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, i = 0;
  return o;
  function o(f) {
    const h = n.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !n.containerState.marker || f === n.containerState.marker : yR(f)) {
      if (n.containerState.type || (n.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), f === 42 || f === 45 ? e.check(cg, r, u)(f) : u(f);
      if (!n.interrupt || f === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(f);
    }
    return r(f);
  }
  function l(f) {
    return yR(f) && ++i < 10 ? (e.consume(f), l) : (!n.interrupt || i < 2) && (n.containerState.marker ? f === n.containerState.marker : f === 41 || f === 46) ? (e.exit("listItemValue"), u(f)) : r(f);
  }
  function u(f) {
    return e.enter("listItemMarker"), e.consume(f), e.exit("listItemMarker"), n.containerState.marker = n.containerState.marker || f, e.check(
      Id,
      // Can’t be empty when interrupting.
      n.interrupt ? r : c,
      e.attempt(A0e, p, d)
    );
  }
  function c(f) {
    return n.containerState.initialBlankLine = !0, s++, p(f);
  }
  function d(f) {
    return Yr(f) ? (e.enter("listItemPrefixWhitespace"), e.consume(f), e.exit("listItemPrefixWhitespace"), p) : r(f);
  }
  function p(f) {
    return n.containerState.size = s + n.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(f);
  }
}
function I0e(e, t, r) {
  const n = this;
  return n.containerState._closeFlow = void 0, e.check(Id, a, s);
  function a(o) {
    return n.containerState.furtherBlankLines = n.containerState.furtherBlankLines || n.containerState.initialBlankLine, on(e, t, "listItemIndent", n.containerState.size + 1)(o);
  }
  function s(o) {
    return n.containerState.furtherBlankLines || !Yr(o) ? (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, i(o)) : (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, e.attempt(T0e, t, i)(o));
  }
  function i(o) {
    return n.containerState._closeFlow = !0, n.interrupt = void 0, on(e, e.attempt(wa, t, r), "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function N0e(e, t, r) {
  const n = this;
  return on(e, a, "listItemIndent", n.containerState.size + 1);
  function a(s) {
    const i = n.events[n.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === n.containerState.size ? t(s) : r(s);
  }
}
function D0e(e) {
  e.exit(this.containerState.type);
}
function O0e(e, t, r) {
  const n = this;
  return on(e, a, "listItemPrefixWhitespace", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function a(s) {
    const i = n.events[n.events.length - 1];
    return !Yr(s) && i && i[1].type === "listItemPrefixWhitespace" ? t(s) : r(s);
  }
}
const jL = {
  name: "setextUnderline",
  resolveTo: P0e,
  tokenize: L0e
};
function P0e(e, t) {
  let r = e.length, n, a, s;
  for (; r--; )
    if (e[r][0] === "enter") {
      if (e[r][1].type === "content") {
        n = r;
        break;
      }
      e[r][1].type === "paragraph" && (a = r);
    } else
      e[r][1].type === "content" && e.splice(r, 1), !s && e[r][1].type === "definition" && (s = r);
  const i = {
    type: "setextHeading",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[a][1].type = "setextHeadingText", s ? (e.splice(a, 0, ["enter", i, t]), e.splice(s + 1, 0, ["exit", e[n][1], t]), e[n][1].end = {
    ...e[s][1].end
  }) : e[n][1] = i, e.push(["exit", i, t]), e;
}
function L0e(e, t, r) {
  const n = this;
  let a;
  return s;
  function s(u) {
    let c = n.events.length, d;
    for (; c--; )
      if (n.events[c][1].type !== "lineEnding" && n.events[c][1].type !== "linePrefix" && n.events[c][1].type !== "content") {
        d = n.events[c][1].type === "paragraph";
        break;
      }
    return !n.parser.lazy[n.now().line] && (n.interrupt || d) ? (e.enter("setextHeadingLine"), a = u, i(u)) : r(u);
  }
  function i(u) {
    return e.enter("setextHeadingLineSequence"), o(u);
  }
  function o(u) {
    return u === a ? (e.consume(u), o) : (e.exit("setextHeadingLineSequence"), Yr(u) ? on(e, l, "lineSuffix")(u) : l(u));
  }
  function l(u) {
    return u === null || _r(u) ? (e.exit("setextHeadingLine"), t(u)) : r(u);
  }
}
const M0e = {
  tokenize: H0e,
  partial: !0
};
function F0e() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: z0e,
        continuation: {
          tokenize: q0e
        },
        exit: j0e
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: U0e
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: $0e,
        resolveTo: B0e
      }
    }
  };
}
function $0e(e, t, r) {
  const n = this;
  let a = n.events.length;
  const s = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []);
  let i;
  for (; a--; ) {
    const l = n.events[a][1];
    if (l.type === "labelImage") {
      i = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!i || !i._balanced)
      return r(l);
    const u = Ms(n.sliceSerialize({
      start: i.end,
      end: n.now()
    }));
    return u.codePointAt(0) !== 94 || !s.includes(u.slice(1)) ? r(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function B0e(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const n = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", n, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", s, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", s, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", n, t]
  ];
  return e.splice(r, e.length - r + 1, ...o), e;
}
function U0e(e, t, r) {
  const n = this, a = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []);
  let s = 0, i;
  return o;
  function o(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d) {
    return d !== 94 ? r(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(d) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      d === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || pn(d)
    )
      return r(d);
    if (d === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return a.includes(Ms(n.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(d);
    }
    return pn(d) || (i = !0), s++, e.consume(d), d === 92 ? c : u;
  }
  function c(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), s++, u) : u(d);
  }
}
function z0e(e, t, r) {
  const n = this, a = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []);
  let s, i = 0, o;
  return l;
  function l(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : r(h);
  }
  function c(h) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || pn(h)
    )
      return r(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteDefinitionLabelString");
      return s = Ms(n.sliceSerialize(m)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return pn(h) || (o = !0), i++, e.consume(h), h === 92 ? d : c;
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), i++, c) : c(h);
  }
  function p(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), a.includes(s) || a.push(s), on(e, f, "gfmFootnoteDefinitionWhitespace")) : r(h);
  }
  function f(h) {
    return t(h);
  }
}
function q0e(e, t, r) {
  return e.check(Id, t, e.attempt(M0e, t, r));
}
function j0e(e) {
  e.exit("gfmFootnoteDefinition");
}
function H0e(e, t, r) {
  const n = this;
  return on(e, a, "gfmFootnoteDefinitionIndent", 5);
  function a(s) {
    const i = n.events[n.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(s) : r(s);
  }
}
function V0e(e) {
  let r = e.singleTilde;
  const n = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: a
  };
  return r == null && (r = !0), {
    text: {
      126: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function a(i, o) {
    let l = -1;
    for (; ++l < i.length; )
      if (i[l][0] === "enter" && i[l][1].type === "strikethroughSequenceTemporary" && i[l][1]._close) {
        let u = l;
        for (; u--; )
          if (i[u][0] === "exit" && i[u][1].type === "strikethroughSequenceTemporary" && i[u][1]._open && // If the sizes are the same:
          i[l][1].end.offset - i[l][1].start.offset === i[u][1].end.offset - i[u][1].start.offset) {
            i[l][1].type = "strikethroughSequence", i[u][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, i[u][1].start),
              end: Object.assign({}, i[l][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, i[u][1].end),
              end: Object.assign({}, i[l][1].start)
            }, p = [["enter", c, o], ["enter", i[u][1], o], ["exit", i[u][1], o], ["enter", d, o]], f = o.parser.constructs.insideSpan.null;
            f && qa(p, p.length, 0, sy(f, i.slice(u + 1, l), o)), qa(p, p.length, 0, [["exit", d, o], ["enter", i[l][1], o], ["exit", i[l][1], o], ["exit", c, o]]), qa(i, u - 1, l - u + 3, p), l = u + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i.length; )
      i[l][1].type === "strikethroughSequenceTemporary" && (i[l][1].type = "data");
    return i;
  }
  function s(i, o, l) {
    const u = this.previous, c = this.events;
    let d = 0;
    return p;
    function p(h) {
      return u === 126 && c[c.length - 1][1].type !== "characterEscape" ? l(h) : (i.enter("strikethroughSequenceTemporary"), f(h));
    }
    function f(h) {
      const m = ld(u);
      if (h === 126)
        return d > 1 ? l(h) : (i.consume(h), d++, f);
      if (d < 2 && !r) return l(h);
      const y = i.exit("strikethroughSequenceTemporary"), b = ld(h);
      return y._open = !b || b === 2 && !!m, y._close = !m || m === 2 && !!b, o(h);
    }
  }
}
class G0e {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, n) {
    W0e(this, t, r, n);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(s, i) {
      return s[0] - i[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const n = [];
    for (; r > 0; )
      r -= 1, n.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    n.push([...t]), t.length = 0;
    let a = n.pop();
    for (; a; )
      t.push(...a), a = n.pop();
    this.map.length = 0;
  }
}
function W0e(e, t, r, n) {
  let a = 0;
  if (!(r === 0 && n.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += r, e.map[a][2].push(...n);
        return;
      }
      a += 1;
    }
    e.map.push([t, r, n]);
  }
}
function K0e(e, t) {
  let r = !1;
  const n = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (r) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && n.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const s = n.length - 1;
          n[s] = n[s] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else a[0] === "enter" && a[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return n;
}
function Y0e() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: X0e,
        resolveAll: Z0e
      }
    }
  };
}
function X0e(e, t, r) {
  const n = this;
  let a = 0, s = 0, i;
  return o;
  function o(B) {
    let U = n.events.length - 1;
    for (; U > -1; ) {
      const I = n.events[U][1].type;
      if (I === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      I === "linePrefix") U--;
      else break;
    }
    const N = U > -1 ? n.events[U][1].type : null, O = N === "tableHead" || N === "tableRow" ? w : l;
    return O === w && n.parser.lazy[n.now().line] ? r(B) : O(B);
  }
  function l(B) {
    return e.enter("tableHead"), e.enter("tableRow"), u(B);
  }
  function u(B) {
    return B === 124 || (i = !0, s += 1), c(B);
  }
  function c(B) {
    return B === null ? r(B) : _r(B) ? s > 1 ? (s = 0, n.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), f) : r(B) : Yr(B) ? on(e, c, "whitespace")(B) : (s += 1, i && (i = !1, a += 1), B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), i = !0, c) : (e.enter("data"), d(B)));
  }
  function d(B) {
    return B === null || B === 124 || pn(B) ? (e.exit("data"), c(B)) : (e.consume(B), B === 92 ? p : d);
  }
  function p(B) {
    return B === 92 || B === 124 ? (e.consume(B), d) : d(B);
  }
  function f(B) {
    return n.interrupt = !1, n.parser.lazy[n.now().line] ? r(B) : (e.enter("tableDelimiterRow"), i = !1, Yr(B) ? on(e, h, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(B) : h(B));
  }
  function h(B) {
    return B === 45 || B === 58 ? y(B) : B === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), m) : E(B);
  }
  function m(B) {
    return Yr(B) ? on(e, y, "whitespace")(B) : y(B);
  }
  function y(B) {
    return B === 58 ? (s += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), b) : B === 45 ? (s += 1, b(B)) : B === null || _r(B) ? _(B) : E(B);
  }
  function b(B) {
    return B === 45 ? (e.enter("tableDelimiterFiller"), v(B)) : E(B);
  }
  function v(B) {
    return B === 45 ? (e.consume(B), v) : B === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), x) : (e.exit("tableDelimiterFiller"), x(B));
  }
  function x(B) {
    return Yr(B) ? on(e, _, "whitespace")(B) : _(B);
  }
  function _(B) {
    return B === 124 ? h(B) : B === null || _r(B) ? !i || a !== s ? E(B) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(B)) : E(B);
  }
  function E(B) {
    return r(B);
  }
  function w(B) {
    return e.enter("tableRow"), C(B);
  }
  function C(B) {
    return B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), C) : B === null || _r(B) ? (e.exit("tableRow"), t(B)) : Yr(B) ? on(e, C, "whitespace")(B) : (e.enter("data"), k(B));
  }
  function k(B) {
    return B === null || B === 124 || pn(B) ? (e.exit("data"), C(B)) : (e.consume(B), B === 92 ? S : k);
  }
  function S(B) {
    return B === 92 || B === 124 ? (e.consume(B), k) : k(B);
  }
}
function Z0e(e, t) {
  let r = -1, n = !0, a = 0, s = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, l = 0, u, c, d;
  const p = new G0e();
  for (; ++r < e.length; ) {
    const f = e[r], h = f[1];
    f[0] === "enter" ? h.type === "tableHead" ? (o = !1, l !== 0 && (HL(p, t, l, u, c), c = void 0, l = 0), u = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(r, 0, [["enter", u, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (n = !0, d = void 0, s = [0, 0, 0, 0], i = [0, r + 1, 0, 0], o && (o = !1, c = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(r, 0, [["enter", c, t]])), a = h.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : a && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (n = !1, i[2] === 0 && (s[1] !== 0 && (i[0] = i[1], d = gm(p, t, s, a, void 0, d), s = [0, 0, 0, 0]), i[2] = r)) : h.type === "tableCellDivider" && (n ? n = !1 : (s[1] !== 0 && (i[0] = i[1], d = gm(p, t, s, a, void 0, d)), s = i, i = [s[1], r, 0, 0])) : h.type === "tableHead" ? (o = !0, l = r) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = r, s[1] !== 0 ? (i[0] = i[1], d = gm(p, t, s, a, r, d)) : i[1] !== 0 && (d = gm(p, t, i, a, r, d)), a = 0) : a && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (i[3] = r);
  }
  for (l !== 0 && HL(p, t, l, u, c), p.consume(t.events), r = -1; ++r < t.events.length; ) {
    const f = t.events[r];
    f[0] === "enter" && f[1].type === "table" && (f[1]._align = K0e(t.events, r));
  }
  return e;
}
function gm(e, t, r, n, a, s) {
  const i = n === 1 ? "tableHeader" : n === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  r[0] !== 0 && (s.end = Object.assign({}, Tc(t.events, r[0])), e.add(r[0], 0, [["exit", s, t]]));
  const l = Tc(t.events, r[1]);
  if (s = {
    type: i,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(r[1], 0, [["enter", s, t]]), r[2] !== 0) {
    const u = Tc(t.events, r[2]), c = Tc(t.events, r[3]), d = {
      type: o,
      start: Object.assign({}, u),
      end: Object.assign({}, c)
    };
    if (e.add(r[2], 0, [["enter", d, t]]), n !== 2) {
      const p = t.events[r[2]], f = t.events[r[3]];
      if (p[1].end = Object.assign({}, f[1].end), p[1].type = "chunkText", p[1].contentType = "text", r[3] > r[2] + 1) {
        const h = r[2] + 1, m = r[3] - r[2] - 1;
        e.add(h, m, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", d, t]]);
  }
  return a !== void 0 && (s.end = Object.assign({}, Tc(t.events, a)), e.add(a, 0, [["exit", s, t]]), s = void 0), s;
}
function HL(e, t, r, n, a) {
  const s = [], i = Tc(t.events, r);
  a && (a.end = Object.assign({}, i), s.push(["exit", a, t])), n.end = Object.assign({}, i), s.push(["exit", n, t]), e.add(r + 1, 0, s);
}
function Tc(e, t) {
  const r = e[t], n = r[0] === "enter" ? "start" : "end";
  return r[1][n];
}
const J0e = {
  name: "tasklistCheck",
  tokenize: ewe
};
function Q0e() {
  return {
    text: {
      91: J0e
    }
  };
}
function ewe(e, t, r) {
  const n = this;
  return a;
  function a(l) {
    return (
      // Exit if there’s stuff before.
      n.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !n._gfmTasklistFirstContentOfListItem ? r(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(l) {
    return pn(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), i) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), i) : r(l);
  }
  function i(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : r(l);
  }
  function o(l) {
    return _r(l) ? t(l) : Yr(l) ? e.check({
      tokenize: twe
    }, t, r)(l) : r(l);
  }
}
function twe(e, t, r) {
  return on(e, n, "whitespace");
  function n(a) {
    return a === null ? r(a) : t(a);
  }
}
function rwe(e) {
  return TN([
    fve(),
    F0e(),
    V0e(e),
    Y0e(),
    Q0e()
  ]);
}
const nwe = {};
function NN(e) {
  const t = (
    /** @type {Processor} */
    this
  ), r = e || nwe, n = t.data(), a = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []);
  a.push(rwe(r)), s.push(sve()), i.push(ove(r));
}
const iwe = {
  tokenize: awe
};
function awe(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, n, a);
  let r;
  return t;
  function n(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), on(e, t, "linePrefix");
  }
  function a(o) {
    return e.enter("paragraph"), s(o);
  }
  function s(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: r
    });
    return r && (r.next = l), r = l, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return _r(o) ? (e.consume(o), e.exit("chunkText"), s) : (e.consume(o), i);
  }
}
const swe = {
  tokenize: owe
}, VL = {
  tokenize: lwe
};
function owe(e) {
  const t = this, r = [];
  let n = 0, a, s, i;
  return o;
  function o(x) {
    if (n < r.length) {
      const _ = r[n];
      return t.containerState = _[1], e.attempt(_[0].continuation, l, u)(x);
    }
    return u(x);
  }
  function l(x) {
    if (n++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && v();
      const _ = t.events.length;
      let E = _, w;
      for (; E--; )
        if (t.events[E][0] === "exit" && t.events[E][1].type === "chunkFlow") {
          w = t.events[E][1].end;
          break;
        }
      b(n);
      let C = _;
      for (; C < t.events.length; )
        t.events[C][1].end = {
          ...w
        }, C++;
      return qa(t.events, E + 1, 0, t.events.slice(_)), t.events.length = C, u(x);
    }
    return o(x);
  }
  function u(x) {
    if (n === r.length) {
      if (!a)
        return p(x);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return h(x);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(VL, c, d)(x);
  }
  function c(x) {
    return a && v(), b(n), p(x);
  }
  function d(x) {
    return t.parser.lazy[t.now().line] = n !== r.length, i = t.now().offset, h(x);
  }
  function p(x) {
    return t.containerState = {}, e.attempt(VL, f, h)(x);
  }
  function f(x) {
    return n++, r.push([t.currentConstruct, t.containerState]), p(x);
  }
  function h(x) {
    if (x === null) {
      a && v(), b(0), e.consume(x);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: a,
      contentType: "flow",
      previous: s
    }), m(x);
  }
  function m(x) {
    if (x === null) {
      y(e.exit("chunkFlow"), !0), b(0), e.consume(x);
      return;
    }
    return _r(x) ? (e.consume(x), y(e.exit("chunkFlow")), n = 0, t.interrupt = void 0, o) : (e.consume(x), m);
  }
  function y(x, _) {
    const E = t.sliceStream(x);
    if (_ && E.push(null), x.previous = s, s && (s.next = x), s = x, a.defineSkip(x.start), a.write(E), t.parser.lazy[x.start.line]) {
      let w = a.events.length;
      for (; w--; )
        if (
          // The token starts before the line ending…
          a.events[w][1].start.offset < i && // …and either is not ended yet…
          (!a.events[w][1].end || // …or ends after it.
          a.events[w][1].end.offset > i)
        )
          return;
      const C = t.events.length;
      let k = C, S, B;
      for (; k--; )
        if (t.events[k][0] === "exit" && t.events[k][1].type === "chunkFlow") {
          if (S) {
            B = t.events[k][1].end;
            break;
          }
          S = !0;
        }
      for (b(n), w = C; w < t.events.length; )
        t.events[w][1].end = {
          ...B
        }, w++;
      qa(t.events, k + 1, 0, t.events.slice(C)), t.events.length = w;
    }
  }
  function b(x) {
    let _ = r.length;
    for (; _-- > x; ) {
      const E = r[_];
      t.containerState = E[1], E[0].exit.call(t, e);
    }
    r.length = x;
  }
  function v() {
    a.write([null]), s = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function lwe(e, t, r) {
  return on(e, e.attempt(this.parser.constructs.document, t, r), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
const uwe = {
  tokenize: cwe
};
function cwe(e) {
  const t = this, r = e.attempt(
    // Try to parse a blank line.
    Id,
    n,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, a, on(e, e.attempt(this.parser.constructs.flow, a, e.attempt(qve, a)), "linePrefix"))
  );
  return r;
  function n(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, r;
  }
  function a(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, r;
  }
}
const dwe = {
  resolveAll: _V()
}, fwe = SV("string"), pwe = SV("text");
function SV(e) {
  return {
    resolveAll: _V(e === "text" ? hwe : void 0),
    tokenize: t
  };
  function t(r) {
    const n = this, a = this.parser.constructs[e], s = r.attempt(a, i, o);
    return i;
    function i(c) {
      return u(c) ? s(c) : o(c);
    }
    function o(c) {
      if (c === null) {
        r.consume(c);
        return;
      }
      return r.enter("data"), r.consume(c), l;
    }
    function l(c) {
      return u(c) ? (r.exit("data"), s(c)) : (r.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const d = a[c];
      let p = -1;
      if (d)
        for (; ++p < d.length; ) {
          const f = d[p];
          if (!f.previous || f.previous.call(n, n.previous))
            return !0;
        }
      return !1;
    }
  }
}
function _V(e) {
  return t;
  function t(r, n) {
    let a = -1, s;
    for (; ++a <= r.length; )
      s === void 0 ? r[a] && r[a][1].type === "data" && (s = a, a++) : (!r[a] || r[a][1].type !== "data") && (a !== s + 2 && (r[s][1].end = r[a - 1][1].end, r.splice(s + 2, a - s - 2), a = s + 2), s = void 0);
    return e ? e(r, n) : r;
  }
}
function hwe(e, t) {
  let r = 0;
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === "lineEnding") && e[r - 1][1].type === "data") {
      const n = e[r - 1][1], a = t.sliceStream(n);
      let s = a.length, i = -1, o = 0, l;
      for (; s--; ) {
        const u = a[s];
        if (typeof u == "string") {
          for (i = u.length; u.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (u === -2)
          l = !0, o++;
        else if (u !== -1) {
          s++;
          break;
        }
      }
      if (o) {
        const u = {
          type: r === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? i : n.start._bufferIndex + i,
            _index: n.start._index + s,
            line: n.end.line,
            column: n.end.column - o,
            offset: n.end.offset - o
          },
          end: {
            ...n.end
          }
        };
        n.end = {
          ...u.start
        }, n.start.offset === n.end.offset ? Object.assign(n, u) : (e.splice(r, 0, ["enter", u, t], ["exit", u, t]), r += 2);
      }
      r++;
    }
  return e;
}
const mwe = {
  42: wa,
  43: wa,
  45: wa,
  48: wa,
  49: wa,
  50: wa,
  51: wa,
  52: wa,
  53: wa,
  54: wa,
  55: wa,
  56: wa,
  57: wa,
  62: gV
}, gwe = {
  91: Wve
}, bwe = {
  [-2]: B1,
  [-1]: B1,
  32: B1
}, ywe = {
  35: Qve,
  42: cg,
  45: [jL, cg],
  60: n0e,
  61: jL,
  95: cg,
  96: zL,
  126: zL
}, vwe = {
  38: yV,
  92: bV
}, wwe = {
  [-5]: U1,
  [-4]: U1,
  [-3]: U1,
  33: x0e,
  38: yV,
  42: xR,
  60: [Sve, c0e],
  91: S0e,
  92: [Zve, bV],
  93: IN,
  95: xR,
  96: Mve
}, xwe = {
  null: [xR, dwe]
}, Ewe = {
  null: [42, 95]
}, Swe = {
  null: []
}, _we = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Ewe,
  contentInitial: gwe,
  disable: Swe,
  document: mwe,
  flow: ywe,
  flowInitial: bwe,
  insideSpan: xwe,
  string: vwe,
  text: wwe
}, Symbol.toStringTag, { value: "Module" }));
function kwe(e, t, r) {
  let n = {
    _bufferIndex: -1,
    _index: 0,
    line: r && r.line || 1,
    column: r && r.column || 1,
    offset: r && r.offset || 0
  };
  const a = {}, s = [];
  let i = [], o = [];
  const l = {
    attempt: C(E),
    check: C(w),
    consume: v,
    enter: x,
    exit: _,
    interrupt: C(w, {
      interrupt: !0
    })
  }, u = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: h,
    parser: e,
    previous: null,
    sliceSerialize: p,
    sliceStream: f,
    write: d
  };
  let c = t.tokenize.call(u, l);
  return t.resolveAll && s.push(t), u;
  function d(U) {
    return i = es(i, U), y(), i[i.length - 1] !== null ? [] : (k(t, 0), u.events = sy(s, u.events, u), u.events);
  }
  function p(U, N) {
    return Awe(f(U), N);
  }
  function f(U) {
    return Cwe(i, U);
  }
  function h() {
    const {
      _bufferIndex: U,
      _index: N,
      line: O,
      column: I,
      offset: q
    } = n;
    return {
      _bufferIndex: U,
      _index: N,
      line: O,
      column: I,
      offset: q
    };
  }
  function m(U) {
    a[U.line] = U.column, B();
  }
  function y() {
    let U;
    for (; n._index < i.length; ) {
      const N = i[n._index];
      if (typeof N == "string")
        for (U = n._index, n._bufferIndex < 0 && (n._bufferIndex = 0); n._index === U && n._bufferIndex < N.length; )
          b(N.charCodeAt(n._bufferIndex));
      else
        b(N);
    }
  }
  function b(U) {
    c = c(U);
  }
  function v(U) {
    _r(U) ? (n.line++, n.column = 1, n.offset += U === -3 ? 2 : 1, B()) : U !== -1 && (n.column++, n.offset++), n._bufferIndex < 0 ? n._index++ : (n._bufferIndex++, n._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    i[n._index].length && (n._bufferIndex = -1, n._index++)), u.previous = U;
  }
  function x(U, N) {
    const O = N || {};
    return O.type = U, O.start = h(), u.events.push(["enter", O, u]), o.push(O), O;
  }
  function _(U) {
    const N = o.pop();
    return N.end = h(), u.events.push(["exit", N, u]), N;
  }
  function E(U, N) {
    k(U, N.from);
  }
  function w(U, N) {
    N.restore();
  }
  function C(U, N) {
    return O;
    function O(I, q, ae) {
      let Q, ne, le, W;
      return Array.isArray(I) ? (
        /* c8 ignore next 1 */
        G(I)
      ) : "tokenize" in I ? (
        // Looks like a construct.
        G([
          /** @type {Construct} */
          I
        ])
      ) : X(I);
      function X(pe) {
        return $;
        function $(F) {
          const ge = F !== null && pe[F], ce = F !== null && pe.null, ie = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ge) ? ge : ge ? [ge] : [],
            ...Array.isArray(ce) ? ce : ce ? [ce] : []
          ];
          return G(ie)(F);
        }
      }
      function G(pe) {
        return Q = pe, ne = 0, pe.length === 0 ? ae : P(pe[ne]);
      }
      function P(pe) {
        return $;
        function $(F) {
          return W = S(), le = pe, pe.partial || (u.currentConstruct = pe), pe.name && u.parser.constructs.disable.null.includes(pe.name) ? ye() : pe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            N ? Object.assign(Object.create(u), N) : u,
            l,
            he,
            ye
          )(F);
        }
      }
      function he(pe) {
        return U(le, W), q;
      }
      function ye(pe) {
        return W.restore(), ++ne < Q.length ? P(Q[ne]) : ae;
      }
    }
  }
  function k(U, N) {
    U.resolveAll && !s.includes(U) && s.push(U), U.resolve && qa(u.events, N, u.events.length - N, U.resolve(u.events.slice(N), u)), U.resolveTo && (u.events = U.resolveTo(u.events, u));
  }
  function S() {
    const U = h(), N = u.previous, O = u.currentConstruct, I = u.events.length, q = Array.from(o);
    return {
      from: I,
      restore: ae
    };
    function ae() {
      n = U, u.previous = N, u.currentConstruct = O, u.events.length = I, o = q, B();
    }
  }
  function B() {
    n.line in a && n.column < 2 && (n.column = a[n.line], n.offset += a[n.line] - 1);
  }
}
function Cwe(e, t) {
  const r = t.start._index, n = t.start._bufferIndex, a = t.end._index, s = t.end._bufferIndex;
  let i;
  if (r === a)
    i = [e[r].slice(n, s)];
  else {
    if (i = e.slice(r, a), n > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(n) : i.shift();
    }
    s > 0 && i.push(e[a].slice(0, s));
  }
  return i;
}
function Awe(e, t) {
  let r = -1;
  const n = [];
  let a;
  for (; ++r < e.length; ) {
    const s = e[r];
    let i;
    if (typeof s == "string")
      i = s;
    else switch (s) {
      case -5: {
        i = "\r";
        break;
      }
      case -4: {
        i = `
`;
        break;
      }
      case -3: {
        i = `\r
`;
        break;
      }
      case -2: {
        i = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && a) continue;
        i = " ";
        break;
      }
      default:
        i = String.fromCharCode(s);
    }
    a = s === -2, n.push(i);
  }
  return n.join("");
}
function Twe(e) {
  const n = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      TN([_we, ...(e || {}).extensions || []])
    ),
    content: a(iwe),
    defined: [],
    document: a(swe),
    flow: a(uwe),
    lazy: {},
    string: a(fwe),
    text: a(pwe)
  };
  return n;
  function a(s) {
    return i;
    function i(o) {
      return kwe(n, s, o);
    }
  }
}
function Rwe(e) {
  for (; !vV(e); )
    ;
  return e;
}
const GL = /[\0\t\n\r]/g;
function Iwe() {
  let e = 1, t = "", r = !0, n;
  return a;
  function a(s, i, o) {
    const l = [];
    let u, c, d, p, f;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(i || void 0).decode(s)), d = 0, t = "", r && (s.charCodeAt(0) === 65279 && d++, r = void 0); d < s.length; ) {
      if (GL.lastIndex = d, u = GL.exec(s), p = u && u.index !== void 0 ? u.index : s.length, f = s.charCodeAt(p), !u) {
        t = s.slice(d);
        break;
      }
      if (f === 10 && d === p && n)
        l.push(-3), n = void 0;
      else
        switch (n && (l.push(-5), n = void 0), d < p && (l.push(s.slice(d, p)), e += p - d), f) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, l.push(-2); e++ < c; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            n = !0, e = 1;
        }
      d = p + 1;
    }
    return o && (n && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
function ss(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? WL(e.position) : "start" in e || "end" in e ? WL(e) : "line" in e || "column" in e ? ER(e) : "";
}
function ER(e) {
  return KL(e && e.line) + ":" + KL(e && e.column);
}
function WL(e) {
  return ER(e && e.start) + "-" + ER(e && e.end);
}
function KL(e) {
  return e && typeof e == "number" ? e : 1;
}
const kV = {}.hasOwnProperty;
function Nwe(e, t, r) {
  return typeof t != "string" && (r = t, t = void 0), Dwe(r)(Rwe(Twe(r).document().write(Iwe()(e, t, !0))));
}
function Dwe(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(H),
      autolinkProtocol: S,
      autolinkEmail: S,
      atxHeading: s(Pe),
      blockQuote: s(ce),
      characterEscape: S,
      characterReference: S,
      codeFenced: s(ie),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: s(ie, i),
      codeText: s(re, i),
      codeTextData: S,
      data: S,
      codeFlowValue: S,
      definition: s(Te),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: s(V),
      hardBreakEscape: s(z),
      hardBreakTrailing: s(z),
      htmlFlow: s(A, i),
      htmlFlowData: S,
      htmlText: s(A, i),
      htmlTextData: S,
      image: s(R),
      label: i,
      link: s(H),
      listItem: s(me),
      listItemValue: p,
      listOrdered: s(be, d),
      listUnordered: s(be),
      paragraph: s(Ce),
      reference: P,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: s(Pe),
      strong: s(We),
      thematicBreak: s(we)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: E,
      autolink: l(),
      autolinkEmail: ge,
      autolinkProtocol: F,
      blockQuote: l(),
      characterEscapeValue: B,
      characterReferenceMarkerHexadecimal: ye,
      characterReferenceMarkerNumeric: ye,
      characterReferenceValue: pe,
      characterReference: $,
      codeFenced: l(y),
      codeFencedFence: m,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: h,
      codeFlowValue: B,
      codeIndented: l(b),
      codeText: l(q),
      codeTextData: B,
      data: B,
      definition: l(),
      definitionDestinationString: _,
      definitionLabelString: v,
      definitionTitleString: x,
      emphasis: l(),
      hardBreakEscape: l(N),
      hardBreakTrailing: l(N),
      htmlFlow: l(O),
      htmlFlowData: B,
      htmlText: l(I),
      htmlTextData: B,
      image: l(Q),
      label: le,
      labelText: ne,
      lineEnding: U,
      link: l(ae),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: he,
      resourceDestinationString: W,
      resourceTitleString: X,
      resource: G,
      setextHeading: l(k),
      setextHeadingLineSequence: C,
      setextHeadingText: w,
      strong: l(),
      thematicBreak: l()
    }
  };
  CV(t, (e || {}).mdastExtensions || []);
  const r = {};
  return n;
  function n(te) {
    let Fe = {
      type: "root",
      children: []
    };
    const Y = {
      stack: [Fe],
      tokenStack: [],
      config: t,
      enter: o,
      exit: u,
      buffer: i,
      resume: c,
      data: r
    }, Je = [];
    let xt = -1;
    for (; ++xt < te.length; )
      if (te[xt][1].type === "listOrdered" || te[xt][1].type === "listUnordered")
        if (te[xt][0] === "enter")
          Je.push(xt);
        else {
          const Ze = Je.pop();
          xt = a(te, Ze, xt);
        }
    for (xt = -1; ++xt < te.length; ) {
      const Ze = t[te[xt][0]];
      kV.call(Ze, te[xt][1].type) && Ze[te[xt][1].type].call(Object.assign({
        sliceSerialize: te[xt][2].sliceSerialize
      }, Y), te[xt][1]);
    }
    if (Y.tokenStack.length > 0) {
      const Ze = Y.tokenStack[Y.tokenStack.length - 1];
      (Ze[1] || YL).call(Y, void 0, Ze[0]);
    }
    for (Fe.position = {
      start: yl(te.length > 0 ? te[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: yl(te.length > 0 ? te[te.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, xt = -1; ++xt < t.transforms.length; )
      Fe = t.transforms[xt](Fe) || Fe;
    return Fe;
  }
  function a(te, Fe, Y) {
    let Je = Fe - 1, xt = -1, Ze = !1, rt, Mt, Qt, kr;
    for (; ++Je <= Y; ) {
      const tr = te[Je];
      switch (tr[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          tr[0] === "enter" ? xt++ : xt--, kr = void 0;
          break;
        }
        case "lineEndingBlank": {
          tr[0] === "enter" && (rt && !kr && !xt && !Qt && (Qt = Je), kr = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          kr = void 0;
      }
      if (!xt && tr[0] === "enter" && tr[1].type === "listItemPrefix" || xt === -1 && tr[0] === "exit" && (tr[1].type === "listUnordered" || tr[1].type === "listOrdered")) {
        if (rt) {
          let Oe = Je;
          for (Mt = void 0; Oe--; ) {
            const Ie = te[Oe];
            if (Ie[1].type === "lineEnding" || Ie[1].type === "lineEndingBlank") {
              if (Ie[0] === "exit") continue;
              Mt && (te[Mt][1].type = "lineEndingBlank", Ze = !0), Ie[1].type = "lineEnding", Mt = Oe;
            } else if (!(Ie[1].type === "linePrefix" || Ie[1].type === "blockQuotePrefix" || Ie[1].type === "blockQuotePrefixWhitespace" || Ie[1].type === "blockQuoteMarker" || Ie[1].type === "listItemIndent")) break;
          }
          Qt && (!Mt || Qt < Mt) && (rt._spread = !0), rt.end = Object.assign({}, Mt ? te[Mt][1].start : tr[1].end), te.splice(Mt || Je, 0, ["exit", rt, tr[2]]), Je++, Y++;
        }
        if (tr[1].type === "listItemPrefix") {
          const Oe = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, tr[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          rt = Oe, te.splice(Je, 0, ["enter", Oe, tr[2]]), Je++, Y++, Qt = void 0, kr = !0;
        }
      }
    }
    return te[Fe][1]._spread = Ze, Y;
  }
  function s(te, Fe) {
    return Y;
    function Y(Je) {
      o.call(this, te(Je), Je), Fe && Fe.call(this, Je);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(te, Fe, Y) {
    this.stack[this.stack.length - 1].children.push(te), this.stack.push(te), this.tokenStack.push([Fe, Y || void 0]), te.position = {
      start: yl(Fe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(te) {
    return Fe;
    function Fe(Y) {
      te && te.call(this, Y), u.call(this, Y);
    }
  }
  function u(te, Fe) {
    const Y = this.stack.pop(), Je = this.tokenStack.pop();
    if (Je)
      Je[0].type !== te.type && (Fe ? Fe.call(this, te, Je[0]) : (Je[1] || YL).call(this, te, Je[0]));
    else throw new Error("Cannot close `" + te.type + "` (" + ss({
      start: te.start,
      end: te.end
    }) + "): it’s not open");
    Y.position.end = yl(te.end);
  }
  function c() {
    return CN(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(te) {
    if (this.data.expectingFirstListItemValue) {
      const Fe = this.stack[this.stack.length - 2];
      Fe.start = Number.parseInt(this.sliceSerialize(te), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.lang = te;
  }
  function h() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.meta = te;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.value = te.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.value = te.replace(/(\r?\n|\r)$/g, "");
  }
  function v(te) {
    const Fe = this.resume(), Y = this.stack[this.stack.length - 1];
    Y.label = Fe, Y.identifier = Ms(this.sliceSerialize(te)).toLowerCase();
  }
  function x() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.title = te;
  }
  function _() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.url = te;
  }
  function E(te) {
    const Fe = this.stack[this.stack.length - 1];
    if (!Fe.depth) {
      const Y = this.sliceSerialize(te).length;
      Fe.depth = Y;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function C(te) {
    const Fe = this.stack[this.stack.length - 1];
    Fe.depth = this.sliceSerialize(te).codePointAt(0) === 61 ? 1 : 2;
  }
  function k() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function S(te) {
    const Y = this.stack[this.stack.length - 1].children;
    let Je = Y[Y.length - 1];
    (!Je || Je.type !== "text") && (Je = xe(), Je.position = {
      start: yl(te.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, Y.push(Je)), this.stack.push(Je);
  }
  function B(te) {
    const Fe = this.stack.pop();
    Fe.value += this.sliceSerialize(te), Fe.position.end = yl(te.end);
  }
  function U(te) {
    const Fe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Y = Fe.children[Fe.children.length - 1];
      Y.position.end = yl(te.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(Fe.type) && (S.call(this, te), B.call(this, te));
  }
  function N() {
    this.data.atHardBreak = !0;
  }
  function O() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.value = te;
  }
  function I() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.value = te;
  }
  function q() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.value = te;
  }
  function ae() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Fe = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = Fe, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function Q() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Fe = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = Fe, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function ne(te) {
    const Fe = this.sliceSerialize(te), Y = this.stack[this.stack.length - 2];
    Y.label = Wye(Fe), Y.identifier = Ms(Fe).toLowerCase();
  }
  function le() {
    const te = this.stack[this.stack.length - 1], Fe = this.resume(), Y = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Y.type === "link") {
      const Je = te.children;
      Y.children = Je;
    } else
      Y.alt = Fe;
  }
  function W() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.url = te;
  }
  function X() {
    const te = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.title = te;
  }
  function G() {
    this.data.inReference = void 0;
  }
  function P() {
    this.data.referenceType = "collapsed";
  }
  function he(te) {
    const Fe = this.resume(), Y = this.stack[this.stack.length - 1];
    Y.label = Fe, Y.identifier = Ms(this.sliceSerialize(te)).toLowerCase(), this.data.referenceType = "full";
  }
  function ye(te) {
    this.data.characterReferenceType = te.type;
  }
  function pe(te) {
    const Fe = this.sliceSerialize(te), Y = this.data.characterReferenceType;
    let Je;
    Y ? (Je = oV(Fe, Y === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Je = Hp(Fe);
    const xt = this.stack[this.stack.length - 1];
    xt.value += Je;
  }
  function $(te) {
    const Fe = this.stack.pop();
    Fe.position.end = yl(te.end);
  }
  function F(te) {
    B.call(this, te);
    const Fe = this.stack[this.stack.length - 1];
    Fe.url = this.sliceSerialize(te);
  }
  function ge(te) {
    B.call(this, te);
    const Fe = this.stack[this.stack.length - 1];
    Fe.url = "mailto:" + this.sliceSerialize(te);
  }
  function ce() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ie() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function re() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Te() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function V() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Pe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function z() {
    return {
      type: "break"
    };
  }
  function A() {
    return {
      type: "html",
      value: ""
    };
  }
  function R() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function H() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function be(te) {
    return {
      type: "list",
      ordered: te.type === "listOrdered",
      start: null,
      spread: te._spread,
      children: []
    };
  }
  function me(te) {
    return {
      type: "listItem",
      spread: te._spread,
      checked: null,
      children: []
    };
  }
  function Ce() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function We() {
    return {
      type: "strong",
      children: []
    };
  }
  function xe() {
    return {
      type: "text",
      value: ""
    };
  }
  function we() {
    return {
      type: "thematicBreak"
    };
  }
}
function yl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function CV(e, t) {
  let r = -1;
  for (; ++r < t.length; ) {
    const n = t[r];
    Array.isArray(n) ? CV(e, n) : Owe(e, n);
  }
}
function Owe(e, t) {
  let r;
  for (r in t)
    if (kV.call(t, r))
      switch (r) {
        case "canContainEols": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "transforms": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "enter":
        case "exit": {
          const n = t[r];
          n && Object.assign(e[r], n);
          break;
        }
      }
}
function YL(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + ss({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + ss({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + ss({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function DN(e) {
  const t = this;
  t.parser = r;
  function r(n) {
    return Nwe(n, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
const Pwe = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(e) {
    return Lwe(e);
  }
);
function Lwe(e) {
  return Mwe(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Mwe(e) {
  return t;
  function t(r, ...n) {
    return !!(r && typeof r == "object" && "type" in r && e.call(this, r, ...n));
  }
}
const Fwe = !0, XL = !1, $we = "skip", Bwe = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, n) {
    const a = Pwe(t), s = 1;
    i(e, void 0, [])();
    function i(o, l, u) {
      const c = o && typeof o == "object" ? o : {};
      if (typeof c.type == "string") {
        const p = (
          // `hast`
          typeof c.tagName == "string" ? c.tagName : (
            // `xast`
            typeof c.name == "string" ? c.name : void 0
          )
        );
        Object.defineProperty(d, "name", {
          value: "node (" + (o.type + (p ? "<" + p + ">" : "")) + ")"
        });
      }
      return d;
      function d() {
        let p = [], f, h, m;
        if (a(o, l, u[u.length - 1] || null) && (p = Uwe(r(o, u)), p[0] === XL))
          return p;
        if (o.children && p[0] !== $we)
          for (h = -1 + s, m = u.concat(o); h > -1 && h < o.children.length; ) {
            if (f = i(o.children[h], h, m)(), f[0] === XL)
              return f;
            h = typeof f[1] == "number" ? f[1] : h + s;
          }
        return p;
      }
    }
  }
);
function Uwe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Fwe, e] : [e];
}
const zwe = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, n) {
    Bwe(e, t, a);
    function a(s, i) {
      const o = i[i.length - 1];
      return r(
        s,
        o ? o.children.indexOf(s) : null,
        o
      );
    }
  }
);
var qwe = Object.defineProperty, jwe = Object.defineProperties, Hwe = Object.getOwnPropertyDescriptors, ZL = Object.getOwnPropertySymbols, Vwe = Object.prototype.hasOwnProperty, Gwe = Object.prototype.propertyIsEnumerable, SR = (e, t, r) => t in e ? qwe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, wn = (e, t) => {
  for (var r in t || (t = {}))
    Vwe.call(t, r) && SR(e, r, t[r]);
  if (ZL)
    for (var r of ZL(t))
      Gwe.call(t, r) && SR(e, r, t[r]);
  return e;
}, ud = (e, t) => jwe(e, Hwe(t)), st = (e, t, r) => (SR(e, typeof t != "symbol" ? t + "" : t, r), r), bm = (e, t, r) => new Promise((n, a) => {
  var s = (l) => {
    try {
      o(r.next(l));
    } catch (u) {
      a(u);
    }
  }, i = (l) => {
    try {
      o(r.throw(l));
    } catch (u) {
      a(u);
    }
  }, o = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(s, i);
  o((r = r.apply(e, t)).next());
});
class Wg {
  constructor(t) {
    st(this, "rootKey"), this.rootKey = t;
  }
}
const Wwe = Object.seal({});
class nt extends Wg {
  constructor(t) {
    super(t), st(this, "root"), this.root = new Array();
  }
  // This method is called by the formatter to get the XML representation of this component.
  // It is called recursively for all child components.
  // It is a serializer to be used in the xml library.
  // https://www.npmjs.com/package/xml
  // Child components can override this method to customize the XML representation, or execute side effects.
  prepForXml(t) {
    var r;
    t.stack.push(this);
    const n = this.root.map((a) => a instanceof Wg ? a.prepForXml(t) : a).filter((a) => a !== void 0);
    return t.stack.pop(), {
      [this.rootKey]: n.length ? n.length === 1 && ((r = n[0]) != null && r._attr) ? n[0] : n : Wwe
    };
  }
  /**
   * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.
   */
  addChildElement(t) {
    return this.root.push(t), this;
  }
}
class Zo extends nt {
  prepForXml(t) {
    const r = super.prepForXml(t);
    if (r && (typeof r[this.rootKey] != "object" || Object.keys(r[this.rootKey]).length))
      return r;
  }
}
class er extends Wg {
  constructor(t) {
    super("_attr"), st(this, "xmlKeys"), this.root = t;
  }
  prepForXml(t) {
    const r = {};
    return Object.keys(this.root).forEach((n) => {
      const a = this.root[n];
      if (a !== void 0) {
        const s = this.xmlKeys && this.xmlKeys[n] || n;
        r[s] = a;
      }
    }), { _attr: r };
  }
}
class Jo extends Wg {
  constructor(t) {
    super("_attr"), this.root = t;
  }
  prepForXml(t) {
    return { _attr: Object.values(this.root).filter(({ value: n }) => n !== void 0).reduce((n, { key: a, value: s }) => ud(wn({}, n), { [a]: s }), {}) };
  }
}
class oi extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      val: "w:val",
      color: "w:color",
      fill: "w:fill",
      space: "w:space",
      sz: "w:sz",
      type: "w:type",
      rsidR: "w:rsidR",
      rsidRPr: "w:rsidRPr",
      rsidSect: "w:rsidSect",
      w: "w:w",
      h: "w:h",
      top: "w:top",
      right: "w:right",
      bottom: "w:bottom",
      left: "w:left",
      header: "w:header",
      footer: "w:footer",
      gutter: "w:gutter",
      linePitch: "w:linePitch",
      pos: "w:pos"
    });
  }
}
var no = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function AV(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var TV = {}, ON = { exports: {} }, Wc = typeof Reflect == "object" ? Reflect : null, JL = Wc && typeof Wc.apply == "function" ? Wc.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, dg;
Wc && typeof Wc.ownKeys == "function" ? dg = Wc.ownKeys : Object.getOwnPropertySymbols ? dg = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : dg = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Kwe(e) {
  console && console.warn && console.warn(e);
}
var RV = Number.isNaN || function(t) {
  return t !== t;
};
function $n() {
  $n.init.call(this);
}
ON.exports = $n;
ON.exports.once = Jwe;
$n.EventEmitter = $n;
$n.prototype._events = void 0;
$n.prototype._eventsCount = 0;
$n.prototype._maxListeners = void 0;
var QL = 10;
function oy(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty($n, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return QL;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || RV(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    QL = e;
  }
});
$n.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
$n.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || RV(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function IV(e) {
  return e._maxListeners === void 0 ? $n.defaultMaxListeners : e._maxListeners;
}
$n.prototype.getMaxListeners = function() {
  return IV(this);
};
$n.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var a = t === "error", s = this._events;
  if (s !== void 0)
    a = a && s.error === void 0;
  else if (!a)
    return !1;
  if (a) {
    var i;
    if (r.length > 0 && (i = r[0]), i instanceof Error)
      throw i;
    var o = new Error("Unhandled error." + (i ? " (" + i.message + ")" : ""));
    throw o.context = i, o;
  }
  var l = s[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    JL(l, this, r);
  else
    for (var u = l.length, c = LV(l, u), n = 0; n < u; ++n)
      JL(c[n], this, r);
  return !0;
};
function NV(e, t, r, n) {
  var a, s, i;
  if (oy(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), i = s[t]), i === void 0)
    i = s[t] = r, ++e._eventsCount;
  else if (typeof i == "function" ? i = s[t] = n ? [r, i] : [i, r] : n ? i.unshift(r) : i.push(r), a = IV(e), a > 0 && i.length > a && !i.warned) {
    i.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + i.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = e, o.type = t, o.count = i.length, Kwe(o);
  }
  return e;
}
$n.prototype.addListener = function(t, r) {
  return NV(this, t, r, !1);
};
$n.prototype.on = $n.prototype.addListener;
$n.prototype.prependListener = function(t, r) {
  return NV(this, t, r, !0);
};
function Ywe() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function DV(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, a = Ywe.bind(n);
  return a.listener = r, n.wrapFn = a, a;
}
$n.prototype.once = function(t, r) {
  return oy(r), this.on(t, DV(this, t, r)), this;
};
$n.prototype.prependOnceListener = function(t, r) {
  return oy(r), this.prependListener(t, DV(this, t, r)), this;
};
$n.prototype.removeListener = function(t, r) {
  var n, a, s, i, o;
  if (oy(r), a = this._events, a === void 0)
    return this;
  if (n = a[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete a[t], a.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, i = n.length - 1; i >= 0; i--)
      if (n[i] === r || n[i].listener === r) {
        o = n[i].listener, s = i;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : Xwe(n, s), n.length === 1 && (a[t] = n[0]), a.removeListener !== void 0 && this.emit("removeListener", t, o || r);
  }
  return this;
};
$n.prototype.off = $n.prototype.removeListener;
$n.prototype.removeAllListeners = function(t) {
  var r, n, a;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), i;
    for (a = 0; a < s.length; ++a)
      i = s[a], i !== "removeListener" && this.removeAllListeners(i);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (a = r.length - 1; a >= 0; a--)
      this.removeListener(t, r[a]);
  return this;
};
function OV(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var a = n[t];
  return a === void 0 ? [] : typeof a == "function" ? r ? [a.listener || a] : [a] : r ? Zwe(a) : LV(a, a.length);
}
$n.prototype.listeners = function(t) {
  return OV(this, t, !0);
};
$n.prototype.rawListeners = function(t) {
  return OV(this, t, !1);
};
$n.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : PV.call(e, t);
};
$n.prototype.listenerCount = PV;
function PV(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
$n.prototype.eventNames = function() {
  return this._eventsCount > 0 ? dg(this._events) : [];
};
function LV(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function Xwe(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Zwe(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function Jwe(e, t) {
  return new Promise(function(r, n) {
    function a(i) {
      e.removeListener(t, s), n(i);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", a), r([].slice.call(arguments));
    }
    MV(e, t, s, { once: !0 }), t !== "error" && Qwe(e, a, { once: !0 });
  });
}
function Qwe(e, t, r) {
  typeof e.on == "function" && MV(e, "error", t, r);
}
function MV(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function a(s) {
      n.once && e.removeEventListener(t, a), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var PN = ON.exports, _R = { exports: {} };
typeof Object.create == "function" ? _R.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : _R.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var Hu = _R.exports;
function e1e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var FV = { exports: {} }, fi = FV.exports = {}, Js, Qs;
function kR() {
  throw new Error("setTimeout has not been defined");
}
function CR() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Js = setTimeout : Js = kR;
  } catch {
    Js = kR;
  }
  try {
    typeof clearTimeout == "function" ? Qs = clearTimeout : Qs = CR;
  } catch {
    Qs = CR;
  }
})();
function $V(e) {
  if (Js === setTimeout)
    return setTimeout(e, 0);
  if ((Js === kR || !Js) && setTimeout)
    return Js = setTimeout, setTimeout(e, 0);
  try {
    return Js(e, 0);
  } catch {
    try {
      return Js.call(null, e, 0);
    } catch {
      return Js.call(this, e, 0);
    }
  }
}
function t1e(e) {
  if (Qs === clearTimeout)
    return clearTimeout(e);
  if ((Qs === CR || !Qs) && clearTimeout)
    return Qs = clearTimeout, clearTimeout(e);
  try {
    return Qs(e);
  } catch {
    try {
      return Qs.call(null, e);
    } catch {
      return Qs.call(this, e);
    }
  }
}
var Lo = [], Kc = !1, mu, fg = -1;
function r1e() {
  !Kc || !mu || (Kc = !1, mu.length ? Lo = mu.concat(Lo) : fg = -1, Lo.length && BV());
}
function BV() {
  if (!Kc) {
    var e = $V(r1e);
    Kc = !0;
    for (var t = Lo.length; t; ) {
      for (mu = Lo, Lo = []; ++fg < t; )
        mu && mu[fg].run();
      fg = -1, t = Lo.length;
    }
    mu = null, Kc = !1, t1e(e);
  }
}
fi.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Lo.push(new UV(e, t)), Lo.length === 1 && !Kc && $V(BV);
};
function UV(e, t) {
  this.fun = e, this.array = t;
}
UV.prototype.run = function() {
  this.fun.apply(null, this.array);
};
fi.title = "browser";
fi.browser = !0;
fi.env = {};
fi.argv = [];
fi.version = "";
fi.versions = {};
function Qo() {
}
fi.on = Qo;
fi.addListener = Qo;
fi.once = Qo;
fi.off = Qo;
fi.removeListener = Qo;
fi.removeAllListeners = Qo;
fi.emit = Qo;
fi.prependListener = Qo;
fi.prependOnceListener = Qo;
fi.listeners = function(e) {
  return [];
};
fi.binding = function(e) {
  throw new Error("process.binding is not supported");
};
fi.cwd = function() {
  return "/";
};
fi.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
fi.umask = function() {
  return 0;
};
var n1e = FV.exports;
const an = /* @__PURE__ */ e1e(n1e);
var z1, eM;
function zV() {
  return eM || (eM = 1, z1 = PN.EventEmitter), z1;
}
var q1 = {}, mf = {}, tM;
function i1e() {
  if (tM)
    return mf;
  tM = 1, mf.byteLength = o, mf.toByteArray = u, mf.fromByteArray = p;
  for (var e = [], t = [], r = typeof Uint8Array < "u" ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, s = n.length; a < s; ++a)
    e[a] = n[a], t[n.charCodeAt(a)] = a;
  t[45] = 62, t[95] = 63;
  function i(f) {
    var h = f.length;
    if (h % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var m = f.indexOf("=");
    m === -1 && (m = h);
    var y = m === h ? 0 : 4 - m % 4;
    return [m, y];
  }
  function o(f) {
    var h = i(f), m = h[0], y = h[1];
    return (m + y) * 3 / 4 - y;
  }
  function l(f, h, m) {
    return (h + m) * 3 / 4 - m;
  }
  function u(f) {
    var h, m = i(f), y = m[0], b = m[1], v = new r(l(f, y, b)), x = 0, _ = b > 0 ? y - 4 : y, E;
    for (E = 0; E < _; E += 4)
      h = t[f.charCodeAt(E)] << 18 | t[f.charCodeAt(E + 1)] << 12 | t[f.charCodeAt(E + 2)] << 6 | t[f.charCodeAt(E + 3)], v[x++] = h >> 16 & 255, v[x++] = h >> 8 & 255, v[x++] = h & 255;
    return b === 2 && (h = t[f.charCodeAt(E)] << 2 | t[f.charCodeAt(E + 1)] >> 4, v[x++] = h & 255), b === 1 && (h = t[f.charCodeAt(E)] << 10 | t[f.charCodeAt(E + 1)] << 4 | t[f.charCodeAt(E + 2)] >> 2, v[x++] = h >> 8 & 255, v[x++] = h & 255), v;
  }
  function c(f) {
    return e[f >> 18 & 63] + e[f >> 12 & 63] + e[f >> 6 & 63] + e[f & 63];
  }
  function d(f, h, m) {
    for (var y, b = [], v = h; v < m; v += 3)
      y = (f[v] << 16 & 16711680) + (f[v + 1] << 8 & 65280) + (f[v + 2] & 255), b.push(c(y));
    return b.join("");
  }
  function p(f) {
    for (var h, m = f.length, y = m % 3, b = [], v = 16383, x = 0, _ = m - y; x < _; x += v)
      b.push(d(f, x, x + v > _ ? _ : x + v));
    return y === 1 ? (h = f[m - 1], b.push(
      e[h >> 2] + e[h << 4 & 63] + "=="
    )) : y === 2 && (h = (f[m - 2] << 8) + f[m - 1], b.push(
      e[h >> 10] + e[h >> 4 & 63] + e[h << 2 & 63] + "="
    )), b.join("");
  }
  return mf;
}
var ym = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var rM;
function a1e() {
  return rM || (rM = 1, ym.read = function(e, t, r, n, a) {
    var s, i, o = a * 8 - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, d = r ? a - 1 : 0, p = r ? -1 : 1, f = e[t + d];
    for (d += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = s * 256 + e[t + d], d += p, c -= 8)
      ;
    for (i = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; i = i * 256 + e[t + d], d += p, c -= 8)
      ;
    if (s === 0)
      s = 1 - u;
    else {
      if (s === l)
        return i ? NaN : (f ? -1 : 1) * (1 / 0);
      i = i + Math.pow(2, n), s = s - u;
    }
    return (f ? -1 : 1) * i * Math.pow(2, s - n);
  }, ym.write = function(e, t, r, n, a, s) {
    var i, o, l, u = s * 8 - a - 1, c = (1 << u) - 1, d = c >> 1, p = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : s - 1, h = n ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, i = c) : (i = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -i)) < 1 && (i--, l *= 2), i + d >= 1 ? t += p / l : t += p * Math.pow(2, 1 - d), t * l >= 2 && (i++, l /= 2), i + d >= c ? (o = 0, i = c) : i + d >= 1 ? (o = (t * l - 1) * Math.pow(2, a), i = i + d) : (o = t * Math.pow(2, d - 1) * Math.pow(2, a), i = 0)); a >= 8; e[r + f] = o & 255, f += h, o /= 256, a -= 8)
      ;
    for (i = i << a | o, u += a; u > 0; e[r + f] = i & 255, f += h, i /= 256, u -= 8)
      ;
    e[r + f - h] |= m * 128;
  }), ym;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var nM;
function ly() {
  return nM || (nM = 1, function(e) {
    var t = i1e(), r = a1e(), n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = o, e.SlowBuffer = v, e.INSPECT_MAX_BYTES = 50;
    var a = 2147483647;
    e.kMaxLength = a, o.TYPED_ARRAY_SUPPORT = s(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function s() {
      try {
        var z = new Uint8Array(1), A = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(A, Uint8Array.prototype), Object.setPrototypeOf(z, A), z.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function i(z) {
      if (z > a)
        throw new RangeError('The value "' + z + '" is invalid for option "size"');
      var A = new Uint8Array(z);
      return Object.setPrototypeOf(A, o.prototype), A;
    }
    function o(z, A, R) {
      if (typeof z == "number") {
        if (typeof A == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return d(z);
      }
      return l(z, A, R);
    }
    o.poolSize = 8192;
    function l(z, A, R) {
      if (typeof z == "string")
        return p(z, A);
      if (ArrayBuffer.isView(z))
        return h(z);
      if (z == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof z
        );
      if (Te(z, ArrayBuffer) || z && Te(z.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Te(z, SharedArrayBuffer) || z && Te(z.buffer, SharedArrayBuffer)))
        return m(z, A, R);
      if (typeof z == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var H = z.valueOf && z.valueOf();
      if (H != null && H !== z)
        return o.from(H, A, R);
      var be = y(z);
      if (be)
        return be;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof z[Symbol.toPrimitive] == "function")
        return o.from(
          z[Symbol.toPrimitive]("string"),
          A,
          R
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof z
      );
    }
    o.from = function(z, A, R) {
      return l(z, A, R);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function u(z) {
      if (typeof z != "number")
        throw new TypeError('"size" argument must be of type number');
      if (z < 0)
        throw new RangeError('The value "' + z + '" is invalid for option "size"');
    }
    function c(z, A, R) {
      return u(z), z <= 0 ? i(z) : A !== void 0 ? typeof R == "string" ? i(z).fill(A, R) : i(z).fill(A) : i(z);
    }
    o.alloc = function(z, A, R) {
      return c(z, A, R);
    };
    function d(z) {
      return u(z), i(z < 0 ? 0 : b(z) | 0);
    }
    o.allocUnsafe = function(z) {
      return d(z);
    }, o.allocUnsafeSlow = function(z) {
      return d(z);
    };
    function p(z, A) {
      if ((typeof A != "string" || A === "") && (A = "utf8"), !o.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      var R = x(z, A) | 0, H = i(R), be = H.write(z, A);
      return be !== R && (H = H.slice(0, be)), H;
    }
    function f(z) {
      for (var A = z.length < 0 ? 0 : b(z.length) | 0, R = i(A), H = 0; H < A; H += 1)
        R[H] = z[H] & 255;
      return R;
    }
    function h(z) {
      if (Te(z, Uint8Array)) {
        var A = new Uint8Array(z);
        return m(A.buffer, A.byteOffset, A.byteLength);
      }
      return f(z);
    }
    function m(z, A, R) {
      if (A < 0 || z.byteLength < A)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (z.byteLength < A + (R || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var H;
      return A === void 0 && R === void 0 ? H = new Uint8Array(z) : R === void 0 ? H = new Uint8Array(z, A) : H = new Uint8Array(z, A, R), Object.setPrototypeOf(H, o.prototype), H;
    }
    function y(z) {
      if (o.isBuffer(z)) {
        var A = b(z.length) | 0, R = i(A);
        return R.length === 0 || z.copy(R, 0, 0, A), R;
      }
      if (z.length !== void 0)
        return typeof z.length != "number" || V(z.length) ? i(0) : f(z);
      if (z.type === "Buffer" && Array.isArray(z.data))
        return f(z.data);
    }
    function b(z) {
      if (z >= a)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
      return z | 0;
    }
    function v(z) {
      return +z != z && (z = 0), o.alloc(+z);
    }
    o.isBuffer = function(A) {
      return A != null && A._isBuffer === !0 && A !== o.prototype;
    }, o.compare = function(A, R) {
      if (Te(A, Uint8Array) && (A = o.from(A, A.offset, A.byteLength)), Te(R, Uint8Array) && (R = o.from(R, R.offset, R.byteLength)), !o.isBuffer(A) || !o.isBuffer(R))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (A === R)
        return 0;
      for (var H = A.length, be = R.length, me = 0, Ce = Math.min(H, be); me < Ce; ++me)
        if (A[me] !== R[me]) {
          H = A[me], be = R[me];
          break;
        }
      return H < be ? -1 : be < H ? 1 : 0;
    }, o.isEncoding = function(A) {
      switch (String(A).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(A, R) {
      if (!Array.isArray(A))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (A.length === 0)
        return o.alloc(0);
      var H;
      if (R === void 0)
        for (R = 0, H = 0; H < A.length; ++H)
          R += A[H].length;
      var be = o.allocUnsafe(R), me = 0;
      for (H = 0; H < A.length; ++H) {
        var Ce = A[H];
        if (Te(Ce, Uint8Array))
          me + Ce.length > be.length ? o.from(Ce).copy(be, me) : Uint8Array.prototype.set.call(
            be,
            Ce,
            me
          );
        else if (o.isBuffer(Ce))
          Ce.copy(be, me);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        me += Ce.length;
      }
      return be;
    };
    function x(z, A) {
      if (o.isBuffer(z))
        return z.length;
      if (ArrayBuffer.isView(z) || Te(z, ArrayBuffer))
        return z.byteLength;
      if (typeof z != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof z
        );
      var R = z.length, H = arguments.length > 2 && arguments[2] === !0;
      if (!H && R === 0)
        return 0;
      for (var be = !1; ; )
        switch (A) {
          case "ascii":
          case "latin1":
          case "binary":
            return R;
          case "utf8":
          case "utf-8":
            return F(z).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return R * 2;
          case "hex":
            return R >>> 1;
          case "base64":
            return ie(z).length;
          default:
            if (be)
              return H ? -1 : F(z).length;
            A = ("" + A).toLowerCase(), be = !0;
        }
    }
    o.byteLength = x;
    function _(z, A, R) {
      var H = !1;
      if ((A === void 0 || A < 0) && (A = 0), A > this.length || ((R === void 0 || R > this.length) && (R = this.length), R <= 0) || (R >>>= 0, A >>>= 0, R <= A))
        return "";
      for (z || (z = "utf8"); ; )
        switch (z) {
          case "hex":
            return le(this, A, R);
          case "utf8":
          case "utf-8":
            return I(this, A, R);
          case "ascii":
            return Q(this, A, R);
          case "latin1":
          case "binary":
            return ne(this, A, R);
          case "base64":
            return O(this, A, R);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return W(this, A, R);
          default:
            if (H)
              throw new TypeError("Unknown encoding: " + z);
            z = (z + "").toLowerCase(), H = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function E(z, A, R) {
      var H = z[A];
      z[A] = z[R], z[R] = H;
    }
    o.prototype.swap16 = function() {
      var A = this.length;
      if (A % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var R = 0; R < A; R += 2)
        E(this, R, R + 1);
      return this;
    }, o.prototype.swap32 = function() {
      var A = this.length;
      if (A % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var R = 0; R < A; R += 4)
        E(this, R, R + 3), E(this, R + 1, R + 2);
      return this;
    }, o.prototype.swap64 = function() {
      var A = this.length;
      if (A % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var R = 0; R < A; R += 8)
        E(this, R, R + 7), E(this, R + 1, R + 6), E(this, R + 2, R + 5), E(this, R + 3, R + 4);
      return this;
    }, o.prototype.toString = function() {
      var A = this.length;
      return A === 0 ? "" : arguments.length === 0 ? I(this, 0, A) : _.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(A) {
      if (!o.isBuffer(A))
        throw new TypeError("Argument must be a Buffer");
      return this === A ? !0 : o.compare(this, A) === 0;
    }, o.prototype.inspect = function() {
      var A = "", R = e.INSPECT_MAX_BYTES;
      return A = this.toString("hex", 0, R).replace(/(.{2})/g, "$1 ").trim(), this.length > R && (A += " ... "), "<Buffer " + A + ">";
    }, n && (o.prototype[n] = o.prototype.inspect), o.prototype.compare = function(A, R, H, be, me) {
      if (Te(A, Uint8Array) && (A = o.from(A, A.offset, A.byteLength)), !o.isBuffer(A))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof A
        );
      if (R === void 0 && (R = 0), H === void 0 && (H = A ? A.length : 0), be === void 0 && (be = 0), me === void 0 && (me = this.length), R < 0 || H > A.length || be < 0 || me > this.length)
        throw new RangeError("out of range index");
      if (be >= me && R >= H)
        return 0;
      if (be >= me)
        return -1;
      if (R >= H)
        return 1;
      if (R >>>= 0, H >>>= 0, be >>>= 0, me >>>= 0, this === A)
        return 0;
      for (var Ce = me - be, We = H - R, xe = Math.min(Ce, We), we = this.slice(be, me), te = A.slice(R, H), Fe = 0; Fe < xe; ++Fe)
        if (we[Fe] !== te[Fe]) {
          Ce = we[Fe], We = te[Fe];
          break;
        }
      return Ce < We ? -1 : We < Ce ? 1 : 0;
    };
    function w(z, A, R, H, be) {
      if (z.length === 0)
        return -1;
      if (typeof R == "string" ? (H = R, R = 0) : R > 2147483647 ? R = 2147483647 : R < -2147483648 && (R = -2147483648), R = +R, V(R) && (R = be ? 0 : z.length - 1), R < 0 && (R = z.length + R), R >= z.length) {
        if (be)
          return -1;
        R = z.length - 1;
      } else if (R < 0)
        if (be)
          R = 0;
        else
          return -1;
      if (typeof A == "string" && (A = o.from(A, H)), o.isBuffer(A))
        return A.length === 0 ? -1 : C(z, A, R, H, be);
      if (typeof A == "number")
        return A = A & 255, typeof Uint8Array.prototype.indexOf == "function" ? be ? Uint8Array.prototype.indexOf.call(z, A, R) : Uint8Array.prototype.lastIndexOf.call(z, A, R) : C(z, [A], R, H, be);
      throw new TypeError("val must be string, number or Buffer");
    }
    function C(z, A, R, H, be) {
      var me = 1, Ce = z.length, We = A.length;
      if (H !== void 0 && (H = String(H).toLowerCase(), H === "ucs2" || H === "ucs-2" || H === "utf16le" || H === "utf-16le")) {
        if (z.length < 2 || A.length < 2)
          return -1;
        me = 2, Ce /= 2, We /= 2, R /= 2;
      }
      function xe(Je, xt) {
        return me === 1 ? Je[xt] : Je.readUInt16BE(xt * me);
      }
      var we;
      if (be) {
        var te = -1;
        for (we = R; we < Ce; we++)
          if (xe(z, we) === xe(A, te === -1 ? 0 : we - te)) {
            if (te === -1 && (te = we), we - te + 1 === We)
              return te * me;
          } else
            te !== -1 && (we -= we - te), te = -1;
      } else
        for (R + We > Ce && (R = Ce - We), we = R; we >= 0; we--) {
          for (var Fe = !0, Y = 0; Y < We; Y++)
            if (xe(z, we + Y) !== xe(A, Y)) {
              Fe = !1;
              break;
            }
          if (Fe)
            return we;
        }
      return -1;
    }
    o.prototype.includes = function(A, R, H) {
      return this.indexOf(A, R, H) !== -1;
    }, o.prototype.indexOf = function(A, R, H) {
      return w(this, A, R, H, !0);
    }, o.prototype.lastIndexOf = function(A, R, H) {
      return w(this, A, R, H, !1);
    };
    function k(z, A, R, H) {
      R = Number(R) || 0;
      var be = z.length - R;
      H ? (H = Number(H), H > be && (H = be)) : H = be;
      var me = A.length;
      H > me / 2 && (H = me / 2);
      for (var Ce = 0; Ce < H; ++Ce) {
        var We = parseInt(A.substr(Ce * 2, 2), 16);
        if (V(We))
          return Ce;
        z[R + Ce] = We;
      }
      return Ce;
    }
    function S(z, A, R, H) {
      return re(F(A, z.length - R), z, R, H);
    }
    function B(z, A, R, H) {
      return re(ge(A), z, R, H);
    }
    function U(z, A, R, H) {
      return re(ie(A), z, R, H);
    }
    function N(z, A, R, H) {
      return re(ce(A, z.length - R), z, R, H);
    }
    o.prototype.write = function(A, R, H, be) {
      if (R === void 0)
        be = "utf8", H = this.length, R = 0;
      else if (H === void 0 && typeof R == "string")
        be = R, H = this.length, R = 0;
      else if (isFinite(R))
        R = R >>> 0, isFinite(H) ? (H = H >>> 0, be === void 0 && (be = "utf8")) : (be = H, H = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var me = this.length - R;
      if ((H === void 0 || H > me) && (H = me), A.length > 0 && (H < 0 || R < 0) || R > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      be || (be = "utf8");
      for (var Ce = !1; ; )
        switch (be) {
          case "hex":
            return k(this, A, R, H);
          case "utf8":
          case "utf-8":
            return S(this, A, R, H);
          case "ascii":
          case "latin1":
          case "binary":
            return B(this, A, R, H);
          case "base64":
            return U(this, A, R, H);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return N(this, A, R, H);
          default:
            if (Ce)
              throw new TypeError("Unknown encoding: " + be);
            be = ("" + be).toLowerCase(), Ce = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function O(z, A, R) {
      return A === 0 && R === z.length ? t.fromByteArray(z) : t.fromByteArray(z.slice(A, R));
    }
    function I(z, A, R) {
      R = Math.min(z.length, R);
      for (var H = [], be = A; be < R; ) {
        var me = z[be], Ce = null, We = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
        if (be + We <= R) {
          var xe, we, te, Fe;
          switch (We) {
            case 1:
              me < 128 && (Ce = me);
              break;
            case 2:
              xe = z[be + 1], (xe & 192) === 128 && (Fe = (me & 31) << 6 | xe & 63, Fe > 127 && (Ce = Fe));
              break;
            case 3:
              xe = z[be + 1], we = z[be + 2], (xe & 192) === 128 && (we & 192) === 128 && (Fe = (me & 15) << 12 | (xe & 63) << 6 | we & 63, Fe > 2047 && (Fe < 55296 || Fe > 57343) && (Ce = Fe));
              break;
            case 4:
              xe = z[be + 1], we = z[be + 2], te = z[be + 3], (xe & 192) === 128 && (we & 192) === 128 && (te & 192) === 128 && (Fe = (me & 15) << 18 | (xe & 63) << 12 | (we & 63) << 6 | te & 63, Fe > 65535 && Fe < 1114112 && (Ce = Fe));
          }
        }
        Ce === null ? (Ce = 65533, We = 1) : Ce > 65535 && (Ce -= 65536, H.push(Ce >>> 10 & 1023 | 55296), Ce = 56320 | Ce & 1023), H.push(Ce), be += We;
      }
      return ae(H);
    }
    var q = 4096;
    function ae(z) {
      var A = z.length;
      if (A <= q)
        return String.fromCharCode.apply(String, z);
      for (var R = "", H = 0; H < A; )
        R += String.fromCharCode.apply(
          String,
          z.slice(H, H += q)
        );
      return R;
    }
    function Q(z, A, R) {
      var H = "";
      R = Math.min(z.length, R);
      for (var be = A; be < R; ++be)
        H += String.fromCharCode(z[be] & 127);
      return H;
    }
    function ne(z, A, R) {
      var H = "";
      R = Math.min(z.length, R);
      for (var be = A; be < R; ++be)
        H += String.fromCharCode(z[be]);
      return H;
    }
    function le(z, A, R) {
      var H = z.length;
      (!A || A < 0) && (A = 0), (!R || R < 0 || R > H) && (R = H);
      for (var be = "", me = A; me < R; ++me)
        be += Pe[z[me]];
      return be;
    }
    function W(z, A, R) {
      for (var H = z.slice(A, R), be = "", me = 0; me < H.length - 1; me += 2)
        be += String.fromCharCode(H[me] + H[me + 1] * 256);
      return be;
    }
    o.prototype.slice = function(A, R) {
      var H = this.length;
      A = ~~A, R = R === void 0 ? H : ~~R, A < 0 ? (A += H, A < 0 && (A = 0)) : A > H && (A = H), R < 0 ? (R += H, R < 0 && (R = 0)) : R > H && (R = H), R < A && (R = A);
      var be = this.subarray(A, R);
      return Object.setPrototypeOf(be, o.prototype), be;
    };
    function X(z, A, R) {
      if (z % 1 !== 0 || z < 0)
        throw new RangeError("offset is not uint");
      if (z + A > R)
        throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(A, R, H) {
      A = A >>> 0, R = R >>> 0, H || X(A, R, this.length);
      for (var be = this[A], me = 1, Ce = 0; ++Ce < R && (me *= 256); )
        be += this[A + Ce] * me;
      return be;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(A, R, H) {
      A = A >>> 0, R = R >>> 0, H || X(A, R, this.length);
      for (var be = this[A + --R], me = 1; R > 0 && (me *= 256); )
        be += this[A + --R] * me;
      return be;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(A, R) {
      return A = A >>> 0, R || X(A, 1, this.length), this[A];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(A, R) {
      return A = A >>> 0, R || X(A, 2, this.length), this[A] | this[A + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(A, R) {
      return A = A >>> 0, R || X(A, 2, this.length), this[A] << 8 | this[A + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + this[A + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), this[A] * 16777216 + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]);
    }, o.prototype.readIntLE = function(A, R, H) {
      A = A >>> 0, R = R >>> 0, H || X(A, R, this.length);
      for (var be = this[A], me = 1, Ce = 0; ++Ce < R && (me *= 256); )
        be += this[A + Ce] * me;
      return me *= 128, be >= me && (be -= Math.pow(2, 8 * R)), be;
    }, o.prototype.readIntBE = function(A, R, H) {
      A = A >>> 0, R = R >>> 0, H || X(A, R, this.length);
      for (var be = R, me = 1, Ce = this[A + --be]; be > 0 && (me *= 256); )
        Ce += this[A + --be] * me;
      return me *= 128, Ce >= me && (Ce -= Math.pow(2, 8 * R)), Ce;
    }, o.prototype.readInt8 = function(A, R) {
      return A = A >>> 0, R || X(A, 1, this.length), this[A] & 128 ? (255 - this[A] + 1) * -1 : this[A];
    }, o.prototype.readInt16LE = function(A, R) {
      A = A >>> 0, R || X(A, 2, this.length);
      var H = this[A] | this[A + 1] << 8;
      return H & 32768 ? H | 4294901760 : H;
    }, o.prototype.readInt16BE = function(A, R) {
      A = A >>> 0, R || X(A, 2, this.length);
      var H = this[A + 1] | this[A] << 8;
      return H & 32768 ? H | 4294901760 : H;
    }, o.prototype.readInt32LE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24;
    }, o.prototype.readInt32BE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3];
    }, o.prototype.readFloatLE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), r.read(this, A, !0, 23, 4);
    }, o.prototype.readFloatBE = function(A, R) {
      return A = A >>> 0, R || X(A, 4, this.length), r.read(this, A, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(A, R) {
      return A = A >>> 0, R || X(A, 8, this.length), r.read(this, A, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(A, R) {
      return A = A >>> 0, R || X(A, 8, this.length), r.read(this, A, !1, 52, 8);
    };
    function G(z, A, R, H, be, me) {
      if (!o.isBuffer(z))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (A > be || A < me)
        throw new RangeError('"value" argument is out of bounds');
      if (R + H > z.length)
        throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(A, R, H, be) {
      if (A = +A, R = R >>> 0, H = H >>> 0, !be) {
        var me = Math.pow(2, 8 * H) - 1;
        G(this, A, R, H, me, 0);
      }
      var Ce = 1, We = 0;
      for (this[R] = A & 255; ++We < H && (Ce *= 256); )
        this[R + We] = A / Ce & 255;
      return R + H;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(A, R, H, be) {
      if (A = +A, R = R >>> 0, H = H >>> 0, !be) {
        var me = Math.pow(2, 8 * H) - 1;
        G(this, A, R, H, me, 0);
      }
      var Ce = H - 1, We = 1;
      for (this[R + Ce] = A & 255; --Ce >= 0 && (We *= 256); )
        this[R + Ce] = A / We & 255;
      return R + H;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 1, 255, 0), this[R] = A & 255, R + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 2, 65535, 0), this[R] = A & 255, this[R + 1] = A >>> 8, R + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 2, 65535, 0), this[R] = A >>> 8, this[R + 1] = A & 255, R + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 4, 4294967295, 0), this[R + 3] = A >>> 24, this[R + 2] = A >>> 16, this[R + 1] = A >>> 8, this[R] = A & 255, R + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 4, 4294967295, 0), this[R] = A >>> 24, this[R + 1] = A >>> 16, this[R + 2] = A >>> 8, this[R + 3] = A & 255, R + 4;
    }, o.prototype.writeIntLE = function(A, R, H, be) {
      if (A = +A, R = R >>> 0, !be) {
        var me = Math.pow(2, 8 * H - 1);
        G(this, A, R, H, me - 1, -me);
      }
      var Ce = 0, We = 1, xe = 0;
      for (this[R] = A & 255; ++Ce < H && (We *= 256); )
        A < 0 && xe === 0 && this[R + Ce - 1] !== 0 && (xe = 1), this[R + Ce] = (A / We >> 0) - xe & 255;
      return R + H;
    }, o.prototype.writeIntBE = function(A, R, H, be) {
      if (A = +A, R = R >>> 0, !be) {
        var me = Math.pow(2, 8 * H - 1);
        G(this, A, R, H, me - 1, -me);
      }
      var Ce = H - 1, We = 1, xe = 0;
      for (this[R + Ce] = A & 255; --Ce >= 0 && (We *= 256); )
        A < 0 && xe === 0 && this[R + Ce + 1] !== 0 && (xe = 1), this[R + Ce] = (A / We >> 0) - xe & 255;
      return R + H;
    }, o.prototype.writeInt8 = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 1, 127, -128), A < 0 && (A = 255 + A + 1), this[R] = A & 255, R + 1;
    }, o.prototype.writeInt16LE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 2, 32767, -32768), this[R] = A & 255, this[R + 1] = A >>> 8, R + 2;
    }, o.prototype.writeInt16BE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 2, 32767, -32768), this[R] = A >>> 8, this[R + 1] = A & 255, R + 2;
    }, o.prototype.writeInt32LE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 4, 2147483647, -2147483648), this[R] = A & 255, this[R + 1] = A >>> 8, this[R + 2] = A >>> 16, this[R + 3] = A >>> 24, R + 4;
    }, o.prototype.writeInt32BE = function(A, R, H) {
      return A = +A, R = R >>> 0, H || G(this, A, R, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), this[R] = A >>> 24, this[R + 1] = A >>> 16, this[R + 2] = A >>> 8, this[R + 3] = A & 255, R + 4;
    };
    function P(z, A, R, H, be, me) {
      if (R + H > z.length)
        throw new RangeError("Index out of range");
      if (R < 0)
        throw new RangeError("Index out of range");
    }
    function he(z, A, R, H, be) {
      return A = +A, R = R >>> 0, be || P(z, A, R, 4), r.write(z, A, R, H, 23, 4), R + 4;
    }
    o.prototype.writeFloatLE = function(A, R, H) {
      return he(this, A, R, !0, H);
    }, o.prototype.writeFloatBE = function(A, R, H) {
      return he(this, A, R, !1, H);
    };
    function ye(z, A, R, H, be) {
      return A = +A, R = R >>> 0, be || P(z, A, R, 8), r.write(z, A, R, H, 52, 8), R + 8;
    }
    o.prototype.writeDoubleLE = function(A, R, H) {
      return ye(this, A, R, !0, H);
    }, o.prototype.writeDoubleBE = function(A, R, H) {
      return ye(this, A, R, !1, H);
    }, o.prototype.copy = function(A, R, H, be) {
      if (!o.isBuffer(A))
        throw new TypeError("argument should be a Buffer");
      if (H || (H = 0), !be && be !== 0 && (be = this.length), R >= A.length && (R = A.length), R || (R = 0), be > 0 && be < H && (be = H), be === H || A.length === 0 || this.length === 0)
        return 0;
      if (R < 0)
        throw new RangeError("targetStart out of bounds");
      if (H < 0 || H >= this.length)
        throw new RangeError("Index out of range");
      if (be < 0)
        throw new RangeError("sourceEnd out of bounds");
      be > this.length && (be = this.length), A.length - R < be - H && (be = A.length - R + H);
      var me = be - H;
      return this === A && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(R, H, be) : Uint8Array.prototype.set.call(
        A,
        this.subarray(H, be),
        R
      ), me;
    }, o.prototype.fill = function(A, R, H, be) {
      if (typeof A == "string") {
        if (typeof R == "string" ? (be = R, R = 0, H = this.length) : typeof H == "string" && (be = H, H = this.length), be !== void 0 && typeof be != "string")
          throw new TypeError("encoding must be a string");
        if (typeof be == "string" && !o.isEncoding(be))
          throw new TypeError("Unknown encoding: " + be);
        if (A.length === 1) {
          var me = A.charCodeAt(0);
          (be === "utf8" && me < 128 || be === "latin1") && (A = me);
        }
      } else typeof A == "number" ? A = A & 255 : typeof A == "boolean" && (A = Number(A));
      if (R < 0 || this.length < R || this.length < H)
        throw new RangeError("Out of range index");
      if (H <= R)
        return this;
      R = R >>> 0, H = H === void 0 ? this.length : H >>> 0, A || (A = 0);
      var Ce;
      if (typeof A == "number")
        for (Ce = R; Ce < H; ++Ce)
          this[Ce] = A;
      else {
        var We = o.isBuffer(A) ? A : o.from(A, be), xe = We.length;
        if (xe === 0)
          throw new TypeError('The value "' + A + '" is invalid for argument "value"');
        for (Ce = 0; Ce < H - R; ++Ce)
          this[Ce + R] = We[Ce % xe];
      }
      return this;
    };
    var pe = /[^+/0-9A-Za-z-_]/g;
    function $(z) {
      if (z = z.split("=")[0], z = z.trim().replace(pe, ""), z.length < 2)
        return "";
      for (; z.length % 4 !== 0; )
        z = z + "=";
      return z;
    }
    function F(z, A) {
      A = A || 1 / 0;
      for (var R, H = z.length, be = null, me = [], Ce = 0; Ce < H; ++Ce) {
        if (R = z.charCodeAt(Ce), R > 55295 && R < 57344) {
          if (!be) {
            if (R > 56319) {
              (A -= 3) > -1 && me.push(239, 191, 189);
              continue;
            } else if (Ce + 1 === H) {
              (A -= 3) > -1 && me.push(239, 191, 189);
              continue;
            }
            be = R;
            continue;
          }
          if (R < 56320) {
            (A -= 3) > -1 && me.push(239, 191, 189), be = R;
            continue;
          }
          R = (be - 55296 << 10 | R - 56320) + 65536;
        } else be && (A -= 3) > -1 && me.push(239, 191, 189);
        if (be = null, R < 128) {
          if ((A -= 1) < 0)
            break;
          me.push(R);
        } else if (R < 2048) {
          if ((A -= 2) < 0)
            break;
          me.push(
            R >> 6 | 192,
            R & 63 | 128
          );
        } else if (R < 65536) {
          if ((A -= 3) < 0)
            break;
          me.push(
            R >> 12 | 224,
            R >> 6 & 63 | 128,
            R & 63 | 128
          );
        } else if (R < 1114112) {
          if ((A -= 4) < 0)
            break;
          me.push(
            R >> 18 | 240,
            R >> 12 & 63 | 128,
            R >> 6 & 63 | 128,
            R & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return me;
    }
    function ge(z) {
      for (var A = [], R = 0; R < z.length; ++R)
        A.push(z.charCodeAt(R) & 255);
      return A;
    }
    function ce(z, A) {
      for (var R, H, be, me = [], Ce = 0; Ce < z.length && !((A -= 2) < 0); ++Ce)
        R = z.charCodeAt(Ce), H = R >> 8, be = R % 256, me.push(be), me.push(H);
      return me;
    }
    function ie(z) {
      return t.toByteArray($(z));
    }
    function re(z, A, R, H) {
      for (var be = 0; be < H && !(be + R >= A.length || be >= z.length); ++be)
        A[be + R] = z[be];
      return be;
    }
    function Te(z, A) {
      return z instanceof A || z != null && z.constructor != null && z.constructor.name != null && z.constructor.name === A.name;
    }
    function V(z) {
      return z !== z;
    }
    var Pe = function() {
      for (var z = "0123456789abcdef", A = new Array(256), R = 0; R < 16; ++R)
        for (var H = R * 16, be = 0; be < 16; ++be)
          A[H + be] = z[R] + z[be];
      return A;
    }();
  }(q1)), q1;
}
var j1 = {}, H1 = {}, V1, iM;
function qV() {
  return iM || (iM = 1, V1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var a = 42;
    t[r] = a;
    for (r in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var i = Object.getOwnPropertyDescriptor(t, r);
      if (i.value !== a || i.enumerable !== !0)
        return !1;
    }
    return !0;
  }), V1;
}
var G1, aM;
function LN() {
  if (aM)
    return G1;
  aM = 1;
  var e = qV();
  return G1 = function() {
    return e() && !!Symbol.toStringTag;
  }, G1;
}
var W1, sM;
function s1e() {
  if (sM)
    return W1;
  sM = 1;
  var e = typeof Symbol < "u" && Symbol, t = qV();
  return W1 = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, W1;
}
var K1, oM;
function o1e() {
  if (oM)
    return K1;
  oM = 1;
  var e = {
    foo: {}
  }, t = Object;
  return K1 = function() {
    return { __proto__: e }.foo === e.foo && !({ __proto__: null } instanceof t);
  }, K1;
}
var Y1, lM;
function l1e() {
  if (lM)
    return Y1;
  lM = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", a = function(l, u) {
    for (var c = [], d = 0; d < l.length; d += 1)
      c[d] = l[d];
    for (var p = 0; p < u.length; p += 1)
      c[p + l.length] = u[p];
    return c;
  }, s = function(l, u) {
    for (var c = [], d = u, p = 0; d < l.length; d += 1, p += 1)
      c[p] = l[d];
    return c;
  }, i = function(o, l) {
    for (var u = "", c = 0; c < o.length; c += 1)
      u += o[c], c + 1 < o.length && (u += l);
    return u;
  };
  return Y1 = function(l) {
    var u = this;
    if (typeof u != "function" || t.apply(u) !== n)
      throw new TypeError(e + u);
    for (var c = s(arguments, 1), d, p = function() {
      if (this instanceof d) {
        var b = u.apply(
          this,
          a(c, arguments)
        );
        return Object(b) === b ? b : this;
      }
      return u.apply(
        l,
        a(c, arguments)
      );
    }, f = r(0, u.length - c.length), h = [], m = 0; m < f; m++)
      h[m] = "$" + m;
    if (d = Function("binder", "return function (" + i(h, ",") + "){ return binder.apply(this,arguments); }")(p), u.prototype) {
      var y = function() {
      };
      y.prototype = u.prototype, d.prototype = new y(), y.prototype = null;
    }
    return d;
  }, Y1;
}
var X1, uM;
function MN() {
  if (uM)
    return X1;
  uM = 1;
  var e = l1e();
  return X1 = Function.prototype.bind || e, X1;
}
var Z1, cM;
function u1e() {
  if (cM)
    return Z1;
  cM = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = MN();
  return Z1 = r.call(e, t), Z1;
}
var J1, dM;
function Nd() {
  if (dM)
    return J1;
  dM = 1;
  var e, t = SyntaxError, r = Function, n = TypeError, a = function(N) {
    try {
      return r('"use strict"; return (' + N + ").constructor;")();
    } catch {
    }
  }, s = Object.getOwnPropertyDescriptor;
  if (s)
    try {
      s({}, "");
    } catch {
      s = null;
    }
  var i = function() {
    throw new n();
  }, o = s ? function() {
    try {
      return arguments.callee, i;
    } catch {
      try {
        return s(arguments, "callee").get;
      } catch {
        return i;
      }
    }
  }() : i, l = s1e()(), u = o1e()(), c = Object.getPrototypeOf || (u ? function(N) {
    return N.__proto__;
  } : null), d = {}, p = typeof Uint8Array > "u" || !c ? e : c(Uint8Array), f = {
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": l && c ? c([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": d,
    "%AsyncGenerator%": d,
    "%AsyncGeneratorFunction%": d,
    "%AsyncIteratorPrototype%": d,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": r,
    "%GeneratorFunction%": d,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": l && c ? c(c([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !l || !c ? e : c((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !l || !c ? e : c((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": l && c ? c(""[Symbol.iterator]()) : e,
    "%Symbol%": l ? Symbol : e,
    "%SyntaxError%": t,
    "%ThrowTypeError%": o,
    "%TypedArray%": p,
    "%TypeError%": n,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (c)
    try {
      null.error;
    } catch (N) {
      var h = c(c(N));
      f["%Error.prototype%"] = h;
    }
  var m = function N(O) {
    var I;
    if (O === "%AsyncFunction%")
      I = a("async function () {}");
    else if (O === "%GeneratorFunction%")
      I = a("function* () {}");
    else if (O === "%AsyncGeneratorFunction%")
      I = a("async function* () {}");
    else if (O === "%AsyncGenerator%") {
      var q = N("%AsyncGeneratorFunction%");
      q && (I = q.prototype);
    } else if (O === "%AsyncIteratorPrototype%") {
      var ae = N("%AsyncGenerator%");
      ae && c && (I = c(ae.prototype));
    }
    return f[O] = I, I;
  }, y = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, b = MN(), v = u1e(), x = b.call(Function.call, Array.prototype.concat), _ = b.call(Function.apply, Array.prototype.splice), E = b.call(Function.call, String.prototype.replace), w = b.call(Function.call, String.prototype.slice), C = b.call(Function.call, RegExp.prototype.exec), k = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, S = /\\(\\)?/g, B = function(O) {
    var I = w(O, 0, 1), q = w(O, -1);
    if (I === "%" && q !== "%")
      throw new t("invalid intrinsic syntax, expected closing `%`");
    if (q === "%" && I !== "%")
      throw new t("invalid intrinsic syntax, expected opening `%`");
    var ae = [];
    return E(O, k, function(Q, ne, le, W) {
      ae[ae.length] = le ? E(W, S, "$1") : ne || Q;
    }), ae;
  }, U = function(O, I) {
    var q = O, ae;
    if (v(y, q) && (ae = y[q], q = "%" + ae[0] + "%"), v(f, q)) {
      var Q = f[q];
      if (Q === d && (Q = m(q)), typeof Q > "u" && !I)
        throw new n("intrinsic " + O + " exists, but is not available. Please file an issue!");
      return {
        alias: ae,
        name: q,
        value: Q
      };
    }
    throw new t("intrinsic " + O + " does not exist!");
  };
  return J1 = function(O, I) {
    if (typeof O != "string" || O.length === 0)
      throw new n("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof I != "boolean")
      throw new n('"allowMissing" argument must be a boolean');
    if (C(/^%?[^%]*%?$/, O) === null)
      throw new t("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var q = B(O), ae = q.length > 0 ? q[0] : "", Q = U("%" + ae + "%", I), ne = Q.name, le = Q.value, W = !1, X = Q.alias;
    X && (ae = X[0], _(q, x([0, 1], X)));
    for (var G = 1, P = !0; G < q.length; G += 1) {
      var he = q[G], ye = w(he, 0, 1), pe = w(he, -1);
      if ((ye === '"' || ye === "'" || ye === "`" || pe === '"' || pe === "'" || pe === "`") && ye !== pe)
        throw new t("property names with quotes must have matching quotes");
      if ((he === "constructor" || !P) && (W = !0), ae += "." + he, ne = "%" + ae + "%", v(f, ne))
        le = f[ne];
      else if (le != null) {
        if (!(he in le)) {
          if (!I)
            throw new n("base intrinsic for " + O + " exists, but the property is not available.");
          return;
        }
        if (s && G + 1 >= q.length) {
          var $ = s(le, he);
          P = !!$, P && "get" in $ && !("originalValue" in $.get) ? le = $.get : le = le[he];
        } else
          P = v(le, he), le = le[he];
        P && !W && (f[ne] = le);
      }
    }
    return le;
  }, J1;
}
var Q1 = { exports: {} }, ex, fM;
function jV() {
  if (fM)
    return ex;
  fM = 1;
  var e = Nd(), t = e("%Object.defineProperty%", !0), r = function() {
    if (t)
      try {
        return t({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return r.hasArrayLengthDefineBug = function() {
    if (!r())
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, ex = r, ex;
}
var tx, pM;
function FN() {
  if (pM)
    return tx;
  pM = 1;
  var e = Nd(), t = e("%Object.getOwnPropertyDescriptor%", !0);
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return tx = t, tx;
}
var rx, hM;
function c1e() {
  if (hM)
    return rx;
  hM = 1;
  var e = jV()(), t = Nd(), r = e && t("%Object.defineProperty%", !0);
  if (r)
    try {
      r({}, "a", { value: 1 });
    } catch {
      r = !1;
    }
  var n = t("%SyntaxError%"), a = t("%TypeError%"), s = FN();
  return rx = function(o, l, u) {
    if (!o || typeof o != "object" && typeof o != "function")
      throw new a("`obj` must be an object or a function`");
    if (typeof l != "string" && typeof l != "symbol")
      throw new a("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new a("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new a("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new a("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new a("`loose`, if provided, must be a boolean");
    var c = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, p = arguments.length > 5 ? arguments[5] : null, f = arguments.length > 6 ? arguments[6] : !1, h = !!s && s(o, l);
    if (r)
      r(o, l, {
        configurable: p === null && h ? h.configurable : !p,
        enumerable: c === null && h ? h.enumerable : !c,
        value: u,
        writable: d === null && h ? h.writable : !d
      });
    else if (f || !c && !d && !p)
      o[l] = u;
    else
      throw new n("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, rx;
}
var nx, mM;
function d1e() {
  if (mM)
    return nx;
  mM = 1;
  var e = Nd(), t = c1e(), r = jV()(), n = FN(), a = e("%TypeError%"), s = e("%Math.floor%");
  return nx = function(o, l) {
    if (typeof o != "function")
      throw new a("`fn` is not a function");
    if (typeof l != "number" || l < 0 || l > 4294967295 || s(l) !== l)
      throw new a("`length` must be a positive 32-bit integer");
    var u = arguments.length > 2 && !!arguments[2], c = !0, d = !0;
    if ("length" in o && n) {
      var p = n(o, "length");
      p && !p.configurable && (c = !1), p && !p.writable && (d = !1);
    }
    return (c || d || !u) && (r ? t(o, "length", l, !0, !0) : t(o, "length", l)), o;
  }, nx;
}
var gM;
function HV() {
  return gM || (gM = 1, function(e) {
    var t = MN(), r = Nd(), n = d1e(), a = r("%TypeError%"), s = r("%Function.prototype.apply%"), i = r("%Function.prototype.call%"), o = r("%Reflect.apply%", !0) || t.call(i, s), l = r("%Object.defineProperty%", !0), u = r("%Math.max%");
    if (l)
      try {
        l({}, "a", { value: 1 });
      } catch {
        l = null;
      }
    e.exports = function(p) {
      if (typeof p != "function")
        throw new a("a function is required");
      var f = o(t, i, arguments);
      return n(
        f,
        1 + u(0, p.length - (arguments.length - 1)),
        !0
      );
    };
    var c = function() {
      return o(t, s, arguments);
    };
    l ? l(e.exports, "apply", { value: c }) : e.exports.apply = c;
  }(Q1)), Q1.exports;
}
var ix, bM;
function VV() {
  if (bM)
    return ix;
  bM = 1;
  var e = Nd(), t = HV(), r = t(e("String.prototype.indexOf"));
  return ix = function(a, s) {
    var i = e(a, !!s);
    return typeof i == "function" && r(a, ".prototype.") > -1 ? t(i) : i;
  }, ix;
}
var ax, yM;
function f1e() {
  if (yM)
    return ax;
  yM = 1;
  var e = LN()(), t = VV(), r = t("Object.prototype.toString"), n = function(o) {
    return e && o && typeof o == "object" && Symbol.toStringTag in o ? !1 : r(o) === "[object Arguments]";
  }, a = function(o) {
    return n(o) ? !0 : o !== null && typeof o == "object" && typeof o.length == "number" && o.length >= 0 && r(o) !== "[object Array]" && r(o.callee) === "[object Function]";
  }, s = function() {
    return n(arguments);
  }();
  return n.isLegacyArguments = a, ax = s ? n : a, ax;
}
var sx, vM;
function p1e() {
  if (vM)
    return sx;
  vM = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, r = /^\s*(?:function)?\*/, n = LN()(), a = Object.getPrototypeOf, s = function() {
    if (!n)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, i;
  return sx = function(l) {
    if (typeof l != "function")
      return !1;
    if (r.test(t.call(l)))
      return !0;
    if (!n) {
      var u = e.call(l);
      return u === "[object GeneratorFunction]";
    }
    if (!a)
      return !1;
    if (typeof i > "u") {
      var c = s();
      i = c ? a(c) : !1;
    }
    return a(l) === i;
  }, sx;
}
var ox, wM;
function h1e() {
  if (wM)
    return ox;
  wM = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, n;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (v) {
      v !== n && (t = null);
    }
  else
    t = null;
  var a = /^\s*class\b/, s = function(x) {
    try {
      var _ = e.call(x);
      return a.test(_);
    } catch {
      return !1;
    }
  }, i = function(x) {
    try {
      return s(x) ? !1 : (e.call(x), !0);
    } catch {
      return !1;
    }
  }, o = Object.prototype.toString, l = "[object Object]", u = "[object Function]", c = "[object GeneratorFunction]", d = "[object HTMLAllCollection]", p = "[object HTML document.all class]", f = "[object HTMLCollection]", h = typeof Symbol == "function" && !!Symbol.toStringTag, m = !(0 in [,]), y = function() {
    return !1;
  };
  if (typeof document == "object") {
    var b = document.all;
    o.call(b) === o.call(document.all) && (y = function(x) {
      if ((m || !x) && (typeof x > "u" || typeof x == "object"))
        try {
          var _ = o.call(x);
          return (_ === d || _ === p || _ === f || _ === l) && x("") == null;
        } catch {
        }
      return !1;
    });
  }
  return ox = t ? function(x) {
    if (y(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    try {
      t(x, null, r);
    } catch (_) {
      if (_ !== n)
        return !1;
    }
    return !s(x) && i(x);
  } : function(x) {
    if (y(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    if (h)
      return i(x);
    if (s(x))
      return !1;
    var _ = o.call(x);
    return _ !== u && _ !== c && !/^\[object HTML/.test(_) ? !1 : i(x);
  }, ox;
}
var lx, xM;
function m1e() {
  if (xM)
    return lx;
  xM = 1;
  var e = h1e(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(l, u, c) {
    for (var d = 0, p = l.length; d < p; d++)
      r.call(l, d) && (c == null ? u(l[d], d, l) : u.call(c, l[d], d, l));
  }, a = function(l, u, c) {
    for (var d = 0, p = l.length; d < p; d++)
      c == null ? u(l.charAt(d), d, l) : u.call(c, l.charAt(d), d, l);
  }, s = function(l, u, c) {
    for (var d in l)
      r.call(l, d) && (c == null ? u(l[d], d, l) : u.call(c, l[d], d, l));
  }, i = function(l, u, c) {
    if (!e(u))
      throw new TypeError("iterator must be a function");
    var d;
    arguments.length >= 3 && (d = c), t.call(l) === "[object Array]" ? n(l, u, d) : typeof l == "string" ? a(l, u, d) : s(l, u, d);
  };
  return lx = i, lx;
}
var ux, EM;
function g1e() {
  if (EM)
    return ux;
  EM = 1;
  var e = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], t = typeof globalThis > "u" ? no : globalThis;
  return ux = function() {
    for (var n = [], a = 0; a < e.length; a++)
      typeof t[e[a]] == "function" && (n[n.length] = e[a]);
    return n;
  }, ux;
}
var cx, SM;
function GV() {
  if (SM)
    return cx;
  SM = 1;
  var e = m1e(), t = g1e(), r = HV(), n = VV(), a = FN(), s = n("Object.prototype.toString"), i = LN()(), o = typeof globalThis > "u" ? no : globalThis, l = t(), u = n("String.prototype.slice"), c = Object.getPrototypeOf, d = n("Array.prototype.indexOf", !0) || function(y, b) {
    for (var v = 0; v < y.length; v += 1)
      if (y[v] === b)
        return v;
    return -1;
  }, p = { __proto__: null };
  i && a && c ? e(l, function(m) {
    var y = new o[m]();
    if (Symbol.toStringTag in y) {
      var b = c(y), v = a(b, Symbol.toStringTag);
      if (!v) {
        var x = c(b);
        v = a(x, Symbol.toStringTag);
      }
      p["$" + m] = r(v.get);
    }
  }) : e(l, function(m) {
    var y = new o[m](), b = y.slice || y.set;
    b && (p["$" + m] = r(b));
  });
  var f = function(y) {
    var b = !1;
    return e(p, function(v, x) {
      if (!b)
        try {
          "$" + v(y) === x && (b = u(x, 1));
        } catch {
        }
    }), b;
  }, h = function(y) {
    var b = !1;
    return e(p, function(v, x) {
      if (!b)
        try {
          v(y), b = u(x, 1);
        } catch {
        }
    }), b;
  };
  return cx = function(y) {
    if (!y || typeof y != "object")
      return !1;
    if (!i) {
      var b = u(s(y), 8, -1);
      return d(l, b) > -1 ? b : b !== "Object" ? !1 : h(y);
    }
    return a ? f(y) : null;
  }, cx;
}
var dx, _M;
function b1e() {
  if (_M)
    return dx;
  _M = 1;
  var e = GV();
  return dx = function(r) {
    return !!e(r);
  }, dx;
}
var kM;
function y1e() {
  return kM || (kM = 1, function(e) {
    var t = f1e(), r = p1e(), n = GV(), a = b1e();
    function s(H) {
      return H.call.bind(H);
    }
    var i = typeof BigInt < "u", o = typeof Symbol < "u", l = s(Object.prototype.toString), u = s(Number.prototype.valueOf), c = s(String.prototype.valueOf), d = s(Boolean.prototype.valueOf);
    if (i)
      var p = s(BigInt.prototype.valueOf);
    if (o)
      var f = s(Symbol.prototype.valueOf);
    function h(H, be) {
      if (typeof H != "object")
        return !1;
      try {
        return be(H), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = a;
    function m(H) {
      return typeof Promise < "u" && H instanceof Promise || H !== null && typeof H == "object" && typeof H.then == "function" && typeof H.catch == "function";
    }
    e.isPromise = m;
    function y(H) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(H) : a(H) || P(H);
    }
    e.isArrayBufferView = y;
    function b(H) {
      return n(H) === "Uint8Array";
    }
    e.isUint8Array = b;
    function v(H) {
      return n(H) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = v;
    function x(H) {
      return n(H) === "Uint16Array";
    }
    e.isUint16Array = x;
    function _(H) {
      return n(H) === "Uint32Array";
    }
    e.isUint32Array = _;
    function E(H) {
      return n(H) === "Int8Array";
    }
    e.isInt8Array = E;
    function w(H) {
      return n(H) === "Int16Array";
    }
    e.isInt16Array = w;
    function C(H) {
      return n(H) === "Int32Array";
    }
    e.isInt32Array = C;
    function k(H) {
      return n(H) === "Float32Array";
    }
    e.isFloat32Array = k;
    function S(H) {
      return n(H) === "Float64Array";
    }
    e.isFloat64Array = S;
    function B(H) {
      return n(H) === "BigInt64Array";
    }
    e.isBigInt64Array = B;
    function U(H) {
      return n(H) === "BigUint64Array";
    }
    e.isBigUint64Array = U;
    function N(H) {
      return l(H) === "[object Map]";
    }
    N.working = typeof Map < "u" && N(/* @__PURE__ */ new Map());
    function O(H) {
      return typeof Map > "u" ? !1 : N.working ? N(H) : H instanceof Map;
    }
    e.isMap = O;
    function I(H) {
      return l(H) === "[object Set]";
    }
    I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
    function q(H) {
      return typeof Set > "u" ? !1 : I.working ? I(H) : H instanceof Set;
    }
    e.isSet = q;
    function ae(H) {
      return l(H) === "[object WeakMap]";
    }
    ae.working = typeof WeakMap < "u" && ae(/* @__PURE__ */ new WeakMap());
    function Q(H) {
      return typeof WeakMap > "u" ? !1 : ae.working ? ae(H) : H instanceof WeakMap;
    }
    e.isWeakMap = Q;
    function ne(H) {
      return l(H) === "[object WeakSet]";
    }
    ne.working = typeof WeakSet < "u" && ne(/* @__PURE__ */ new WeakSet());
    function le(H) {
      return ne(H);
    }
    e.isWeakSet = le;
    function W(H) {
      return l(H) === "[object ArrayBuffer]";
    }
    W.working = typeof ArrayBuffer < "u" && W(new ArrayBuffer());
    function X(H) {
      return typeof ArrayBuffer > "u" ? !1 : W.working ? W(H) : H instanceof ArrayBuffer;
    }
    e.isArrayBuffer = X;
    function G(H) {
      return l(H) === "[object DataView]";
    }
    G.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && G(new DataView(new ArrayBuffer(1), 0, 1));
    function P(H) {
      return typeof DataView > "u" ? !1 : G.working ? G(H) : H instanceof DataView;
    }
    e.isDataView = P;
    var he = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function ye(H) {
      return l(H) === "[object SharedArrayBuffer]";
    }
    function pe(H) {
      return typeof he > "u" ? !1 : (typeof ye.working > "u" && (ye.working = ye(new he())), ye.working ? ye(H) : H instanceof he);
    }
    e.isSharedArrayBuffer = pe;
    function $(H) {
      return l(H) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = $;
    function F(H) {
      return l(H) === "[object Map Iterator]";
    }
    e.isMapIterator = F;
    function ge(H) {
      return l(H) === "[object Set Iterator]";
    }
    e.isSetIterator = ge;
    function ce(H) {
      return l(H) === "[object Generator]";
    }
    e.isGeneratorObject = ce;
    function ie(H) {
      return l(H) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = ie;
    function re(H) {
      return h(H, u);
    }
    e.isNumberObject = re;
    function Te(H) {
      return h(H, c);
    }
    e.isStringObject = Te;
    function V(H) {
      return h(H, d);
    }
    e.isBooleanObject = V;
    function Pe(H) {
      return i && h(H, p);
    }
    e.isBigIntObject = Pe;
    function z(H) {
      return o && h(H, f);
    }
    e.isSymbolObject = z;
    function A(H) {
      return re(H) || Te(H) || V(H) || Pe(H) || z(H);
    }
    e.isBoxedPrimitive = A;
    function R(H) {
      return typeof Uint8Array < "u" && (X(H) || pe(H));
    }
    e.isAnyArrayBuffer = R, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(H) {
      Object.defineProperty(e, H, {
        enumerable: !1,
        value: function() {
          throw new Error(H + " is not supported in userland");
        }
      });
    });
  }(H1)), H1;
}
var fx, CM;
function v1e() {
  return CM || (CM = 1, fx = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), fx;
}
var AM;
function WV() {
  return AM || (AM = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(P) {
      for (var he = Object.keys(P), ye = {}, pe = 0; pe < he.length; pe++)
        ye[he[pe]] = Object.getOwnPropertyDescriptor(P, he[pe]);
      return ye;
    }, r = /%[sdj%]/g;
    e.format = function(G) {
      if (!E(G)) {
        for (var P = [], he = 0; he < arguments.length; he++)
          P.push(i(arguments[he]));
        return P.join(" ");
      }
      for (var he = 1, ye = arguments, pe = ye.length, $ = String(G).replace(r, function(ge) {
        if (ge === "%%")
          return "%";
        if (he >= pe)
          return ge;
        switch (ge) {
          case "%s":
            return String(ye[he++]);
          case "%d":
            return Number(ye[he++]);
          case "%j":
            try {
              return JSON.stringify(ye[he++]);
            } catch {
              return "[Circular]";
            }
          default:
            return ge;
        }
      }), F = ye[he]; he < pe; F = ye[++he])
        v(F) || !S(F) ? $ += " " + F : $ += " " + i(F);
      return $;
    }, e.deprecate = function(G, P) {
      if (typeof an < "u" && an.noDeprecation === !0)
        return G;
      if (typeof an > "u")
        return function() {
          return e.deprecate(G, P).apply(this, arguments);
        };
      var he = !1;
      function ye() {
        if (!he) {
          if (an.throwDeprecation)
            throw new Error(P);
          an.traceDeprecation ? console.trace(P) : console.error(P), he = !0;
        }
        return G.apply(this, arguments);
      }
      return ye;
    };
    var n = {}, a = /^$/;
    if (an.env.NODE_DEBUG) {
      var s = an.env.NODE_DEBUG;
      s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), a = new RegExp("^" + s + "$", "i");
    }
    e.debuglog = function(G) {
      if (G = G.toUpperCase(), !n[G])
        if (a.test(G)) {
          var P = an.pid;
          n[G] = function() {
            var he = e.format.apply(e, arguments);
            console.error("%s %d: %s", G, P, he);
          };
        } else
          n[G] = function() {
          };
      return n[G];
    };
    function i(G, P) {
      var he = {
        seen: [],
        stylize: l
      };
      return arguments.length >= 3 && (he.depth = arguments[2]), arguments.length >= 4 && (he.colors = arguments[3]), b(P) ? he.showHidden = P : P && e._extend(he, P), C(he.showHidden) && (he.showHidden = !1), C(he.depth) && (he.depth = 2), C(he.colors) && (he.colors = !1), C(he.customInspect) && (he.customInspect = !0), he.colors && (he.stylize = o), c(he, G, he.depth);
    }
    e.inspect = i, i.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, i.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function o(G, P) {
      var he = i.styles[P];
      return he ? "\x1B[" + i.colors[he][0] + "m" + G + "\x1B[" + i.colors[he][1] + "m" : G;
    }
    function l(G, P) {
      return G;
    }
    function u(G) {
      var P = {};
      return G.forEach(function(he, ye) {
        P[he] = !0;
      }), P;
    }
    function c(G, P, he) {
      if (G.customInspect && P && N(P.inspect) && // Filter out the util module, it's inspect function is special
      P.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(P.constructor && P.constructor.prototype === P)) {
        var ye = P.inspect(he, G);
        return E(ye) || (ye = c(G, ye, he)), ye;
      }
      var pe = d(G, P);
      if (pe)
        return pe;
      var $ = Object.keys(P), F = u($);
      if (G.showHidden && ($ = Object.getOwnPropertyNames(P)), U(P) && ($.indexOf("message") >= 0 || $.indexOf("description") >= 0))
        return p(P);
      if ($.length === 0) {
        if (N(P)) {
          var ge = P.name ? ": " + P.name : "";
          return G.stylize("[Function" + ge + "]", "special");
        }
        if (k(P))
          return G.stylize(RegExp.prototype.toString.call(P), "regexp");
        if (B(P))
          return G.stylize(Date.prototype.toString.call(P), "date");
        if (U(P))
          return p(P);
      }
      var ce = "", ie = !1, re = ["{", "}"];
      if (y(P) && (ie = !0, re = ["[", "]"]), N(P)) {
        var Te = P.name ? ": " + P.name : "";
        ce = " [Function" + Te + "]";
      }
      if (k(P) && (ce = " " + RegExp.prototype.toString.call(P)), B(P) && (ce = " " + Date.prototype.toUTCString.call(P)), U(P) && (ce = " " + p(P)), $.length === 0 && (!ie || P.length == 0))
        return re[0] + ce + re[1];
      if (he < 0)
        return k(P) ? G.stylize(RegExp.prototype.toString.call(P), "regexp") : G.stylize("[Object]", "special");
      G.seen.push(P);
      var V;
      return ie ? V = f(G, P, he, F, $) : V = $.map(function(Pe) {
        return h(G, P, he, F, Pe, ie);
      }), G.seen.pop(), m(V, ce, re);
    }
    function d(G, P) {
      if (C(P))
        return G.stylize("undefined", "undefined");
      if (E(P)) {
        var he = "'" + JSON.stringify(P).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return G.stylize(he, "string");
      }
      if (_(P))
        return G.stylize("" + P, "number");
      if (b(P))
        return G.stylize("" + P, "boolean");
      if (v(P))
        return G.stylize("null", "null");
    }
    function p(G) {
      return "[" + Error.prototype.toString.call(G) + "]";
    }
    function f(G, P, he, ye, pe) {
      for (var $ = [], F = 0, ge = P.length; F < ge; ++F)
        ne(P, String(F)) ? $.push(h(
          G,
          P,
          he,
          ye,
          String(F),
          !0
        )) : $.push("");
      return pe.forEach(function(ce) {
        ce.match(/^\d+$/) || $.push(h(
          G,
          P,
          he,
          ye,
          ce,
          !0
        ));
      }), $;
    }
    function h(G, P, he, ye, pe, $) {
      var F, ge, ce;
      if (ce = Object.getOwnPropertyDescriptor(P, pe) || { value: P[pe] }, ce.get ? ce.set ? ge = G.stylize("[Getter/Setter]", "special") : ge = G.stylize("[Getter]", "special") : ce.set && (ge = G.stylize("[Setter]", "special")), ne(ye, pe) || (F = "[" + pe + "]"), ge || (G.seen.indexOf(ce.value) < 0 ? (v(he) ? ge = c(G, ce.value, null) : ge = c(G, ce.value, he - 1), ge.indexOf(`
`) > -1 && ($ ? ge = ge.split(`
`).map(function(ie) {
        return "  " + ie;
      }).join(`
`).slice(2) : ge = `
` + ge.split(`
`).map(function(ie) {
        return "   " + ie;
      }).join(`
`))) : ge = G.stylize("[Circular]", "special")), C(F)) {
        if ($ && pe.match(/^\d+$/))
          return ge;
        F = JSON.stringify("" + pe), F.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (F = F.slice(1, -1), F = G.stylize(F, "name")) : (F = F.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), F = G.stylize(F, "string"));
      }
      return F + ": " + ge;
    }
    function m(G, P, he) {
      var ye = G.reduce(function(pe, $) {
        return $.indexOf(`
`) >= 0, pe + $.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return ye > 60 ? he[0] + (P === "" ? "" : P + `
 `) + " " + G.join(`,
  `) + " " + he[1] : he[0] + P + " " + G.join(", ") + " " + he[1];
    }
    e.types = y1e();
    function y(G) {
      return Array.isArray(G);
    }
    e.isArray = y;
    function b(G) {
      return typeof G == "boolean";
    }
    e.isBoolean = b;
    function v(G) {
      return G === null;
    }
    e.isNull = v;
    function x(G) {
      return G == null;
    }
    e.isNullOrUndefined = x;
    function _(G) {
      return typeof G == "number";
    }
    e.isNumber = _;
    function E(G) {
      return typeof G == "string";
    }
    e.isString = E;
    function w(G) {
      return typeof G == "symbol";
    }
    e.isSymbol = w;
    function C(G) {
      return G === void 0;
    }
    e.isUndefined = C;
    function k(G) {
      return S(G) && I(G) === "[object RegExp]";
    }
    e.isRegExp = k, e.types.isRegExp = k;
    function S(G) {
      return typeof G == "object" && G !== null;
    }
    e.isObject = S;
    function B(G) {
      return S(G) && I(G) === "[object Date]";
    }
    e.isDate = B, e.types.isDate = B;
    function U(G) {
      return S(G) && (I(G) === "[object Error]" || G instanceof Error);
    }
    e.isError = U, e.types.isNativeError = U;
    function N(G) {
      return typeof G == "function";
    }
    e.isFunction = N;
    function O(G) {
      return G === null || typeof G == "boolean" || typeof G == "number" || typeof G == "string" || typeof G == "symbol" || // ES6 symbol
      typeof G > "u";
    }
    e.isPrimitive = O, e.isBuffer = v1e();
    function I(G) {
      return Object.prototype.toString.call(G);
    }
    function q(G) {
      return G < 10 ? "0" + G.toString(10) : G.toString(10);
    }
    var ae = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Q() {
      var G = /* @__PURE__ */ new Date(), P = [
        q(G.getHours()),
        q(G.getMinutes()),
        q(G.getSeconds())
      ].join(":");
      return [G.getDate(), ae[G.getMonth()], P].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", Q(), e.format.apply(e, arguments));
    }, e.inherits = Hu, e._extend = function(G, P) {
      if (!P || !S(P))
        return G;
      for (var he = Object.keys(P), ye = he.length; ye--; )
        G[he[ye]] = P[he[ye]];
      return G;
    };
    function ne(G, P) {
      return Object.prototype.hasOwnProperty.call(G, P);
    }
    var le = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(P) {
      if (typeof P != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (le && P[le]) {
        var he = P[le];
        if (typeof he != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(he, le, {
          value: he,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), he;
      }
      function he() {
        for (var ye, pe, $ = new Promise(function(ce, ie) {
          ye = ce, pe = ie;
        }), F = [], ge = 0; ge < arguments.length; ge++)
          F.push(arguments[ge]);
        F.push(function(ce, ie) {
          ce ? pe(ce) : ye(ie);
        });
        try {
          P.apply(this, F);
        } catch (ce) {
          pe(ce);
        }
        return $;
      }
      return Object.setPrototypeOf(he, Object.getPrototypeOf(P)), le && Object.defineProperty(he, le, {
        value: he,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        he,
        t(P)
      );
    }, e.promisify.custom = le;
    function W(G, P) {
      if (!G) {
        var he = new Error("Promise was rejected with a falsy value");
        he.reason = G, G = he;
      }
      return P(G);
    }
    function X(G) {
      if (typeof G != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function P() {
        for (var he = [], ye = 0; ye < arguments.length; ye++)
          he.push(arguments[ye]);
        var pe = he.pop();
        if (typeof pe != "function")
          throw new TypeError("The last argument must be of type Function");
        var $ = this, F = function() {
          return pe.apply($, arguments);
        };
        G.apply(this, he).then(
          function(ge) {
            an.nextTick(F.bind(null, null, ge));
          },
          function(ge) {
            an.nextTick(W.bind(null, ge, F));
          }
        );
      }
      return Object.setPrototypeOf(P, Object.getPrototypeOf(G)), Object.defineProperties(
        P,
        t(G)
      ), P;
    }
    e.callbackify = X;
  }(j1)), j1;
}
var px, TM;
function w1e() {
  if (TM)
    return px;
  TM = 1;
  function e(p, f) {
    var h = Object.keys(p);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(p);
      f && (m = m.filter(function(y) {
        return Object.getOwnPropertyDescriptor(p, y).enumerable;
      })), h.push.apply(h, m);
    }
    return h;
  }
  function t(p) {
    for (var f = 1; f < arguments.length; f++) {
      var h = arguments[f] != null ? arguments[f] : {};
      f % 2 ? e(Object(h), !0).forEach(function(m) {
        r(p, m, h[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(p, Object.getOwnPropertyDescriptors(h)) : e(Object(h)).forEach(function(m) {
        Object.defineProperty(p, m, Object.getOwnPropertyDescriptor(h, m));
      });
    }
    return p;
  }
  function r(p, f, h) {
    return f in p ? Object.defineProperty(p, f, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : p[f] = h, p;
  }
  function n(p, f) {
    if (!(p instanceof f))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(p, f) {
    for (var h = 0; h < f.length; h++) {
      var m = f[h];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(p, m.key, m);
    }
  }
  function s(p, f, h) {
    return a(p.prototype, f), p;
  }
  var i = ly(), o = i.Buffer, l = WV(), u = l.inspect, c = u && u.custom || "inspect";
  function d(p, f, h) {
    o.prototype.copy.call(p, f, h);
  }
  return px = /* @__PURE__ */ function() {
    function p() {
      n(this, p), this.head = null, this.tail = null, this.length = 0;
    }
    return s(p, [{
      key: "push",
      value: function(h) {
        var m = {
          data: h,
          next: null
        };
        this.length > 0 ? this.tail.next = m : this.head = m, this.tail = m, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(h) {
        var m = {
          data: h,
          next: this.head
        };
        this.length === 0 && (this.tail = m), this.head = m, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var h = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(h) {
        if (this.length === 0)
          return "";
        for (var m = this.head, y = "" + m.data; m = m.next; )
          y += h + m.data;
        return y;
      }
    }, {
      key: "concat",
      value: function(h) {
        if (this.length === 0)
          return o.alloc(0);
        for (var m = o.allocUnsafe(h >>> 0), y = this.head, b = 0; y; )
          d(y.data, m, b), b += y.data.length, y = y.next;
        return m;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(h, m) {
        var y;
        return h < this.head.data.length ? (y = this.head.data.slice(0, h), this.head.data = this.head.data.slice(h)) : h === this.head.data.length ? y = this.shift() : y = m ? this._getString(h) : this._getBuffer(h), y;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(h) {
        var m = this.head, y = 1, b = m.data;
        for (h -= b.length; m = m.next; ) {
          var v = m.data, x = h > v.length ? v.length : h;
          if (x === v.length ? b += v : b += v.slice(0, h), h -= x, h === 0) {
            x === v.length ? (++y, m.next ? this.head = m.next : this.head = this.tail = null) : (this.head = m, m.data = v.slice(x));
            break;
          }
          ++y;
        }
        return this.length -= y, b;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(h) {
        var m = o.allocUnsafe(h), y = this.head, b = 1;
        for (y.data.copy(m), h -= y.data.length; y = y.next; ) {
          var v = y.data, x = h > v.length ? v.length : h;
          if (v.copy(m, m.length - h, 0, x), h -= x, h === 0) {
            x === v.length ? (++b, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = v.slice(x));
            break;
          }
          ++b;
        }
        return this.length -= b, m;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: c,
      value: function(h, m) {
        return u(this, t({}, m, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), p;
  }(), px;
}
var hx, RM;
function KV() {
  if (RM)
    return hx;
  RM = 1;
  function e(i, o) {
    var l = this, u = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
    return u || c ? (o ? o(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, an.nextTick(a, this, i)) : an.nextTick(a, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(d) {
      !o && d ? l._writableState ? l._writableState.errorEmitted ? an.nextTick(r, l) : (l._writableState.errorEmitted = !0, an.nextTick(t, l, d)) : an.nextTick(t, l, d) : o ? (an.nextTick(r, l), o(d)) : an.nextTick(r, l);
    }), this);
  }
  function t(i, o) {
    a(i, o), r(i);
  }
  function r(i) {
    i._writableState && !i._writableState.emitClose || i._readableState && !i._readableState.emitClose || i.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function a(i, o) {
    i.emit("error", o);
  }
  function s(i, o) {
    var l = i._readableState, u = i._writableState;
    l && l.autoDestroy || u && u.autoDestroy ? i.destroy(o) : i.emit("error", o);
  }
  return hx = {
    destroy: e,
    undestroy: n,
    errorOrDestroy: s
  }, hx;
}
var mx = {}, IM;
function Dd() {
  if (IM)
    return mx;
  IM = 1;
  function e(o, l) {
    o.prototype = Object.create(l.prototype), o.prototype.constructor = o, o.__proto__ = l;
  }
  var t = {};
  function r(o, l, u) {
    u || (u = Error);
    function c(p, f, h) {
      return typeof l == "string" ? l : l(p, f, h);
    }
    var d = /* @__PURE__ */ function(p) {
      e(f, p);
      function f(h, m, y) {
        return p.call(this, c(h, m, y)) || this;
      }
      return f;
    }(u);
    d.prototype.name = u.name, d.prototype.code = o, t[o] = d;
  }
  function n(o, l) {
    if (Array.isArray(o)) {
      var u = o.length;
      return o = o.map(function(c) {
        return String(c);
      }), u > 2 ? "one of ".concat(l, " ").concat(o.slice(0, u - 1).join(", "), ", or ") + o[u - 1] : u === 2 ? "one of ".concat(l, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(l, " ").concat(o[0]);
    } else
      return "of ".concat(l, " ").concat(String(o));
  }
  function a(o, l, u) {
    return o.substr(0, l.length) === l;
  }
  function s(o, l, u) {
    return (u === void 0 || u > o.length) && (u = o.length), o.substring(u - l.length, u) === l;
  }
  function i(o, l, u) {
    return typeof u != "number" && (u = 0), u + l.length > o.length ? !1 : o.indexOf(l, u) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(o, l) {
    return 'The value "' + l + '" is invalid for option "' + o + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(o, l, u) {
    var c;
    typeof l == "string" && a(l, "not ") ? (c = "must not be", l = l.replace(/^not /, "")) : c = "must be";
    var d;
    if (s(o, " argument"))
      d = "The ".concat(o, " ").concat(c, " ").concat(n(l, "type"));
    else {
      var p = i(o, ".") ? "property" : "argument";
      d = 'The "'.concat(o, '" ').concat(p, " ").concat(c, " ").concat(n(l, "type"));
    }
    return d += ". Received type ".concat(typeof u), d;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), mx.codes = t, mx;
}
var gx, NM;
function YV() {
  if (NM)
    return gx;
  NM = 1;
  var e = Dd().codes.ERR_INVALID_OPT_VALUE;
  function t(n, a, s) {
    return n.highWaterMark != null ? n.highWaterMark : a ? n[s] : null;
  }
  function r(n, a, s, i) {
    var o = t(a, i, s);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var l = i ? s : "highWaterMark";
        throw new e(l, o);
      }
      return Math.floor(o);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return gx = {
    getHighWaterMark: r
  }, gx;
}
var bx, DM;
function x1e() {
  if (DM)
    return bx;
  DM = 1, bx = e;
  function e(r, n) {
    if (t("noDeprecation"))
      return r;
    var a = !1;
    function s() {
      if (!a) {
        if (t("throwDeprecation"))
          throw new Error(n);
        t("traceDeprecation") ? console.trace(n) : console.warn(n), a = !0;
      }
      return r.apply(this, arguments);
    }
    return s;
  }
  function t(r) {
    try {
      if (!no.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var n = no.localStorage[r];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return bx;
}
var yx, OM;
function XV() {
  if (OM)
    return yx;
  OM = 1, yx = k;
  function e(pe) {
    var $ = this;
    this.next = null, this.entry = null, this.finish = function() {
      ye($, pe);
    };
  }
  var t;
  k.WritableState = w;
  var r = {
    deprecate: x1e()
  }, n = zV(), a = ly().Buffer, s = no.Uint8Array || function() {
  };
  function i(pe) {
    return a.from(pe);
  }
  function o(pe) {
    return a.isBuffer(pe) || pe instanceof s;
  }
  var l = KV(), u = YV(), c = u.getHighWaterMark, d = Dd().codes, p = d.ERR_INVALID_ARG_TYPE, f = d.ERR_METHOD_NOT_IMPLEMENTED, h = d.ERR_MULTIPLE_CALLBACK, m = d.ERR_STREAM_CANNOT_PIPE, y = d.ERR_STREAM_DESTROYED, b = d.ERR_STREAM_NULL_VALUES, v = d.ERR_STREAM_WRITE_AFTER_END, x = d.ERR_UNKNOWN_ENCODING, _ = l.errorOrDestroy;
  Hu(k, n);
  function E() {
  }
  function w(pe, $, F) {
    t = t || cd(), pe = pe || {}, typeof F != "boolean" && (F = $ instanceof t), this.objectMode = !!pe.objectMode, F && (this.objectMode = this.objectMode || !!pe.writableObjectMode), this.highWaterMark = c(this, pe, "writableHighWaterMark", F), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ge = pe.decodeStrings === !1;
    this.decodeStrings = !ge, this.defaultEncoding = pe.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ce) {
      ae($, ce);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = pe.emitClose !== !1, this.autoDestroy = !!pe.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  w.prototype.getBuffer = function() {
    for (var $ = this.bufferedRequest, F = []; $; )
      F.push($), $ = $.next;
    return F;
  }, function() {
    try {
      Object.defineProperty(w.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var C;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (C = Function.prototype[Symbol.hasInstance], Object.defineProperty(k, Symbol.hasInstance, {
    value: function($) {
      return C.call(this, $) ? !0 : this !== k ? !1 : $ && $._writableState instanceof w;
    }
  })) : C = function($) {
    return $ instanceof this;
  };
  function k(pe) {
    t = t || cd();
    var $ = this instanceof t;
    if (!$ && !C.call(k, this))
      return new k(pe);
    this._writableState = new w(pe, this, $), this.writable = !0, pe && (typeof pe.write == "function" && (this._write = pe.write), typeof pe.writev == "function" && (this._writev = pe.writev), typeof pe.destroy == "function" && (this._destroy = pe.destroy), typeof pe.final == "function" && (this._final = pe.final)), n.call(this);
  }
  k.prototype.pipe = function() {
    _(this, new m());
  };
  function S(pe, $) {
    var F = new v();
    _(pe, F), an.nextTick($, F);
  }
  function B(pe, $, F, ge) {
    var ce;
    return F === null ? ce = new b() : typeof F != "string" && !$.objectMode && (ce = new p("chunk", ["string", "Buffer"], F)), ce ? (_(pe, ce), an.nextTick(ge, ce), !1) : !0;
  }
  k.prototype.write = function(pe, $, F) {
    var ge = this._writableState, ce = !1, ie = !ge.objectMode && o(pe);
    return ie && !a.isBuffer(pe) && (pe = i(pe)), typeof $ == "function" && (F = $, $ = null), ie ? $ = "buffer" : $ || ($ = ge.defaultEncoding), typeof F != "function" && (F = E), ge.ending ? S(this, F) : (ie || B(this, ge, pe, F)) && (ge.pendingcb++, ce = N(this, ge, ie, pe, $, F)), ce;
  }, k.prototype.cork = function() {
    this._writableState.corked++;
  }, k.prototype.uncork = function() {
    var pe = this._writableState;
    pe.corked && (pe.corked--, !pe.writing && !pe.corked && !pe.bufferProcessing && pe.bufferedRequest && le(this, pe));
  }, k.prototype.setDefaultEncoding = function($) {
    if (typeof $ == "string" && ($ = $.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf(($ + "").toLowerCase()) > -1))
      throw new x($);
    return this._writableState.defaultEncoding = $, this;
  }, Object.defineProperty(k.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function U(pe, $, F) {
    return !pe.objectMode && pe.decodeStrings !== !1 && typeof $ == "string" && ($ = a.from($, F)), $;
  }
  Object.defineProperty(k.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function N(pe, $, F, ge, ce, ie) {
    if (!F) {
      var re = U($, ge, ce);
      ge !== re && (F = !0, ce = "buffer", ge = re);
    }
    var Te = $.objectMode ? 1 : ge.length;
    $.length += Te;
    var V = $.length < $.highWaterMark;
    if (V || ($.needDrain = !0), $.writing || $.corked) {
      var Pe = $.lastBufferedRequest;
      $.lastBufferedRequest = {
        chunk: ge,
        encoding: ce,
        isBuf: F,
        callback: ie,
        next: null
      }, Pe ? Pe.next = $.lastBufferedRequest : $.bufferedRequest = $.lastBufferedRequest, $.bufferedRequestCount += 1;
    } else
      O(pe, $, !1, Te, ge, ce, ie);
    return V;
  }
  function O(pe, $, F, ge, ce, ie, re) {
    $.writelen = ge, $.writecb = re, $.writing = !0, $.sync = !0, $.destroyed ? $.onwrite(new y("write")) : F ? pe._writev(ce, $.onwrite) : pe._write(ce, ie, $.onwrite), $.sync = !1;
  }
  function I(pe, $, F, ge, ce) {
    --$.pendingcb, F ? (an.nextTick(ce, ge), an.nextTick(P, pe, $), pe._writableState.errorEmitted = !0, _(pe, ge)) : (ce(ge), pe._writableState.errorEmitted = !0, _(pe, ge), P(pe, $));
  }
  function q(pe) {
    pe.writing = !1, pe.writecb = null, pe.length -= pe.writelen, pe.writelen = 0;
  }
  function ae(pe, $) {
    var F = pe._writableState, ge = F.sync, ce = F.writecb;
    if (typeof ce != "function")
      throw new h();
    if (q(F), $)
      I(pe, F, ge, $, ce);
    else {
      var ie = W(F) || pe.destroyed;
      !ie && !F.corked && !F.bufferProcessing && F.bufferedRequest && le(pe, F), ge ? an.nextTick(Q, pe, F, ie, ce) : Q(pe, F, ie, ce);
    }
  }
  function Q(pe, $, F, ge) {
    F || ne(pe, $), $.pendingcb--, ge(), P(pe, $);
  }
  function ne(pe, $) {
    $.length === 0 && $.needDrain && ($.needDrain = !1, pe.emit("drain"));
  }
  function le(pe, $) {
    $.bufferProcessing = !0;
    var F = $.bufferedRequest;
    if (pe._writev && F && F.next) {
      var ge = $.bufferedRequestCount, ce = new Array(ge), ie = $.corkedRequestsFree;
      ie.entry = F;
      for (var re = 0, Te = !0; F; )
        ce[re] = F, F.isBuf || (Te = !1), F = F.next, re += 1;
      ce.allBuffers = Te, O(pe, $, !0, $.length, ce, "", ie.finish), $.pendingcb++, $.lastBufferedRequest = null, ie.next ? ($.corkedRequestsFree = ie.next, ie.next = null) : $.corkedRequestsFree = new e($), $.bufferedRequestCount = 0;
    } else {
      for (; F; ) {
        var V = F.chunk, Pe = F.encoding, z = F.callback, A = $.objectMode ? 1 : V.length;
        if (O(pe, $, !1, A, V, Pe, z), F = F.next, $.bufferedRequestCount--, $.writing)
          break;
      }
      F === null && ($.lastBufferedRequest = null);
    }
    $.bufferedRequest = F, $.bufferProcessing = !1;
  }
  k.prototype._write = function(pe, $, F) {
    F(new f("_write()"));
  }, k.prototype._writev = null, k.prototype.end = function(pe, $, F) {
    var ge = this._writableState;
    return typeof pe == "function" ? (F = pe, pe = null, $ = null) : typeof $ == "function" && (F = $, $ = null), pe != null && this.write(pe, $), ge.corked && (ge.corked = 1, this.uncork()), ge.ending || he(this, ge, F), this;
  }, Object.defineProperty(k.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function W(pe) {
    return pe.ending && pe.length === 0 && pe.bufferedRequest === null && !pe.finished && !pe.writing;
  }
  function X(pe, $) {
    pe._final(function(F) {
      $.pendingcb--, F && _(pe, F), $.prefinished = !0, pe.emit("prefinish"), P(pe, $);
    });
  }
  function G(pe, $) {
    !$.prefinished && !$.finalCalled && (typeof pe._final == "function" && !$.destroyed ? ($.pendingcb++, $.finalCalled = !0, an.nextTick(X, pe, $)) : ($.prefinished = !0, pe.emit("prefinish")));
  }
  function P(pe, $) {
    var F = W($);
    if (F && (G(pe, $), $.pendingcb === 0 && ($.finished = !0, pe.emit("finish"), $.autoDestroy))) {
      var ge = pe._readableState;
      (!ge || ge.autoDestroy && ge.endEmitted) && pe.destroy();
    }
    return F;
  }
  function he(pe, $, F) {
    $.ending = !0, P(pe, $), F && ($.finished ? an.nextTick(F) : pe.once("finish", F)), $.ended = !0, pe.writable = !1;
  }
  function ye(pe, $, F) {
    var ge = pe.entry;
    for (pe.entry = null; ge; ) {
      var ce = ge.callback;
      $.pendingcb--, ce(F), ge = ge.next;
    }
    $.corkedRequestsFree.next = pe;
  }
  return Object.defineProperty(k.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function($) {
      this._writableState && (this._writableState.destroyed = $);
    }
  }), k.prototype.destroy = l.destroy, k.prototype._undestroy = l.undestroy, k.prototype._destroy = function(pe, $) {
    $(pe);
  }, yx;
}
var vx, PM;
function cd() {
  if (PM)
    return vx;
  PM = 1;
  var e = Object.keys || function(u) {
    var c = [];
    for (var d in u)
      c.push(d);
    return c;
  };
  vx = i;
  var t = ZV(), r = XV();
  Hu(i, t);
  for (var n = e(r.prototype), a = 0; a < n.length; a++) {
    var s = n[a];
    i.prototype[s] || (i.prototype[s] = r.prototype[s]);
  }
  function i(u) {
    if (!(this instanceof i))
      return new i(u);
    t.call(this, u), r.call(this, u), this.allowHalfOpen = !0, u && (u.readable === !1 && (this.readable = !1), u.writable === !1 && (this.writable = !1), u.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(i.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(i.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(i.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || an.nextTick(l, this);
  }
  function l(u) {
    u.end();
  }
  return Object.defineProperty(i.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), vx;
}
var wx = {}, vm = { exports: {} }, LM;
function E1e() {
  return LM || (LM = 1, function(e, t) {
    var r = ly(), n = r.Buffer;
    function a(i, o) {
      for (var l in i)
        o[l] = i[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (a(r, t), t.Buffer = s);
    function s(i, o, l) {
      return n(i, o, l);
    }
    a(n, s), s.from = function(i, o, l) {
      if (typeof i == "number")
        throw new TypeError("Argument must not be a number");
      return n(i, o, l);
    }, s.alloc = function(i, o, l) {
      if (typeof i != "number")
        throw new TypeError("Argument must be a number");
      var u = n(i);
      return o !== void 0 ? typeof l == "string" ? u.fill(o, l) : u.fill(o) : u.fill(0), u;
    }, s.allocUnsafe = function(i) {
      if (typeof i != "number")
        throw new TypeError("Argument must be a number");
      return n(i);
    }, s.allocUnsafeSlow = function(i) {
      if (typeof i != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(i);
    };
  }(vm, vm.exports)), vm.exports;
}
var MM;
function AR() {
  if (MM)
    return wx;
  MM = 1;
  var e = E1e().Buffer, t = e.isEncoding || function(b) {
    switch (b = "" + b, b && b.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(b) {
    if (!b)
      return "utf8";
    for (var v; ; )
      switch (b) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return b;
        default:
          if (v)
            return;
          b = ("" + b).toLowerCase(), v = !0;
      }
  }
  function n(b) {
    var v = r(b);
    if (typeof v != "string" && (e.isEncoding === t || !t(b)))
      throw new Error("Unknown encoding: " + b);
    return v || b;
  }
  wx.StringDecoder = a;
  function a(b) {
    this.encoding = n(b);
    var v;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = p, v = 4;
        break;
      case "utf8":
        this.fillLast = l, v = 4;
        break;
      case "base64":
        this.text = f, this.end = h, v = 3;
        break;
      default:
        this.write = m, this.end = y;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(v);
  }
  a.prototype.write = function(b) {
    if (b.length === 0)
      return "";
    var v, x;
    if (this.lastNeed) {
      if (v = this.fillLast(b), v === void 0)
        return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < b.length ? v ? v + this.text(b, x) : this.text(b, x) : v || "";
  }, a.prototype.end = c, a.prototype.text = u, a.prototype.fillLast = function(b) {
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
  };
  function s(b) {
    return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
  }
  function i(b, v, x) {
    var _ = v.length - 1;
    if (_ < x)
      return 0;
    var E = s(v[_]);
    return E >= 0 ? (E > 0 && (b.lastNeed = E - 1), E) : --_ < x || E === -2 ? 0 : (E = s(v[_]), E >= 0 ? (E > 0 && (b.lastNeed = E - 2), E) : --_ < x || E === -2 ? 0 : (E = s(v[_]), E >= 0 ? (E > 0 && (E === 2 ? E = 0 : b.lastNeed = E - 3), E) : 0));
  }
  function o(b, v, x) {
    if ((v[0] & 192) !== 128)
      return b.lastNeed = 0, "�";
    if (b.lastNeed > 1 && v.length > 1) {
      if ((v[1] & 192) !== 128)
        return b.lastNeed = 1, "�";
      if (b.lastNeed > 2 && v.length > 2 && (v[2] & 192) !== 128)
        return b.lastNeed = 2, "�";
    }
  }
  function l(b) {
    var v = this.lastTotal - this.lastNeed, x = o(this, b);
    if (x !== void 0)
      return x;
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, v, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, v, 0, b.length), this.lastNeed -= b.length;
  }
  function u(b, v) {
    var x = i(this, b, v);
    if (!this.lastNeed)
      return b.toString("utf8", v);
    this.lastTotal = x;
    var _ = b.length - (x - this.lastNeed);
    return b.copy(this.lastChar, 0, _), b.toString("utf8", v, _);
  }
  function c(b) {
    var v = b && b.length ? this.write(b) : "";
    return this.lastNeed ? v + "�" : v;
  }
  function d(b, v) {
    if ((b.length - v) % 2 === 0) {
      var x = b.toString("utf16le", v);
      if (x) {
        var _ = x.charCodeAt(x.length - 1);
        if (_ >= 55296 && _ <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", v, b.length - 1);
  }
  function p(b) {
    var v = b && b.length ? this.write(b) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return v + this.lastChar.toString("utf16le", 0, x);
    }
    return v;
  }
  function f(b, v) {
    var x = (b.length - v) % 3;
    return x === 0 ? b.toString("base64", v) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", v, b.length - x));
  }
  function h(b) {
    var v = b && b.length ? this.write(b) : "";
    return this.lastNeed ? v + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : v;
  }
  function m(b) {
    return b.toString(this.encoding);
  }
  function y(b) {
    return b && b.length ? this.write(b) : "";
  }
  return wx;
}
var xx, FM;
function $N() {
  if (FM)
    return xx;
  FM = 1;
  var e = Dd().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(s) {
    var i = !1;
    return function() {
      if (!i) {
        i = !0;
        for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
          l[u] = arguments[u];
        s.apply(this, l);
      }
    };
  }
  function r() {
  }
  function n(s) {
    return s.setHeader && typeof s.abort == "function";
  }
  function a(s, i, o) {
    if (typeof i == "function")
      return a(s, null, i);
    i || (i = {}), o = t(o || r);
    var l = i.readable || i.readable !== !1 && s.readable, u = i.writable || i.writable !== !1 && s.writable, c = function() {
      s.writable || p();
    }, d = s._writableState && s._writableState.finished, p = function() {
      u = !1, d = !0, l || o.call(s);
    }, f = s._readableState && s._readableState.endEmitted, h = function() {
      l = !1, f = !0, u || o.call(s);
    }, m = function(x) {
      o.call(s, x);
    }, y = function() {
      var x;
      if (l && !f)
        return (!s._readableState || !s._readableState.ended) && (x = new e()), o.call(s, x);
      if (u && !d)
        return (!s._writableState || !s._writableState.ended) && (x = new e()), o.call(s, x);
    }, b = function() {
      s.req.on("finish", p);
    };
    return n(s) ? (s.on("complete", p), s.on("abort", y), s.req ? b() : s.on("request", b)) : u && !s._writableState && (s.on("end", c), s.on("close", c)), s.on("end", h), s.on("finish", p), i.error !== !1 && s.on("error", m), s.on("close", y), function() {
      s.removeListener("complete", p), s.removeListener("abort", y), s.removeListener("request", b), s.req && s.req.removeListener("finish", p), s.removeListener("end", c), s.removeListener("close", c), s.removeListener("finish", p), s.removeListener("end", h), s.removeListener("error", m), s.removeListener("close", y);
    };
  }
  return xx = a, xx;
}
var Ex, $M;
function S1e() {
  if ($M)
    return Ex;
  $M = 1;
  var e;
  function t(b, v, x) {
    return v in b ? Object.defineProperty(b, v, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : b[v] = x, b;
  }
  var r = $N(), n = Symbol("lastResolve"), a = Symbol("lastReject"), s = Symbol("error"), i = Symbol("ended"), o = Symbol("lastPromise"), l = Symbol("handlePromise"), u = Symbol("stream");
  function c(b, v) {
    return {
      value: b,
      done: v
    };
  }
  function d(b) {
    var v = b[n];
    if (v !== null) {
      var x = b[u].read();
      x !== null && (b[o] = null, b[n] = null, b[a] = null, v(c(x, !1)));
    }
  }
  function p(b) {
    an.nextTick(d, b);
  }
  function f(b, v) {
    return function(x, _) {
      b.then(function() {
        if (v[i]) {
          x(c(void 0, !0));
          return;
        }
        v[l](x, _);
      }, _);
    };
  }
  var h = Object.getPrototypeOf(function() {
  }), m = Object.setPrototypeOf((e = {
    get stream() {
      return this[u];
    },
    next: function() {
      var v = this, x = this[s];
      if (x !== null)
        return Promise.reject(x);
      if (this[i])
        return Promise.resolve(c(void 0, !0));
      if (this[u].destroyed)
        return new Promise(function(C, k) {
          an.nextTick(function() {
            v[s] ? k(v[s]) : C(c(void 0, !0));
          });
        });
      var _ = this[o], E;
      if (_)
        E = new Promise(f(_, this));
      else {
        var w = this[u].read();
        if (w !== null)
          return Promise.resolve(c(w, !1));
        E = new Promise(this[l]);
      }
      return this[o] = E, E;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var v = this;
    return new Promise(function(x, _) {
      v[u].destroy(null, function(E) {
        if (E) {
          _(E);
          return;
        }
        x(c(void 0, !0));
      });
    });
  }), e), h), y = function(v) {
    var x, _ = Object.create(m, (x = {}, t(x, u, {
      value: v,
      writable: !0
    }), t(x, n, {
      value: null,
      writable: !0
    }), t(x, a, {
      value: null,
      writable: !0
    }), t(x, s, {
      value: null,
      writable: !0
    }), t(x, i, {
      value: v._readableState.endEmitted,
      writable: !0
    }), t(x, l, {
      value: function(w, C) {
        var k = _[u].read();
        k ? (_[o] = null, _[n] = null, _[a] = null, w(c(k, !1))) : (_[n] = w, _[a] = C);
      },
      writable: !0
    }), x));
    return _[o] = null, r(v, function(E) {
      if (E && E.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var w = _[a];
        w !== null && (_[o] = null, _[n] = null, _[a] = null, w(E)), _[s] = E;
        return;
      }
      var C = _[n];
      C !== null && (_[o] = null, _[n] = null, _[a] = null, C(c(void 0, !0))), _[i] = !0;
    }), v.on("readable", p.bind(null, _)), _;
  };
  return Ex = y, Ex;
}
var Sx, BM;
function _1e() {
  return BM || (BM = 1, Sx = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Sx;
}
var _x, UM;
function ZV() {
  if (UM)
    return _x;
  UM = 1, _x = S;
  var e;
  S.ReadableState = k, PN.EventEmitter;
  var t = function(re, Te) {
    return re.listeners(Te).length;
  }, r = zV(), n = ly().Buffer, a = no.Uint8Array || function() {
  };
  function s(ie) {
    return n.from(ie);
  }
  function i(ie) {
    return n.isBuffer(ie) || ie instanceof a;
  }
  var o = WV(), l;
  o && o.debuglog ? l = o.debuglog("stream") : l = function() {
  };
  var u = w1e(), c = KV(), d = YV(), p = d.getHighWaterMark, f = Dd().codes, h = f.ERR_INVALID_ARG_TYPE, m = f.ERR_STREAM_PUSH_AFTER_EOF, y = f.ERR_METHOD_NOT_IMPLEMENTED, b = f.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, v, x, _;
  Hu(S, r);
  var E = c.errorOrDestroy, w = ["error", "close", "destroy", "pause", "resume"];
  function C(ie, re, Te) {
    if (typeof ie.prependListener == "function")
      return ie.prependListener(re, Te);
    !ie._events || !ie._events[re] ? ie.on(re, Te) : Array.isArray(ie._events[re]) ? ie._events[re].unshift(Te) : ie._events[re] = [Te, ie._events[re]];
  }
  function k(ie, re, Te) {
    e = e || cd(), ie = ie || {}, typeof Te != "boolean" && (Te = re instanceof e), this.objectMode = !!ie.objectMode, Te && (this.objectMode = this.objectMode || !!ie.readableObjectMode), this.highWaterMark = p(this, ie, "readableHighWaterMark", Te), this.buffer = new u(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ie.emitClose !== !1, this.autoDestroy = !!ie.autoDestroy, this.destroyed = !1, this.defaultEncoding = ie.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ie.encoding && (v || (v = AR().StringDecoder), this.decoder = new v(ie.encoding), this.encoding = ie.encoding);
  }
  function S(ie) {
    if (e = e || cd(), !(this instanceof S))
      return new S(ie);
    var re = this instanceof e;
    this._readableState = new k(ie, this, re), this.readable = !0, ie && (typeof ie.read == "function" && (this._read = ie.read), typeof ie.destroy == "function" && (this._destroy = ie.destroy)), r.call(this);
  }
  Object.defineProperty(S.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(re) {
      this._readableState && (this._readableState.destroyed = re);
    }
  }), S.prototype.destroy = c.destroy, S.prototype._undestroy = c.undestroy, S.prototype._destroy = function(ie, re) {
    re(ie);
  }, S.prototype.push = function(ie, re) {
    var Te = this._readableState, V;
    return Te.objectMode ? V = !0 : typeof ie == "string" && (re = re || Te.defaultEncoding, re !== Te.encoding && (ie = n.from(ie, re), re = ""), V = !0), B(this, ie, re, !1, V);
  }, S.prototype.unshift = function(ie) {
    return B(this, ie, null, !0, !1);
  };
  function B(ie, re, Te, V, Pe) {
    l("readableAddChunk", re);
    var z = ie._readableState;
    if (re === null)
      z.reading = !1, ae(ie, z);
    else {
      var A;
      if (Pe || (A = N(z, re)), A)
        E(ie, A);
      else if (z.objectMode || re && re.length > 0)
        if (typeof re != "string" && !z.objectMode && Object.getPrototypeOf(re) !== n.prototype && (re = s(re)), V)
          z.endEmitted ? E(ie, new b()) : U(ie, z, re, !0);
        else if (z.ended)
          E(ie, new m());
        else {
          if (z.destroyed)
            return !1;
          z.reading = !1, z.decoder && !Te ? (re = z.decoder.write(re), z.objectMode || re.length !== 0 ? U(ie, z, re, !1) : le(ie, z)) : U(ie, z, re, !1);
        }
      else V || (z.reading = !1, le(ie, z));
    }
    return !z.ended && (z.length < z.highWaterMark || z.length === 0);
  }
  function U(ie, re, Te, V) {
    re.flowing && re.length === 0 && !re.sync ? (re.awaitDrain = 0, ie.emit("data", Te)) : (re.length += re.objectMode ? 1 : Te.length, V ? re.buffer.unshift(Te) : re.buffer.push(Te), re.needReadable && Q(ie)), le(ie, re);
  }
  function N(ie, re) {
    var Te;
    return !i(re) && typeof re != "string" && re !== void 0 && !ie.objectMode && (Te = new h("chunk", ["string", "Buffer", "Uint8Array"], re)), Te;
  }
  S.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, S.prototype.setEncoding = function(ie) {
    v || (v = AR().StringDecoder);
    var re = new v(ie);
    this._readableState.decoder = re, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Te = this._readableState.buffer.head, V = ""; Te !== null; )
      V += re.write(Te.data), Te = Te.next;
    return this._readableState.buffer.clear(), V !== "" && this._readableState.buffer.push(V), this._readableState.length = V.length, this;
  };
  var O = 1073741824;
  function I(ie) {
    return ie >= O ? ie = O : (ie--, ie |= ie >>> 1, ie |= ie >>> 2, ie |= ie >>> 4, ie |= ie >>> 8, ie |= ie >>> 16, ie++), ie;
  }
  function q(ie, re) {
    return ie <= 0 || re.length === 0 && re.ended ? 0 : re.objectMode ? 1 : ie !== ie ? re.flowing && re.length ? re.buffer.head.data.length : re.length : (ie > re.highWaterMark && (re.highWaterMark = I(ie)), ie <= re.length ? ie : re.ended ? re.length : (re.needReadable = !0, 0));
  }
  S.prototype.read = function(ie) {
    l("read", ie), ie = parseInt(ie, 10);
    var re = this._readableState, Te = ie;
    if (ie !== 0 && (re.emittedReadable = !1), ie === 0 && re.needReadable && ((re.highWaterMark !== 0 ? re.length >= re.highWaterMark : re.length > 0) || re.ended))
      return l("read: emitReadable", re.length, re.ended), re.length === 0 && re.ended ? F(this) : Q(this), null;
    if (ie = q(ie, re), ie === 0 && re.ended)
      return re.length === 0 && F(this), null;
    var V = re.needReadable;
    l("need readable", V), (re.length === 0 || re.length - ie < re.highWaterMark) && (V = !0, l("length less than watermark", V)), re.ended || re.reading ? (V = !1, l("reading or ended", V)) : V && (l("do read"), re.reading = !0, re.sync = !0, re.length === 0 && (re.needReadable = !0), this._read(re.highWaterMark), re.sync = !1, re.reading || (ie = q(Te, re)));
    var Pe;
    return ie > 0 ? Pe = $(ie, re) : Pe = null, Pe === null ? (re.needReadable = re.length <= re.highWaterMark, ie = 0) : (re.length -= ie, re.awaitDrain = 0), re.length === 0 && (re.ended || (re.needReadable = !0), Te !== ie && re.ended && F(this)), Pe !== null && this.emit("data", Pe), Pe;
  };
  function ae(ie, re) {
    if (l("onEofChunk"), !re.ended) {
      if (re.decoder) {
        var Te = re.decoder.end();
        Te && Te.length && (re.buffer.push(Te), re.length += re.objectMode ? 1 : Te.length);
      }
      re.ended = !0, re.sync ? Q(ie) : (re.needReadable = !1, re.emittedReadable || (re.emittedReadable = !0, ne(ie)));
    }
  }
  function Q(ie) {
    var re = ie._readableState;
    l("emitReadable", re.needReadable, re.emittedReadable), re.needReadable = !1, re.emittedReadable || (l("emitReadable", re.flowing), re.emittedReadable = !0, an.nextTick(ne, ie));
  }
  function ne(ie) {
    var re = ie._readableState;
    l("emitReadable_", re.destroyed, re.length, re.ended), !re.destroyed && (re.length || re.ended) && (ie.emit("readable"), re.emittedReadable = !1), re.needReadable = !re.flowing && !re.ended && re.length <= re.highWaterMark, pe(ie);
  }
  function le(ie, re) {
    re.readingMore || (re.readingMore = !0, an.nextTick(W, ie, re));
  }
  function W(ie, re) {
    for (; !re.reading && !re.ended && (re.length < re.highWaterMark || re.flowing && re.length === 0); ) {
      var Te = re.length;
      if (l("maybeReadMore read 0"), ie.read(0), Te === re.length)
        break;
    }
    re.readingMore = !1;
  }
  S.prototype._read = function(ie) {
    E(this, new y("_read()"));
  }, S.prototype.pipe = function(ie, re) {
    var Te = this, V = this._readableState;
    switch (V.pipesCount) {
      case 0:
        V.pipes = ie;
        break;
      case 1:
        V.pipes = [V.pipes, ie];
        break;
      default:
        V.pipes.push(ie);
        break;
    }
    V.pipesCount += 1, l("pipe count=%d opts=%j", V.pipesCount, re);
    var Pe = (!re || re.end !== !1) && ie !== an.stdout && ie !== an.stderr, z = Pe ? R : te;
    V.endEmitted ? an.nextTick(z) : Te.once("end", z), ie.on("unpipe", A);
    function A(Fe, Y) {
      l("onunpipe"), Fe === Te && Y && Y.hasUnpiped === !1 && (Y.hasUnpiped = !0, me());
    }
    function R() {
      l("onend"), ie.end();
    }
    var H = X(Te);
    ie.on("drain", H);
    var be = !1;
    function me() {
      l("cleanup"), ie.removeListener("close", xe), ie.removeListener("finish", we), ie.removeListener("drain", H), ie.removeListener("error", We), ie.removeListener("unpipe", A), Te.removeListener("end", R), Te.removeListener("end", te), Te.removeListener("data", Ce), be = !0, V.awaitDrain && (!ie._writableState || ie._writableState.needDrain) && H();
    }
    Te.on("data", Ce);
    function Ce(Fe) {
      l("ondata");
      var Y = ie.write(Fe);
      l("dest.write", Y), Y === !1 && ((V.pipesCount === 1 && V.pipes === ie || V.pipesCount > 1 && ce(V.pipes, ie) !== -1) && !be && (l("false write response, pause", V.awaitDrain), V.awaitDrain++), Te.pause());
    }
    function We(Fe) {
      l("onerror", Fe), te(), ie.removeListener("error", We), t(ie, "error") === 0 && E(ie, Fe);
    }
    C(ie, "error", We);
    function xe() {
      ie.removeListener("finish", we), te();
    }
    ie.once("close", xe);
    function we() {
      l("onfinish"), ie.removeListener("close", xe), te();
    }
    ie.once("finish", we);
    function te() {
      l("unpipe"), Te.unpipe(ie);
    }
    return ie.emit("pipe", Te), V.flowing || (l("pipe resume"), Te.resume()), ie;
  };
  function X(ie) {
    return function() {
      var Te = ie._readableState;
      l("pipeOnDrain", Te.awaitDrain), Te.awaitDrain && Te.awaitDrain--, Te.awaitDrain === 0 && t(ie, "data") && (Te.flowing = !0, pe(ie));
    };
  }
  S.prototype.unpipe = function(ie) {
    var re = this._readableState, Te = {
      hasUnpiped: !1
    };
    if (re.pipesCount === 0)
      return this;
    if (re.pipesCount === 1)
      return ie && ie !== re.pipes ? this : (ie || (ie = re.pipes), re.pipes = null, re.pipesCount = 0, re.flowing = !1, ie && ie.emit("unpipe", this, Te), this);
    if (!ie) {
      var V = re.pipes, Pe = re.pipesCount;
      re.pipes = null, re.pipesCount = 0, re.flowing = !1;
      for (var z = 0; z < Pe; z++)
        V[z].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var A = ce(re.pipes, ie);
    return A === -1 ? this : (re.pipes.splice(A, 1), re.pipesCount -= 1, re.pipesCount === 1 && (re.pipes = re.pipes[0]), ie.emit("unpipe", this, Te), this);
  }, S.prototype.on = function(ie, re) {
    var Te = r.prototype.on.call(this, ie, re), V = this._readableState;
    return ie === "data" ? (V.readableListening = this.listenerCount("readable") > 0, V.flowing !== !1 && this.resume()) : ie === "readable" && !V.endEmitted && !V.readableListening && (V.readableListening = V.needReadable = !0, V.flowing = !1, V.emittedReadable = !1, l("on readable", V.length, V.reading), V.length ? Q(this) : V.reading || an.nextTick(P, this)), Te;
  }, S.prototype.addListener = S.prototype.on, S.prototype.removeListener = function(ie, re) {
    var Te = r.prototype.removeListener.call(this, ie, re);
    return ie === "readable" && an.nextTick(G, this), Te;
  }, S.prototype.removeAllListeners = function(ie) {
    var re = r.prototype.removeAllListeners.apply(this, arguments);
    return (ie === "readable" || ie === void 0) && an.nextTick(G, this), re;
  };
  function G(ie) {
    var re = ie._readableState;
    re.readableListening = ie.listenerCount("readable") > 0, re.resumeScheduled && !re.paused ? re.flowing = !0 : ie.listenerCount("data") > 0 && ie.resume();
  }
  function P(ie) {
    l("readable nexttick read 0"), ie.read(0);
  }
  S.prototype.resume = function() {
    var ie = this._readableState;
    return ie.flowing || (l("resume"), ie.flowing = !ie.readableListening, he(this, ie)), ie.paused = !1, this;
  };
  function he(ie, re) {
    re.resumeScheduled || (re.resumeScheduled = !0, an.nextTick(ye, ie, re));
  }
  function ye(ie, re) {
    l("resume", re.reading), re.reading || ie.read(0), re.resumeScheduled = !1, ie.emit("resume"), pe(ie), re.flowing && !re.reading && ie.read(0);
  }
  S.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function pe(ie) {
    var re = ie._readableState;
    for (l("flow", re.flowing); re.flowing && ie.read() !== null; )
      ;
  }
  S.prototype.wrap = function(ie) {
    var re = this, Te = this._readableState, V = !1;
    ie.on("end", function() {
      if (l("wrapped end"), Te.decoder && !Te.ended) {
        var A = Te.decoder.end();
        A && A.length && re.push(A);
      }
      re.push(null);
    }), ie.on("data", function(A) {
      if (l("wrapped data"), Te.decoder && (A = Te.decoder.write(A)), !(Te.objectMode && A == null) && !(!Te.objectMode && (!A || !A.length))) {
        var R = re.push(A);
        R || (V = !0, ie.pause());
      }
    });
    for (var Pe in ie)
      this[Pe] === void 0 && typeof ie[Pe] == "function" && (this[Pe] = /* @__PURE__ */ function(R) {
        return function() {
          return ie[R].apply(ie, arguments);
        };
      }(Pe));
    for (var z = 0; z < w.length; z++)
      ie.on(w[z], this.emit.bind(this, w[z]));
    return this._read = function(A) {
      l("wrapped _read", A), V && (V = !1, ie.resume());
    }, this;
  }, typeof Symbol == "function" && (S.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = S1e()), x(this);
  }), Object.defineProperty(S.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(S.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(S.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(re) {
      this._readableState && (this._readableState.flowing = re);
    }
  }), S._fromList = $, Object.defineProperty(S.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function $(ie, re) {
    if (re.length === 0)
      return null;
    var Te;
    return re.objectMode ? Te = re.buffer.shift() : !ie || ie >= re.length ? (re.decoder ? Te = re.buffer.join("") : re.buffer.length === 1 ? Te = re.buffer.first() : Te = re.buffer.concat(re.length), re.buffer.clear()) : Te = re.buffer.consume(ie, re.decoder), Te;
  }
  function F(ie) {
    var re = ie._readableState;
    l("endReadable", re.endEmitted), re.endEmitted || (re.ended = !0, an.nextTick(ge, re, ie));
  }
  function ge(ie, re) {
    if (l("endReadableNT", ie.endEmitted, ie.length), !ie.endEmitted && ie.length === 0 && (ie.endEmitted = !0, re.readable = !1, re.emit("end"), ie.autoDestroy)) {
      var Te = re._writableState;
      (!Te || Te.autoDestroy && Te.finished) && re.destroy();
    }
  }
  typeof Symbol == "function" && (S.from = function(ie, re) {
    return _ === void 0 && (_ = _1e()), _(S, ie, re);
  });
  function ce(ie, re) {
    for (var Te = 0, V = ie.length; Te < V; Te++)
      if (ie[Te] === re)
        return Te;
    return -1;
  }
  return _x;
}
var kx, zM;
function JV() {
  if (zM)
    return kx;
  zM = 1, kx = o;
  var e = Dd().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, r = e.ERR_MULTIPLE_CALLBACK, n = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = e.ERR_TRANSFORM_WITH_LENGTH_0, s = cd();
  Hu(o, s);
  function i(c, d) {
    var p = this._transformState;
    p.transforming = !1;
    var f = p.writecb;
    if (f === null)
      return this.emit("error", new r());
    p.writechunk = null, p.writecb = null, d != null && this.push(d), f(c);
    var h = this._readableState;
    h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
  }
  function o(c) {
    if (!(this instanceof o))
      return new o(c);
    s.call(this, c), this._transformState = {
      afterTransform: i.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, c && (typeof c.transform == "function" && (this._transform = c.transform), typeof c.flush == "function" && (this._flush = c.flush)), this.on("prefinish", l);
  }
  function l() {
    var c = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(d, p) {
      u(c, d, p);
    }) : u(this, null, null);
  }
  o.prototype.push = function(c, d) {
    return this._transformState.needTransform = !1, s.prototype.push.call(this, c, d);
  }, o.prototype._transform = function(c, d, p) {
    p(new t("_transform()"));
  }, o.prototype._write = function(c, d, p) {
    var f = this._transformState;
    if (f.writecb = p, f.writechunk = c, f.writeencoding = d, !f.transforming) {
      var h = this._readableState;
      (f.needTransform || h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
    }
  }, o.prototype._read = function(c) {
    var d = this._transformState;
    d.writechunk !== null && !d.transforming ? (d.transforming = !0, this._transform(d.writechunk, d.writeencoding, d.afterTransform)) : d.needTransform = !0;
  }, o.prototype._destroy = function(c, d) {
    s.prototype._destroy.call(this, c, function(p) {
      d(p);
    });
  };
  function u(c, d, p) {
    if (d)
      return c.emit("error", d);
    if (p != null && c.push(p), c._writableState.length)
      throw new a();
    if (c._transformState.transforming)
      throw new n();
    return c.push(null);
  }
  return kx;
}
var Cx, qM;
function k1e() {
  if (qM)
    return Cx;
  qM = 1, Cx = t;
  var e = JV();
  Hu(t, e);
  function t(r) {
    if (!(this instanceof t))
      return new t(r);
    e.call(this, r);
  }
  return t.prototype._transform = function(r, n, a) {
    a(null, r);
  }, Cx;
}
var Ax, jM;
function C1e() {
  if (jM)
    return Ax;
  jM = 1;
  var e;
  function t(p) {
    var f = !1;
    return function() {
      f || (f = !0, p.apply(void 0, arguments));
    };
  }
  var r = Dd().codes, n = r.ERR_MISSING_ARGS, a = r.ERR_STREAM_DESTROYED;
  function s(p) {
    if (p)
      throw p;
  }
  function i(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function o(p, f, h, m) {
    m = t(m);
    var y = !1;
    p.on("close", function() {
      y = !0;
    }), e === void 0 && (e = $N()), e(p, {
      readable: f,
      writable: h
    }, function(v) {
      if (v)
        return m(v);
      y = !0, m();
    });
    var b = !1;
    return function(v) {
      if (!y && !b) {
        if (b = !0, i(p))
          return p.abort();
        if (typeof p.destroy == "function")
          return p.destroy();
        m(v || new a("pipe"));
      }
    };
  }
  function l(p) {
    p();
  }
  function u(p, f) {
    return p.pipe(f);
  }
  function c(p) {
    return !p.length || typeof p[p.length - 1] != "function" ? s : p.pop();
  }
  function d() {
    for (var p = arguments.length, f = new Array(p), h = 0; h < p; h++)
      f[h] = arguments[h];
    var m = c(f);
    if (Array.isArray(f[0]) && (f = f[0]), f.length < 2)
      throw new n("streams");
    var y, b = f.map(function(v, x) {
      var _ = x < f.length - 1, E = x > 0;
      return o(v, _, E, function(w) {
        y || (y = w), w && b.forEach(l), !_ && (b.forEach(l), m(y));
      });
    });
    return f.reduce(u);
  }
  return Ax = d, Ax;
}
var BN = cs, UN = PN.EventEmitter, A1e = Hu;
A1e(cs, UN);
cs.Readable = ZV();
cs.Writable = XV();
cs.Duplex = cd();
cs.Transform = JV();
cs.PassThrough = k1e();
cs.finished = $N();
cs.pipeline = C1e();
cs.Stream = cs;
function cs() {
  UN.call(this);
}
cs.prototype.pipe = function(e, t) {
  var r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function a() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", a), !e._isStdio && (!t || t.end !== !1) && (r.on("end", i), r.on("close", o));
  var s = !1;
  function i() {
    s || (s = !0, e.end());
  }
  function o() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function l(c) {
    if (u(), UN.listenerCount(this, "error") === 0)
      throw c;
  }
  r.on("error", l), e.on("error", l);
  function u() {
    r.removeListener("data", n), e.removeListener("drain", a), r.removeListener("end", i), r.removeListener("close", o), r.removeListener("error", l), e.removeListener("error", l), r.removeListener("end", u), r.removeListener("close", u), e.removeListener("close", u);
  }
  return r.on("end", u), r.on("close", u), e.on("close", u), e.emit("pipe", r), e;
};
(function(e) {
  (function(t) {
    t.parser = function($, F) {
      return new n($, F);
    }, t.SAXParser = n, t.SAXStream = c, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
    var r = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function n($, F) {
      if (!(this instanceof n))
        return new n($, F);
      var ge = this;
      s(ge), ge.q = ge.c = "", ge.bufferCheckPosition = t.MAX_BUFFER_LENGTH, ge.opt = F || {}, ge.opt.lowercase = ge.opt.lowercase || ge.opt.lowercasetags, ge.looseCase = ge.opt.lowercase ? "toLowerCase" : "toUpperCase", ge.tags = [], ge.closed = ge.closedRoot = ge.sawRoot = !1, ge.tag = ge.error = null, ge.strict = !!$, ge.noscript = !!($ || ge.opt.noscript), ge.state = S.BEGIN, ge.strictEntities = ge.opt.strictEntities, ge.ENTITIES = ge.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), ge.attribList = [], ge.opt.xmlns && (ge.ns = Object.create(m)), ge.trackPosition = ge.opt.position !== !1, ge.trackPosition && (ge.position = ge.line = ge.column = 0), U(ge, "onready");
    }
    Object.create || (Object.create = function($) {
      function F() {
      }
      F.prototype = $;
      var ge = new F();
      return ge;
    }), Object.keys || (Object.keys = function($) {
      var F = [];
      for (var ge in $)
        $.hasOwnProperty(ge) && F.push(ge);
      return F;
    });
    function a($) {
      for (var F = Math.max(t.MAX_BUFFER_LENGTH, 10), ge = 0, ce = 0, ie = r.length; ce < ie; ce++) {
        var re = $[r[ce]].length;
        if (re > F)
          switch (r[ce]) {
            case "textNode":
              O($);
              break;
            case "cdata":
              N($, "oncdata", $.cdata), $.cdata = "";
              break;
            case "script":
              N($, "onscript", $.script), $.script = "";
              break;
            default:
              q($, "Max buffer length exceeded: " + r[ce]);
          }
        ge = Math.max(ge, re);
      }
      var Te = t.MAX_BUFFER_LENGTH - ge;
      $.bufferCheckPosition = Te + $.position;
    }
    function s($) {
      for (var F = 0, ge = r.length; F < ge; F++)
        $[r[F]] = "";
    }
    function i($) {
      O($), $.cdata !== "" && (N($, "oncdata", $.cdata), $.cdata = ""), $.script !== "" && (N($, "onscript", $.script), $.script = "");
    }
    n.prototype = {
      end: function() {
        ae(this);
      },
      write: pe,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        i(this);
      }
    };
    var o;
    try {
      o = BN.Stream;
    } catch {
      o = function() {
      };
    }
    var l = t.EVENTS.filter(function($) {
      return $ !== "error" && $ !== "end";
    });
    function u($, F) {
      return new c($, F);
    }
    function c($, F) {
      if (!(this instanceof c))
        return new c($, F);
      o.apply(this), this._parser = new n($, F), this.writable = !0, this.readable = !0;
      var ge = this;
      this._parser.onend = function() {
        ge.emit("end");
      }, this._parser.onerror = function(ce) {
        ge.emit("error", ce), ge._parser.error = null;
      }, this._decoder = null, l.forEach(function(ce) {
        Object.defineProperty(ge, "on" + ce, {
          get: function() {
            return ge._parser["on" + ce];
          },
          set: function(ie) {
            if (!ie)
              return ge.removeAllListeners(ce), ge._parser["on" + ce] = ie, ie;
            ge.on(ce, ie);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    c.prototype = Object.create(o.prototype, {
      constructor: {
        value: c
      }
    }), c.prototype.write = function($) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer($)) {
        if (!this._decoder) {
          var F = AR().StringDecoder;
          this._decoder = new F("utf8");
        }
        $ = this._decoder.write($);
      }
      return this._parser.write($.toString()), this.emit("data", $), !0;
    }, c.prototype.end = function($) {
      return $ && $.length && this.write($), this._parser.end(), !0;
    }, c.prototype.on = function($, F) {
      var ge = this;
      return !ge._parser["on" + $] && l.indexOf($) !== -1 && (ge._parser["on" + $] = function() {
        var ce = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        ce.splice(0, 0, $), ge.emit.apply(ge, ce);
      }), o.prototype.on.call(ge, $, F);
    };
    var d = "[CDATA[", p = "DOCTYPE", f = "http://www.w3.org/XML/1998/namespace", h = "http://www.w3.org/2000/xmlns/", m = { xml: f, xmlns: h }, y = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, v = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, x = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function _($) {
      return $ === " " || $ === `
` || $ === "\r" || $ === "	";
    }
    function E($) {
      return $ === '"' || $ === "'";
    }
    function w($) {
      return $ === ">" || _($);
    }
    function C($, F) {
      return $.test(F);
    }
    function k($, F) {
      return !C($, F);
    }
    var S = 0;
    t.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++
      // <script> ... <
    }, t.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, t.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(t.ENTITIES).forEach(function($) {
      var F = t.ENTITIES[$], ge = typeof F == "number" ? String.fromCharCode(F) : F;
      t.ENTITIES[$] = ge;
    });
    for (var B in t.STATE)
      t.STATE[t.STATE[B]] = B;
    S = t.STATE;
    function U($, F, ge) {
      $[F] && $[F](ge);
    }
    function N($, F, ge) {
      $.textNode && O($), U($, F, ge);
    }
    function O($) {
      $.textNode = I($.opt, $.textNode), $.textNode && U($, "ontext", $.textNode), $.textNode = "";
    }
    function I($, F) {
      return $.trim && (F = F.trim()), $.normalize && (F = F.replace(/\s+/g, " ")), F;
    }
    function q($, F) {
      return O($), $.trackPosition && (F += `
Line: ` + $.line + `
Column: ` + $.column + `
Char: ` + $.c), F = new Error(F), $.error = F, U($, "onerror", F), $;
    }
    function ae($) {
      return $.sawRoot && !$.closedRoot && Q($, "Unclosed root tag"), $.state !== S.BEGIN && $.state !== S.BEGIN_WHITESPACE && $.state !== S.TEXT && q($, "Unexpected end"), O($), $.c = "", $.closed = !0, U($, "onend"), n.call($, $.strict, $.opt), $;
    }
    function Q($, F) {
      if (typeof $ != "object" || !($ instanceof n))
        throw new Error("bad call to strictFail");
      $.strict && q($, F);
    }
    function ne($) {
      $.strict || ($.tagName = $.tagName[$.looseCase]());
      var F = $.tags[$.tags.length - 1] || $, ge = $.tag = { name: $.tagName, attributes: {} };
      $.opt.xmlns && (ge.ns = F.ns), $.attribList.length = 0, N($, "onopentagstart", ge);
    }
    function le($, F) {
      var ge = $.indexOf(":"), ce = ge < 0 ? ["", $] : $.split(":"), ie = ce[0], re = ce[1];
      return F && $ === "xmlns" && (ie = "xmlns", re = ""), { prefix: ie, local: re };
    }
    function W($) {
      if ($.strict || ($.attribName = $.attribName[$.looseCase]()), $.attribList.indexOf($.attribName) !== -1 || $.tag.attributes.hasOwnProperty($.attribName)) {
        $.attribName = $.attribValue = "";
        return;
      }
      if ($.opt.xmlns) {
        var F = le($.attribName, !0), ge = F.prefix, ce = F.local;
        if (ge === "xmlns")
          if (ce === "xml" && $.attribValue !== f)
            Q(
              $,
              "xml: prefix must be bound to " + f + `
Actual: ` + $.attribValue
            );
          else if (ce === "xmlns" && $.attribValue !== h)
            Q(
              $,
              "xmlns: prefix must be bound to " + h + `
Actual: ` + $.attribValue
            );
          else {
            var ie = $.tag, re = $.tags[$.tags.length - 1] || $;
            ie.ns === re.ns && (ie.ns = Object.create(re.ns)), ie.ns[ce] = $.attribValue;
          }
        $.attribList.push([$.attribName, $.attribValue]);
      } else
        $.tag.attributes[$.attribName] = $.attribValue, N($, "onattribute", {
          name: $.attribName,
          value: $.attribValue
        });
      $.attribName = $.attribValue = "";
    }
    function X($, F) {
      if ($.opt.xmlns) {
        var ge = $.tag, ce = le($.tagName);
        ge.prefix = ce.prefix, ge.local = ce.local, ge.uri = ge.ns[ce.prefix] || "", ge.prefix && !ge.uri && (Q($, "Unbound namespace prefix: " + JSON.stringify($.tagName)), ge.uri = ce.prefix);
        var ie = $.tags[$.tags.length - 1] || $;
        ge.ns && ie.ns !== ge.ns && Object.keys(ge.ns).forEach(function(Ce) {
          N($, "onopennamespace", {
            prefix: Ce,
            uri: ge.ns[Ce]
          });
        });
        for (var re = 0, Te = $.attribList.length; re < Te; re++) {
          var V = $.attribList[re], Pe = V[0], z = V[1], A = le(Pe, !0), R = A.prefix, H = A.local, be = R === "" ? "" : ge.ns[R] || "", me = {
            name: Pe,
            value: z,
            prefix: R,
            local: H,
            uri: be
          };
          R && R !== "xmlns" && !be && (Q($, "Unbound namespace prefix: " + JSON.stringify(R)), me.uri = R), $.tag.attributes[Pe] = me, N($, "onattribute", me);
        }
        $.attribList.length = 0;
      }
      $.tag.isSelfClosing = !!F, $.sawRoot = !0, $.tags.push($.tag), N($, "onopentag", $.tag), F || (!$.noscript && $.tagName.toLowerCase() === "script" ? $.state = S.SCRIPT : $.state = S.TEXT, $.tag = null, $.tagName = ""), $.attribName = $.attribValue = "", $.attribList.length = 0;
    }
    function G($) {
      if (!$.tagName) {
        Q($, "Weird empty close tag."), $.textNode += "</>", $.state = S.TEXT;
        return;
      }
      if ($.script) {
        if ($.tagName !== "script") {
          $.script += "</" + $.tagName + ">", $.tagName = "", $.state = S.SCRIPT;
          return;
        }
        N($, "onscript", $.script), $.script = "";
      }
      var F = $.tags.length, ge = $.tagName;
      $.strict || (ge = ge[$.looseCase]());
      for (var ce = ge; F--; ) {
        var ie = $.tags[F];
        if (ie.name !== ce)
          Q($, "Unexpected close tag");
        else
          break;
      }
      if (F < 0) {
        Q($, "Unmatched closing tag: " + $.tagName), $.textNode += "</" + $.tagName + ">", $.state = S.TEXT;
        return;
      }
      $.tagName = ge;
      for (var re = $.tags.length; re-- > F; ) {
        var Te = $.tag = $.tags.pop();
        $.tagName = $.tag.name, N($, "onclosetag", $.tagName);
        var V = {};
        for (var Pe in Te.ns)
          V[Pe] = Te.ns[Pe];
        var z = $.tags[$.tags.length - 1] || $;
        $.opt.xmlns && Te.ns !== z.ns && Object.keys(Te.ns).forEach(function(A) {
          var R = Te.ns[A];
          N($, "onclosenamespace", { prefix: A, uri: R });
        });
      }
      F === 0 && ($.closedRoot = !0), $.tagName = $.attribValue = $.attribName = "", $.attribList.length = 0, $.state = S.TEXT;
    }
    function P($) {
      var F = $.entity, ge = F.toLowerCase(), ce, ie = "";
      return $.ENTITIES[F] ? $.ENTITIES[F] : $.ENTITIES[ge] ? $.ENTITIES[ge] : (F = ge, F.charAt(0) === "#" && (F.charAt(1) === "x" ? (F = F.slice(2), ce = parseInt(F, 16), ie = ce.toString(16)) : (F = F.slice(1), ce = parseInt(F, 10), ie = ce.toString(10))), F = F.replace(/^0+/, ""), isNaN(ce) || ie.toLowerCase() !== F ? (Q($, "Invalid character entity"), "&" + $.entity + ";") : String.fromCodePoint(ce));
    }
    function he($, F) {
      F === "<" ? ($.state = S.OPEN_WAKA, $.startTagPosition = $.position) : _(F) || (Q($, "Non-whitespace before first tag."), $.textNode = F, $.state = S.TEXT);
    }
    function ye($, F) {
      var ge = "";
      return F < $.length && (ge = $.charAt(F)), ge;
    }
    function pe($) {
      var F = this;
      if (this.error)
        throw this.error;
      if (F.closed)
        return q(
          F,
          "Cannot write after close. Assign an onready handler."
        );
      if ($ === null)
        return ae(F);
      typeof $ == "object" && ($ = $.toString());
      for (var ge = 0, ce = ""; ce = ye($, ge++), F.c = ce, !!ce; )
        switch (F.trackPosition && (F.position++, ce === `
` ? (F.line++, F.column = 0) : F.column++), F.state) {
          case S.BEGIN:
            if (F.state = S.BEGIN_WHITESPACE, ce === "\uFEFF")
              continue;
            he(F, ce);
            continue;
          case S.BEGIN_WHITESPACE:
            he(F, ce);
            continue;
          case S.TEXT:
            if (F.sawRoot && !F.closedRoot) {
              for (var ie = ge - 1; ce && ce !== "<" && ce !== "&"; )
                ce = ye($, ge++), ce && F.trackPosition && (F.position++, ce === `
` ? (F.line++, F.column = 0) : F.column++);
              F.textNode += $.substring(ie, ge - 1);
            }
            ce === "<" && !(F.sawRoot && F.closedRoot && !F.strict) ? (F.state = S.OPEN_WAKA, F.startTagPosition = F.position) : (!_(ce) && (!F.sawRoot || F.closedRoot) && Q(F, "Text data outside of root node."), ce === "&" ? F.state = S.TEXT_ENTITY : F.textNode += ce);
            continue;
          case S.SCRIPT:
            ce === "<" ? F.state = S.SCRIPT_ENDING : F.script += ce;
            continue;
          case S.SCRIPT_ENDING:
            ce === "/" ? F.state = S.CLOSE_TAG : (F.script += "<" + ce, F.state = S.SCRIPT);
            continue;
          case S.OPEN_WAKA:
            if (ce === "!")
              F.state = S.SGML_DECL, F.sgmlDecl = "";
            else if (!_(ce))
              if (C(y, ce))
                F.state = S.OPEN_TAG, F.tagName = ce;
              else if (ce === "/")
                F.state = S.CLOSE_TAG, F.tagName = "";
              else if (ce === "?")
                F.state = S.PROC_INST, F.procInstName = F.procInstBody = "";
              else {
                if (Q(F, "Unencoded <"), F.startTagPosition + 1 < F.position) {
                  var re = F.position - F.startTagPosition;
                  ce = new Array(re).join(" ") + ce;
                }
                F.textNode += "<" + ce, F.state = S.TEXT;
              }
            continue;
          case S.SGML_DECL:
            (F.sgmlDecl + ce).toUpperCase() === d ? (N(F, "onopencdata"), F.state = S.CDATA, F.sgmlDecl = "", F.cdata = "") : F.sgmlDecl + ce === "--" ? (F.state = S.COMMENT, F.comment = "", F.sgmlDecl = "") : (F.sgmlDecl + ce).toUpperCase() === p ? (F.state = S.DOCTYPE, (F.doctype || F.sawRoot) && Q(
              F,
              "Inappropriately located doctype declaration"
            ), F.doctype = "", F.sgmlDecl = "") : ce === ">" ? (N(F, "onsgmldeclaration", F.sgmlDecl), F.sgmlDecl = "", F.state = S.TEXT) : (E(ce) && (F.state = S.SGML_DECL_QUOTED), F.sgmlDecl += ce);
            continue;
          case S.SGML_DECL_QUOTED:
            ce === F.q && (F.state = S.SGML_DECL, F.q = ""), F.sgmlDecl += ce;
            continue;
          case S.DOCTYPE:
            ce === ">" ? (F.state = S.TEXT, N(F, "ondoctype", F.doctype), F.doctype = !0) : (F.doctype += ce, ce === "[" ? F.state = S.DOCTYPE_DTD : E(ce) && (F.state = S.DOCTYPE_QUOTED, F.q = ce));
            continue;
          case S.DOCTYPE_QUOTED:
            F.doctype += ce, ce === F.q && (F.q = "", F.state = S.DOCTYPE);
            continue;
          case S.DOCTYPE_DTD:
            F.doctype += ce, ce === "]" ? F.state = S.DOCTYPE : E(ce) && (F.state = S.DOCTYPE_DTD_QUOTED, F.q = ce);
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            F.doctype += ce, ce === F.q && (F.state = S.DOCTYPE_DTD, F.q = "");
            continue;
          case S.COMMENT:
            ce === "-" ? F.state = S.COMMENT_ENDING : F.comment += ce;
            continue;
          case S.COMMENT_ENDING:
            ce === "-" ? (F.state = S.COMMENT_ENDED, F.comment = I(F.opt, F.comment), F.comment && N(F, "oncomment", F.comment), F.comment = "") : (F.comment += "-" + ce, F.state = S.COMMENT);
            continue;
          case S.COMMENT_ENDED:
            ce !== ">" ? (Q(F, "Malformed comment"), F.comment += "--" + ce, F.state = S.COMMENT) : F.state = S.TEXT;
            continue;
          case S.CDATA:
            ce === "]" ? F.state = S.CDATA_ENDING : F.cdata += ce;
            continue;
          case S.CDATA_ENDING:
            ce === "]" ? F.state = S.CDATA_ENDING_2 : (F.cdata += "]" + ce, F.state = S.CDATA);
            continue;
          case S.CDATA_ENDING_2:
            ce === ">" ? (F.cdata && N(F, "oncdata", F.cdata), N(F, "onclosecdata"), F.cdata = "", F.state = S.TEXT) : ce === "]" ? F.cdata += "]" : (F.cdata += "]]" + ce, F.state = S.CDATA);
            continue;
          case S.PROC_INST:
            ce === "?" ? F.state = S.PROC_INST_ENDING : _(ce) ? F.state = S.PROC_INST_BODY : F.procInstName += ce;
            continue;
          case S.PROC_INST_BODY:
            if (!F.procInstBody && _(ce))
              continue;
            ce === "?" ? F.state = S.PROC_INST_ENDING : F.procInstBody += ce;
            continue;
          case S.PROC_INST_ENDING:
            ce === ">" ? (N(F, "onprocessinginstruction", {
              name: F.procInstName,
              body: F.procInstBody
            }), F.procInstName = F.procInstBody = "", F.state = S.TEXT) : (F.procInstBody += "?" + ce, F.state = S.PROC_INST_BODY);
            continue;
          case S.OPEN_TAG:
            C(b, ce) ? F.tagName += ce : (ne(F), ce === ">" ? X(F) : ce === "/" ? F.state = S.OPEN_TAG_SLASH : (_(ce) || Q(F, "Invalid character in tag name"), F.state = S.ATTRIB));
            continue;
          case S.OPEN_TAG_SLASH:
            ce === ">" ? (X(F, !0), G(F)) : (Q(F, "Forward-slash in opening tag not followed by >"), F.state = S.ATTRIB);
            continue;
          case S.ATTRIB:
            if (_(ce))
              continue;
            ce === ">" ? X(F) : ce === "/" ? F.state = S.OPEN_TAG_SLASH : C(y, ce) ? (F.attribName = ce, F.attribValue = "", F.state = S.ATTRIB_NAME) : Q(F, "Invalid attribute name");
            continue;
          case S.ATTRIB_NAME:
            ce === "=" ? F.state = S.ATTRIB_VALUE : ce === ">" ? (Q(F, "Attribute without value"), F.attribValue = F.attribName, W(F), X(F)) : _(ce) ? F.state = S.ATTRIB_NAME_SAW_WHITE : C(b, ce) ? F.attribName += ce : Q(F, "Invalid attribute name");
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (ce === "=")
              F.state = S.ATTRIB_VALUE;
            else {
              if (_(ce))
                continue;
              Q(F, "Attribute without value"), F.tag.attributes[F.attribName] = "", F.attribValue = "", N(F, "onattribute", {
                name: F.attribName,
                value: ""
              }), F.attribName = "", ce === ">" ? X(F) : C(y, ce) ? (F.attribName = ce, F.state = S.ATTRIB_NAME) : (Q(F, "Invalid attribute name"), F.state = S.ATTRIB);
            }
            continue;
          case S.ATTRIB_VALUE:
            if (_(ce))
              continue;
            E(ce) ? (F.q = ce, F.state = S.ATTRIB_VALUE_QUOTED) : (Q(F, "Unquoted attribute value"), F.state = S.ATTRIB_VALUE_UNQUOTED, F.attribValue = ce);
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (ce !== F.q) {
              ce === "&" ? F.state = S.ATTRIB_VALUE_ENTITY_Q : F.attribValue += ce;
              continue;
            }
            W(F), F.q = "", F.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            _(ce) ? F.state = S.ATTRIB : ce === ">" ? X(F) : ce === "/" ? F.state = S.OPEN_TAG_SLASH : C(y, ce) ? (Q(F, "No whitespace between attributes"), F.attribName = ce, F.attribValue = "", F.state = S.ATTRIB_NAME) : Q(F, "Invalid attribute name");
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!w(ce)) {
              ce === "&" ? F.state = S.ATTRIB_VALUE_ENTITY_U : F.attribValue += ce;
              continue;
            }
            W(F), ce === ">" ? X(F) : F.state = S.ATTRIB;
            continue;
          case S.CLOSE_TAG:
            if (F.tagName)
              ce === ">" ? G(F) : C(b, ce) ? F.tagName += ce : F.script ? (F.script += "</" + F.tagName, F.tagName = "", F.state = S.SCRIPT) : (_(ce) || Q(F, "Invalid tagname in closing tag"), F.state = S.CLOSE_TAG_SAW_WHITE);
            else {
              if (_(ce))
                continue;
              k(y, ce) ? F.script ? (F.script += "</" + ce, F.state = S.SCRIPT) : Q(F, "Invalid tagname in closing tag.") : F.tagName = ce;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (_(ce))
              continue;
            ce === ">" ? G(F) : Q(F, "Invalid characters in closing tag");
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var Te, V;
            switch (F.state) {
              case S.TEXT_ENTITY:
                Te = S.TEXT, V = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                Te = S.ATTRIB_VALUE_QUOTED, V = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                Te = S.ATTRIB_VALUE_UNQUOTED, V = "attribValue";
                break;
            }
            ce === ";" ? (F[V] += P(F), F.entity = "", F.state = Te) : C(F.entity.length ? x : v, ce) ? F.entity += ce : (Q(F, "Invalid character in entity name"), F[V] += "&" + F.entity + ce, F.entity = "", F.state = Te);
            continue;
          default:
            throw new Error(F, "Unknown state: " + F.state);
        }
      return F.position >= F.bufferCheckPosition && a(F), F;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var $ = String.fromCharCode, F = Math.floor, ge = function() {
        var ce = 16384, ie = [], re, Te, V = -1, Pe = arguments.length;
        if (!Pe)
          return "";
        for (var z = ""; ++V < Pe; ) {
          var A = Number(arguments[V]);
          if (!isFinite(A) || // `NaN`, `+Infinity`, or `-Infinity`
          A < 0 || // not a valid Unicode code point
          A > 1114111 || // not a valid Unicode code point
          F(A) !== A)
            throw RangeError("Invalid code point: " + A);
          A <= 65535 ? ie.push(A) : (A -= 65536, re = (A >> 10) + 55296, Te = A % 1024 + 56320, ie.push(re, Te)), (V + 1 === Pe || ie.length > ce) && (z += $.apply(null, ie), ie.length = 0);
        }
        return z;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: ge,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = ge;
    }();
  })(e);
})(TV);
var zN = {
  isArray: function(e) {
    return Array.isArray ? Array.isArray(e) : Object.prototype.toString.call(e) === "[object Array]";
  }
}, T1e = zN.isArray, qN = {
  copyOptions: function(e) {
    var t, r = {};
    for (t in e)
      e.hasOwnProperty(t) && (r[t] = e[t]);
    return r;
  },
  ensureFlagExists: function(e, t) {
    (!(e in t) || typeof t[e] != "boolean") && (t[e] = !1);
  },
  ensureSpacesExists: function(e) {
    (!("spaces" in e) || typeof e.spaces != "number" && typeof e.spaces != "string") && (e.spaces = 0);
  },
  ensureAlwaysArrayExists: function(e) {
    (!("alwaysArray" in e) || typeof e.alwaysArray != "boolean" && !T1e(e.alwaysArray)) && (e.alwaysArray = !1);
  },
  ensureKeyExists: function(e, t) {
    (!(e + "Key" in t) || typeof t[e + "Key"] != "string") && (t[e + "Key"] = t.compact ? "_" + e : e);
  },
  checkFnExists: function(e, t) {
    return e + "Fn" in t;
  }
}, R1e = TV, Pn = qN, Yc = zN.isArray, ft, qr;
function I1e(e) {
  return ft = Pn.copyOptions(e), Pn.ensureFlagExists("ignoreDeclaration", ft), Pn.ensureFlagExists("ignoreInstruction", ft), Pn.ensureFlagExists("ignoreAttributes", ft), Pn.ensureFlagExists("ignoreText", ft), Pn.ensureFlagExists("ignoreComment", ft), Pn.ensureFlagExists("ignoreCdata", ft), Pn.ensureFlagExists("ignoreDoctype", ft), Pn.ensureFlagExists("compact", ft), Pn.ensureFlagExists("alwaysChildren", ft), Pn.ensureFlagExists("addParent", ft), Pn.ensureFlagExists("trim", ft), Pn.ensureFlagExists("nativeType", ft), Pn.ensureFlagExists("nativeTypeAttributes", ft), Pn.ensureFlagExists("sanitize", ft), Pn.ensureFlagExists("instructionHasAttributes", ft), Pn.ensureFlagExists("captureSpacesBetweenElements", ft), Pn.ensureAlwaysArrayExists(ft), Pn.ensureKeyExists("declaration", ft), Pn.ensureKeyExists("instruction", ft), Pn.ensureKeyExists("attributes", ft), Pn.ensureKeyExists("text", ft), Pn.ensureKeyExists("comment", ft), Pn.ensureKeyExists("cdata", ft), Pn.ensureKeyExists("doctype", ft), Pn.ensureKeyExists("type", ft), Pn.ensureKeyExists("name", ft), Pn.ensureKeyExists("elements", ft), Pn.ensureKeyExists("parent", ft), ft;
}
function QV(e) {
  var t = Number(e);
  if (!isNaN(t))
    return t;
  var r = e.toLowerCase();
  return r === "true" ? !0 : r === "false" ? !1 : e;
}
function Sh(e, t) {
  var r;
  if (ft.compact) {
    if (!qr[ft[e + "Key"]] && (Yc(ft.alwaysArray) ? ft.alwaysArray.indexOf(ft[e + "Key"]) !== -1 : ft.alwaysArray) && (qr[ft[e + "Key"]] = []), qr[ft[e + "Key"]] && !Yc(qr[ft[e + "Key"]]) && (qr[ft[e + "Key"]] = [qr[ft[e + "Key"]]]), e + "Fn" in ft && typeof t == "string" && (t = ft[e + "Fn"](t, qr)), e === "instruction" && ("instructionFn" in ft || "instructionNameFn" in ft)) {
      for (r in t)
        if (t.hasOwnProperty(r))
          if ("instructionFn" in ft)
            t[r] = ft.instructionFn(t[r], r, qr);
          else {
            var n = t[r];
            delete t[r], t[ft.instructionNameFn(r, n, qr)] = n;
          }
    }
    Yc(qr[ft[e + "Key"]]) ? qr[ft[e + "Key"]].push(t) : qr[ft[e + "Key"]] = t;
  } else {
    qr[ft.elementsKey] || (qr[ft.elementsKey] = []);
    var a = {};
    if (a[ft.typeKey] = e, e === "instruction") {
      for (r in t)
        if (t.hasOwnProperty(r))
          break;
      a[ft.nameKey] = "instructionNameFn" in ft ? ft.instructionNameFn(r, t, qr) : r, ft.instructionHasAttributes ? (a[ft.attributesKey] = t[r][ft.attributesKey], "instructionFn" in ft && (a[ft.attributesKey] = ft.instructionFn(a[ft.attributesKey], r, qr))) : ("instructionFn" in ft && (t[r] = ft.instructionFn(t[r], r, qr)), a[ft.instructionKey] = t[r]);
    } else
      e + "Fn" in ft && (t = ft[e + "Fn"](t, qr)), a[ft[e + "Key"]] = t;
    ft.addParent && (a[ft.parentKey] = qr), qr[ft.elementsKey].push(a);
  }
}
function eG(e) {
  if ("attributesFn" in ft && e && (e = ft.attributesFn(e, qr)), (ft.trim || "attributeValueFn" in ft || "attributeNameFn" in ft || ft.nativeTypeAttributes) && e) {
    var t;
    for (t in e)
      if (e.hasOwnProperty(t) && (ft.trim && (e[t] = e[t].trim()), ft.nativeTypeAttributes && (e[t] = QV(e[t])), "attributeValueFn" in ft && (e[t] = ft.attributeValueFn(e[t], t, qr)), "attributeNameFn" in ft)) {
        var r = e[t];
        delete e[t], e[ft.attributeNameFn(t, e[t], qr)] = r;
      }
  }
  return e;
}
function N1e(e) {
  var t = {};
  if (e.body && (e.name.toLowerCase() === "xml" || ft.instructionHasAttributes)) {
    for (var r = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, n; (n = r.exec(e.body)) !== null; )
      t[n[1]] = n[2] || n[3] || n[4];
    t = eG(t);
  }
  if (e.name.toLowerCase() === "xml") {
    if (ft.ignoreDeclaration)
      return;
    qr[ft.declarationKey] = {}, Object.keys(t).length && (qr[ft.declarationKey][ft.attributesKey] = t), ft.addParent && (qr[ft.declarationKey][ft.parentKey] = qr);
  } else {
    if (ft.ignoreInstruction)
      return;
    ft.trim && (e.body = e.body.trim());
    var a = {};
    ft.instructionHasAttributes && Object.keys(t).length ? (a[e.name] = {}, a[e.name][ft.attributesKey] = t) : a[e.name] = e.body, Sh("instruction", a);
  }
}
function D1e(e, t) {
  var r;
  if (typeof e == "object" && (t = e.attributes, e = e.name), t = eG(t), "elementNameFn" in ft && (e = ft.elementNameFn(e, qr)), ft.compact) {
    if (r = {}, !ft.ignoreAttributes && t && Object.keys(t).length) {
      r[ft.attributesKey] = {};
      var n;
      for (n in t)
        t.hasOwnProperty(n) && (r[ft.attributesKey][n] = t[n]);
    }
    !(e in qr) && (Yc(ft.alwaysArray) ? ft.alwaysArray.indexOf(e) !== -1 : ft.alwaysArray) && (qr[e] = []), qr[e] && !Yc(qr[e]) && (qr[e] = [qr[e]]), Yc(qr[e]) ? qr[e].push(r) : qr[e] = r;
  } else
    qr[ft.elementsKey] || (qr[ft.elementsKey] = []), r = {}, r[ft.typeKey] = "element", r[ft.nameKey] = e, !ft.ignoreAttributes && t && Object.keys(t).length && (r[ft.attributesKey] = t), ft.alwaysChildren && (r[ft.elementsKey] = []), qr[ft.elementsKey].push(r);
  r[ft.parentKey] = qr, qr = r;
}
function O1e(e) {
  ft.ignoreText || !e.trim() && !ft.captureSpacesBetweenElements || (ft.trim && (e = e.trim()), ft.nativeType && (e = QV(e)), ft.sanitize && (e = e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), Sh("text", e));
}
function P1e(e) {
  ft.ignoreComment || (ft.trim && (e = e.trim()), Sh("comment", e));
}
function L1e(e) {
  var t = qr[ft.parentKey];
  ft.addParent || delete qr[ft.parentKey], qr = t;
}
function M1e(e) {
  ft.ignoreCdata || (ft.trim && (e = e.trim()), Sh("cdata", e));
}
function F1e(e) {
  ft.ignoreDoctype || (e = e.replace(/^ /, ""), ft.trim && (e = e.trim()), Sh("doctype", e));
}
function $1e(e) {
  e.note = e;
}
var tG = function(e, t) {
  var r = R1e.parser(!0, {}), n = {};
  if (qr = n, ft = I1e(t), r.opt = { strictEntities: !0 }, r.onopentag = D1e, r.ontext = O1e, r.oncomment = P1e, r.onclosetag = L1e, r.onerror = $1e, r.oncdata = M1e, r.ondoctype = F1e, r.onprocessinginstruction = N1e, r.write(e).close(), n[ft.elementsKey]) {
    var a = n[ft.elementsKey];
    delete n[ft.elementsKey], n[ft.elementsKey] = a, delete n.text;
  }
  return n;
}, HM = qN, B1e = tG;
function U1e(e) {
  var t = HM.copyOptions(e);
  return HM.ensureSpacesExists(t), t;
}
var z1e = function(e, t) {
  var r, n, a, s;
  return r = U1e(t), n = B1e(e, r), s = "compact" in r && r.compact ? "_parent" : "parent", "addParent" in r && r.addParent ? a = JSON.stringify(n, function(i, o) {
    return i === s ? "_" : o;
  }, r.spaces) : a = JSON.stringify(n, null, r.spaces), a.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}, Vn = qN, q1e = zN.isArray, ji, Hi;
function j1e(e) {
  var t = Vn.copyOptions(e);
  return Vn.ensureFlagExists("ignoreDeclaration", t), Vn.ensureFlagExists("ignoreInstruction", t), Vn.ensureFlagExists("ignoreAttributes", t), Vn.ensureFlagExists("ignoreText", t), Vn.ensureFlagExists("ignoreComment", t), Vn.ensureFlagExists("ignoreCdata", t), Vn.ensureFlagExists("ignoreDoctype", t), Vn.ensureFlagExists("compact", t), Vn.ensureFlagExists("indentText", t), Vn.ensureFlagExists("indentCdata", t), Vn.ensureFlagExists("indentAttributes", t), Vn.ensureFlagExists("indentInstruction", t), Vn.ensureFlagExists("fullTagEmptyElement", t), Vn.ensureFlagExists("noQuotesForNativeAttributes", t), Vn.ensureSpacesExists(t), typeof t.spaces == "number" && (t.spaces = Array(t.spaces + 1).join(" ")), Vn.ensureKeyExists("declaration", t), Vn.ensureKeyExists("instruction", t), Vn.ensureKeyExists("attributes", t), Vn.ensureKeyExists("text", t), Vn.ensureKeyExists("comment", t), Vn.ensureKeyExists("cdata", t), Vn.ensureKeyExists("doctype", t), Vn.ensureKeyExists("type", t), Vn.ensureKeyExists("name", t), Vn.ensureKeyExists("elements", t), t;
}
function eo(e, t, r) {
  return (!r && e.spaces ? `
` : "") + Array(t + 1).join(e.spaces);
}
function uy(e, t, r) {
  if (t.ignoreAttributes)
    return "";
  "attributesFn" in t && (e = t.attributesFn(e, Hi, ji));
  var n, a, s, i, o = [];
  for (n in e)
    e.hasOwnProperty(n) && e[n] !== null && e[n] !== void 0 && (i = t.noQuotesForNativeAttributes && typeof e[n] != "string" ? "" : '"', a = "" + e[n], a = a.replace(/"/g, "&quot;"), s = "attributeNameFn" in t ? t.attributeNameFn(n, a, Hi, ji) : n, o.push(t.spaces && t.indentAttributes ? eo(t, r + 1, !1) : " "), o.push(s + "=" + i + ("attributeValueFn" in t ? t.attributeValueFn(a, n, Hi, ji) : a) + i));
  return e && Object.keys(e).length && t.spaces && t.indentAttributes && o.push(eo(t, r, !1)), o.join("");
}
function rG(e, t, r) {
  return ji = e, Hi = "xml", t.ignoreDeclaration ? "" : "<?xml" + uy(e[t.attributesKey], t, r) + "?>";
}
function nG(e, t, r) {
  if (t.ignoreInstruction)
    return "";
  var n;
  for (n in e)
    if (e.hasOwnProperty(n))
      break;
  var a = "instructionNameFn" in t ? t.instructionNameFn(n, e[n], Hi, ji) : n;
  if (typeof e[n] == "object")
    return ji = e, Hi = a, "<?" + a + uy(e[n][t.attributesKey], t, r) + "?>";
  var s = e[n] ? e[n] : "";
  return "instructionFn" in t && (s = t.instructionFn(s, n, Hi, ji)), "<?" + a + (s ? " " + s : "") + "?>";
}
function iG(e, t) {
  return t.ignoreComment ? "" : "<!--" + ("commentFn" in t ? t.commentFn(e, Hi, ji) : e) + "-->";
}
function aG(e, t) {
  return t.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in t ? t.cdataFn(e, Hi, ji) : e.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
}
function sG(e, t) {
  return t.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in t ? t.doctypeFn(e, Hi, ji) : e) + ">";
}
function jN(e, t) {
  return t.ignoreText ? "" : (e = "" + e, e = e.replace(/&amp;/g, "&"), e = e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in t ? t.textFn(e, Hi, ji) : e);
}
function H1e(e, t) {
  var r;
  if (e.elements && e.elements.length)
    for (r = 0; r < e.elements.length; ++r)
      switch (e.elements[r][t.typeKey]) {
        case "text":
          if (t.indentText)
            return !0;
          break;
        case "cdata":
          if (t.indentCdata)
            return !0;
          break;
        case "instruction":
          if (t.indentInstruction)
            return !0;
          break;
        case "doctype":
        case "comment":
        case "element":
          return !0;
        default:
          return !0;
      }
  return !1;
}
function V1e(e, t, r) {
  ji = e, Hi = e.name;
  var n = [], a = "elementNameFn" in t ? t.elementNameFn(e.name, e) : e.name;
  n.push("<" + a), e[t.attributesKey] && n.push(uy(e[t.attributesKey], t, r));
  var s = e[t.elementsKey] && e[t.elementsKey].length || e[t.attributesKey] && e[t.attributesKey]["xml:space"] === "preserve";
  return s || ("fullTagEmptyElementFn" in t ? s = t.fullTagEmptyElementFn(e.name, e) : s = t.fullTagEmptyElement), s ? (n.push(">"), e[t.elementsKey] && e[t.elementsKey].length && (n.push(oG(e[t.elementsKey], t, r + 1)), ji = e, Hi = e.name), n.push(t.spaces && H1e(e, t) ? `
` + Array(r + 1).join(t.spaces) : ""), n.push("</" + a + ">")) : n.push("/>"), n.join("");
}
function oG(e, t, r, n) {
  return e.reduce(function(a, s) {
    var i = eo(t, r, n && !a);
    switch (s.type) {
      case "element":
        return a + i + V1e(s, t, r);
      case "comment":
        return a + i + iG(s[t.commentKey], t);
      case "doctype":
        return a + i + sG(s[t.doctypeKey], t);
      case "cdata":
        return a + (t.indentCdata ? i : "") + aG(s[t.cdataKey], t);
      case "text":
        return a + (t.indentText ? i : "") + jN(s[t.textKey], t);
      case "instruction":
        var o = {};
        return o[s[t.nameKey]] = s[t.attributesKey] ? s : s[t.instructionKey], a + (t.indentInstruction ? i : "") + nG(o, t, r);
    }
  }, "");
}
function lG(e, t, r) {
  var n;
  for (n in e)
    if (e.hasOwnProperty(n))
      switch (n) {
        case t.parentKey:
        case t.attributesKey:
          break;
        case t.textKey:
          if (t.indentText || r)
            return !0;
          break;
        case t.cdataKey:
          if (t.indentCdata || r)
            return !0;
          break;
        case t.instructionKey:
          if (t.indentInstruction || r)
            return !0;
          break;
        case t.doctypeKey:
        case t.commentKey:
          return !0;
        default:
          return !0;
      }
  return !1;
}
function G1e(e, t, r, n, a) {
  ji = e, Hi = t;
  var s = "elementNameFn" in r ? r.elementNameFn(t, e) : t;
  if (typeof e > "u" || e === null || e === "")
    return "fullTagEmptyElementFn" in r && r.fullTagEmptyElementFn(t, e) || r.fullTagEmptyElement ? "<" + s + "></" + s + ">" : "<" + s + "/>";
  var i = [];
  if (t) {
    if (i.push("<" + s), typeof e != "object")
      return i.push(">" + jN(e, r) + "</" + s + ">"), i.join("");
    e[r.attributesKey] && i.push(uy(e[r.attributesKey], r, n));
    var o = lG(e, r, !0) || e[r.attributesKey] && e[r.attributesKey]["xml:space"] === "preserve";
    if (o || ("fullTagEmptyElementFn" in r ? o = r.fullTagEmptyElementFn(t, e) : o = r.fullTagEmptyElement), o)
      i.push(">");
    else
      return i.push("/>"), i.join("");
  }
  return i.push(uG(e, r, n + 1, !1)), ji = e, Hi = t, t && i.push((a ? eo(r, n, !1) : "") + "</" + s + ">"), i.join("");
}
function uG(e, t, r, n) {
  var a, s, i, o = [];
  for (s in e)
    if (e.hasOwnProperty(s))
      for (i = q1e(e[s]) ? e[s] : [e[s]], a = 0; a < i.length; ++a) {
        switch (s) {
          case t.declarationKey:
            o.push(rG(i[a], t, r));
            break;
          case t.instructionKey:
            o.push((t.indentInstruction ? eo(t, r, n) : "") + nG(i[a], t, r));
            break;
          case t.attributesKey:
          case t.parentKey:
            break;
          case t.textKey:
            o.push((t.indentText ? eo(t, r, n) : "") + jN(i[a], t));
            break;
          case t.cdataKey:
            o.push((t.indentCdata ? eo(t, r, n) : "") + aG(i[a], t));
            break;
          case t.doctypeKey:
            o.push(eo(t, r, n) + sG(i[a], t));
            break;
          case t.commentKey:
            o.push(eo(t, r, n) + iG(i[a], t));
            break;
          default:
            o.push(eo(t, r, n) + G1e(i[a], s, t, r, lG(i[a], t)));
        }
        n = n && !o.length;
      }
  return o.join("");
}
var cG = function(e, t) {
  t = j1e(t);
  var r = [];
  return ji = e, Hi = "_root_", t.compact ? r.push(uG(e, t, 0, !0)) : (e[t.declarationKey] && r.push(rG(e[t.declarationKey], t, 0)), e[t.elementsKey] && e[t.elementsKey].length && r.push(oG(e[t.elementsKey], t, 0, !r.length))), r.join("");
}, W1e = cG, K1e = function(e, t) {
  e instanceof Buffer && (e = e.toString());
  var r = null;
  if (typeof e == "string")
    try {
      r = JSON.parse(e);
    } catch {
      throw new Error("The JSON structure is invalid");
    }
  else
    r = e;
  return W1e(r, t);
}, Y1e = tG, X1e = z1e, Z1e = cG, J1e = K1e, dG = {
  xml2js: Y1e,
  xml2json: X1e,
  js2xml: Z1e,
  json2xml: J1e
};
const HN = (e) => {
  switch (e.type) {
    case void 0:
    case "element":
      const t = new exe(e.name, e.attributes), r = e.elements || [];
      for (const n of r) {
        const a = HN(n);
        a !== void 0 && t.push(a);
      }
      return t;
    case "text":
      return e.text;
    default:
      return;
  }
};
class Q1e extends er {
  // noop
}
class exe extends nt {
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  static fromXmlString(t) {
    const r = dG.xml2js(t, { compact: !1 });
    return HN(r);
  }
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(t, r) {
    super(t), r && this.root.push(new Q1e(r));
  }
  push(t) {
    this.root.push(t);
  }
}
class txe extends nt {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(t) {
    super(""), this._attr = t;
  }
  prepForXml(t) {
    return {
      _attr: this._attr
    };
  }
}
class fG extends nt {
  constructor(t, r) {
    super(t), r && (this.root = r.root);
  }
}
const Gi = (e) => {
  if (isNaN(e))
    throw new Error(`Invalid value '${e}' specified. Must be an integer.`);
  return Math.floor(e);
}, cy = (e) => {
  const t = Gi(e);
  if (t < 0)
    throw new Error(`Invalid value '${e}' specified. Must be a positive integer.`);
  return t;
}, VN = (e, t) => {
  const r = t * 2;
  if (e.length !== r || isNaN(+`0x${e}`))
    throw new Error(`Invalid hex value '${e}'. Expected ${r} digit hex value`);
  return e;
}, rxe = (e) => VN(e, 2), VM = (e) => VN(e, 1), GN = (e) => {
  const t = e.slice(-2), r = e.substring(0, e.length - 2);
  return `${Number(r)}${t}`;
}, pG = (e) => {
  const t = GN(e);
  if (parseFloat(t) < 0)
    throw new Error(`Invalid value '${t}' specified. Expected a positive number.`);
  return t;
}, dd = (e) => {
  if (e === "auto")
    return e;
  const t = e.charAt(0) === "#" ? e.substring(1) : e;
  return VN(t, 3);
}, Mo = (e) => typeof e == "string" ? GN(e) : Gi(e), nxe = (e) => typeof e == "string" ? pG(e) : cy(e), Li = (e) => typeof e == "string" ? pG(e) : cy(e), ixe = (e) => {
  const t = e.substring(0, e.length - 1);
  return `${Number(t)}%`;
}, axe = (e) => typeof e == "number" ? Gi(e) : e.slice(-1) === "%" ? ixe(e) : GN(e), sxe = cy, oxe = cy, lxe = (e) => e.toISOString();
class Pt extends nt {
  constructor(t, r = !0) {
    super(t), r !== !0 && this.root.push(new oi({ val: r }));
  }
}
class Tx extends nt {
  constructor(t, r) {
    super(t), this.root.push(new oi({ val: nxe(r) }));
  }
}
class Ol extends nt {
  constructor(t, r) {
    super(t), this.root.push(new oi({ val: r }));
  }
}
const gf = (e, t) => new Wi({
  name: e,
  attributes: {
    value: { key: "w:val", value: t }
  }
});
class WN extends nt {
  constructor(t, r) {
    super(t), this.root.push(new oi({ val: r }));
  }
}
class uxe extends nt {
  constructor(t, r) {
    super(t), this.root.push(new oi({ val: r }));
  }
}
class cu extends nt {
  constructor(t, r) {
    super(t), this.root.push(r);
  }
}
class Wi extends nt {
  constructor({
    name: t,
    attributes: r,
    children: n
  }) {
    super(t), r && this.root.push(new Jo(r)), n && this.root.push(...n);
  }
}
const bi = {
  /** Align Start */
  START: "start",
  /** Align Center */
  CENTER: "center",
  /** End */
  END: "end",
  /** Justified */
  BOTH: "both",
  /** Medium Kashida Length */
  MEDIUM_KASHIDA: "mediumKashida",
  /** Distribute All Characters Equally */
  DISTRIBUTE: "distribute",
  /** Align to List Tab */
  NUM_TAB: "numTab",
  /** Widest Kashida Length */
  HIGH_KASHIDA: "highKashida",
  /** Low Kashida Length */
  LOW_KASHIDA: "lowKashida",
  /** Thai Language Justification */
  THAI_DISTRIBUTE: "thaiDistribute",
  /** Align Left */
  LEFT: "left",
  /** Align Right */
  RIGHT: "right",
  /** Justified */
  JUSTIFIED: "both"
};
class cxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class hG extends nt {
  constructor(t) {
    super("w:jc"), this.root.push(new cxe({ val: t }));
  }
}
class Fn extends nt {
  constructor(t, { color: r, size: n, space: a, style: s }) {
    super(t), this.root.push(
      new dxe({
        style: s,
        color: r === void 0 ? void 0 : dd(r),
        size: n === void 0 ? void 0 : sxe(n),
        space: a === void 0 ? void 0 : oxe(a)
      })
    );
  }
}
class dxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      style: "w:val",
      color: "w:color",
      size: "w:sz",
      space: "w:space"
    });
  }
}
const KN = {
  SINGLE: "single",
  DASH_DOT_STROKED: "dashDotStroked",
  DASHED: "dashed",
  DASH_SMALL_GAP: "dashSmallGap",
  DOT_DASH: "dotDash",
  DOT_DOT_DASH: "dotDotDash",
  DOTTED: "dotted",
  DOUBLE: "double",
  DOUBLE_WAVE: "doubleWave",
  INSET: "inset",
  NIL: "nil",
  NONE: "none",
  OUTSET: "outset",
  THICK: "thick",
  THICK_THIN_LARGE_GAP: "thickThinLargeGap",
  THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
  THICK_THIN_SMALL_GAP: "thickThinSmallGap",
  THIN_THICK_LARGE_GAP: "thinThickLargeGap",
  THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
  THIN_THICK_SMALL_GAP: "thinThickSmallGap",
  THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
  THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
  THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
  THREE_D_EMBOSS: "threeDEmboss",
  THREE_D_ENGRAVE: "threeDEngrave",
  TRIPLE: "triple",
  WAVE: "wave"
};
class fxe extends Zo {
  constructor(t) {
    super("w:pBdr"), t.top && this.root.push(new Fn("w:top", t.top)), t.bottom && this.root.push(new Fn("w:bottom", t.bottom)), t.left && this.root.push(new Fn("w:left", t.left)), t.right && this.root.push(new Fn("w:right", t.right));
  }
}
class pxe extends nt {
  constructor() {
    super("w:pBdr");
    const t = new Fn("w:bottom", {
      color: "auto",
      space: 1,
      style: KN.SINGLE,
      size: 6
    });
    this.root.push(t);
  }
}
class hxe extends nt {
  constructor({ start: t, end: r, left: n, right: a, hanging: s, firstLine: i }) {
    super("w:ind"), this.root.push(
      new Jo({
        start: {
          key: "w:start",
          value: t === void 0 ? void 0 : Mo(t)
        },
        end: {
          key: "w:end",
          value: r === void 0 ? void 0 : Mo(r)
        },
        left: {
          key: "w:left",
          value: n === void 0 ? void 0 : Mo(n)
        },
        right: {
          key: "w:right",
          value: a === void 0 ? void 0 : Mo(a)
        },
        hanging: {
          key: "w:hanging",
          value: s === void 0 ? void 0 : Li(s)
        },
        firstLine: {
          key: "w:firstLine",
          value: i === void 0 ? void 0 : Li(i)
        }
      })
    );
  }
}
let mxe = class extends nt {
  constructor() {
    super("w:br");
  }
};
const YN = {
  BEGIN: "begin",
  END: "end",
  SEPARATE: "separate"
};
class XN extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
  }
}
class wm extends nt {
  constructor(t) {
    super("w:fldChar"), this.root.push(new XN({ type: YN.BEGIN, dirty: t }));
  }
}
class xm extends nt {
  constructor(t) {
    super("w:fldChar"), this.root.push(new XN({ type: YN.SEPARATE, dirty: t }));
  }
}
class Em extends nt {
  constructor(t) {
    super("w:fldChar"), this.root.push(new XN({ type: YN.END, dirty: t }));
  }
}
const fd = {
  DEFAULT: "default",
  PRESERVE: "preserve"
};
class pd extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { space: "xml:space" });
  }
}
class gxe extends nt {
  constructor() {
    super("w:instrText"), this.root.push(new pd({ space: fd.PRESERVE })), this.root.push("PAGE");
  }
}
class bxe extends nt {
  constructor() {
    super("w:instrText"), this.root.push(new pd({ space: fd.PRESERVE })), this.root.push("NUMPAGES");
  }
}
class yxe extends nt {
  constructor() {
    super("w:instrText"), this.root.push(new pd({ space: fd.PRESERVE })), this.root.push("SECTIONPAGES");
  }
}
class vxe extends nt {
  constructor() {
    super("w:instrText"), this.root.push(new pd({ space: fd.PRESERVE })), this.root.push("SECTION");
  }
}
class wxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      fill: "w:fill",
      color: "w:color",
      type: "w:val"
    });
  }
}
class dy extends nt {
  constructor({ fill: t, color: r, type: n }) {
    super("w:shd"), this.root.push(
      new wxe({
        fill: t === void 0 ? void 0 : dd(t),
        color: r === void 0 ? void 0 : dd(r),
        type: n
      })
    );
  }
}
class xxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "w:id",
      author: "w:author",
      date: "w:date"
    });
  }
}
const Exe = {
  DOT: "dot"
};
class Sxe extends nt {
  constructor(t) {
    super("w:em"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class _xe extends Sxe {
  constructor(t = Exe.DOT) {
    super(t);
  }
}
class kxe extends nt {
  constructor(t) {
    super("w:spacing"), this.root.push(
      new oi({
        val: Mo(t)
      })
    );
  }
}
let Cxe = class extends nt {
  constructor(t) {
    super("w:color"), this.root.push(
      new oi({
        val: dd(t)
      })
    );
  }
};
class Axe extends nt {
  constructor(t) {
    super("w:highlight"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class Txe extends nt {
  constructor(t) {
    super("w:highlightCs"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
const Rxe = (e) => new Wi({
  name: "w:lang",
  attributes: {
    value: {
      key: "w:val",
      value: e.value
    },
    eastAsia: {
      key: "w:eastAsia",
      value: e.eastAsia
    },
    bidirectional: {
      key: "w:bidi",
      value: e.bidirectional
    }
  }
});
class GM extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      ascii: "w:ascii",
      cs: "w:cs",
      eastAsia: "w:eastAsia",
      hAnsi: "w:hAnsi",
      hint: "w:hint"
    });
  }
}
class Rx extends nt {
  constructor(t, r) {
    if (super("w:rFonts"), typeof t == "string") {
      const n = t;
      this.root.push(
        new GM({
          ascii: n,
          cs: n,
          eastAsia: n,
          hAnsi: n,
          hint: r
        })
      );
    } else {
      const n = t;
      this.root.push(new GM(n));
    }
  }
}
let mG = class extends nt {
  constructor(t) {
    super("w:vertAlign"), this.root.push(
      new oi({
        val: t
      })
    );
  }
};
class Ixe extends mG {
  constructor() {
    super("superscript");
  }
}
class Nxe extends mG {
  constructor() {
    super("subscript");
  }
}
const gG = {
  SINGLE: "single",
  WORDS: "words",
  DOUBLE: "double",
  THICK: "thick",
  DOTTED: "dotted",
  DOTTEDHEAVY: "dottedHeavy",
  DASH: "dash",
  DASHEDHEAVY: "dashedHeavy",
  DASHLONG: "dashLong",
  DASHLONGHEAVY: "dashLongHeavy",
  DOTDASH: "dotDash",
  DASHDOTHEAVY: "dashDotHeavy",
  DOTDOTDASH: "dotDotDash",
  DASHDOTDOTHEAVY: "dashDotDotHeavy",
  WAVE: "wave",
  WAVYHEAVY: "wavyHeavy",
  WAVYDOUBLE: "wavyDouble",
  NONE: "none"
};
class Dxe extends nt {
  constructor(t = gG.SINGLE, r) {
    super("w:u"), this.root.push(
      new oi({
        val: t,
        color: r === void 0 ? void 0 : dd(r)
      })
    );
  }
}
class Vu extends Zo {
  constructor(t) {
    var r, n;
    if (super("w:rPr"), !t)
      return;
    t.noProof !== void 0 && this.push(new Pt("w:noProof", t.noProof)), t.bold !== void 0 && this.push(new Pt("w:b", t.bold)), (t.boldComplexScript === void 0 && t.bold !== void 0 || t.boldComplexScript) && this.push(new Pt("w:bCs", (r = t.boldComplexScript) != null ? r : t.bold)), t.italics !== void 0 && this.push(new Pt("w:i", t.italics)), (t.italicsComplexScript === void 0 && t.italics !== void 0 || t.italicsComplexScript) && this.push(new Pt("w:iCs", (n = t.italicsComplexScript) != null ? n : t.italics)), t.underline && this.push(new Dxe(t.underline.type, t.underline.color)), t.effect && this.push(new Ol("w:effect", t.effect)), t.emphasisMark && this.push(new _xe(t.emphasisMark.type)), t.color && this.push(new Cxe(t.color)), t.kern && this.push(new Tx("w:kern", t.kern)), t.position && this.push(new Ol("w:position", t.position)), t.size !== void 0 && this.push(new Tx("w:sz", t.size));
    const a = t.sizeComplexScript === void 0 || t.sizeComplexScript === !0 ? t.size : t.sizeComplexScript;
    a && this.push(new Tx("w:szCs", a)), t.rightToLeft !== void 0 && this.push(new Pt("w:rtl", t.rightToLeft)), t.smallCaps !== void 0 ? this.push(new Pt("w:smallCaps", t.smallCaps)) : t.allCaps !== void 0 && this.push(new Pt("w:caps", t.allCaps)), t.strike !== void 0 && this.push(new Pt("w:strike", t.strike)), t.doubleStrike !== void 0 && this.push(new Pt("w:dstrike", t.doubleStrike)), t.subScript && this.push(new Nxe()), t.superScript && this.push(new Ixe()), t.style && this.push(new Ol("w:rStyle", t.style)), t.font && (typeof t.font == "string" ? this.push(new Rx(t.font)) : "name" in t.font ? this.push(new Rx(t.font.name, t.font.hint)) : this.push(new Rx(t.font))), t.highlight && this.push(new Axe(t.highlight));
    const s = t.highlightComplexScript === void 0 || t.highlightComplexScript === !0 ? t.highlight : t.highlightComplexScript;
    s && this.push(new Txe(s)), t.characterSpacing && this.push(new kxe(t.characterSpacing)), t.emboss !== void 0 && this.push(new Pt("w:emboss", t.emboss)), t.imprint !== void 0 && this.push(new Pt("w:imprint", t.imprint)), t.shading && this.push(new dy(t.shading)), t.revision && this.push(new Oxe(t.revision)), t.border && this.push(new Fn("w:bdr", t.border)), t.snapToGrid !== void 0 && this.push(new Pt("w:snapToGrid", t.snapToGrid)), t.vanish && this.push(new Pt("w:vanish", t.vanish)), t.specVanish && this.push(new Pt("w:specVanish", t.vanish)), t.scale !== void 0 && this.push(new WN("w:w", t.scale)), t.language && this.push(Rxe(t.language)), t.math && this.push(new Pt("w:oMath", t.math));
  }
  push(t) {
    this.root.push(t);
  }
}
class Oxe extends nt {
  constructor(t) {
    super("w:rPrChange"), this.root.push(
      new xxe({
        id: t.id,
        author: t.author,
        date: t.date
      })
    ), this.addChildElement(new Vu(t));
  }
}
class TR extends nt {
  constructor(t) {
    var r;
    return super("w:t"), typeof t == "string" ? (this.root.push(new pd({ space: fd.PRESERVE })), this.root.push(t), this) : (this.root.push(new pd({ space: (r = t.space) != null ? r : fd.DEFAULT })), this.root.push(t.text), this);
  }
}
const Sm = {
  CURRENT: "CURRENT",
  TOTAL_PAGES: "TOTAL_PAGES",
  TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
  CURRENT_SECTION: "SECTION"
};
class Gu extends nt {
  constructor(t) {
    if (super("w:r"), st(this, "properties"), this.properties = new Vu(t), this.root.push(this.properties), t.break)
      for (let r = 0; r < t.break; r++)
        this.root.push(new mxe());
    if (t.children)
      for (const r of t.children) {
        if (typeof r == "string") {
          switch (r) {
            case Sm.CURRENT:
              this.root.push(new wm()), this.root.push(new gxe()), this.root.push(new xm()), this.root.push(new Em());
              break;
            case Sm.TOTAL_PAGES:
              this.root.push(new wm()), this.root.push(new bxe()), this.root.push(new xm()), this.root.push(new Em());
              break;
            case Sm.TOTAL_PAGES_IN_SECTION:
              this.root.push(new wm()), this.root.push(new yxe()), this.root.push(new xm()), this.root.push(new Em());
              break;
            case Sm.CURRENT_SECTION:
              this.root.push(new wm()), this.root.push(new vxe()), this.root.push(new xm()), this.root.push(new Em());
              break;
            default:
              this.root.push(new TR(r));
              break;
          }
          continue;
        }
        this.root.push(r);
      }
    else t.text && this.root.push(new TR(t.text));
  }
}
class Kg extends Gu {
  constructor(t) {
    if (typeof t == "string")
      return super({}), this.root.push(new TR(t)), this;
    super(t);
  }
}
class Pxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      char: "w:char",
      symbolfont: "w:font"
    });
  }
}
let WM = class extends nt {
  constructor(t = "", r = "Wingdings") {
    super("w:sym"), this.root.push(new Pxe({ char: t, symbolfont: r }));
  }
};
class Lxe extends Gu {
  constructor(t) {
    if (typeof t == "string")
      return super({}), this.root.push(new WM(t)), this;
    super(t), this.root.push(new WM(t.char, t.symbolfont));
  }
}
let Mxe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Fxe = (e, t = 21) => (r = t) => {
  let n = "", a = r;
  for (; a--; )
    n += e[Math.random() * e.length | 0];
  return n;
}, $xe = (e = 21) => {
  let t = "", r = e;
  for (; r--; )
    t += Mxe[Math.random() * 64 | 0];
  return t;
};
const Pi = (e) => Math.floor(e * 72 * 20), fy = (e = 0) => {
  let t = e;
  return () => ++t;
}, Bxe = () => fy(), Uxe = () => fy(1), zxe = () => fy(), qxe = () => fy(), bG = () => $xe().toLowerCase(), bf = (e) => Fxe("1234567890abcdef", e)(), jxe = () => `${bf(8)}-${bf(4)}-${bf(4)}-${bf(4)}-${bf(12)}`, Hxe = {
  CHARACTER: "character",
  COLUMN: "column",
  INSIDE_MARGIN: "insideMargin",
  LEFT_MARGIN: "leftMargin",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  RIGHT_MARGIN: "rightMargin"
}, Vxe = {
  BOTTOM_MARGIN: "bottomMargin",
  INSIDE_MARGIN: "insideMargin",
  LINE: "line",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  PARAGRAPH: "paragraph",
  TOP_MARGIN: "topMargin"
};
class Gxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}
class Wxe extends nt {
  constructor() {
    super("wp:simplePos"), this.root.push(
      new Gxe({
        x: 0,
        y: 0
      })
    );
  }
}
class yG extends nt {
  constructor(t) {
    super("wp:align"), this.root.push(t);
  }
}
class vG extends nt {
  constructor(t) {
    super("wp:posOffset"), this.root.push(t.toString());
  }
}
class Kxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}
class Yxe extends nt {
  constructor(t) {
    if (super("wp:positionH"), this.root.push(
      new Kxe({
        relativeFrom: t.relative || Hxe.PAGE
      })
    ), t.align)
      this.root.push(new yG(t.align));
    else if (t.offset !== void 0)
      this.root.push(new vG(t.offset));
    else
      throw new Error("There is no configuration provided for floating position (Align or offset)");
  }
}
class Xxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}
class Zxe extends nt {
  constructor(t) {
    if (super("wp:positionV"), this.root.push(
      new Xxe({
        relativeFrom: t.relative || Vxe.PAGE
      })
    ), t.align)
      this.root.push(new yG(t.align));
    else if (t.offset !== void 0)
      this.root.push(new vG(t.offset));
    else
      throw new Error("There is no configuration provided for floating position (Align or offset)");
  }
}
class Jxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      uri: "uri"
    });
  }
}
class Qxe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      embed: "r:embed",
      cstate: "cstate"
    });
  }
}
class eEe extends nt {
  constructor(t) {
    super("a:blip"), this.root.push(
      new Qxe({
        embed: `rId{${t.fileName}}`,
        cstate: "none"
      })
    );
  }
}
class tEe extends nt {
  constructor() {
    super("a:srcRect");
  }
}
class rEe extends nt {
  constructor() {
    super("a:fillRect");
  }
}
class nEe extends nt {
  constructor() {
    super("a:stretch"), this.root.push(new rEe());
  }
}
class iEe extends nt {
  constructor(t) {
    super("pic:blipFill"), this.root.push(new eEe(t)), this.root.push(new tEe()), this.root.push(new nEe());
  }
}
class aEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      noChangeAspect: "noChangeAspect",
      noChangeArrowheads: "noChangeArrowheads"
    });
  }
}
class sEe extends nt {
  constructor() {
    super("a:picLocks"), this.root.push(
      new aEe({
        noChangeAspect: 1,
        noChangeArrowheads: 1
      })
    );
  }
}
class oEe extends nt {
  constructor() {
    super("pic:cNvPicPr"), this.root.push(new sEe());
  }
}
const wG = (e, t) => new Wi({
  name: "a:hlinkClick",
  attributes: ud(wn({}, t ? {
    xmlns: {
      key: "xmlns:a",
      value: "http://schemas.openxmlformats.org/drawingml/2006/main"
    }
  } : {}), {
    id: {
      key: "r:id",
      value: `rId${e}`
    }
  })
});
class lEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "id",
      name: "name",
      descr: "descr"
    });
  }
}
class uEe extends nt {
  constructor() {
    super("pic:cNvPr"), this.root.push(
      new lEe({
        id: 0,
        name: "",
        descr: ""
      })
    );
  }
  prepForXml(t) {
    for (let r = t.stack.length - 1; r >= 0; r--) {
      const n = t.stack[r];
      if (n instanceof ZN) {
        this.root.push(wG(n.linkId, !1));
        break;
      }
    }
    return super.prepForXml(t);
  }
}
class cEe extends nt {
  constructor() {
    super("pic:nvPicPr"), this.root.push(new uEe()), this.root.push(new oEe());
  }
}
class dEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns:pic"
    });
  }
}
class fEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}
class pEe extends nt {
  constructor(t, r) {
    super("a:ext"), st(this, "attributes"), this.attributes = new fEe({
      cx: t,
      cy: r
    }), this.root.push(this.attributes);
  }
}
class hEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}
class mEe extends nt {
  constructor() {
    super("a:off"), this.root.push(
      new hEe({
        x: 0,
        y: 0
      })
    );
  }
}
class gEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      flipVertical: "flipV",
      flipHorizontal: "flipH",
      rotation: "rot"
    });
  }
}
class bEe extends nt {
  constructor(t) {
    var r, n;
    super("a:xfrm"), st(this, "extents"), this.root.push(
      new gEe({
        flipVertical: (r = t.flip) == null ? void 0 : r.vertical,
        flipHorizontal: (n = t.flip) == null ? void 0 : n.horizontal,
        rotation: t.rotation
      })
    ), this.extents = new pEe(t.emus.x, t.emus.y), this.root.push(new mEe()), this.root.push(this.extents);
  }
}
const xG = () => new Wi({ name: "a:noFill" }), yEe = (e) => new Wi({
  name: "a:schemeClr",
  attributes: {
    value: {
      key: "val",
      value: e.value
    }
  }
}), vEe = (e) => new Wi({
  name: "a:srgbClr",
  attributes: {
    value: {
      key: "val",
      value: e.value
    }
  }
}), KM = (e) => new Wi({
  name: "a:solidFill",
  children: [e.type === "rgb" ? vEe(e) : yEe(e)]
}), wEe = (e) => new Wi({
  name: "a:ln",
  attributes: {
    width: {
      key: "w",
      value: e.width
    },
    cap: {
      key: "cap",
      value: e.cap
    },
    compoundLine: {
      key: "cmpd",
      value: e.compoundLine
    },
    align: {
      key: "algn",
      value: e.align
    }
  },
  children: [
    e.type === "noFill" ? xG() : e.solidFillType === "rgb" ? KM({
      type: "rgb",
      value: e.value
    }) : KM({
      type: "scheme",
      value: e.value
    })
  ]
});
class xEe extends nt {
  constructor() {
    super("a:avLst");
  }
}
class EEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      prst: "prst"
    });
  }
}
class SEe extends nt {
  constructor() {
    super("a:prstGeom"), this.root.push(
      new EEe({
        prst: "rect"
      })
    ), this.root.push(new xEe());
  }
}
class _Ee extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      bwMode: "bwMode"
    });
  }
}
class kEe extends nt {
  constructor({ outline: t, transform: r }) {
    super("pic:spPr"), st(this, "form"), this.root.push(
      new _Ee({
        bwMode: "auto"
      })
    ), this.form = new bEe(r), this.root.push(this.form), this.root.push(new SEe()), t && (this.root.push(xG()), this.root.push(wEe(t)));
  }
}
class CEe extends nt {
  constructor({
    mediaData: t,
    transform: r,
    outline: n
  }) {
    super("pic:pic"), this.root.push(
      new dEe({
        xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture"
      })
    ), this.root.push(new cEe()), this.root.push(new iEe(t)), this.root.push(new kEe({ transform: r, outline: n }));
  }
}
class AEe extends nt {
  constructor({
    mediaData: t,
    transform: r,
    outline: n
  }) {
    super("a:graphicData"), st(this, "pic"), this.root.push(
      new Jxe({
        uri: "http://schemas.openxmlformats.org/drawingml/2006/picture"
      })
    ), this.pic = new CEe({ mediaData: t, transform: r, outline: n }), this.root.push(this.pic);
  }
}
class TEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      a: "xmlns:a"
    });
  }
}
class EG extends nt {
  constructor({
    mediaData: t,
    transform: r,
    outline: n
  }) {
    super("a:graphic"), st(this, "data"), this.root.push(
      new TEe({
        a: "http://schemas.openxmlformats.org/drawingml/2006/main"
      })
    ), this.data = new AEe({ mediaData: t, transform: r, outline: n }), this.root.push(this.data);
  }
}
const _m = {
  NONE: 0,
  SQUARE: 1,
  TIGHT: 2,
  TOP_AND_BOTTOM: 3
}, REe = {
  BOTH_SIDES: "bothSides",
  LEFT: "left",
  RIGHT: "right",
  LARGEST: "largest"
};
class YM extends nt {
  constructor() {
    super("wp:wrapNone");
  }
}
class IEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      wrapText: "wrapText"
    });
  }
}
class NEe extends nt {
  constructor(t, r = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }) {
    super("wp:wrapSquare"), this.root.push(
      new IEe({
        wrapText: t.side || REe.BOTH_SIDES,
        distT: r.top,
        distB: r.bottom,
        distL: r.left,
        distR: r.right
      })
    );
  }
}
class DEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}
class OEe extends nt {
  constructor(t = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTight"), this.root.push(
      new DEe({
        distT: t.top,
        distB: t.bottom
      })
    );
  }
}
class PEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}
class LEe extends nt {
  constructor(t = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTopAndBottom"), this.root.push(
      new PEe({
        distT: t.top,
        distB: t.bottom
      })
    );
  }
}
class SG extends nt {
  constructor({ name: t, description: r, title: n } = { name: "", description: "", title: "" }) {
    super("wp:docPr"), st(this, "docPropertiesUniqueNumericId", zxe()), this.root.push(
      new Jo({
        id: {
          key: "id",
          value: this.docPropertiesUniqueNumericId()
        },
        name: {
          key: "name",
          value: t
        },
        description: {
          key: "descr",
          value: r
        },
        title: {
          key: "title",
          value: n
        }
      })
    );
  }
  prepForXml(t) {
    for (let r = t.stack.length - 1; r >= 0; r--) {
      const n = t.stack[r];
      if (n instanceof ZN) {
        this.root.push(wG(n.linkId, !0));
        break;
      }
    }
    return super.prepForXml(t);
  }
}
const _G = ({ top: e, right: t, bottom: r, left: n }) => new Wi({
  name: "wp:effectExtent",
  attributes: {
    top: {
      key: "t",
      value: e
    },
    right: {
      key: "r",
      value: t
    },
    bottom: {
      key: "b",
      value: r
    },
    left: {
      key: "l",
      value: n
    }
  }
});
class MEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}
class kG extends nt {
  constructor(t, r) {
    super("wp:extent"), st(this, "attributes"), this.attributes = new MEe({
      cx: t,
      cy: r
    }), this.root.push(this.attributes);
  }
}
class FEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns:a",
      noChangeAspect: "noChangeAspect"
    });
  }
}
class $Ee extends nt {
  constructor() {
    super("a:graphicFrameLocks"), this.root.push(
      new FEe({
        xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
        noChangeAspect: 1
      })
    );
  }
}
class CG extends nt {
  constructor() {
    super("wp:cNvGraphicFramePr"), this.root.push(new $Ee());
  }
}
class BEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      allowOverlap: "allowOverlap",
      behindDoc: "behindDoc",
      layoutInCell: "layoutInCell",
      locked: "locked",
      relativeHeight: "relativeHeight",
      simplePos: "simplePos"
    });
  }
}
class UEe extends nt {
  constructor({
    mediaData: t,
    transform: r,
    drawingOptions: n
  }) {
    super("wp:anchor");
    const a = wn({
      allowOverlap: !0,
      behindDocument: !1,
      lockAnchor: !1,
      layoutInCell: !0,
      verticalPosition: {},
      horizontalPosition: {}
    }, n.floating);
    if (this.root.push(
      new BEe({
        distT: a.margins && a.margins.top || 0,
        distB: a.margins && a.margins.bottom || 0,
        distL: a.margins && a.margins.left || 0,
        distR: a.margins && a.margins.right || 0,
        simplePos: "0",
        // note: word doesn't fully support - so we use 0
        allowOverlap: a.allowOverlap === !0 ? "1" : "0",
        behindDoc: a.behindDocument === !0 ? "1" : "0",
        locked: a.lockAnchor === !0 ? "1" : "0",
        layoutInCell: a.layoutInCell === !0 ? "1" : "0",
        relativeHeight: a.zIndex ? a.zIndex : r.emus.y
      })
    ), this.root.push(new Wxe()), this.root.push(new Yxe(a.horizontalPosition)), this.root.push(new Zxe(a.verticalPosition)), this.root.push(new kG(r.emus.x, r.emus.y)), this.root.push(_G({ top: 0, right: 0, bottom: 0, left: 0 })), n.floating !== void 0 && n.floating.wrap !== void 0)
      switch (n.floating.wrap.type) {
        case _m.SQUARE:
          this.root.push(new NEe(n.floating.wrap, n.floating.margins));
          break;
        case _m.TIGHT:
          this.root.push(new OEe(n.floating.margins));
          break;
        case _m.TOP_AND_BOTTOM:
          this.root.push(new LEe(n.floating.margins));
          break;
        case _m.NONE:
        default:
          this.root.push(new YM());
      }
    else
      this.root.push(new YM());
    this.root.push(new SG(n.docProperties)), this.root.push(new CG()), this.root.push(new EG({ mediaData: t, transform: r, outline: n.outline }));
  }
}
const zEe = ({ mediaData: e, transform: t, docProperties: r, outline: n }) => {
  var a, s, i, o;
  return new Wi({
    name: "wp:inline",
    attributes: {
      distanceTop: {
        key: "distT",
        value: 0
      },
      distanceBottom: {
        key: "distB",
        value: 0
      },
      distanceLeft: {
        key: "distL",
        value: 0
      },
      distanceRight: {
        key: "distR",
        value: 0
      }
    },
    children: [
      new kG(t.emus.x, t.emus.y),
      _G(
        n ? {
          top: ((a = n.width) != null ? a : 9525) * 2,
          right: ((s = n.width) != null ? s : 9525) * 2,
          bottom: ((i = n.width) != null ? i : 9525) * 2,
          left: ((o = n.width) != null ? o : 9525) * 2
        } : { top: 0, right: 0, bottom: 0, left: 0 }
      ),
      new SG(r),
      new CG(),
      new EG({ mediaData: e, transform: t, outline: n })
    ]
  });
};
class qEe extends nt {
  constructor(t, r = {}) {
    super("w:drawing"), r.floating ? this.root.push(new UEe({ mediaData: t, transform: t.transformation, drawingOptions: r })) : this.root.push(
      zEe({
        mediaData: t,
        transform: t.transformation,
        docProperties: r.docProperties,
        outline: r.outline
      })
    );
  }
}
class jEe extends Gu {
  constructor(t) {
    super({}), st(this, "key", `${bG()}.png`), st(this, "imageData");
    const r = typeof t.data == "string" ? this.convertDataURIToBinary(t.data) : t.data;
    this.imageData = {
      stream: r,
      fileName: this.key,
      transformation: {
        pixels: {
          x: Math.round(t.transformation.width),
          y: Math.round(t.transformation.height)
        },
        emus: {
          x: Math.round(t.transformation.width * 9525),
          y: Math.round(t.transformation.height * 9525)
        },
        flip: t.transformation.flip,
        rotation: t.transformation.rotation ? t.transformation.rotation * 6e4 : void 0
      }
    };
    const n = new qEe(this.imageData, {
      floating: t.floating,
      docProperties: t.altText,
      outline: t.outline
    });
    this.root.push(n);
  }
  prepForXml(t) {
    return t.file.Media.addImage(this.key, this.imageData), super.prepForXml(t);
  }
  convertDataURIToBinary(t) {
    if (typeof atob == "function") {
      const r = ";base64,", n = t.indexOf(r), a = n === -1 ? 0 : n + r.length;
      return new Uint8Array(
        atob(t.substring(a)).split("").map((s) => s.charCodeAt(0))
      );
    } else {
      const r = require("buffer");
      return new r.Buffer(t, "base64");
    }
  }
}
class HEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
  }
}
class VEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      "xmlns:cx": "xmlns:cx",
      "xmlns:cx1": "xmlns:cx1",
      "xmlns:cx2": "xmlns:cx2",
      "xmlns:cx3": "xmlns:cx3",
      "xmlns:cx4": "xmlns:cx4",
      "xmlns:cx5": "xmlns:cx5",
      "xmlns:cx6": "xmlns:cx6",
      "xmlns:cx7": "xmlns:cx7",
      "xmlns:cx8": "xmlns:cx8",
      "xmlns:mc": "xmlns:mc",
      "xmlns:aink": "xmlns:aink",
      "xmlns:am3d": "xmlns:am3d",
      "xmlns:o": "xmlns:o",
      "xmlns:r": "xmlns:r",
      "xmlns:m": "xmlns:m",
      "xmlns:v": "xmlns:v",
      "xmlns:wp14": "xmlns:wp14",
      "xmlns:wp": "xmlns:wp",
      "xmlns:w10": "xmlns:w10",
      "xmlns:w": "xmlns:w",
      "xmlns:w14": "xmlns:w14",
      "xmlns:w15": "xmlns:w15",
      "xmlns:w16cex": "xmlns:w16cex",
      "xmlns:w16cid": "xmlns:w16cid",
      "xmlns:w16": "xmlns:w16",
      "xmlns:w16sdtdh": "xmlns:w16sdtdh",
      "xmlns:w16se": "xmlns:w16se",
      "xmlns:wpg": "xmlns:wpg",
      "xmlns:wpi": "xmlns:wpi",
      "xmlns:wne": "xmlns:wne",
      "xmlns:wps": "xmlns:wps"
    });
  }
}
class GEe extends nt {
  constructor({ id: t, initials: r, author: n, date: a = /* @__PURE__ */ new Date(), children: s }) {
    super("w:comment"), this.root.push(
      new HEe({
        id: t,
        initials: r,
        author: n,
        date: a.toISOString()
      })
    );
    for (const i of s)
      this.root.push(i);
  }
}
class WEe extends nt {
  constructor({ children: t }) {
    super("w:comments"), this.root.push(
      new VEe({
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      })
    );
    for (const r of t)
      this.root.push(new GEe(r));
  }
}
class KEe extends nt {
  constructor() {
    super("w:pageBreakBefore");
  }
}
const RR = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  AT_LEAST: "atLeast",
  EXACTLY: "exactly",
  EXACT: "exact",
  AUTO: "auto"
};
class YEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      after: "w:after",
      before: "w:before",
      line: "w:line",
      lineRule: "w:lineRule"
    });
  }
}
class XEe extends nt {
  constructor(t) {
    super("w:spacing"), this.root.push(new YEe(t));
  }
}
const pc = {
  HEADING_1: "Heading1",
  HEADING_2: "Heading2",
  HEADING_3: "Heading3",
  HEADING_4: "Heading4",
  HEADING_5: "Heading5",
  HEADING_6: "Heading6",
  TITLE: "Title"
};
let km = class extends nt {
  constructor(t) {
    super("w:pStyle"), this.root.push(
      new oi({
        val: t
      })
    );
  }
};
class ZEe extends nt {
  constructor(t) {
    super("w:tabs");
    for (const r of t)
      this.root.push(new QEe(r));
  }
}
const XM = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  BAR: "bar",
  CLEAR: "clear",
  DECIMAL: "decimal",
  END: "end",
  NUM: "num",
  START: "start"
};
class JEe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
  }
}
class QEe extends nt {
  constructor({ type: t, position: r, leader: n }) {
    super("w:tab"), this.root.push(
      new JEe({
        val: t,
        pos: r,
        leader: n
      })
    );
  }
}
class ZM extends nt {
  constructor(t, r) {
    super("w:numPr"), this.root.push(new eSe(r)), this.root.push(new tSe(t));
  }
}
class eSe extends nt {
  constructor(t) {
    if (super("w:ilvl"), t > 9)
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class tSe extends nt {
  constructor(t) {
    super("w:numId"), this.root.push(
      new oi({
        val: typeof t == "string" ? `{${t}}` : t
      })
    );
  }
}
class AG extends nt {
  constructor() {
    super(...arguments), st(this, "fileChild", Symbol());
  }
}
class rSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "Id",
      type: "Type",
      target: "Target",
      targetMode: "TargetMode"
    });
  }
}
const nSe = {
  EXTERNAL: "External"
};
class iSe extends nt {
  constructor(t, r, n, a) {
    super("Relationship"), this.root.push(
      new rSe({
        id: t,
        type: r,
        target: n,
        targetMode: a
      })
    );
  }
}
class aSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "r:id",
      history: "w:history",
      anchor: "w:anchor"
    });
  }
}
class ZN extends nt {
  constructor(t, r, n) {
    super("w:hyperlink"), st(this, "linkId"), this.linkId = r;
    const a = {
      history: 1,
      anchor: n || void 0,
      id: n ? void 0 : `rId${this.linkId}`
    }, s = new aSe(a);
    this.root.push(s), t.forEach((i) => {
      this.root.push(i);
    });
  }
}
class TG extends nt {
  constructor(t) {
    super("w:externalHyperlink"), this.options = t;
  }
}
class sSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "w:id",
      name: "w:name"
    });
  }
}
class oSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "w:id"
    });
  }
}
class lSe {
  constructor(t) {
    st(this, "bookmarkUniqueNumericId", qxe()), st(this, "start"), st(this, "children"), st(this, "end");
    const r = this.bookmarkUniqueNumericId();
    this.start = new uSe(t.id, r), this.children = t.children, this.end = new cSe(r);
  }
}
class uSe extends nt {
  constructor(t, r) {
    super("w:bookmarkStart");
    const n = new sSe({
      name: t,
      id: r
    });
    this.root.push(n);
  }
}
class cSe extends nt {
  constructor(t) {
    super("w:bookmarkEnd");
    const r = new oSe({
      id: t
    });
    this.root.push(r);
  }
}
class dSe extends nt {
  constructor(t) {
    super("w:outlineLvl"), this.level = t, this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class fSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      verticalAlign: "w:val"
    });
  }
}
class RG extends nt {
  constructor(t) {
    super("w:vAlign"), this.root.push(new fSe({ verticalAlign: t }));
  }
}
const Xc = {
  DEFAULT: "default",
  FIRST: "first",
  EVEN: "even"
};
class pSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      type: "w:type",
      id: "r:id"
    });
  }
}
const JM = {
  HEADER: "w:headerReference",
  FOOTER: "w:footerReference"
};
class Ix extends nt {
  constructor(t, r) {
    super(t), this.root.push(
      new pSe({
        type: r.type || Xc.DEFAULT,
        id: `rId${r.id}`
      })
    );
  }
}
class hSe extends nt {
  constructor({ space: t, count: r, separate: n, equalWidth: a, children: s }) {
    super("w:cols"), this.root.push(
      new Jo({
        space: { key: "w:space", value: t === void 0 ? void 0 : Li(t) },
        count: { key: "w:num", value: r === void 0 ? void 0 : Gi(r) },
        separate: { key: "w:sep", value: n },
        equalWidth: { key: "w:equalWidth", value: a }
      })
    ), !a && s && s.forEach((i) => this.addChildElement(i));
  }
}
class mSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      type: "w:type",
      linePitch: "w:linePitch",
      charSpace: "w:charSpace"
    });
  }
}
class gSe extends nt {
  constructor(t, r, n) {
    super("w:docGrid"), this.root.push(
      new mSe({
        type: n,
        linePitch: Gi(t),
        charSpace: r ? Gi(r) : void 0
      })
    );
  }
}
const bSe = ({ countBy: e, start: t, restart: r, distance: n }) => new Wi({
  name: "w:lnNumType",
  attributes: {
    countBy: { key: "w:countBy", value: e === void 0 ? void 0 : Gi(e) },
    start: { key: "w:start", value: t === void 0 ? void 0 : Gi(t) },
    restart: { key: "w:restart", value: r },
    distance: {
      key: "w:distance",
      value: n === void 0 ? void 0 : Li(n)
    }
  }
});
class QM extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      display: "w:display",
      offsetFrom: "w:offsetFrom",
      zOrder: "w:zOrder"
    });
  }
}
class ySe extends Zo {
  constructor(t) {
    if (super("w:pgBorders"), !t)
      return this;
    t.pageBorders ? this.root.push(
      new QM({
        display: t.pageBorders.display,
        offsetFrom: t.pageBorders.offsetFrom,
        zOrder: t.pageBorders.zOrder
      })
    ) : this.root.push(new QM({})), t.pageBorderTop && this.root.push(new Fn("w:top", t.pageBorderTop)), t.pageBorderLeft && this.root.push(new Fn("w:left", t.pageBorderLeft)), t.pageBorderBottom && this.root.push(new Fn("w:bottom", t.pageBorderBottom)), t.pageBorderRight && this.root.push(new Fn("w:right", t.pageBorderRight));
  }
}
class vSe extends nt {
  constructor(t, r, n, a, s, i, o) {
    super("w:pgMar"), this.root.push(
      new Jo({
        top: { key: "w:top", value: Mo(t) },
        right: { key: "w:right", value: Li(r) },
        bottom: { key: "w:bottom", value: Mo(n) },
        left: { key: "w:left", value: Li(a) },
        header: { key: "w:header", value: Li(s) },
        footer: { key: "w:footer", value: Li(i) },
        gutter: { key: "w:gutter", value: Li(o) }
      })
    );
  }
}
class wSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      start: "w:start",
      formatType: "w:fmt",
      separator: "w:chapSep"
    });
  }
}
class xSe extends nt {
  constructor({ start: t, formatType: r, separator: n }) {
    super("w:pgNumType"), this.root.push(
      new wSe({
        start: t === void 0 ? void 0 : Gi(t),
        formatType: r,
        separator: n
      })
    );
  }
}
const IG = {
  PORTRAIT: "portrait",
  LANDSCAPE: "landscape"
};
class ESe extends nt {
  constructor(t, r, n) {
    super("w:pgSz");
    const a = n === IG.LANDSCAPE, s = Li(t), i = Li(r);
    this.root.push(
      new Jo({
        width: { key: "w:w", value: a ? i : s },
        height: { key: "w:h", value: a ? s : i },
        orientation: { key: "w:orient", value: n }
      })
    );
  }
}
class SSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class _Se extends nt {
  constructor(t) {
    super("w:textDirection"), this.root.push(
      new SSe({
        val: t
      })
    );
  }
}
class kSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      val: "w:val"
    });
  }
}
class CSe extends nt {
  constructor(t) {
    super("w:type"), this.root.push(new kSe({ val: t }));
  }
}
const du = {
  TOP: 1440,
  RIGHT: 1440,
  BOTTOM: 1440,
  LEFT: 1440,
  HEADER: 708,
  FOOTER: 708,
  GUTTER: 0
}, Nx = {
  WIDTH: 11906,
  HEIGHT: 16838,
  ORIENTATION: IG.PORTRAIT
};
class ASe extends nt {
  constructor({
    page: {
      size: {
        width: t = Nx.WIDTH,
        height: r = Nx.HEIGHT,
        orientation: n = Nx.ORIENTATION
      } = {},
      margin: {
        top: a = du.TOP,
        right: s = du.RIGHT,
        bottom: i = du.BOTTOM,
        left: o = du.LEFT,
        header: l = du.HEADER,
        footer: u = du.FOOTER,
        gutter: c = du.GUTTER
      } = {},
      pageNumbers: d = {},
      borders: p,
      textDirection: f
    } = {},
    grid: { linePitch: h = 360, charSpace: m, type: y } = {},
    headerWrapperGroup: b = {},
    footerWrapperGroup: v = {},
    lineNumbers: x,
    titlePage: _,
    verticalAlign: E,
    column: w,
    type: C
  } = {}) {
    super("w:sectPr"), this.addHeaderFooterGroup(JM.HEADER, b), this.addHeaderFooterGroup(JM.FOOTER, v), C && this.root.push(new CSe(C)), this.root.push(new ESe(t, r, n)), this.root.push(new vSe(a, s, i, o, l, u, c)), p && this.root.push(new ySe(p)), x && this.root.push(bSe(x)), this.root.push(new xSe(d)), w && this.root.push(new hSe(w)), E && this.root.push(new RG(E)), _ !== void 0 && this.root.push(new Pt("w:titlePg", _)), f && this.root.push(new _Se(f)), this.root.push(new gSe(h, m, y));
  }
  addHeaderFooterGroup(t, r) {
    r.default && this.root.push(
      new Ix(t, {
        type: Xc.DEFAULT,
        id: r.default.View.ReferenceId
      })
    ), r.first && this.root.push(
      new Ix(t, {
        type: Xc.FIRST,
        id: r.first.View.ReferenceId
      })
    ), r.even && this.root.push(
      new Ix(t, {
        type: Xc.EVEN,
        id: r.even.View.ReferenceId
      })
    );
  }
}
class TSe extends nt {
  constructor() {
    super("w:body"), st(this, "sections", []);
  }
  /**
   * Adds new section properties.
   * Note: Previous section is created in paragraph after the current element, and then new section will be added.
   * The spec says:
   *  - section element should be in the last paragraph of the section
   *  - last section should be direct child of body
   *
   * @param options new section options
   */
  addSection(t) {
    const r = this.sections.pop();
    this.root.push(this.createSectionParagraph(r)), this.sections.push(new ASe(t));
  }
  prepForXml(t) {
    return this.sections.length === 1 && (this.root.splice(0, 1), this.root.push(this.sections.pop())), super.prepForXml(t);
  }
  push(t) {
    this.root.push(t);
  }
  createSectionParagraph(t) {
    const r = new Ha({}), n = new hd({});
    return n.push(t), r.addChildElement(n), r;
  }
}
class _h extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      aink: "xmlns:aink",
      am3d: "xmlns:am3d",
      w16cex: "xmlns:w16cex",
      w16cid: "xmlns:w16cid",
      w16: "xmlns:w16",
      w16sdtdh: "xmlns:w16sdtdh",
      w16se: "xmlns:w16se"
    });
  }
}
class RSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      color: "w:color",
      themeColor: "w:themeColor",
      themeShade: "w:themeShade",
      themeTint: "w:themeTint"
    });
  }
}
class ISe extends nt {
  constructor(t) {
    super("w:background"), this.root.push(
      new RSe({
        color: t.color === void 0 ? void 0 : dd(t.color),
        themeColor: t.themeColor,
        themeShade: t.themeShade === void 0 ? void 0 : VM(t.themeShade),
        themeTint: t.themeTint === void 0 ? void 0 : VM(t.themeTint)
      })
    );
  }
}
class NSe extends nt {
  constructor(t) {
    super("w:document"), st(this, "body"), this.root.push(
      new _h({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
        cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
        am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
        w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        w16: "http://schemas.microsoft.com/office/word/2018/wordml",
        w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        Ignorable: "w14 w15 wp14"
      })
    ), this.body = new TSe(), t.background && this.root.push(new ISe(t.background)), this.root.push(this.body);
  }
  add(t) {
    return this.body.push(t), this;
  }
  get Body() {
    return this.body;
  }
}
class DSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}
class Od extends nt {
  constructor() {
    super("Relationships"), this.root.push(
      new DSe({
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      })
    );
  }
  createRelationship(t, r, n, a) {
    const s = new iSe(`rId${t}`, r, n, a);
    return this.root.push(s), s;
  }
  get RelationshipCount() {
    return this.root.length - 1;
  }
}
class NG {
  constructor(t) {
    st(this, "document"), st(this, "relationships"), this.document = new NSe(t), this.relationships = new Od();
  }
  get View() {
    return this.document;
  }
  get Relationships() {
    return this.relationships;
  }
}
class OSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class PSe extends nt {
  constructor() {
    super("w:wordWrap"), this.root.push(new OSe({ val: 0 }));
  }
}
const LSe = (e) => {
  var t, r;
  return new Wi({
    name: "w:framePr",
    attributes: {
      anchorLock: {
        key: "w:anchorLock",
        value: e.anchorLock
      },
      dropCap: {
        key: "w:dropCap",
        value: e.dropCap
      },
      width: {
        key: "w:w",
        value: e.width
      },
      height: {
        key: "w:h",
        value: e.height
      },
      x: {
        key: "w:x",
        value: e.position ? e.position.x : void 0
      },
      y: {
        key: "w:y",
        value: e.position ? e.position.y : void 0
      },
      anchorHorizontal: {
        key: "w:hAnchor",
        value: e.anchor.horizontal
      },
      anchorVertical: {
        key: "w:vAnchor",
        value: e.anchor.vertical
      },
      spaceHorizontal: {
        key: "w:hSpace",
        value: (t = e.space) == null ? void 0 : t.horizontal
      },
      spaceVertical: {
        key: "w:vSpace",
        value: (r = e.space) == null ? void 0 : r.vertical
      },
      rule: {
        key: "w:hRule",
        value: e.rule
      },
      alignmentX: {
        key: "w:xAlign",
        value: e.alignment ? e.alignment.x : void 0
      },
      alignmentY: {
        key: "w:yAlign",
        value: e.alignment ? e.alignment.y : void 0
      },
      lines: {
        key: "w:lines",
        value: e.lines
      },
      wrap: {
        key: "w:wrap",
        value: e.wrap
      }
    }
  });
};
class hd extends Zo {
  constructor(t) {
    var r, n;
    if (super("w:pPr"), st(this, "numberingReferences", []), !t)
      return this;
    t.heading && this.push(new km(t.heading)), t.bullet && this.push(new km("ListParagraph")), t.numbering && !t.style && !t.heading && (t.numbering.custom || this.push(new km("ListParagraph"))), t.style && this.push(new km(t.style)), t.keepNext !== void 0 && this.push(new Pt("w:keepNext", t.keepNext)), t.keepLines !== void 0 && this.push(new Pt("w:keepLines", t.keepLines)), t.pageBreakBefore && this.push(new KEe()), t.frame && this.push(LSe(t.frame)), t.widowControl !== void 0 && this.push(new Pt("w:widowControl", t.widowControl)), t.bullet && this.push(new ZM(1, t.bullet.level)), t.numbering && (this.numberingReferences.push({
      reference: t.numbering.reference,
      instance: (r = t.numbering.instance) != null ? r : 0
    }), this.push(new ZM(`${t.numbering.reference}-${(n = t.numbering.instance) != null ? n : 0}`, t.numbering.level))), t.border && this.push(new fxe(t.border)), t.thematicBreak && this.push(new pxe()), t.shading && this.push(new dy(t.shading)), t.wordWrap && this.push(new PSe()), t.overflowPunctuation && this.push(new Pt("w:overflowPunct", t.overflowPunctuation));
    const a = [
      ...t.rightTabStop !== void 0 ? [{ type: XM.RIGHT, position: t.rightTabStop }] : [],
      ...t.tabStops ? t.tabStops : [],
      ...t.leftTabStop !== void 0 ? [{ type: XM.LEFT, position: t.leftTabStop }] : []
    ];
    a.length > 0 && this.push(new ZEe(a)), t.bidirectional !== void 0 && this.push(new Pt("w:bidi", t.bidirectional)), t.spacing && this.push(new XEe(t.spacing)), t.indent && this.push(new hxe(t.indent)), t.contextualSpacing !== void 0 && this.push(new Pt("w:contextualSpacing", t.contextualSpacing)), t.alignment && this.push(new hG(t.alignment)), t.outlineLevel !== void 0 && this.push(new dSe(t.outlineLevel)), t.suppressLineNumbers !== void 0 && this.push(new Pt("w:suppressLineNumbers", t.suppressLineNumbers)), t.autoSpaceEastAsianText !== void 0 && this.push(new Pt("w:autoSpaceDN", t.autoSpaceEastAsianText)), t.run && this.push(new Vu(t.run));
  }
  push(t) {
    this.root.push(t);
  }
  prepForXml(t) {
    if (t.viewWrapper instanceof NG)
      for (const r of this.numberingReferences)
        t.file.Numbering.createConcreteNumberingInstance(r.reference, r.instance);
    return super.prepForXml(t);
  }
}
class Ha extends AG {
  constructor(t) {
    if (super("w:p"), st(this, "properties"), typeof t == "string")
      return this.properties = new hd({}), this.root.push(this.properties), this.root.push(new Kg(t)), this;
    if (this.properties = new hd(t), this.root.push(this.properties), t.text && this.root.push(new Kg(t.text)), t.children)
      for (const r of t.children) {
        if (r instanceof lSe) {
          this.root.push(r.start);
          for (const n of r.children)
            this.root.push(n);
          this.root.push(r.end);
          continue;
        }
        this.root.push(r);
      }
  }
  prepForXml(t) {
    for (const r of this.root)
      if (r instanceof TG) {
        const n = this.root.indexOf(r), a = new ZN(r.options.children, bG());
        t.viewWrapper.Relationships.createRelationship(
          a.linkId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          r.options.link,
          nSe.EXTERNAL
        ), this.root[n] = a;
      }
    return super.prepForXml(t);
  }
  addRunToFront(t) {
    return this.root.splice(1, 0, t), this;
  }
}
let DG = class extends nt {
  constructor(t) {
    super("m:oMath");
    for (const r of t.children)
      this.root.push(r);
  }
};
class MSe extends nt {
  constructor(t) {
    super("m:t"), this.root.push(t);
  }
}
class FSe extends nt {
  constructor(t) {
    super("m:r"), this.root.push(new MSe(t));
  }
}
class $Se extends nt {
  constructor(t) {
    super("m:den");
    for (const r of t)
      this.root.push(r);
  }
}
class BSe extends nt {
  constructor(t) {
    super("m:num");
    for (const r of t)
      this.root.push(r);
  }
}
class USe extends nt {
  constructor(t) {
    super("m:f"), this.root.push(new BSe(t.numerator)), this.root.push(new $Se(t.denominator));
  }
}
class zSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { accent: "m:val" });
  }
}
class qSe extends nt {
  constructor(t) {
    super("m:chr"), this.root.push(new zSe({ accent: t }));
  }
}
class py extends nt {
  constructor(t) {
    super("m:e");
    for (const r of t)
      this.root.push(r);
  }
}
class jSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { value: "m:val" });
  }
}
class HSe extends nt {
  constructor() {
    super("m:limLoc"), this.root.push(new jSe({ value: "undOvr" }));
  }
}
class VSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { hide: "m:val" });
  }
}
class GSe extends nt {
  constructor() {
    super("m:subHide"), this.root.push(new VSe({ hide: 1 }));
  }
}
class WSe extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { hide: "m:val" });
  }
}
class KSe extends nt {
  constructor() {
    super("m:supHide"), this.root.push(new WSe({ hide: 1 }));
  }
}
class YSe extends nt {
  constructor(t, r, n) {
    super("m:naryPr"), t && this.root.push(new qSe(t)), this.root.push(new HSe()), r || this.root.push(new KSe()), n || this.root.push(new GSe());
  }
}
class OG extends nt {
  constructor(t) {
    super("m:sub");
    for (const r of t)
      this.root.push(r);
  }
}
class PG extends nt {
  constructor(t) {
    super("m:sup");
    for (const r of t)
      this.root.push(r);
  }
}
class XSe extends nt {
  constructor(t) {
    super("m:nary"), this.root.push(new YSe("∑", !!t.superScript, !!t.subScript)), t.subScript && this.root.push(new OG(t.subScript)), t.superScript && this.root.push(new PG(t.superScript)), this.root.push(new py(t.children));
  }
}
class ZSe extends nt {
  constructor() {
    super("m:sSupPr");
  }
}
class JSe extends nt {
  constructor(t) {
    super("m:sSup"), this.root.push(new ZSe()), this.root.push(new py(t.children)), this.root.push(new PG(t.superScript));
  }
}
class QSe extends nt {
  constructor() {
    super("m:sSubPr");
  }
}
class e_e extends nt {
  constructor(t) {
    super("m:sSub"), this.root.push(new QSe()), this.root.push(new py(t.children)), this.root.push(new OG(t.subScript));
  }
}
class t_e extends nt {
  constructor(t) {
    if (super("m:deg"), t)
      for (const r of t)
        this.root.push(r);
  }
}
class r_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { hide: "m:val" });
  }
}
class n_e extends nt {
  constructor() {
    super("m:degHide"), this.root.push(new r_e({ hide: 1 }));
  }
}
class i_e extends nt {
  constructor(t) {
    super("m:radPr"), t || this.root.push(new n_e());
  }
}
class e5 extends nt {
  constructor(t) {
    super("m:rad"), this.root.push(new i_e(!!t.degree)), this.root.push(new t_e(t.degree)), this.root.push(new py(t.children));
  }
}
class a_e extends nt {
  constructor(t) {
    super("w:tblGrid");
    for (const r of t)
      this.root.push(new s_e(r));
  }
}
class s_e extends nt {
  constructor(t) {
    super("w:gridCol"), t !== void 0 && this.root.push(
      new Jo({
        width: { key: "w:w", value: Li(t) }
      })
    );
  }
}
const LG = {
  TABLE: "w:tblCellMar",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  TABLE_CELL: "w:tcMar"
};
class MG extends Zo {
  constructor(t, { marginUnitType: r = IR.DXA, top: n, left: a, bottom: s, right: i }) {
    super(t), n !== void 0 && this.root.push(new gu("w:top", { type: r, size: n })), a !== void 0 && this.root.push(new gu("w:left", { type: r, size: a })), s !== void 0 && this.root.push(new gu("w:bottom", { type: r, size: s })), i !== void 0 && this.root.push(new gu("w:right", { type: r, size: i }));
  }
}
const IR = {
  /** Auto. */
  AUTO: "auto",
  /** Value is in twentieths of a point */
  DXA: "dxa",
  /** No (empty) value. */
  NIL: "nil",
  /** Value is in percentage. */
  PERCENTAGE: "pct"
};
class gu extends nt {
  constructor(t, { type: r = IR.AUTO, size: n }) {
    super(t);
    let a = n;
    r === IR.PERCENTAGE && typeof n == "number" && (a = `${n}%`), this.root.push(
      new Jo({
        type: { key: "w:type", value: r },
        size: { key: "w:w", value: axe(a) }
      })
    );
  }
}
class o_e extends Zo {
  constructor(t) {
    super("w:tcBorders"), t.top && this.root.push(new Fn("w:top", t.top)), t.start && this.root.push(new Fn("w:start", t.start)), t.left && this.root.push(new Fn("w:left", t.left)), t.bottom && this.root.push(new Fn("w:bottom", t.bottom)), t.end && this.root.push(new Fn("w:end", t.end)), t.right && this.root.push(new Fn("w:right", t.right));
  }
}
class l_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class u_e extends nt {
  constructor(t) {
    super("w:gridSpan"), this.root.push(
      new l_e({
        val: Gi(t)
      })
    );
  }
}
const FG = {
  /**
   * Cell that is merged with upper one.
   */
  CONTINUE: "continue",
  /**
   * Cell that is starting the vertical merge.
   */
  RESTART: "restart"
};
class c_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class t5 extends nt {
  constructor(t) {
    super("w:vMerge"), this.root.push(
      new c_e({
        val: t
      })
    );
  }
}
class d_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class f_e extends nt {
  constructor(t) {
    super("w:textDirection"), this.root.push(
      new d_e({
        val: t
      })
    );
  }
}
class p_e extends Zo {
  constructor(t) {
    super("w:tcPr"), t.width && this.root.push(new gu("w:tcW", t.width)), t.columnSpan && this.root.push(new u_e(t.columnSpan)), t.verticalMerge ? this.root.push(new t5(t.verticalMerge)) : t.rowSpan && t.rowSpan > 1 && this.root.push(new t5(FG.RESTART)), t.borders && this.root.push(new o_e(t.borders)), t.shading && this.root.push(new dy(t.shading)), t.margins && this.root.push(new MG(LG.TABLE_CELL, t.margins)), t.textDirection && this.root.push(new f_e(t.textDirection)), t.verticalAlign && this.root.push(new RG(t.verticalAlign));
  }
}
let JN = class extends nt {
  constructor(t) {
    super("w:tc"), this.options = t, this.root.push(new p_e(t));
    for (const r of t.children)
      this.root.push(r);
  }
  prepForXml(t) {
    return this.root[this.root.length - 1] instanceof Ha || this.root.push(new Ha({})), super.prepForXml(t);
  }
};
const hc = {
  style: KN.NONE,
  size: 0,
  color: "auto"
}, mc = {
  style: KN.SINGLE,
  size: 4,
  color: "auto"
};
class $G extends nt {
  constructor(t) {
    super("w:tblBorders"), t.top ? this.root.push(new Fn("w:top", t.top)) : this.root.push(new Fn("w:top", mc)), t.left ? this.root.push(new Fn("w:left", t.left)) : this.root.push(new Fn("w:left", mc)), t.bottom ? this.root.push(new Fn("w:bottom", t.bottom)) : this.root.push(new Fn("w:bottom", mc)), t.right ? this.root.push(new Fn("w:right", t.right)) : this.root.push(new Fn("w:right", mc)), t.insideHorizontal ? this.root.push(new Fn("w:insideH", t.insideHorizontal)) : this.root.push(new Fn("w:insideH", mc)), t.insideVertical ? this.root.push(new Fn("w:insideV", t.insideVertical)) : this.root.push(new Fn("w:insideV", mc));
  }
}
st($G, "NONE", {
  top: hc,
  bottom: hc,
  left: hc,
  right: hc,
  insideHorizontal: hc,
  insideVertical: hc
});
class h_e extends nt {
  constructor({
    horizontalAnchor: t,
    verticalAnchor: r,
    absoluteHorizontalPosition: n,
    relativeHorizontalPosition: a,
    absoluteVerticalPosition: s,
    relativeVerticalPosition: i,
    bottomFromText: o,
    topFromText: l,
    leftFromText: u,
    rightFromText: c,
    overlap: d
  }) {
    super("w:tblpPr"), this.root.push(
      new Jo({
        leftFromText: {
          key: "w:leftFromText",
          value: u === void 0 ? void 0 : Li(u)
        },
        rightFromText: {
          key: "w:rightFromText",
          value: c === void 0 ? void 0 : Li(c)
        },
        topFromText: {
          key: "w:topFromText",
          value: l === void 0 ? void 0 : Li(l)
        },
        bottomFromText: {
          key: "w:bottomFromText",
          value: o === void 0 ? void 0 : Li(o)
        },
        absoluteHorizontalPosition: {
          key: "w:tblpX",
          value: n === void 0 ? void 0 : Mo(n)
        },
        absoluteVerticalPosition: {
          key: "w:tblpY",
          value: s === void 0 ? void 0 : Mo(s)
        },
        horizontalAnchor: {
          key: "w:horzAnchor",
          value: t === void 0 ? void 0 : t
        },
        relativeHorizontalPosition: {
          key: "w:tblpXSpec",
          value: a
        },
        relativeVerticalPosition: {
          key: "w:tblpYSpec",
          value: i
        },
        verticalAnchor: {
          key: "w:vertAnchor",
          value: r
        }
      })
    ), d && this.root.push(new uxe("w:tblOverlap", d));
  }
}
class m_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { type: "w:type" });
  }
}
class g_e extends nt {
  constructor(t) {
    super("w:tblLayout"), this.root.push(new m_e({ type: t }));
  }
}
class b_e extends Zo {
  constructor(t) {
    super("w:tblPr"), t.style && this.root.push(new Ol("w:tblStyle", t.style)), t.float && this.root.push(new h_e(t.float)), t.visuallyRightToLeft !== void 0 && this.root.push(new Pt("w:bidiVisual", t.visuallyRightToLeft)), t.width && this.root.push(new gu("w:tblW", t.width)), t.alignment && this.root.push(new hG(t.alignment)), t.indent && this.root.push(new gu("w:tblInd", t.indent)), t.borders && this.root.push(new $G(t.borders)), t.shading && this.root.push(new dy(t.shading)), t.layout && this.root.push(new g_e(t.layout)), t.cellMargin && this.root.push(new MG(LG.TABLE, t.cellMargin));
  }
}
let y_e = class extends AG {
  constructor({
    rows: t,
    width: r,
    // eslint-disable-next-line functional/immutable-data
    columnWidths: n = Array(Math.max(...t.map((p) => p.CellCount))).fill(100),
    margins: a,
    indent: s,
    float: i,
    layout: o,
    style: l,
    borders: u,
    alignment: c,
    visuallyRightToLeft: d
  }) {
    super("w:tbl"), this.root.push(
      new b_e({
        borders: u ?? {},
        width: r ?? { size: 100 },
        indent: s,
        float: i,
        layout: o,
        style: l,
        alignment: c,
        cellMargin: a,
        visuallyRightToLeft: d
      })
    ), this.root.push(new a_e(n));
    for (const p of t)
      this.root.push(p);
    t.forEach((p, f) => {
      if (f === t.length - 1)
        return;
      let h = 0;
      p.cells.forEach((m) => {
        if (m.options.rowSpan && m.options.rowSpan > 1) {
          const y = new JN({
            // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row
            rowSpan: m.options.rowSpan - 1,
            columnSpan: m.options.columnSpan,
            borders: m.options.borders,
            children: [],
            verticalMerge: FG.CONTINUE
          });
          t[f + 1].addCellToColumnIndex(y, h);
        }
        h += m.options.columnSpan || 1;
      });
    });
  }
};
class v_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
  }
}
class w_e extends nt {
  constructor(t, r) {
    super("w:trHeight"), this.root.push(
      new v_e({
        value: Li(t),
        rule: r
      })
    );
  }
}
class x_e extends Zo {
  constructor(t) {
    super("w:trPr"), t.cantSplit !== void 0 && this.root.push(new Pt("w:cantSplit", t.cantSplit)), t.tableHeader !== void 0 && this.root.push(new Pt("w:tblHeader", t.tableHeader)), t.height && this.root.push(new w_e(t.height.value, t.height.rule));
  }
}
let E_e = class extends nt {
  constructor(t) {
    super("w:tr"), this.options = t, this.root.push(new x_e(t));
    for (const r of t.children)
      this.root.push(r);
  }
  get CellCount() {
    return this.options.children.length;
  }
  get cells() {
    return this.root.filter((t) => t instanceof JN);
  }
  addCellToIndex(t, r) {
    this.root.splice(r + 1, 0, t);
  }
  addCellToColumnIndex(t, r) {
    const n = this.columnIndexToRootIndex(r, !0);
    this.addCellToIndex(t, n - 1);
  }
  rootIndexToColumnIndex(t) {
    if (t < 1 || t >= this.root.length)
      throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
    let r = 0;
    for (let n = 1; n < t; n++) {
      const a = this.root[n];
      r += a.options.columnSpan || 1;
    }
    return r;
  }
  columnIndexToRootIndex(t, r = !1) {
    if (t < 0)
      throw new Error("cell 'columnIndex' should not less than zero");
    let n = 0, a = 1;
    for (; n <= t; ) {
      if (a >= this.root.length) {
        if (r)
          return this.root.length;
        throw new Error(`cell 'columnIndex' should not great than ${n - 1}`);
      }
      const s = this.root[a];
      a += 1, n += s && s.options.columnSpan || 1;
    }
    return a - 1;
  }
};
class S_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}
class __e extends nt {
  constructor() {
    super("Properties"), this.root.push(
      new S_e({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    );
  }
}
class k_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}
class C_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      contentType: "ContentType",
      extension: "Extension"
    });
  }
}
class vl extends nt {
  constructor(t, r) {
    super("Default"), this.root.push(
      new C_e({
        contentType: t,
        extension: r
      })
    );
  }
}
class A_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      contentType: "ContentType",
      partName: "PartName"
    });
  }
}
class Xa extends nt {
  constructor(t, r) {
    super("Override"), this.root.push(
      new A_e({
        contentType: t,
        partName: r
      })
    );
  }
}
class T_e extends nt {
  constructor() {
    super("Types"), this.root.push(
      new k_e({
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      })
    ), this.root.push(new vl("image/png", "png")), this.root.push(new vl("image/jpeg", "jpeg")), this.root.push(new vl("image/jpeg", "jpg")), this.root.push(new vl("image/bmp", "bmp")), this.root.push(new vl("image/gif", "gif")), this.root.push(new vl("application/vnd.openxmlformats-package.relationships+xml", "rels")), this.root.push(new vl("application/xml", "xml")), this.root.push(new vl("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf")), this.root.push(
      new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml")
    ), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml")), this.root.push(new Xa("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml")), this.root.push(new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
  }
  addFooter(t) {
    this.root.push(
      new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${t}.xml`)
    );
  }
  addHeader(t) {
    this.root.push(
      new Xa("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${t}.xml`)
    );
  }
}
class R_e extends nt {
  constructor(t) {
    super("cp:coreProperties"), this.root.push(
      new _h({
        cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
        dc: "http://purl.org/dc/elements/1.1/",
        dcterms: "http://purl.org/dc/terms/",
        dcmitype: "http://purl.org/dc/dcmitype/",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
      })
    ), t.title && this.root.push(new cu("dc:title", t.title)), t.subject && this.root.push(new cu("dc:subject", t.subject)), t.creator && this.root.push(new cu("dc:creator", t.creator)), t.keywords && this.root.push(new cu("cp:keywords", t.keywords)), t.description && this.root.push(new cu("dc:description", t.description)), t.lastModifiedBy && this.root.push(new cu("cp:lastModifiedBy", t.lastModifiedBy)), t.revision && this.root.push(new cu("cp:revision", String(t.revision))), this.root.push(new r5("dcterms:created")), this.root.push(new r5("dcterms:modified"));
  }
}
class r5 extends nt {
  constructor(t) {
    super(t), this.root.push(
      new _h({
        type: "dcterms:W3CDTF"
      })
    ), this.root.push(lxe(/* @__PURE__ */ new Date()));
  }
}
class I_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}
class N_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      fmtid: "fmtid",
      pid: "pid",
      name: "name"
    });
  }
}
class D_e extends nt {
  constructor(t, r) {
    super("property"), this.root.push(
      new N_e({
        fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        pid: t.toString(),
        name: r.name
      })
    ), this.root.push(new O_e(r.value));
  }
}
class O_e extends nt {
  constructor(t) {
    super("vt:lpwstr"), this.root.push(t);
  }
}
class P_e extends nt {
  constructor(t) {
    super("Properties"), st(this, "nextId"), st(this, "properties", []), this.root.push(
      new I_e({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    ), this.nextId = 2;
    for (const r of t)
      this.addCustomProperty(r);
  }
  prepForXml(t) {
    return this.properties.forEach((r) => this.root.push(r)), super.prepForXml(t);
  }
  addCustomProperty(t) {
    this.properties.push(new D_e(this.nextId++, t));
  }
}
class L_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type"
    });
  }
}
let M_e = class extends fG {
  constructor(t, r) {
    super("w:ftr", r), st(this, "refId"), this.refId = t, r || this.root.push(
      new L_e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      })
    );
  }
  get ReferenceId() {
    return this.refId;
  }
  add(t) {
    this.root.push(t);
  }
};
class F_e {
  constructor(t, r, n) {
    st(this, "footer"), st(this, "relationships"), this.media = t, this.footer = new M_e(r, n), this.relationships = new Od();
  }
  add(t) {
    this.footer.add(t);
  }
  addChildElement(t) {
    this.footer.addChildElement(t);
  }
  get View() {
    return this.footer;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}
class $_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      type: "w:type",
      id: "w:id"
    });
  }
}
class B_e extends nt {
  constructor() {
    super("w:footnoteRef");
  }
}
class U_e extends Gu {
  constructor() {
    super({
      style: "FootnoteReference"
    }), this.root.push(new B_e());
  }
}
const n5 = {
  SEPERATOR: "separator",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CONTINUATION_SEPERATOR: "continuationSeparator"
};
class Dx extends nt {
  constructor(t) {
    super("w:footnote"), this.root.push(
      new $_e({
        type: t.type,
        id: t.id
      })
    );
    for (let r = 0; r < t.children.length; r++) {
      const n = t.children[r];
      r === 0 && n.addRunToFront(new U_e()), this.root.push(n);
    }
  }
}
class z_e extends nt {
  constructor() {
    super("w:continuationSeparator");
  }
}
class q_e extends Gu {
  constructor() {
    super({}), this.root.push(new z_e());
  }
}
class j_e extends nt {
  constructor() {
    super("w:separator");
  }
}
class H_e extends Gu {
  constructor() {
    super({}), this.root.push(new j_e());
  }
}
class V_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}
class G_e extends nt {
  constructor() {
    super("w:footnotes"), this.root.push(
      new V_e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    const t = new Dx({
      id: -1,
      type: n5.SEPERATOR,
      children: [
        new Ha({
          spacing: {
            after: 0,
            line: 240,
            lineRule: RR.AUTO
          },
          children: [new H_e()]
        })
      ]
    });
    this.root.push(t);
    const r = new Dx({
      id: 0,
      type: n5.CONTINUATION_SEPERATOR,
      children: [
        new Ha({
          spacing: {
            after: 0,
            line: 240,
            lineRule: RR.AUTO
          },
          children: [new q_e()]
        })
      ]
    });
    this.root.push(r);
  }
  createFootNote(t, r) {
    const n = new Dx({
      id: t,
      children: r
    });
    this.root.push(n);
  }
}
class W_e {
  constructor() {
    st(this, "footnotess"), st(this, "relationships"), this.footnotess = new G_e(), this.relationships = new Od();
  }
  get View() {
    return this.footnotess;
  }
  get Relationships() {
    return this.relationships;
  }
}
class K_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      w16cid: "xmlns:w16cid",
      w16se: "xmlns:w16se"
    });
  }
}
let Y_e = class extends fG {
  constructor(t, r) {
    super("w:hdr", r), st(this, "refId"), this.refId = t, r || this.root.push(
      new K_e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
        cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
      })
    );
  }
  get ReferenceId() {
    return this.refId;
  }
  add(t) {
    this.root.push(t);
  }
};
class X_e {
  constructor(t, r, n) {
    st(this, "header"), st(this, "relationships"), this.media = t, this.header = new Y_e(r, n), this.relationships = new Od();
  }
  add(t) {
    return this.header.add(t), this;
  }
  addChildElement(t) {
    this.header.addChildElement(t);
  }
  get View() {
    return this.header;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}
class Z_e {
  constructor() {
    st(this, "map"), this.map = /* @__PURE__ */ new Map();
  }
  addImage(t, r) {
    this.map.set(t, r);
  }
  get Array() {
    return Array.from(this.map.values());
  }
}
const na = {
  DECIMAL: "decimal",
  UPPER_ROMAN: "upperRoman",
  LOWER_ROMAN: "lowerRoman",
  UPPER_LETTER: "upperLetter",
  LOWER_LETTER: "lowerLetter",
  ORDINAL: "ordinal",
  CARDINAL_TEXT: "cardinalText",
  ORDINAL_TEXT: "ordinalText",
  HEX: "hex",
  CHICAGO: "chicago",
  IDEOGRAPH__DIGITAL: "ideographDigital",
  JAPANESE_COUNTING: "japaneseCounting",
  AIUEO: "aiueo",
  IROHA: "iroha",
  DECIMAL_FULL_WIDTH: "decimalFullWidth",
  DECIMAL_HALF_WIDTH: "decimalHalfWidth",
  JAPANESE_LEGAL: "japaneseLegal",
  JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
  DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
  DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
  AIUEO_FULL_WIDTH: "aiueoFullWidth",
  IROHA_FULL_WIDTH: "irohaFullWidth",
  DECIMAL_ZERO: "decimalZero",
  BULLET: "bullet",
  GANADA: "ganada",
  CHOSUNG: "chosung",
  DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
  DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
  DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
  IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
  IDEOGRAPH_TRADITIONAL: "ideographTraditional",
  IDEOGRAPH_ZODIAC: "ideographZodiac",
  IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
  TAIWANESE_COUNTING: "taiwaneseCounting",
  IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
  TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
  TAIWANESE_DIGITAL: "taiwaneseDigital",
  CHINESE_COUNTING: "chineseCounting",
  CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
  CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
  KOREAN_DIGITAL: "koreanDigital",
  KOREAN_COUNTING: "koreanCounting",
  KOREAN_LEGAL: "koreanLegal",
  KOREAN_DIGITAL2: "koreanDigital2",
  VIETNAMESE_COUNTING: "vietnameseCounting",
  RUSSIAN_LOWER: "russianLower",
  RUSSIAN_UPPER: "russianUpper",
  NONE: "none",
  NUMBER_IN_DASH: "numberInDash",
  HEBREW1: "hebrew1",
  HEBREW2: "hebrew2",
  ARABIC_ALPHA: "arabicAlpha",
  ARABIC_ABJAD: "arabicAbjad",
  HINDI_VOWELS: "hindiVowels",
  HINDI_CONSONANTS: "hindiConsonants",
  HINDI_NUMBERS: "hindiNumbers",
  HINDI_COUNTING: "hindiCounting",
  THAI_LETTERS: "thaiLetters",
  THAI_NUMBERS: "thaiNumbers",
  THAI_COUNTING: "thaiCounting",
  BAHT_TEXT: "bahtText",
  DOLLAR_TEXT: "dollarText",
  CUSTOM: "custom"
};
class J_e extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      ilvl: "w:ilvl",
      tentative: "w15:tentative"
    });
  }
}
class Q_e extends nt {
  constructor(t) {
    super("w:numFmt"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class eke extends nt {
  constructor(t) {
    super("w:lvlText"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class tke extends nt {
  constructor(t) {
    super("w:lvlJc"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class rke extends nt {
  constructor(t) {
    super("w:suff"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class nke extends nt {
  constructor() {
    super("w:isLgl");
  }
}
class ike extends nt {
  constructor({
    level: t,
    format: r,
    text: n,
    alignment: a = bi.START,
    start: s = 1,
    style: i,
    suffix: o,
    isLegalNumberingStyle: l
  }) {
    if (super("w:lvl"), st(this, "paragraphProperties"), st(this, "runProperties"), this.root.push(new WN("w:start", Gi(s))), r && this.root.push(new Q_e(r)), o && this.root.push(new rke(o)), l && this.root.push(new nke()), n && this.root.push(new eke(n)), this.root.push(new tke(a)), this.paragraphProperties = new hd(i && i.paragraph), this.runProperties = new Vu(i && i.run), this.root.push(this.paragraphProperties), this.root.push(this.runProperties), t > 9)
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    this.root.push(
      new J_e({
        ilvl: Gi(t),
        tentative: 1
      })
    );
  }
}
class ake extends ike {
  // This is the level that sits under abstractNum. We make a
  // handful of properties required
}
class ske extends nt {
  constructor(t) {
    super("w:multiLevelType"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class oke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      abstractNumId: "w:abstractNumId",
      restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
    });
  }
}
class i5 extends nt {
  constructor(t, r) {
    super("w:abstractNum"), st(this, "id"), this.root.push(
      new oke({
        abstractNumId: Gi(t),
        restartNumberingAfterBreak: 0
      })
    ), this.root.push(new ske("hybridMultilevel")), this.id = t;
    for (const n of r)
      this.root.push(new ake(n));
  }
}
class lke extends nt {
  constructor(t) {
    super("w:abstractNumId"), this.root.push(
      new oi({
        val: t
      })
    );
  }
}
class uke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { numId: "w:numId" });
  }
}
class a5 extends nt {
  constructor(t) {
    if (super("w:num"), st(this, "numId"), st(this, "reference"), st(this, "instance"), this.numId = t.numId, this.reference = t.reference, this.instance = t.instance, this.root.push(
      new uke({
        numId: Gi(t.numId)
      })
    ), this.root.push(new lke(Gi(t.abstractNumId))), t.overrideLevels && t.overrideLevels.length)
      for (const r of t.overrideLevels)
        this.root.push(new dke(r.num, r.start));
  }
}
class cke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { ilvl: "w:ilvl" });
  }
}
class dke extends nt {
  constructor(t, r) {
    super("w:lvlOverride"), this.root.push(new cke({ ilvl: t })), r !== void 0 && this.root.push(new pke(r));
  }
}
class fke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class pke extends nt {
  constructor(t) {
    super("w:startOverride"), this.root.push(new fke({ val: t }));
  }
}
class hke extends nt {
  constructor(t) {
    super("w:numbering"), st(this, "abstractNumberingMap", /* @__PURE__ */ new Map()), st(this, "concreteNumberingMap", /* @__PURE__ */ new Map()), st(this, "referenceConfigMap", /* @__PURE__ */ new Map()), st(this, "abstractNumUniqueNumericId", Bxe()), st(this, "concreteNumUniqueNumericId", Uxe()), this.root.push(
      new _h({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    const r = new i5(this.abstractNumUniqueNumericId(), [
      {
        level: 0,
        format: na.BULLET,
        text: "●",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: Pi(0.5), hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 1,
        format: na.BULLET,
        text: "○",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: Pi(1), hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 2,
        format: na.BULLET,
        text: "■",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 2160, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 3,
        format: na.BULLET,
        text: "●",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 2880, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 4,
        format: na.BULLET,
        text: "○",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 3600, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 5,
        format: na.BULLET,
        text: "■",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 4320, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 6,
        format: na.BULLET,
        text: "●",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 5040, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 7,
        format: na.BULLET,
        text: "●",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 5760, hanging: Pi(0.25) }
          }
        }
      },
      {
        level: 8,
        format: na.BULLET,
        text: "●",
        alignment: bi.LEFT,
        style: {
          paragraph: {
            indent: { left: 6480, hanging: Pi(0.25) }
          }
        }
      }
    ]);
    this.concreteNumberingMap.set(
      "default-bullet-numbering",
      new a5({
        numId: 1,
        abstractNumId: r.id,
        reference: "default-bullet-numbering",
        instance: 0,
        overrideLevels: [
          {
            num: 0,
            start: 1
          }
        ]
      })
    ), this.abstractNumberingMap.set("default-bullet-numbering", r);
    for (const n of t.config)
      this.abstractNumberingMap.set(n.reference, new i5(this.abstractNumUniqueNumericId(), n.levels)), this.referenceConfigMap.set(n.reference, n.levels);
  }
  prepForXml(t) {
    for (const r of this.abstractNumberingMap.values())
      this.root.push(r);
    for (const r of this.concreteNumberingMap.values())
      this.root.push(r);
    return super.prepForXml(t);
  }
  createConcreteNumberingInstance(t, r) {
    const n = this.abstractNumberingMap.get(t);
    if (!n)
      return;
    const a = `${t}-${r}`;
    if (this.concreteNumberingMap.has(a))
      return;
    const s = this.referenceConfigMap.get(t), i = s && s[0].start, o = {
      numId: this.concreteNumUniqueNumericId(),
      abstractNumId: n.id,
      reference: t,
      instance: r,
      overrideLevels: [
        i && Number.isInteger(i) ? {
          num: 0,
          start: i
        } : {
          num: 0,
          start: 1
        }
      ]
    };
    this.concreteNumberingMap.set(a, new a5(o));
  }
  get ConcreteNumbering() {
    return Array.from(this.concreteNumberingMap.values());
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get ReferenceConfig() {
    return Array.from(this.referenceConfigMap.values());
  }
}
class mke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      version: "w:val",
      name: "w:name",
      uri: "w:uri"
    });
  }
}
class gke extends nt {
  constructor(t) {
    super("w:compatSetting"), this.root.push(
      new mke({
        version: t,
        uri: "http://schemas.microsoft.com/office/word",
        name: "compatibilityMode"
      })
    );
  }
}
class bke extends nt {
  constructor(t) {
    super("w:compat"), t.version && this.root.push(new gke(t.version)), t.useSingleBorderforContiguousCells && this.root.push(new Pt("w:useSingleBorderforContiguousCells", t.useSingleBorderforContiguousCells)), t.wordPerfectJustification && this.root.push(new Pt("w:wpJustification", t.wordPerfectJustification)), t.noTabStopForHangingIndent && this.root.push(new Pt("w:noTabHangInd", t.noTabStopForHangingIndent)), t.noLeading && this.root.push(new Pt("w:noLeading", t.noLeading)), t.spaceForUnderline && this.root.push(new Pt("w:spaceForUL", t.spaceForUnderline)), t.noColumnBalance && this.root.push(new Pt("w:noColumnBalance", t.noColumnBalance)), t.balanceSingleByteDoubleByteWidth && this.root.push(new Pt("w:balanceSingleByteDoubleByteWidth", t.balanceSingleByteDoubleByteWidth)), t.noExtraLineSpacing && this.root.push(new Pt("w:noExtraLineSpacing", t.noExtraLineSpacing)), t.doNotLeaveBackslashAlone && this.root.push(new Pt("w:doNotLeaveBackslashAlone", t.doNotLeaveBackslashAlone)), t.underlineTrailingSpaces && this.root.push(new Pt("w:ulTrailSpace", t.underlineTrailingSpaces)), t.doNotExpandShiftReturn && this.root.push(new Pt("w:doNotExpandShiftReturn", t.doNotExpandShiftReturn)), t.spacingInWholePoints && this.root.push(new Pt("w:spacingInWholePoints", t.spacingInWholePoints)), t.lineWrapLikeWord6 && this.root.push(new Pt("w:lineWrapLikeWord6", t.lineWrapLikeWord6)), t.printBodyTextBeforeHeader && this.root.push(new Pt("w:printBodyTextBeforeHeader", t.printBodyTextBeforeHeader)), t.printColorsBlack && this.root.push(new Pt("w:printColBlack", t.printColorsBlack)), t.spaceWidth && this.root.push(new Pt("w:wpSpaceWidth", t.spaceWidth)), t.showBreaksInFrames && this.root.push(new Pt("w:showBreaksInFrames", t.showBreaksInFrames)), t.subFontBySize && this.root.push(new Pt("w:subFontBySize", t.subFontBySize)), t.suppressBottomSpacing && this.root.push(new Pt("w:suppressBottomSpacing", t.suppressBottomSpacing)), t.suppressTopSpacing && this.root.push(new Pt("w:suppressTopSpacing", t.suppressTopSpacing)), t.suppressSpacingAtTopOfPage && this.root.push(new Pt("w:suppressSpacingAtTopOfPage", t.suppressSpacingAtTopOfPage)), t.suppressTopSpacingWP && this.root.push(new Pt("w:suppressTopSpacingWP", t.suppressTopSpacingWP)), t.suppressSpBfAfterPgBrk && this.root.push(new Pt("w:suppressSpBfAfterPgBrk", t.suppressSpBfAfterPgBrk)), t.swapBordersFacingPages && this.root.push(new Pt("w:swapBordersFacingPages", t.swapBordersFacingPages)), t.convertMailMergeEsc && this.root.push(new Pt("w:convMailMergeEsc", t.convertMailMergeEsc)), t.truncateFontHeightsLikeWP6 && this.root.push(new Pt("w:truncateFontHeightsLikeWP6", t.truncateFontHeightsLikeWP6)), t.macWordSmallCaps && this.root.push(new Pt("w:mwSmallCaps", t.macWordSmallCaps)), t.usePrinterMetrics && this.root.push(new Pt("w:usePrinterMetrics", t.usePrinterMetrics)), t.doNotSuppressParagraphBorders && this.root.push(new Pt("w:doNotSuppressParagraphBorders", t.doNotSuppressParagraphBorders)), t.wrapTrailSpaces && this.root.push(new Pt("w:wrapTrailSpaces", t.wrapTrailSpaces)), t.footnoteLayoutLikeWW8 && this.root.push(new Pt("w:footnoteLayoutLikeWW8", t.footnoteLayoutLikeWW8)), t.shapeLayoutLikeWW8 && this.root.push(new Pt("w:shapeLayoutLikeWW8", t.shapeLayoutLikeWW8)), t.alignTablesRowByRow && this.root.push(new Pt("w:alignTablesRowByRow", t.alignTablesRowByRow)), t.forgetLastTabAlignment && this.root.push(new Pt("w:forgetLastTabAlignment", t.forgetLastTabAlignment)), t.adjustLineHeightInTable && this.root.push(new Pt("w:adjustLineHeightInTable", t.adjustLineHeightInTable)), t.autoSpaceLikeWord95 && this.root.push(new Pt("w:autoSpaceLikeWord95", t.autoSpaceLikeWord95)), t.noSpaceRaiseLower && this.root.push(new Pt("w:noSpaceRaiseLower", t.noSpaceRaiseLower)), t.doNotUseHTMLParagraphAutoSpacing && this.root.push(new Pt("w:doNotUseHTMLParagraphAutoSpacing", t.doNotUseHTMLParagraphAutoSpacing)), t.layoutRawTableWidth && this.root.push(new Pt("w:layoutRawTableWidth", t.layoutRawTableWidth)), t.layoutTableRowsApart && this.root.push(new Pt("w:layoutTableRowsApart", t.layoutTableRowsApart)), t.useWord97LineBreakRules && this.root.push(new Pt("w:useWord97LineBreakRules", t.useWord97LineBreakRules)), t.doNotBreakWrappedTables && this.root.push(new Pt("w:doNotBreakWrappedTables", t.doNotBreakWrappedTables)), t.doNotSnapToGridInCell && this.root.push(new Pt("w:doNotSnapToGridInCell", t.doNotSnapToGridInCell)), t.selectFieldWithFirstOrLastCharacter && this.root.push(new Pt("w:selectFldWithFirstOrLastChar", t.selectFieldWithFirstOrLastCharacter)), t.applyBreakingRules && this.root.push(new Pt("w:applyBreakingRules", t.applyBreakingRules)), t.doNotWrapTextWithPunctuation && this.root.push(new Pt("w:doNotWrapTextWithPunct", t.doNotWrapTextWithPunctuation)), t.doNotUseEastAsianBreakRules && this.root.push(new Pt("w:doNotUseEastAsianBreakRules", t.doNotUseEastAsianBreakRules)), t.useWord2002TableStyleRules && this.root.push(new Pt("w:useWord2002TableStyleRules", t.useWord2002TableStyleRules)), t.growAutofit && this.root.push(new Pt("w:growAutofit", t.growAutofit)), t.useFELayout && this.root.push(new Pt("w:useFELayout", t.useFELayout)), t.useNormalStyleForList && this.root.push(new Pt("w:useNormalStyleForList", t.useNormalStyleForList)), t.doNotUseIndentAsNumberingTabStop && this.root.push(new Pt("w:doNotUseIndentAsNumberingTabStop", t.doNotUseIndentAsNumberingTabStop)), t.useAlternateEastAsianLineBreakRules && this.root.push(new Pt("w:useAltKinsokuLineBreakRules", t.useAlternateEastAsianLineBreakRules)), t.allowSpaceOfSameStyleInTable && this.root.push(new Pt("w:allowSpaceOfSameStyleInTable", t.allowSpaceOfSameStyleInTable)), t.doNotSuppressIndentation && this.root.push(new Pt("w:doNotSuppressIndentation", t.doNotSuppressIndentation)), t.doNotAutofitConstrainedTables && this.root.push(new Pt("w:doNotAutofitConstrainedTables", t.doNotAutofitConstrainedTables)), t.autofitToFirstFixedWidthCell && this.root.push(new Pt("w:autofitToFirstFixedWidthCell", t.autofitToFirstFixedWidthCell)), t.underlineTabInNumberingList && this.root.push(new Pt("w:underlineTabInNumList", t.underlineTabInNumberingList)), t.displayHangulFixedWidth && this.root.push(new Pt("w:displayHangulFixedWidth", t.displayHangulFixedWidth)), t.splitPgBreakAndParaMark && this.root.push(new Pt("w:splitPgBreakAndParaMark", t.splitPgBreakAndParaMark)), t.doNotVerticallyAlignCellWithSp && this.root.push(new Pt("w:doNotVertAlignCellWithSp", t.doNotVerticallyAlignCellWithSp)), t.doNotBreakConstrainedForcedTable && this.root.push(new Pt("w:doNotBreakConstrainedForcedTable", t.doNotBreakConstrainedForcedTable)), t.ignoreVerticalAlignmentInTextboxes && this.root.push(new Pt("w:doNotVertAlignInTxbx", t.ignoreVerticalAlignmentInTextboxes)), t.useAnsiKerningPairs && this.root.push(new Pt("w:useAnsiKerningPairs", t.useAnsiKerningPairs)), t.cachedColumnBalance && this.root.push(new Pt("w:cachedColBalance", t.cachedColumnBalance));
  }
}
class yke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}
class vke extends nt {
  constructor(t) {
    var r, n, a, s;
    super("w:settings"), this.root.push(
      new yke({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    ), this.root.push(new Pt("w:displayBackgroundShape", !0)), t.trackRevisions !== void 0 && this.root.push(new Pt("w:trackRevisions", t.trackRevisions)), t.evenAndOddHeaders !== void 0 && this.root.push(new Pt("w:evenAndOddHeaders", t.evenAndOddHeaders)), t.updateFields !== void 0 && this.root.push(new Pt("w:updateFields", t.updateFields)), t.defaultTabStop !== void 0 && this.root.push(new WN("w:defaultTabStop", t.defaultTabStop)), this.root.push(
      new bke(ud(wn({}, (r = t.compatibility) != null ? r : {}), {
        version: (s = (a = (n = t.compatibility) == null ? void 0 : n.version) != null ? a : t.compatibilityModeVersion) != null ? s : 15
      }))
    );
  }
}
class BG extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", { val: "w:val" });
  }
}
class wke extends nt {
  constructor(t) {
    super("w:name"), this.root.push(new BG({ val: t }));
  }
}
class xke extends nt {
  constructor(t) {
    super("w:uiPriority"), this.root.push(new BG({ val: Gi(t) }));
  }
}
class Eke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      type: "w:type",
      styleId: "w:styleId",
      default: "w:default",
      customStyle: "w:customStyle"
    });
  }
}
class UG extends nt {
  constructor(t, r) {
    super("w:style"), this.root.push(new Eke(t)), r.name && this.root.push(new wke(r.name)), r.basedOn && this.root.push(new Ol("w:basedOn", r.basedOn)), r.next && this.root.push(new Ol("w:next", r.next)), r.link && this.root.push(new Ol("w:link", r.link)), r.uiPriority !== void 0 && this.root.push(new xke(r.uiPriority)), r.semiHidden !== void 0 && this.root.push(new Pt("w:semiHidden", r.semiHidden)), r.unhideWhenUsed !== void 0 && this.root.push(new Pt("w:unhideWhenUsed", r.unhideWhenUsed)), r.quickFormat !== void 0 && this.root.push(new Pt("w:qFormat", r.quickFormat));
  }
}
class hy extends UG {
  constructor(t) {
    super({ type: "paragraph", styleId: t.id }, t), st(this, "paragraphProperties"), st(this, "runProperties"), this.paragraphProperties = new hd(t.paragraph), this.runProperties = new Vu(t.run), this.root.push(this.paragraphProperties), this.root.push(this.runProperties);
  }
}
class my extends UG {
  constructor(t) {
    super(
      { type: "character", styleId: t.id },
      wn({
        uiPriority: 99,
        unhideWhenUsed: !0
      }, t)
    ), st(this, "runProperties"), this.runProperties = new Vu(t.run), this.root.push(this.runProperties);
  }
}
class Xl extends hy {
  constructor(t) {
    super(wn({
      basedOn: "Normal",
      next: "Normal",
      quickFormat: !0
    }, t));
  }
}
class Ske extends Xl {
  constructor(t) {
    super(wn({
      id: "Title",
      name: "Title"
    }, t));
  }
}
class _ke extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading1",
      name: "Heading 1"
    }, t));
  }
}
class kke extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading2",
      name: "Heading 2"
    }, t));
  }
}
class Cke extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading3",
      name: "Heading 3"
    }, t));
  }
}
class Ake extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading4",
      name: "Heading 4"
    }, t));
  }
}
class Tke extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading5",
      name: "Heading 5"
    }, t));
  }
}
class Rke extends Xl {
  constructor(t) {
    super(wn({
      id: "Heading6",
      name: "Heading 6"
    }, t));
  }
}
class Ike extends Xl {
  constructor(t) {
    super(wn({
      id: "Strong",
      name: "Strong"
    }, t));
  }
}
class Nke extends hy {
  constructor(t) {
    super(wn({
      id: "ListParagraph",
      name: "List Paragraph",
      basedOn: "Normal",
      quickFormat: !0
    }, t));
  }
}
class Dke extends hy {
  constructor(t) {
    super(wn({
      id: "FootnoteText",
      name: "footnote text",
      link: "FootnoteTextChar",
      basedOn: "Normal",
      uiPriority: 99,
      semiHidden: !0,
      unhideWhenUsed: !0,
      paragraph: {
        spacing: {
          after: 0,
          line: 240,
          lineRule: RR.AUTO
        }
      },
      run: {
        size: 20
      }
    }, t));
  }
}
class Oke extends my {
  constructor(t) {
    super(wn({
      id: "FootnoteReference",
      name: "footnote reference",
      basedOn: "DefaultParagraphFont",
      semiHidden: !0,
      run: {
        superScript: !0
      }
    }, t));
  }
}
class Pke extends my {
  constructor(t) {
    super(wn({
      id: "FootnoteTextChar",
      name: "Footnote Text Char",
      basedOn: "DefaultParagraphFont",
      link: "FootnoteText",
      semiHidden: !0,
      run: {
        size: 20
      }
    }, t));
  }
}
class Lke extends my {
  constructor(t) {
    super(wn({
      id: "Hyperlink",
      name: "Hyperlink",
      basedOn: "DefaultParagraphFont",
      run: {
        color: "0563C1",
        underline: {
          type: gG.SINGLE
        }
      }
    }, t));
  }
}
class NR extends nt {
  constructor(t) {
    if (super("w:styles"), t.initialStyles && this.root.push(t.initialStyles), t.importedStyles)
      for (const r of t.importedStyles)
        this.root.push(r);
    if (t.paragraphStyles)
      for (const r of t.paragraphStyles)
        this.root.push(new hy(r));
    if (t.characterStyles)
      for (const r of t.characterStyles)
        this.root.push(new my(r));
  }
}
class Mke extends nt {
  constructor(t) {
    super("w:pPrDefault"), this.root.push(new hd(t));
  }
}
class Fke extends nt {
  constructor(t) {
    super("w:rPrDefault"), this.root.push(new Vu(t));
  }
}
class $ke extends nt {
  constructor(t) {
    super("w:docDefaults"), st(this, "runPropertiesDefaults"), st(this, "paragraphPropertiesDefaults"), this.runPropertiesDefaults = new Fke(t.run), this.paragraphPropertiesDefaults = new Mke(t.paragraph), this.root.push(this.runPropertiesDefaults), this.root.push(this.paragraphPropertiesDefaults);
  }
}
class Bke {
  /**
   * Creates new Style based on the given styles.
   * Parses the styles and convert them to XmlComponent.
   * Example content from styles.xml:
   * <?xml version="1.0">
   * <w:styles xmlns:mc="some schema" ...>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading1">
   *           <w:name w:val="heading 1"/>
   *           .....
   *   </w:style>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading2">
   *           <w:name w:val="heading 2"/>
   *           .....
   *   </w:style>
   *
   *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>
   *
   * </w:styles>
   *
   * @param externalStyles context from styles.xml
   */
  newInstance(t) {
    const r = dG.xml2js(t, { compact: !1 });
    let n;
    for (const i of r.elements || [])
      i.name === "w:styles" && (n = i);
    if (n === void 0)
      throw new Error("can not find styles element");
    const a = n.elements || [];
    return new NR({
      initialStyles: new txe(n.attributes),
      importedStyles: a.map((i) => HN(i))
    });
  }
}
class s5 {
  newInstance(t = {}) {
    var r;
    return {
      initialStyles: new _h({
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        Ignorable: "w14 w15"
      }),
      importedStyles: [
        new $ke((r = t.document) != null ? r : {}),
        new Ske(wn({
          run: {
            size: 56
          }
        }, t.title)),
        new _ke(wn({
          run: {
            color: "2E74B5",
            size: 32
          }
        }, t.heading1)),
        new kke(wn({
          run: {
            color: "2E74B5",
            size: 26
          }
        }, t.heading2)),
        new Cke(wn({
          run: {
            color: "1F4D78",
            size: 24
          }
        }, t.heading3)),
        new Ake(wn({
          run: {
            color: "2E74B5",
            italics: !0
          }
        }, t.heading4)),
        new Tke(wn({
          run: {
            color: "2E74B5"
          }
        }, t.heading5)),
        new Rke(wn({
          run: {
            color: "1F4D78"
          }
        }, t.heading6)),
        new Ike(wn({
          run: {
            bold: !0
          }
        }, t.strong)),
        new Nke(t.listParagraph || {}),
        new Lke(t.hyperlink || {}),
        new Oke(t.footnoteReference || {}),
        new Dke(t.footnoteText || {}),
        new Pke(t.footnoteTextChar || {})
      ]
    };
  }
}
const Cm = ({ id: e, fontKey: t, subsetted: r }, n) => new Wi({
  name: n,
  attributes: wn({
    id: { key: "r:id", value: e }
  }, t ? { fontKey: { key: "w:fontKey", value: `{${t}}` } } : {}),
  children: [...r ? [new Pt("w:subsetted", r)] : []]
}), Uke = ({
  name: e,
  altName: t,
  panose1: r,
  charset: n,
  family: a,
  notTrueType: s,
  pitch: i,
  sig: o,
  embedRegular: l,
  embedBold: u,
  embedItalic: c,
  embedBoldItalic: d
}) => (
  // http://www.datypic.com/sc/ooxml/e-w_font-1.html
  new Wi({
    name: "w:font",
    attributes: {
      name: { key: "w:name", value: e }
    },
    children: [
      // http://www.datypic.com/sc/ooxml/e-w_altName-1.html
      ...t ? [gf("w:altName", t)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html
      ...r ? [gf("w:panose1", r)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_charset-1.html
      ...n ? [gf("w:charset", n)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_family-1.html
      ...a ? [gf("w:family", a)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html
      ...s ? [new Pt("w:notTrueType", s)] : [],
      ...i ? [gf("w:pitch", i)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_sig-1.html
      ...o ? [
        new Wi({
          name: "w:sig",
          attributes: {
            usb0: { key: "w:usb0", value: o.usb0 },
            usb1: { key: "w:usb1", value: o.usb1 },
            usb2: { key: "w:usb2", value: o.usb2 },
            usb3: { key: "w:usb3", value: o.usb3 },
            csb0: { key: "w:csb0", value: o.csb0 },
            csb1: { key: "w:csb1", value: o.csb1 }
          }
        })
      ] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html
      ...l ? [Cm(l, "w:embedRegular")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html
      ...u ? [Cm(u, "w:embedBold")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html
      ...c ? [Cm(c, "w:embedItalic")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html
      ...d ? [Cm(d, "w:embedBoldItalic")] : []
    ]
  })
), zke = ({
  name: e,
  index: t,
  fontKey: r,
  characterSet: n
}) => Uke({
  name: e,
  sig: {
    usb0: "E0002AFF",
    usb1: "C000247B",
    usb2: "00000009",
    usb3: "00000000",
    csb0: "000001FF",
    csb1: "00000000"
  },
  charset: n,
  family: "auto",
  pitch: "variable",
  embedRegular: {
    fontKey: r,
    id: `rId${t}`
  }
}), qke = (e) => (
  // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html
  // http://www.datypic.com/sc/ooxml/e-w_fonts.html
  new Wi({
    name: "w:fonts",
    attributes: {
      mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
      r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
      w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
      w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
      w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
      w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
      w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
      w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
      w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
      w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
      Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
    },
    children: e.map(
      (t, r) => zke({
        name: t.name,
        index: r + 1,
        fontKey: t.fontKey
      })
    )
  })
);
class jke {
  constructor(t) {
    st(this, "fontTable"), st(this, "relationships"), st(this, "fontOptionsWithKey", []), this.options = t, this.fontOptionsWithKey = t.map((r) => ud(wn({}, r), { fontKey: jxe() })), this.fontTable = qke(this.fontOptionsWithKey), this.relationships = new Od();
    for (let r = 0; r < t.length; r++)
      this.relationships.createRelationship(
        r + 1,
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font",
        `fonts/${t[r].name}.odttf`
      );
  }
  get View() {
    return this.fontTable;
  }
  get Relationships() {
    return this.relationships;
  }
}
class Hke {
  constructor(t) {
    st(this, "currentRelationshipId", 1), st(this, "documentWrapper"), st(this, "headers", []), st(this, "footers", []), st(this, "coreProperties"), st(this, "numbering"), st(this, "media"), st(this, "fileRelationships"), st(this, "footnotesWrapper"), st(this, "settings"), st(this, "contentTypes"), st(this, "customProperties"), st(this, "appProperties"), st(this, "styles"), st(this, "comments"), st(this, "fontWrapper");
    var r, n, a, s, i, o, l, u;
    if (this.coreProperties = new R_e(ud(wn({}, t), {
      creator: (r = t.creator) != null ? r : "Un-named",
      revision: (n = t.revision) != null ? n : 1,
      lastModifiedBy: (a = t.lastModifiedBy) != null ? a : "Un-named"
    })), this.numbering = new hke(t.numbering ? t.numbering : { config: [] }), this.comments = new WEe((s = t.comments) != null ? s : { children: [] }), this.fileRelationships = new Od(), this.customProperties = new P_e((i = t.customProperties) != null ? i : []), this.appProperties = new __e(), this.footnotesWrapper = new W_e(), this.contentTypes = new T_e(), this.documentWrapper = new NG({ background: t.background }), this.settings = new vke({
      compatibilityModeVersion: t.compatabilityModeVersion,
      compatibility: t.compatibility,
      evenAndOddHeaders: !!t.evenAndOddHeaderAndFooters,
      trackRevisions: (o = t.features) == null ? void 0 : o.trackRevisions,
      updateFields: (l = t.features) == null ? void 0 : l.updateFields,
      defaultTabStop: t.defaultTabStop
    }), this.media = new Z_e(), t.externalStyles) {
      const c = new Bke();
      this.styles = c.newInstance(t.externalStyles);
    } else if (t.styles) {
      const d = new s5().newInstance(t.styles.default);
      this.styles = new NR(wn(wn({}, d), t.styles));
    } else {
      const c = new s5();
      this.styles = new NR(c.newInstance());
    }
    this.addDefaultRelationships();
    for (const c of t.sections)
      this.addSection(c);
    if (t.footnotes)
      for (const c in t.footnotes)
        this.footnotesWrapper.View.createFootNote(parseFloat(c), t.footnotes[c].children);
    this.fontWrapper = new jke((u = t.fonts) != null ? u : []);
  }
  addSection({ headers: t = {}, footers: r = {}, children: n, properties: a }) {
    this.documentWrapper.View.Body.addSection(ud(wn({}, a), {
      headerWrapperGroup: {
        default: t.default ? this.createHeader(t.default) : void 0,
        first: t.first ? this.createHeader(t.first) : void 0,
        even: t.even ? this.createHeader(t.even) : void 0
      },
      footerWrapperGroup: {
        default: r.default ? this.createFooter(r.default) : void 0,
        first: r.first ? this.createFooter(r.first) : void 0,
        even: r.even ? this.createFooter(r.even) : void 0
      }
    }));
    for (const s of n)
      this.documentWrapper.View.add(s);
  }
  createHeader(t) {
    const r = new X_e(this.media, this.currentRelationshipId++);
    for (const n of t.options.children)
      r.add(n);
    return this.addHeaderToDocument(r), r;
  }
  createFooter(t) {
    const r = new F_e(this.media, this.currentRelationshipId++);
    for (const n of t.options.children)
      r.add(n);
    return this.addFooterToDocument(r), r;
  }
  addHeaderToDocument(t, r = Xc.DEFAULT) {
    this.headers.push({ header: t, type: r }), this.documentWrapper.Relationships.createRelationship(
      t.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
      `header${this.headers.length}.xml`
    ), this.contentTypes.addHeader(this.headers.length);
  }
  addFooterToDocument(t, r = Xc.DEFAULT) {
    this.footers.push({ footer: t, type: r }), this.documentWrapper.Relationships.createRelationship(
      t.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
      `footer${this.footers.length}.xml`
    ), this.contentTypes.addFooter(this.footers.length);
  }
  addDefaultRelationships() {
    this.fileRelationships.createRelationship(
      1,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      "word/document.xml"
    ), this.fileRelationships.createRelationship(
      2,
      "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      "docProps/core.xml"
    ), this.fileRelationships.createRelationship(
      3,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      "docProps/app.xml"
    ), this.fileRelationships.createRelationship(
      4,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
      "docProps/custom.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      "styles.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
      "numbering.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
      "footnotes.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
      "settings.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      "comments.xml"
    );
  }
  get Document() {
    return this.documentWrapper;
  }
  get Styles() {
    return this.styles;
  }
  get CoreProperties() {
    return this.coreProperties;
  }
  get Numbering() {
    return this.numbering;
  }
  get Media() {
    return this.media;
  }
  get FileRelationships() {
    return this.fileRelationships;
  }
  get Headers() {
    return this.headers.map((t) => t.header);
  }
  get Footers() {
    return this.footers.map((t) => t.footer);
  }
  get ContentTypes() {
    return this.contentTypes;
  }
  get CustomProperties() {
    return this.customProperties;
  }
  get AppProperties() {
    return this.appProperties;
  }
  get FootNotes() {
    return this.footnotesWrapper;
  }
  get Settings() {
    return this.settings;
  }
  get Comments() {
    return this.comments;
  }
  get FontTable() {
    return this.fontWrapper;
  }
}
class Vke extends nt {
  constructor() {
    super("w:sdtContent");
  }
}
class Gke extends nt {
  constructor(t) {
    super("w:sdtPr"), t && this.root.push(new Ol("w:alias", t));
  }
}
class Wke extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      id: "w:id"
    });
  }
}
class Kke extends nt {
  constructor(t) {
    super("w:footnoteReference"), this.root.push(
      new Wke({
        id: t
      })
    );
  }
}
class Yke extends Gu {
  constructor(t) {
    super({ style: "FootnoteReference" }), this.root.push(new Kke(t));
  }
}
class o5 extends er {
  constructor() {
    super(...arguments), st(this, "xmlKeys", {
      val: "w14:val",
      symbolfont: "w14:font"
    });
  }
}
class Ox extends nt {
  constructor(t, r, n) {
    super(t), n ? this.root.push(new o5({ val: rxe(r), symbolfont: n })) : this.root.push(new o5({ val: r }));
  }
}
class Xke extends nt {
  constructor(t) {
    var r, n, a, s, i, o, l, u;
    super("w14:checkbox"), st(this, "DEFAULT_UNCHECKED_SYMBOL", "2610"), st(this, "DEFAULT_CHECKED_SYMBOL", "2612"), st(this, "DEFAULT_FONT", "MS Gothic");
    const c = t?.checked ? "1" : "0";
    let d, p;
    this.root.push(new Ox("w14:checked", c)), d = (r = t?.checkedState) != null && r.value ? (n = t?.checkedState) == null ? void 0 : n.value : this.DEFAULT_CHECKED_SYMBOL, p = (a = t?.checkedState) != null && a.font ? (s = t?.checkedState) == null ? void 0 : s.font : this.DEFAULT_FONT, this.root.push(new Ox("w14:checkedState", d, p)), d = (i = t?.uncheckedState) != null && i.value ? (o = t?.uncheckedState) == null ? void 0 : o.value : this.DEFAULT_UNCHECKED_SYMBOL, p = (l = t?.uncheckedState) != null && l.font ? (u = t?.uncheckedState) == null ? void 0 : u.font : this.DEFAULT_FONT, this.root.push(new Ox("w14:uncheckedState", d, p));
  }
}
class Zke extends nt {
  constructor(t) {
    var r, n, a, s;
    super("w:sdt"), st(this, "DEFAULT_UNCHECKED_SYMBOL", "2610"), st(this, "DEFAULT_CHECKED_SYMBOL", "2612"), st(this, "DEFAULT_FONT", "MS Gothic");
    const i = new Gke(t?.alias);
    i.addChildElement(new Xke(t)), this.root.push(i);
    const o = new Vke(), l = (r = t?.checkedState) == null ? void 0 : r.font, u = (n = t?.checkedState) == null ? void 0 : n.value, c = (a = t?.uncheckedState) == null ? void 0 : a.font, d = (s = t?.uncheckedState) == null ? void 0 : s.value;
    let p, f;
    t?.checked ? (p = l || this.DEFAULT_FONT, f = u || this.DEFAULT_CHECKED_SYMBOL) : (p = c || this.DEFAULT_FONT, f = d || this.DEFAULT_UNCHECKED_SYMBOL);
    const h = new Lxe({
      char: f,
      symbolfont: p
    });
    o.addChildElement(h), this.root.push(o);
  }
}
function Am(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var zG = { exports: {} };
(function(e, t) {
  (function(r) {
    e.exports = r();
  })(function() {
    return function r(n, a, s) {
      function i(u, c) {
        if (!a[u]) {
          if (!n[u]) {
            var d = typeof Am == "function" && Am;
            if (!c && d)
              return d(u, !0);
            if (o)
              return o(u, !0);
            var p = new Error("Cannot find module '" + u + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var f = a[u] = { exports: {} };
          n[u][0].call(f.exports, function(h) {
            var m = n[u][1][h];
            return i(m || h);
          }, f, f.exports, r, n, a, s);
        }
        return a[u].exports;
      }
      for (var o = typeof Am == "function" && Am, l = 0; l < s.length; l++)
        i(s[l]);
      return i;
    }({ 1: [function(r, n, a) {
      var s = r("./utils"), i = r("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      a.encode = function(l) {
        for (var u, c, d, p, f, h, m, y = [], b = 0, v = l.length, x = v, _ = s.getTypeOf(l) !== "string"; b < l.length; )
          x = v - b, d = _ ? (u = l[b++], c = b < v ? l[b++] : 0, b < v ? l[b++] : 0) : (u = l.charCodeAt(b++), c = b < v ? l.charCodeAt(b++) : 0, b < v ? l.charCodeAt(b++) : 0), p = u >> 2, f = (3 & u) << 4 | c >> 4, h = 1 < x ? (15 & c) << 2 | d >> 6 : 64, m = 2 < x ? 63 & d : 64, y.push(o.charAt(p) + o.charAt(f) + o.charAt(h) + o.charAt(m));
        return y.join("");
      }, a.decode = function(l) {
        var u, c, d, p, f, h, m = 0, y = 0, b = "data:";
        if (l.substr(0, b.length) === b)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var v, x = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === o.charAt(64) && x--, l.charAt(l.length - 2) === o.charAt(64) && x--, x % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (v = i.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); m < l.length; )
          u = o.indexOf(l.charAt(m++)) << 2 | (p = o.indexOf(l.charAt(m++))) >> 4, c = (15 & p) << 4 | (f = o.indexOf(l.charAt(m++))) >> 2, d = (3 & f) << 6 | (h = o.indexOf(l.charAt(m++))), v[y++] = u, f !== 64 && (v[y++] = c), h !== 64 && (v[y++] = d);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(r, n, a) {
      var s = r("./external"), i = r("./stream/DataWorker"), o = r("./stream/Crc32Probe"), l = r("./stream/DataLengthProbe");
      function u(c, d, p, f, h) {
        this.compressedSize = c, this.uncompressedSize = d, this.crc32 = p, this.compression = f, this.compressedContent = h;
      }
      u.prototype = { getContentWorker: function() {
        var c = new i(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return c.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), c;
      }, getCompressedWorker: function() {
        return new i(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, u.createWorkerFrom = function(c, d, p) {
        return c.pipe(new o()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, n.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(r, n, a) {
      var s = r("./stream/GenericWorker");
      a.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, a.DEFLATE = r("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(r, n, a) {
      var s = r("./utils"), i = function() {
        for (var o, l = [], u = 0; u < 256; u++) {
          o = u;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          l[u] = o;
        }
        return l;
      }();
      n.exports = function(o, l) {
        return o !== void 0 && o.length ? s.getTypeOf(o) !== "string" ? function(u, c, d, p) {
          var f = i, h = p + d;
          u ^= -1;
          for (var m = p; m < h; m++)
            u = u >>> 8 ^ f[255 & (u ^ c[m])];
          return -1 ^ u;
        }(0 | l, o, o.length, 0) : function(u, c, d, p) {
          var f = i, h = p + d;
          u ^= -1;
          for (var m = p; m < h; m++)
            u = u >>> 8 ^ f[255 & (u ^ c.charCodeAt(m))];
          return -1 ^ u;
        }(0 | l, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(r, n, a) {
      a.base64 = !1, a.binary = !1, a.dir = !1, a.createFolders = !0, a.date = null, a.compression = null, a.compressionOptions = null, a.comment = null, a.unixPermissions = null, a.dosPermissions = null;
    }, {}], 6: [function(r, n, a) {
      var s = null;
      s = typeof Promise < "u" ? Promise : r("lie"), n.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(r, n, a) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", i = r("pako"), o = r("./utils"), l = r("./stream/GenericWorker"), u = s ? "uint8array" : "array";
      function c(d, p) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
      }
      a.magic = "\b\0", o.inherits(c, l), c.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(u, d.data), !1);
      }, c.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, c.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(p) {
          d.push({ data: p, meta: d.meta });
        };
      }, a.compressWorker = function(d) {
        return new c("Deflate", d);
      }, a.uncompressWorker = function() {
        return new c("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(r, n, a) {
      function s(f, h) {
        var m, y = "";
        for (m = 0; m < h; m++)
          y += String.fromCharCode(255 & f), f >>>= 8;
        return y;
      }
      function i(f, h, m, y, b, v) {
        var x, _, E = f.file, w = f.compression, C = v !== u.utf8encode, k = o.transformTo("string", v(E.name)), S = o.transformTo("string", u.utf8encode(E.name)), B = E.comment, U = o.transformTo("string", v(B)), N = o.transformTo("string", u.utf8encode(B)), O = S.length !== E.name.length, I = N.length !== B.length, q = "", ae = "", Q = "", ne = E.dir, le = E.date, W = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        h && !m || (W.crc32 = f.crc32, W.compressedSize = f.compressedSize, W.uncompressedSize = f.uncompressedSize);
        var X = 0;
        h && (X |= 8), C || !O && !I || (X |= 2048);
        var G = 0, P = 0;
        ne && (G |= 16), b === "UNIX" ? (P = 798, G |= function(ye, pe) {
          var $ = ye;
          return ye || ($ = pe ? 16893 : 33204), (65535 & $) << 16;
        }(E.unixPermissions, ne)) : (P = 20, G |= function(ye) {
          return 63 & (ye || 0);
        }(E.dosPermissions)), x = le.getUTCHours(), x <<= 6, x |= le.getUTCMinutes(), x <<= 5, x |= le.getUTCSeconds() / 2, _ = le.getUTCFullYear() - 1980, _ <<= 4, _ |= le.getUTCMonth() + 1, _ <<= 5, _ |= le.getUTCDate(), O && (ae = s(1, 1) + s(c(k), 4) + S, q += "up" + s(ae.length, 2) + ae), I && (Q = s(1, 1) + s(c(U), 4) + N, q += "uc" + s(Q.length, 2) + Q);
        var he = "";
        return he += `
\0`, he += s(X, 2), he += w.magic, he += s(x, 2), he += s(_, 2), he += s(W.crc32, 4), he += s(W.compressedSize, 4), he += s(W.uncompressedSize, 4), he += s(k.length, 2), he += s(q.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + he + k + q, dirRecord: d.CENTRAL_FILE_HEADER + s(P, 2) + he + s(U.length, 2) + "\0\0\0\0" + s(G, 4) + s(y, 4) + k + q + U };
      }
      var o = r("../utils"), l = r("../stream/GenericWorker"), u = r("../utf8"), c = r("../crc32"), d = r("../signature");
      function p(f, h, m, y) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = h, this.zipPlatform = m, this.encodeFileName = y, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(p, l), p.prototype.push = function(f) {
        var h = f.meta.percent || 0, m = this.entriesCount, y = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: m ? (h + 100 * (m - y - 1)) / m : 100 } }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var h = this.streamFiles && !f.file.dir;
        if (h) {
          var m = i(f, h, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var h = this.streamFiles && !f.file.dir, m = i(f, h, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), h)
          this.push({ data: function(y) {
            return d.DATA_DESCRIPTOR + s(y.crc32, 4) + s(y.compressedSize, 4) + s(y.uncompressedSize, 4);
          }(f), meta: { percent: 100 } });
        else
          for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, h = 0; h < this.dirRecords.length; h++)
          this.push({ data: this.dirRecords[h], meta: { percent: 100 } });
        var m = this.bytesWritten - f, y = function(b, v, x, _, E) {
          var w = o.transformTo("string", E(_));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(b, 2) + s(b, 2) + s(v, 4) + s(x, 4) + s(w.length, 2) + w;
        }(this.dirRecords.length, m, f, this.zipComment, this.encodeFileName);
        this.push({ data: y, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var h = this;
        return f.on("data", function(m) {
          h.processChunk(m);
        }), f.on("end", function() {
          h.closedSource(h.previous.streamInfo), h._sources.length ? h.prepareNextSource() : h.end();
        }), f.on("error", function(m) {
          h.error(m);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(f) {
        var h = this._sources;
        if (!l.prototype.error.call(this, f))
          return !1;
        for (var m = 0; m < h.length; m++)
          try {
            h[m].error(f);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, h = 0; h < f.length; h++)
          f[h].lock();
      }, n.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(r, n, a) {
      var s = r("../compressions"), i = r("./ZipFileWorker");
      a.generateWorker = function(o, l, u) {
        var c = new i(l.streamFiles, u, l.platform, l.encodeFileName), d = 0;
        try {
          o.forEach(function(p, f) {
            d++;
            var h = function(v, x) {
              var _ = v || x, E = s[_];
              if (!E)
                throw new Error(_ + " is not a valid compression method !");
              return E;
            }(f.options.compression, l.compression), m = f.options.compressionOptions || l.compressionOptions || {}, y = f.dir, b = f.date;
            f._compressWorker(h, m).withStreamInfo("file", { name: p, dir: y, date: b, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(c);
          }), c.entriesCount = d;
        } catch (p) {
          c.error(p);
        }
        return c;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(r, n, a) {
      function s() {
        if (!(this instanceof s))
          return new s();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var i = new s();
          for (var o in this)
            typeof this[o] != "function" && (i[o] = this[o]);
          return i;
        };
      }
      (s.prototype = r("./object")).loadAsync = r("./load"), s.support = r("./support"), s.defaults = r("./defaults"), s.version = "3.10.1", s.loadAsync = function(i, o) {
        return new s().loadAsync(i, o);
      }, s.external = r("./external"), n.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(r, n, a) {
      var s = r("./utils"), i = r("./external"), o = r("./utf8"), l = r("./zipEntries"), u = r("./stream/Crc32Probe"), c = r("./nodejsUtils");
      function d(p) {
        return new i.Promise(function(f, h) {
          var m = p.decompressed.getContentWorker().pipe(new u());
          m.on("error", function(y) {
            h(y);
          }).on("end", function() {
            m.streamInfo.crc32 !== p.decompressed.crc32 ? h(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      n.exports = function(p, f) {
        var h = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), c.isNode && c.isStream(p) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", p, !0, f.optimizedBinaryString, f.base64).then(function(m) {
          var y = new l(f);
          return y.load(m), y;
        }).then(function(m) {
          var y = [i.Promise.resolve(m)], b = m.files;
          if (f.checkCRC32)
            for (var v = 0; v < b.length; v++)
              y.push(d(b[v]));
          return i.Promise.all(y);
        }).then(function(m) {
          for (var y = m.shift(), b = y.files, v = 0; v < b.length; v++) {
            var x = b[v], _ = x.fileNameStr, E = s.resolve(x.fileNameStr);
            h.file(E, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: f.createFolders }), x.dir || (h.file(E).unsafeOriginalName = _);
          }
          return y.zipComment.length && (h.comment = y.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(r, n, a) {
      var s = r("../utils"), i = r("../stream/GenericWorker");
      function o(l, u) {
        i.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(u);
      }
      s.inherits(o, i), o.prototype._bindStream = function(l) {
        var u = this;
        (this._stream = l).pause(), l.on("data", function(c) {
          u.push({ data: c, meta: { percent: 0 } });
        }).on("error", function(c) {
          u.isPaused ? this.generatedError = c : u.error(c);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, o.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, o.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, n.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(r, n, a) {
      var s = r("readable-stream").Readable;
      function i(o, l, u) {
        s.call(this, l), this._helper = o;
        var c = this;
        o.on("data", function(d, p) {
          c.push(d) || c._helper.pause(), u && u(p);
        }).on("error", function(d) {
          c.emit("error", d);
        }).on("end", function() {
          c.push(null);
        });
      }
      r("../utils").inherits(i, s), i.prototype._read = function() {
        this._helper.resume();
      }, n.exports = i;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(r, n, a) {
      n.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, i) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(s, i);
        if (typeof s == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(s, i);
      }, allocBuffer: function(s) {
        if (Buffer.alloc)
          return Buffer.alloc(s);
        var i = new Buffer(s);
        return i.fill(0), i;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(r, n, a) {
      function s(E, w, C) {
        var k, S = o.getTypeOf(w), B = o.extend(C || {}, c);
        B.date = B.date || /* @__PURE__ */ new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (E = b(E)), B.createFolders && (k = y(E)) && v.call(this, k, !0);
        var U = S === "string" && B.binary === !1 && B.base64 === !1;
        C && C.binary !== void 0 || (B.binary = !U), (w instanceof d && w.uncompressedSize === 0 || B.dir || !w || w.length === 0) && (B.base64 = !1, B.binary = !0, w = "", B.compression = "STORE", S = "string");
        var N = null;
        N = w instanceof d || w instanceof l ? w : h.isNode && h.isStream(w) ? new m(E, w) : o.prepareContent(E, w, B.binary, B.optimizedBinaryString, B.base64);
        var O = new p(E, N, B);
        this.files[E] = O;
      }
      var i = r("./utf8"), o = r("./utils"), l = r("./stream/GenericWorker"), u = r("./stream/StreamHelper"), c = r("./defaults"), d = r("./compressedObject"), p = r("./zipObject"), f = r("./generate"), h = r("./nodejsUtils"), m = r("./nodejs/NodejsStreamInputAdapter"), y = function(E) {
        E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
        var w = E.lastIndexOf("/");
        return 0 < w ? E.substring(0, w) : "";
      }, b = function(E) {
        return E.slice(-1) !== "/" && (E += "/"), E;
      }, v = function(E, w) {
        return w = w !== void 0 ? w : c.createFolders, E = b(E), this.files[E] || s.call(this, E, null, { dir: !0, createFolders: w }), this.files[E];
      };
      function x(E) {
        return Object.prototype.toString.call(E) === "[object RegExp]";
      }
      var _ = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(E) {
        var w, C, k;
        for (w in this.files)
          k = this.files[w], (C = w.slice(this.root.length, w.length)) && w.slice(0, this.root.length) === this.root && E(C, k);
      }, filter: function(E) {
        var w = [];
        return this.forEach(function(C, k) {
          E(C, k) && w.push(k);
        }), w;
      }, file: function(E, w, C) {
        if (arguments.length !== 1)
          return E = this.root + E, s.call(this, E, w, C), this;
        if (x(E)) {
          var k = E;
          return this.filter(function(B, U) {
            return !U.dir && k.test(B);
          });
        }
        var S = this.files[this.root + E];
        return S && !S.dir ? S : null;
      }, folder: function(E) {
        if (!E)
          return this;
        if (x(E))
          return this.filter(function(S, B) {
            return B.dir && E.test(S);
          });
        var w = this.root + E, C = v.call(this, w), k = this.clone();
        return k.root = C.name, k;
      }, remove: function(E) {
        E = this.root + E;
        var w = this.files[E];
        if (w || (E.slice(-1) !== "/" && (E += "/"), w = this.files[E]), w && !w.dir)
          delete this.files[E];
        else
          for (var C = this.filter(function(S, B) {
            return B.name.slice(0, E.length) === E;
          }), k = 0; k < C.length; k++)
            delete this.files[C[k].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(E) {
        var w, C = {};
        try {
          if ((C = o.extend(E || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = C.type.toLowerCase(), C.compression = C.compression.toUpperCase(), C.type === "binarystring" && (C.type = "string"), !C.type)
            throw new Error("No output type specified.");
          o.checkSupport(C.type), C.platform !== "darwin" && C.platform !== "freebsd" && C.platform !== "linux" && C.platform !== "sunos" || (C.platform = "UNIX"), C.platform === "win32" && (C.platform = "DOS");
          var k = C.comment || this.comment || "";
          w = f.generateWorker(this, C, k);
        } catch (S) {
          (w = new l("error")).error(S);
        }
        return new u(w, C.type || "string", C.mimeType);
      }, generateAsync: function(E, w) {
        return this.generateInternalStream(E).accumulate(w);
      }, generateNodeStream: function(E, w) {
        return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(w);
      } };
      n.exports = _;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(r, n, a) {
      n.exports = r("stream");
    }, { stream: void 0 }], 17: [function(r, n, a) {
      var s = r("./DataReader");
      function i(o) {
        s.call(this, o);
        for (var l = 0; l < this.data.length; l++)
          o[l] = 255 & o[l];
      }
      r("../utils").inherits(i, s), i.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, i.prototype.lastIndexOfSignature = function(o) {
        for (var l = o.charCodeAt(0), u = o.charCodeAt(1), c = o.charCodeAt(2), d = o.charCodeAt(3), p = this.length - 4; 0 <= p; --p)
          if (this.data[p] === l && this.data[p + 1] === u && this.data[p + 2] === c && this.data[p + 3] === d)
            return p - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(o) {
        var l = o.charCodeAt(0), u = o.charCodeAt(1), c = o.charCodeAt(2), d = o.charCodeAt(3), p = this.readData(4);
        return l === p[0] && u === p[1] && c === p[2] && d === p[3];
      }, i.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, l;
      }, n.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(r, n, a) {
      var s = r("../utils");
      function i(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var l, u = 0;
        for (this.checkOffset(o), l = this.index + o - 1; l >= this.index; l--)
          u = (u << 8) + this.byteAt(l);
        return this.index += o, u;
      }, readString: function(o) {
        return s.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, n.exports = i;
    }, { "../utils": 32 }], 19: [function(r, n, a) {
      var s = r("./Uint8ArrayReader");
      function i(o) {
        s.call(this, o);
      }
      r("../utils").inherits(i, s), i.prototype.readData = function(o) {
        this.checkOffset(o);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, l;
      }, n.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(r, n, a) {
      var s = r("./DataReader");
      function i(o) {
        s.call(this, o);
      }
      r("../utils").inherits(i, s), i.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, i.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, i.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, i.prototype.readData = function(o) {
        this.checkOffset(o);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, l;
      }, n.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(r, n, a) {
      var s = r("./ArrayReader");
      function i(o) {
        s.call(this, o);
      }
      r("../utils").inherits(i, s), i.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, l;
      }, n.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(r, n, a) {
      var s = r("../utils"), i = r("../support"), o = r("./ArrayReader"), l = r("./StringReader"), u = r("./NodeBufferReader"), c = r("./Uint8ArrayReader");
      n.exports = function(d) {
        var p = s.getTypeOf(d);
        return s.checkSupport(p), p !== "string" || i.uint8array ? p === "nodebuffer" ? new u(d) : i.uint8array ? new c(s.transformTo("uint8array", d)) : new o(s.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(r, n, a) {
      a.LOCAL_FILE_HEADER = "PK", a.CENTRAL_FILE_HEADER = "PK", a.CENTRAL_DIRECTORY_END = "PK", a.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", a.ZIP64_CENTRAL_DIRECTORY_END = "PK", a.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(r, n, a) {
      var s = r("./GenericWorker"), i = r("../utils");
      function o(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      i.inherits(o, s), o.prototype.processChunk = function(l) {
        this.push({ data: i.transformTo(this.destType, l.data), meta: l.meta });
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(r, n, a) {
      var s = r("./GenericWorker"), i = r("../crc32");
      function o() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      r("../utils").inherits(o, s), o.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = i(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, n.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(r, n, a) {
      var s = r("../utils"), i = r("./GenericWorker");
      function o(l) {
        i.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(o, i), o.prototype.processChunk = function(l) {
        if (l) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + l.data.length;
        }
        i.prototype.processChunk.call(this, l);
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(r, n, a) {
      var s = r("../utils"), i = r("./GenericWorker");
      function o(l) {
        i.call(this, "DataWorker");
        var u = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(c) {
          u.dataIsReady = !0, u.data = c, u.max = c && c.length || 0, u.type = s.getTypeOf(c), u.isPaused || u._tickAndRepeat();
        }, function(c) {
          u.error(c);
        });
      }
      s.inherits(o, i), o.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var l = null, u = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, u);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, u);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, u);
        }
        return this.index = u, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(r, n, a) {
      function s(i) {
        this.name = i || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(i) {
        this.emit("data", i);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (i) {
          this.emit("error", i);
        }
        return !0;
      }, error: function(i) {
        return !this.isFinished && (this.isPaused ? this.generatedError = i : (this.isFinished = !0, this.emit("error", i), this.previous && this.previous.error(i), this.cleanUp()), !0);
      }, on: function(i, o) {
        return this._listeners[i].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(i, o) {
        if (this._listeners[i])
          for (var l = 0; l < this._listeners[i].length; l++)
            this._listeners[i][l].call(this, o);
      }, pipe: function(i) {
        return i.registerPrevious(this);
      }, registerPrevious: function(i) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = i.streamInfo, this.mergeStreamInfo(), this.previous = i;
        var o = this;
        return i.on("data", function(l) {
          o.processChunk(l);
        }), i.on("end", function() {
          o.end();
        }), i.on("error", function(l) {
          o.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var i = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), i = !0), this.previous && this.previous.resume(), !i;
      }, flush: function() {
      }, processChunk: function(i) {
        this.push(i);
      }, withStreamInfo: function(i, o) {
        return this.extraStreamInfo[i] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var i in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, i) && (this.streamInfo[i] = this.extraStreamInfo[i]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var i = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + i : i;
      } }, n.exports = s;
    }, {}], 29: [function(r, n, a) {
      var s = r("../utils"), i = r("./ConvertWorker"), o = r("./GenericWorker"), l = r("../base64"), u = r("../support"), c = r("../external"), d = null;
      if (u.nodestream)
        try {
          d = r("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function p(h, m) {
        return new c.Promise(function(y, b) {
          var v = [], x = h._internalType, _ = h._outputType, E = h._mimeType;
          h.on("data", function(w, C) {
            v.push(w), m && m(C);
          }).on("error", function(w) {
            v = [], b(w);
          }).on("end", function() {
            try {
              var w = function(C, k, S) {
                switch (C) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", k), S);
                  case "base64":
                    return l.encode(k);
                  default:
                    return s.transformTo(C, k);
                }
              }(_, function(C, k) {
                var S, B = 0, U = null, N = 0;
                for (S = 0; S < k.length; S++)
                  N += k[S].length;
                switch (C) {
                  case "string":
                    return k.join("");
                  case "array":
                    return Array.prototype.concat.apply([], k);
                  case "uint8array":
                    for (U = new Uint8Array(N), S = 0; S < k.length; S++)
                      U.set(k[S], B), B += k[S].length;
                    return U;
                  case "nodebuffer":
                    return Buffer.concat(k);
                  default:
                    throw new Error("concat : unsupported type '" + C + "'");
                }
              }(x, v), E);
              y(w);
            } catch (C) {
              b(C);
            }
            v = [];
          }).resume();
        });
      }
      function f(h, m, y) {
        var b = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
        }
        try {
          this._internalType = b, this._outputType = m, this._mimeType = y, s.checkSupport(b), this._worker = h.pipe(new i(b)), h.lock();
        } catch (v) {
          this._worker = new o("error"), this._worker.error(v);
        }
      }
      f.prototype = { accumulate: function(h) {
        return p(this, h);
      }, on: function(h, m) {
        var y = this;
        return h === "data" ? this._worker.on(h, function(b) {
          m.call(y, b.data, b.meta);
        }) : this._worker.on(h, function() {
          s.delay(m, arguments, y);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(h) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, h);
      } }, n.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(r, n, a) {
      if (a.base64 = !0, a.array = !0, a.string = !0, a.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", a.nodebuffer = typeof Buffer < "u", a.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        a.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          a.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(s), a.blob = i.getBlob("application/zip").size === 0;
          } catch {
            a.blob = !1;
          }
        }
      }
      try {
        a.nodestream = !!r("readable-stream").Readable;
      } catch {
        a.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(r, n, a) {
      for (var s = r("./utils"), i = r("./support"), o = r("./nodejsUtils"), l = r("./stream/GenericWorker"), u = new Array(256), c = 0; c < 256; c++)
        u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      u[254] = u[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      a.utf8encode = function(f) {
        return i.nodebuffer ? o.newBufferFrom(f, "utf-8") : function(h) {
          var m, y, b, v, x, _ = h.length, E = 0;
          for (v = 0; v < _; v++)
            (64512 & (y = h.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (b = h.charCodeAt(v + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), v++), E += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
          for (m = i.uint8array ? new Uint8Array(E) : new Array(E), v = x = 0; x < E; v++)
            (64512 & (y = h.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (b = h.charCodeAt(v + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), v++), y < 128 ? m[x++] = y : (y < 2048 ? m[x++] = 192 | y >>> 6 : (y < 65536 ? m[x++] = 224 | y >>> 12 : (m[x++] = 240 | y >>> 18, m[x++] = 128 | y >>> 12 & 63), m[x++] = 128 | y >>> 6 & 63), m[x++] = 128 | 63 & y);
          return m;
        }(f);
      }, a.utf8decode = function(f) {
        return i.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(h) {
          var m, y, b, v, x = h.length, _ = new Array(2 * x);
          for (m = y = 0; m < x; )
            if ((b = h[m++]) < 128)
              _[y++] = b;
            else if (4 < (v = u[b]))
              _[y++] = 65533, m += v - 1;
            else {
              for (b &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && m < x; )
                b = b << 6 | 63 & h[m++], v--;
              1 < v ? _[y++] = 65533 : b < 65536 ? _[y++] = b : (b -= 65536, _[y++] = 55296 | b >> 10 & 1023, _[y++] = 56320 | 1023 & b);
            }
          return _.length !== y && (_.subarray ? _ = _.subarray(0, y) : _.length = y), s.applyFromCharCode(_);
        }(f = s.transformTo(i.uint8array ? "uint8array" : "array", f));
      }, s.inherits(d, l), d.prototype.processChunk = function(f) {
        var h = s.transformTo(i.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (i.uint8array) {
            var m = h;
            (h = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), h.set(m, this.leftOver.length);
          } else
            h = this.leftOver.concat(h);
          this.leftOver = null;
        }
        var y = function(v, x) {
          var _;
          for ((x = x || v.length) > v.length && (x = v.length), _ = x - 1; 0 <= _ && (192 & v[_]) == 128; )
            _--;
          return _ < 0 || _ === 0 ? x : _ + u[v[_]] > x ? _ : x;
        }(h), b = h;
        y !== h.length && (i.uint8array ? (b = h.subarray(0, y), this.leftOver = h.subarray(y, h.length)) : (b = h.slice(0, y), this.leftOver = h.slice(y, h.length))), this.push({ data: a.utf8decode(b), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: a.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, a.Utf8DecodeWorker = d, s.inherits(p, l), p.prototype.processChunk = function(f) {
        this.push({ data: a.utf8encode(f.data), meta: f.meta });
      }, a.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(r, n, a) {
      var s = r("./support"), i = r("./base64"), o = r("./nodejsUtils"), l = r("./external");
      function u(m) {
        return m;
      }
      function c(m, y) {
        for (var b = 0; b < m.length; ++b)
          y[b] = 255 & m.charCodeAt(b);
        return y;
      }
      r("setimmediate"), a.newBlob = function(m, y) {
        a.checkSupport("blob");
        try {
          return new Blob([m], { type: y });
        } catch {
          try {
            var b = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return b.append(m), b.getBlob(y);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(m, y, b) {
        var v = [], x = 0, _ = m.length;
        if (_ <= b)
          return String.fromCharCode.apply(null, m);
        for (; x < _; )
          y === "array" || y === "nodebuffer" ? v.push(String.fromCharCode.apply(null, m.slice(x, Math.min(x + b, _)))) : v.push(String.fromCharCode.apply(null, m.subarray(x, Math.min(x + b, _)))), x += b;
        return v.join("");
      }, stringifyByChar: function(m) {
        for (var y = "", b = 0; b < m.length; b++)
          y += String.fromCharCode(m[b]);
        return y;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(m) {
        var y = 65536, b = a.getTypeOf(m), v = !0;
        if (b === "uint8array" ? v = d.applyCanBeUsed.uint8array : b === "nodebuffer" && (v = d.applyCanBeUsed.nodebuffer), v)
          for (; 1 < y; )
            try {
              return d.stringifyByChunk(m, b, y);
            } catch {
              y = Math.floor(y / 2);
            }
        return d.stringifyByChar(m);
      }
      function f(m, y) {
        for (var b = 0; b < m.length; b++)
          y[b] = m[b];
        return y;
      }
      a.applyFromCharCode = p;
      var h = {};
      h.string = { string: u, array: function(m) {
        return c(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return h.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return c(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return c(m, o.allocBuffer(m.length));
      } }, h.array = { string: p, array: u, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, h.arraybuffer = { string: function(m) {
        return p(new Uint8Array(m));
      }, array: function(m) {
        return f(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: u, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(new Uint8Array(m));
      } }, h.uint8array = { string: p, array: function(m) {
        return f(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: u, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, h.nodebuffer = { string: p, array: function(m) {
        return f(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return h.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return f(m, new Uint8Array(m.length));
      }, nodebuffer: u }, a.transformTo = function(m, y) {
        if (y = y || "", !m)
          return y;
        a.checkSupport(m);
        var b = a.getTypeOf(y);
        return h[b][m](y);
      }, a.resolve = function(m) {
        for (var y = m.split("/"), b = [], v = 0; v < y.length; v++) {
          var x = y[v];
          x === "." || x === "" && v !== 0 && v !== y.length - 1 || (x === ".." ? b.pop() : b.push(x));
        }
        return b.join("/");
      }, a.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : s.nodebuffer && o.isBuffer(m) ? "nodebuffer" : s.uint8array && m instanceof Uint8Array ? "uint8array" : s.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(m) {
        if (!s[m.toLowerCase()])
          throw new Error(m + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(m) {
        var y, b, v = "";
        for (b = 0; b < (m || "").length; b++)
          v += "\\x" + ((y = m.charCodeAt(b)) < 16 ? "0" : "") + y.toString(16).toUpperCase();
        return v;
      }, a.delay = function(m, y, b) {
        setImmediate(function() {
          m.apply(b || null, y || []);
        });
      }, a.inherits = function(m, y) {
        function b() {
        }
        b.prototype = y.prototype, m.prototype = new b();
      }, a.extend = function() {
        var m, y, b = {};
        for (m = 0; m < arguments.length; m++)
          for (y in arguments[m])
            Object.prototype.hasOwnProperty.call(arguments[m], y) && b[y] === void 0 && (b[y] = arguments[m][y]);
        return b;
      }, a.prepareContent = function(m, y, b, v, x) {
        return l.Promise.resolve(y).then(function(_) {
          return s.blob && (_ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(_)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(E, w) {
            var C = new FileReader();
            C.onload = function(k) {
              E(k.target.result);
            }, C.onerror = function(k) {
              w(k.target.error);
            }, C.readAsArrayBuffer(_);
          }) : _;
        }).then(function(_) {
          var E = a.getTypeOf(_);
          return E ? (E === "arraybuffer" ? _ = a.transformTo("uint8array", _) : E === "string" && (x ? _ = i.decode(_) : b && v !== !0 && (_ = function(w) {
            return c(w, s.uint8array ? new Uint8Array(w.length) : new Array(w.length));
          }(_))), _) : l.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(r, n, a) {
      var s = r("./reader/readerFor"), i = r("./utils"), o = r("./signature"), l = r("./zipEntry"), u = r("./support");
      function c(d) {
        this.files = [], this.loadOptions = d;
      }
      c.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(p) + ", expected " + i.pretty(d) + ")");
        }
      }, isSignature: function(d, p) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var h = this.reader.readString(4) === p;
        return this.reader.setIndex(f), h;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), p = u.uint8array ? "uint8array" : "array", f = i.transformTo(p, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, p, f, h = this.zip64EndOfCentralSize - 44; 0 < h; )
          d = this.reader.readInt(2), p = this.reader.readInt(4), f = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, p;
        for (d = 0; d < this.files.length; d++)
          p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); )
          (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (d < 0)
          throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var p = d;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var h = p - f;
        if (0 < h)
          this.isSignature(p, o.CENTRAL_FILE_HEADER) || (this.reader.zero = h);
        else if (h < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(h) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = s(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, n.exports = c;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(r, n, a) {
      var s = r("./reader/readerFor"), i = r("./utils"), o = r("./compressedObject"), l = r("./crc32"), u = r("./utf8"), c = r("./compressions"), d = r("./support");
      function p(f, h) {
        this.options = f, this.loadOptions = h;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var h, m;
        if (f.skip(22), this.fileNameLength = f.readInt(2), m = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((h = function(y) {
          for (var b in c)
            if (Object.prototype.hasOwnProperty.call(c, b) && c[b].magic === y)
              return c[b];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + i.pretty(this.compressionMethod) + " unknown (inner file : " + i.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, h, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var h = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        f.skip(h), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === i.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === i.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === i.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === i.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var h, m, y, b = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < b; )
          h = f.readInt(2), m = f.readInt(2), y = f.readData(m), this.extraFields[h] = { id: h, length: m, value: y };
        f.setIndex(b);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
        else {
          var h = this.findExtraFieldUnicodePath();
          if (h !== null)
            this.fileNameStr = h;
          else {
            var m = i.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var y = this.findExtraFieldUnicodeComment();
          if (y !== null)
            this.fileCommentStr = y;
          else {
            var b = i.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(b);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var h = s(f.value);
          return h.readInt(1) !== 1 || l(this.fileName) !== h.readInt(4) ? null : u.utf8decode(h.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var h = s(f.value);
          return h.readInt(1) !== 1 || l(this.fileComment) !== h.readInt(4) ? null : u.utf8decode(h.readData(f.length - 5));
        }
        return null;
      } }, n.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(r, n, a) {
      function s(h, m, y) {
        this.name = h, this.dir = y.dir, this.date = y.date, this.comment = y.comment, this.unixPermissions = y.unixPermissions, this.dosPermissions = y.dosPermissions, this._data = m, this._dataBinary = y.binary, this.options = { compression: y.compression, compressionOptions: y.compressionOptions };
      }
      var i = r("./stream/StreamHelper"), o = r("./stream/DataWorker"), l = r("./utf8"), u = r("./compressedObject"), c = r("./stream/GenericWorker");
      s.prototype = { internalStream: function(h) {
        var m = null, y = "string";
        try {
          if (!h)
            throw new Error("No output type specified.");
          var b = (y = h.toLowerCase()) === "string" || y === "text";
          y !== "binarystring" && y !== "text" || (y = "string"), m = this._decompressWorker();
          var v = !this._dataBinary;
          v && !b && (m = m.pipe(new l.Utf8EncodeWorker())), !v && b && (m = m.pipe(new l.Utf8DecodeWorker()));
        } catch (x) {
          (m = new c("error")).error(x);
        }
        return new i(m, y, "");
      }, async: function(h, m) {
        return this.internalStream(h).accumulate(m);
      }, nodeStream: function(h, m) {
        return this.internalStream(h || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(h, m) {
        if (this._data instanceof u && this._data.compression.magic === h.magic)
          return this._data.getCompressedWorker();
        var y = this._decompressWorker();
        return this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())), u.createWorkerFrom(y, h, m);
      }, _decompressWorker: function() {
        return this._data instanceof u ? this._data.getContentWorker() : this._data instanceof c ? this._data : new o(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++)
        s.prototype[d[f]] = p;
      n.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(r, n, a) {
      (function(s) {
        var i, o, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var u = 0, c = new l(h), d = s.document.createTextNode("");
          c.observe(d, { characterData: !0 }), i = function() {
            d.data = u = ++u % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0)
          i = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
            var m = s.document.createElement("script");
            m.onreadystatechange = function() {
              h(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, s.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(h, 0);
          };
        else {
          var p = new s.MessageChannel();
          p.port1.onmessage = h, i = function() {
            p.port2.postMessage(0);
          };
        }
        var f = [];
        function h() {
          var m, y;
          o = !0;
          for (var b = f.length; b; ) {
            for (y = f, f = [], m = -1; ++m < b; )
              y[m]();
            b = f.length;
          }
          o = !1;
        }
        n.exports = function(m) {
          f.push(m) !== 1 || o || i();
        };
      }).call(this, typeof no < "u" ? no : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(r, n, a) {
      var s = r("immediate");
      function i() {
      }
      var o = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      function d(b) {
        if (typeof b != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, b !== i && m(this, b);
      }
      function p(b, v, x) {
        this.promise = b, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function f(b, v, x) {
        s(function() {
          var _;
          try {
            _ = v(x);
          } catch (E) {
            return o.reject(b, E);
          }
          _ === b ? o.reject(b, new TypeError("Cannot resolve promise with itself")) : o.resolve(b, _);
        });
      }
      function h(b) {
        var v = b && b.then;
        if (b && (typeof b == "object" || typeof b == "function") && typeof v == "function")
          return function() {
            v.apply(b, arguments);
          };
      }
      function m(b, v) {
        var x = !1;
        function _(C) {
          x || (x = !0, o.reject(b, C));
        }
        function E(C) {
          x || (x = !0, o.resolve(b, C));
        }
        var w = y(function() {
          v(E, _);
        });
        w.status === "error" && _(w.value);
      }
      function y(b, v) {
        var x = {};
        try {
          x.value = b(v), x.status = "success";
        } catch (_) {
          x.status = "error", x.value = _;
        }
        return x;
      }
      (n.exports = d).prototype.finally = function(b) {
        if (typeof b != "function")
          return this;
        var v = this.constructor;
        return this.then(function(x) {
          return v.resolve(b()).then(function() {
            return x;
          });
        }, function(x) {
          return v.resolve(b()).then(function() {
            throw x;
          });
        });
      }, d.prototype.catch = function(b) {
        return this.then(null, b);
      }, d.prototype.then = function(b, v) {
        if (typeof b != "function" && this.state === u || typeof v != "function" && this.state === l)
          return this;
        var x = new this.constructor(i);
        return this.state !== c ? f(x, this.state === u ? b : v, this.outcome) : this.queue.push(new p(x, b, v)), x;
      }, p.prototype.callFulfilled = function(b) {
        o.resolve(this.promise, b);
      }, p.prototype.otherCallFulfilled = function(b) {
        f(this.promise, this.onFulfilled, b);
      }, p.prototype.callRejected = function(b) {
        o.reject(this.promise, b);
      }, p.prototype.otherCallRejected = function(b) {
        f(this.promise, this.onRejected, b);
      }, o.resolve = function(b, v) {
        var x = y(h, v);
        if (x.status === "error")
          return o.reject(b, x.value);
        var _ = x.value;
        if (_)
          m(b, _);
        else {
          b.state = u, b.outcome = v;
          for (var E = -1, w = b.queue.length; ++E < w; )
            b.queue[E].callFulfilled(v);
        }
        return b;
      }, o.reject = function(b, v) {
        b.state = l, b.outcome = v;
        for (var x = -1, _ = b.queue.length; ++x < _; )
          b.queue[x].callRejected(v);
        return b;
      }, d.resolve = function(b) {
        return b instanceof this ? b : o.resolve(new this(i), b);
      }, d.reject = function(b) {
        var v = new this(i);
        return o.reject(v, b);
      }, d.all = function(b) {
        var v = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = b.length, _ = !1;
        if (!x)
          return this.resolve([]);
        for (var E = new Array(x), w = 0, C = -1, k = new this(i); ++C < x; )
          S(b[C], C);
        return k;
        function S(B, U) {
          v.resolve(B).then(function(N) {
            E[U] = N, ++w !== x || _ || (_ = !0, o.resolve(k, E));
          }, function(N) {
            _ || (_ = !0, o.reject(k, N));
          });
        }
      }, d.race = function(b) {
        var v = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = b.length, _ = !1;
        if (!x)
          return this.resolve([]);
        for (var E = -1, w = new this(i); ++E < x; )
          C = b[E], v.resolve(C).then(function(k) {
            _ || (_ = !0, o.resolve(w, k));
          }, function(k) {
            _ || (_ = !0, o.reject(w, k));
          });
        var C;
        return w;
      };
    }, { immediate: 36 }], 38: [function(r, n, a) {
      var s = {};
      (0, r("./lib/utils/common").assign)(s, r("./lib/deflate"), r("./lib/inflate"), r("./lib/zlib/constants")), n.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(r, n, a) {
      var s = r("./zlib/deflate"), i = r("./utils/common"), o = r("./utils/strings"), l = r("./zlib/messages"), u = r("./zlib/zstream"), c = Object.prototype.toString, d = 0, p = -1, f = 0, h = 8;
      function m(b) {
        if (!(this instanceof m))
          return new m(b);
        this.options = i.assign({ level: p, method: h, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, b || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var x = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (x !== d)
          throw new Error(l[x]);
        if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var _;
          if (_ = typeof v.dictionary == "string" ? o.string2buf(v.dictionary) : c.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (x = s.deflateSetDictionary(this.strm, _)) !== d)
            throw new Error(l[x]);
          this._dict_set = !0;
        }
      }
      function y(b, v) {
        var x = new m(v);
        if (x.push(b, !0), x.err)
          throw x.msg || l[x.err];
        return x.result;
      }
      m.prototype.push = function(b, v) {
        var x, _, E = this.strm, w = this.options.chunkSize;
        if (this.ended)
          return !1;
        _ = v === ~~v ? v : v === !0 ? 4 : 0, typeof b == "string" ? E.input = o.string2buf(b) : c.call(b) === "[object ArrayBuffer]" ? E.input = new Uint8Array(b) : E.input = b, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new i.Buf8(w), E.next_out = 0, E.avail_out = w), (x = s.deflate(E, _)) !== 1 && x !== d)
            return this.onEnd(x), !(this.ended = !0);
          E.avail_out !== 0 && (E.avail_in !== 0 || _ !== 4 && _ !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(i.shrinkBuf(E.output, E.next_out))) : this.onData(i.shrinkBuf(E.output, E.next_out)));
        } while ((0 < E.avail_in || E.avail_out === 0) && x !== 1);
        return _ === 4 ? (x = s.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === d) : _ !== 2 || (this.onEnd(d), !(E.avail_out = 0));
      }, m.prototype.onData = function(b) {
        this.chunks.push(b);
      }, m.prototype.onEnd = function(b) {
        b === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, a.Deflate = m, a.deflate = y, a.deflateRaw = function(b, v) {
        return (v = v || {}).raw = !0, y(b, v);
      }, a.gzip = function(b, v) {
        return (v = v || {}).gzip = !0, y(b, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(r, n, a) {
      var s = r("./zlib/inflate"), i = r("./utils/common"), o = r("./utils/strings"), l = r("./zlib/constants"), u = r("./zlib/messages"), c = r("./zlib/zstream"), d = r("./zlib/gzheader"), p = Object.prototype.toString;
      function f(m) {
        if (!(this instanceof f))
          return new f(m);
        this.options = i.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var y = this.options;
        y.raw && 0 <= y.windowBits && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), !(0 <= y.windowBits && y.windowBits < 16) || m && m.windowBits || (y.windowBits += 32), 15 < y.windowBits && y.windowBits < 48 && !(15 & y.windowBits) && (y.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var b = s.inflateInit2(this.strm, y.windowBits);
        if (b !== l.Z_OK)
          throw new Error(u[b]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      function h(m, y) {
        var b = new f(y);
        if (b.push(m, !0), b.err)
          throw b.msg || u[b.err];
        return b.result;
      }
      f.prototype.push = function(m, y) {
        var b, v, x, _, E, w, C = this.strm, k = this.options.chunkSize, S = this.options.dictionary, B = !1;
        if (this.ended)
          return !1;
        v = y === ~~y ? y : y === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof m == "string" ? C.input = o.binstring2buf(m) : p.call(m) === "[object ArrayBuffer]" ? C.input = new Uint8Array(m) : C.input = m, C.next_in = 0, C.avail_in = C.input.length;
        do {
          if (C.avail_out === 0 && (C.output = new i.Buf8(k), C.next_out = 0, C.avail_out = k), (b = s.inflate(C, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && S && (w = typeof S == "string" ? o.string2buf(S) : p.call(S) === "[object ArrayBuffer]" ? new Uint8Array(S) : S, b = s.inflateSetDictionary(this.strm, w)), b === l.Z_BUF_ERROR && B === !0 && (b = l.Z_OK, B = !1), b !== l.Z_STREAM_END && b !== l.Z_OK)
            return this.onEnd(b), !(this.ended = !0);
          C.next_out && (C.avail_out !== 0 && b !== l.Z_STREAM_END && (C.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = o.utf8border(C.output, C.next_out), _ = C.next_out - x, E = o.buf2string(C.output, x), C.next_out = _, C.avail_out = k - _, _ && i.arraySet(C.output, C.output, x, _, 0), this.onData(E)) : this.onData(i.shrinkBuf(C.output, C.next_out)))), C.avail_in === 0 && C.avail_out === 0 && (B = !0);
        } while ((0 < C.avail_in || C.avail_out === 0) && b !== l.Z_STREAM_END);
        return b === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (b = s.inflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(C.avail_out = 0));
      }, f.prototype.onData = function(m) {
        this.chunks.push(m);
      }, f.prototype.onEnd = function(m) {
        m === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, a.Inflate = f, a.inflate = h, a.inflateRaw = function(m, y) {
        return (y = y || {}).raw = !0, h(m, y);
      }, a.ungzip = h;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(r, n, a) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      a.assign = function(l) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var c = u.shift();
          if (c) {
            if (typeof c != "object")
              throw new TypeError(c + "must be non-object");
            for (var d in c)
              c.hasOwnProperty(d) && (l[d] = c[d]);
          }
        }
        return l;
      }, a.shrinkBuf = function(l, u) {
        return l.length === u ? l : l.subarray ? l.subarray(0, u) : (l.length = u, l);
      };
      var i = { arraySet: function(l, u, c, d, p) {
        if (u.subarray && l.subarray)
          l.set(u.subarray(c, c + d), p);
        else
          for (var f = 0; f < d; f++)
            l[p + f] = u[c + f];
      }, flattenChunks: function(l) {
        var u, c, d, p, f, h;
        for (u = d = 0, c = l.length; u < c; u++)
          d += l[u].length;
        for (h = new Uint8Array(d), u = p = 0, c = l.length; u < c; u++)
          f = l[u], h.set(f, p), p += f.length;
        return h;
      } }, o = { arraySet: function(l, u, c, d, p) {
        for (var f = 0; f < d; f++)
          l[p + f] = u[c + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      a.setTyped = function(l) {
        l ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, i)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, o));
      }, a.setTyped(s);
    }, {}], 42: [function(r, n, a) {
      var s = r("./common"), i = !0, o = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        i = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = !1;
      }
      for (var l = new s.Buf8(256), u = 0; u < 256; u++)
        l[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      function c(d, p) {
        if (p < 65537 && (d.subarray && o || !d.subarray && i))
          return String.fromCharCode.apply(null, s.shrinkBuf(d, p));
        for (var f = "", h = 0; h < p; h++)
          f += String.fromCharCode(d[h]);
        return f;
      }
      l[254] = l[254] = 1, a.string2buf = function(d) {
        var p, f, h, m, y, b = d.length, v = 0;
        for (m = 0; m < b; m++)
          (64512 & (f = d.charCodeAt(m))) == 55296 && m + 1 < b && (64512 & (h = d.charCodeAt(m + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (h - 56320), m++), v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (p = new s.Buf8(v), m = y = 0; y < v; m++)
          (64512 & (f = d.charCodeAt(m))) == 55296 && m + 1 < b && (64512 & (h = d.charCodeAt(m + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (h - 56320), m++), f < 128 ? p[y++] = f : (f < 2048 ? p[y++] = 192 | f >>> 6 : (f < 65536 ? p[y++] = 224 | f >>> 12 : (p[y++] = 240 | f >>> 18, p[y++] = 128 | f >>> 12 & 63), p[y++] = 128 | f >>> 6 & 63), p[y++] = 128 | 63 & f);
        return p;
      }, a.buf2binstring = function(d) {
        return c(d, d.length);
      }, a.binstring2buf = function(d) {
        for (var p = new s.Buf8(d.length), f = 0, h = p.length; f < h; f++)
          p[f] = d.charCodeAt(f);
        return p;
      }, a.buf2string = function(d, p) {
        var f, h, m, y, b = p || d.length, v = new Array(2 * b);
        for (f = h = 0; f < b; )
          if ((m = d[f++]) < 128)
            v[h++] = m;
          else if (4 < (y = l[m]))
            v[h++] = 65533, f += y - 1;
          else {
            for (m &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && f < b; )
              m = m << 6 | 63 & d[f++], y--;
            1 < y ? v[h++] = 65533 : m < 65536 ? v[h++] = m : (m -= 65536, v[h++] = 55296 | m >> 10 & 1023, v[h++] = 56320 | 1023 & m);
          }
        return c(v, h);
      }, a.utf8border = function(d, p) {
        var f;
        for ((p = p || d.length) > d.length && (p = d.length), f = p - 1; 0 <= f && (192 & d[f]) == 128; )
          f--;
        return f < 0 || f === 0 ? p : f + l[d[f]] > p ? f : p;
      };
    }, { "./common": 41 }], 43: [function(r, n, a) {
      n.exports = function(s, i, o, l) {
        for (var u = 65535 & s | 0, c = s >>> 16 & 65535 | 0, d = 0; o !== 0; ) {
          for (o -= d = 2e3 < o ? 2e3 : o; c = c + (u = u + i[l++] | 0) | 0, --d; )
            ;
          u %= 65521, c %= 65521;
        }
        return u | c << 16 | 0;
      };
    }, {}], 44: [function(r, n, a) {
      n.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(r, n, a) {
      var s = function() {
        for (var i, o = [], l = 0; l < 256; l++) {
          i = l;
          for (var u = 0; u < 8; u++)
            i = 1 & i ? 3988292384 ^ i >>> 1 : i >>> 1;
          o[l] = i;
        }
        return o;
      }();
      n.exports = function(i, o, l, u) {
        var c = s, d = u + l;
        i ^= -1;
        for (var p = u; p < d; p++)
          i = i >>> 8 ^ c[255 & (i ^ o[p])];
        return -1 ^ i;
      };
    }, {}], 46: [function(r, n, a) {
      var s, i = r("../utils/common"), o = r("./trees"), l = r("./adler32"), u = r("./crc32"), c = r("./messages"), d = 0, p = 4, f = 0, h = -2, m = -1, y = 4, b = 2, v = 8, x = 9, _ = 286, E = 30, w = 19, C = 2 * _ + 1, k = 15, S = 3, B = 258, U = B + S + 1, N = 42, O = 113, I = 1, q = 2, ae = 3, Q = 4;
      function ne(V, Pe) {
        return V.msg = c[Pe], Pe;
      }
      function le(V) {
        return (V << 1) - (4 < V ? 9 : 0);
      }
      function W(V) {
        for (var Pe = V.length; 0 <= --Pe; )
          V[Pe] = 0;
      }
      function X(V) {
        var Pe = V.state, z = Pe.pending;
        z > V.avail_out && (z = V.avail_out), z !== 0 && (i.arraySet(V.output, Pe.pending_buf, Pe.pending_out, z, V.next_out), V.next_out += z, Pe.pending_out += z, V.total_out += z, V.avail_out -= z, Pe.pending -= z, Pe.pending === 0 && (Pe.pending_out = 0));
      }
      function G(V, Pe) {
        o._tr_flush_block(V, 0 <= V.block_start ? V.block_start : -1, V.strstart - V.block_start, Pe), V.block_start = V.strstart, X(V.strm);
      }
      function P(V, Pe) {
        V.pending_buf[V.pending++] = Pe;
      }
      function he(V, Pe) {
        V.pending_buf[V.pending++] = Pe >>> 8 & 255, V.pending_buf[V.pending++] = 255 & Pe;
      }
      function ye(V, Pe) {
        var z, A, R = V.max_chain_length, H = V.strstart, be = V.prev_length, me = V.nice_match, Ce = V.strstart > V.w_size - U ? V.strstart - (V.w_size - U) : 0, We = V.window, xe = V.w_mask, we = V.prev, te = V.strstart + B, Fe = We[H + be - 1], Y = We[H + be];
        V.prev_length >= V.good_match && (R >>= 2), me > V.lookahead && (me = V.lookahead);
        do
          if (We[(z = Pe) + be] === Y && We[z + be - 1] === Fe && We[z] === We[H] && We[++z] === We[H + 1]) {
            H += 2, z++;
            do
              ;
            while (We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && We[++H] === We[++z] && H < te);
            if (A = B - (te - H), H = te - B, be < A) {
              if (V.match_start = Pe, me <= (be = A))
                break;
              Fe = We[H + be - 1], Y = We[H + be];
            }
          }
        while ((Pe = we[Pe & xe]) > Ce && --R != 0);
        return be <= V.lookahead ? be : V.lookahead;
      }
      function pe(V) {
        var Pe, z, A, R, H, be, me, Ce, We, xe, we = V.w_size;
        do {
          if (R = V.window_size - V.lookahead - V.strstart, V.strstart >= we + (we - U)) {
            for (i.arraySet(V.window, V.window, we, we, 0), V.match_start -= we, V.strstart -= we, V.block_start -= we, Pe = z = V.hash_size; A = V.head[--Pe], V.head[Pe] = we <= A ? A - we : 0, --z; )
              ;
            for (Pe = z = we; A = V.prev[--Pe], V.prev[Pe] = we <= A ? A - we : 0, --z; )
              ;
            R += we;
          }
          if (V.strm.avail_in === 0)
            break;
          if (be = V.strm, me = V.window, Ce = V.strstart + V.lookahead, We = R, xe = void 0, xe = be.avail_in, We < xe && (xe = We), z = xe === 0 ? 0 : (be.avail_in -= xe, i.arraySet(me, be.input, be.next_in, xe, Ce), be.state.wrap === 1 ? be.adler = l(be.adler, me, xe, Ce) : be.state.wrap === 2 && (be.adler = u(be.adler, me, xe, Ce)), be.next_in += xe, be.total_in += xe, xe), V.lookahead += z, V.lookahead + V.insert >= S)
            for (H = V.strstart - V.insert, V.ins_h = V.window[H], V.ins_h = (V.ins_h << V.hash_shift ^ V.window[H + 1]) & V.hash_mask; V.insert && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[H + S - 1]) & V.hash_mask, V.prev[H & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = H, H++, V.insert--, !(V.lookahead + V.insert < S)); )
              ;
        } while (V.lookahead < U && V.strm.avail_in !== 0);
      }
      function $(V, Pe) {
        for (var z, A; ; ) {
          if (V.lookahead < U) {
            if (pe(V), V.lookahead < U && Pe === d)
              return I;
            if (V.lookahead === 0)
              break;
          }
          if (z = 0, V.lookahead >= S && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + S - 1]) & V.hash_mask, z = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), z !== 0 && V.strstart - z <= V.w_size - U && (V.match_length = ye(V, z)), V.match_length >= S)
            if (A = o._tr_tally(V, V.strstart - V.match_start, V.match_length - S), V.lookahead -= V.match_length, V.match_length <= V.max_lazy_match && V.lookahead >= S) {
              for (V.match_length--; V.strstart++, V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + S - 1]) & V.hash_mask, z = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart, --V.match_length != 0; )
                ;
              V.strstart++;
            } else
              V.strstart += V.match_length, V.match_length = 0, V.ins_h = V.window[V.strstart], V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + 1]) & V.hash_mask;
          else
            A = o._tr_tally(V, 0, V.window[V.strstart]), V.lookahead--, V.strstart++;
          if (A && (G(V, !1), V.strm.avail_out === 0))
            return I;
        }
        return V.insert = V.strstart < S - 1 ? V.strstart : S - 1, Pe === p ? (G(V, !0), V.strm.avail_out === 0 ? ae : Q) : V.last_lit && (G(V, !1), V.strm.avail_out === 0) ? I : q;
      }
      function F(V, Pe) {
        for (var z, A, R; ; ) {
          if (V.lookahead < U) {
            if (pe(V), V.lookahead < U && Pe === d)
              return I;
            if (V.lookahead === 0)
              break;
          }
          if (z = 0, V.lookahead >= S && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + S - 1]) & V.hash_mask, z = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), V.prev_length = V.match_length, V.prev_match = V.match_start, V.match_length = S - 1, z !== 0 && V.prev_length < V.max_lazy_match && V.strstart - z <= V.w_size - U && (V.match_length = ye(V, z), V.match_length <= 5 && (V.strategy === 1 || V.match_length === S && 4096 < V.strstart - V.match_start) && (V.match_length = S - 1)), V.prev_length >= S && V.match_length <= V.prev_length) {
            for (R = V.strstart + V.lookahead - S, A = o._tr_tally(V, V.strstart - 1 - V.prev_match, V.prev_length - S), V.lookahead -= V.prev_length - 1, V.prev_length -= 2; ++V.strstart <= R && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + S - 1]) & V.hash_mask, z = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), --V.prev_length != 0; )
              ;
            if (V.match_available = 0, V.match_length = S - 1, V.strstart++, A && (G(V, !1), V.strm.avail_out === 0))
              return I;
          } else if (V.match_available) {
            if ((A = o._tr_tally(V, 0, V.window[V.strstart - 1])) && G(V, !1), V.strstart++, V.lookahead--, V.strm.avail_out === 0)
              return I;
          } else
            V.match_available = 1, V.strstart++, V.lookahead--;
        }
        return V.match_available && (A = o._tr_tally(V, 0, V.window[V.strstart - 1]), V.match_available = 0), V.insert = V.strstart < S - 1 ? V.strstart : S - 1, Pe === p ? (G(V, !0), V.strm.avail_out === 0 ? ae : Q) : V.last_lit && (G(V, !1), V.strm.avail_out === 0) ? I : q;
      }
      function ge(V, Pe, z, A, R) {
        this.good_length = V, this.max_lazy = Pe, this.nice_length = z, this.max_chain = A, this.func = R;
      }
      function ce() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(2 * C), this.dyn_dtree = new i.Buf16(2 * (2 * E + 1)), this.bl_tree = new i.Buf16(2 * (2 * w + 1)), W(this.dyn_ltree), W(this.dyn_dtree), W(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(k + 1), this.heap = new i.Buf16(2 * _ + 1), W(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * _ + 1), W(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function ie(V) {
        var Pe;
        return V && V.state ? (V.total_in = V.total_out = 0, V.data_type = b, (Pe = V.state).pending = 0, Pe.pending_out = 0, Pe.wrap < 0 && (Pe.wrap = -Pe.wrap), Pe.status = Pe.wrap ? N : O, V.adler = Pe.wrap === 2 ? 0 : 1, Pe.last_flush = d, o._tr_init(Pe), f) : ne(V, h);
      }
      function re(V) {
        var Pe = ie(V);
        return Pe === f && function(z) {
          z.window_size = 2 * z.w_size, W(z.head), z.max_lazy_match = s[z.level].max_lazy, z.good_match = s[z.level].good_length, z.nice_match = s[z.level].nice_length, z.max_chain_length = s[z.level].max_chain, z.strstart = 0, z.block_start = 0, z.lookahead = 0, z.insert = 0, z.match_length = z.prev_length = S - 1, z.match_available = 0, z.ins_h = 0;
        }(V.state), Pe;
      }
      function Te(V, Pe, z, A, R, H) {
        if (!V)
          return h;
        var be = 1;
        if (Pe === m && (Pe = 6), A < 0 ? (be = 0, A = -A) : 15 < A && (be = 2, A -= 16), R < 1 || x < R || z !== v || A < 8 || 15 < A || Pe < 0 || 9 < Pe || H < 0 || y < H)
          return ne(V, h);
        A === 8 && (A = 9);
        var me = new ce();
        return (V.state = me).strm = V, me.wrap = be, me.gzhead = null, me.w_bits = A, me.w_size = 1 << me.w_bits, me.w_mask = me.w_size - 1, me.hash_bits = R + 7, me.hash_size = 1 << me.hash_bits, me.hash_mask = me.hash_size - 1, me.hash_shift = ~~((me.hash_bits + S - 1) / S), me.window = new i.Buf8(2 * me.w_size), me.head = new i.Buf16(me.hash_size), me.prev = new i.Buf16(me.w_size), me.lit_bufsize = 1 << R + 6, me.pending_buf_size = 4 * me.lit_bufsize, me.pending_buf = new i.Buf8(me.pending_buf_size), me.d_buf = 1 * me.lit_bufsize, me.l_buf = 3 * me.lit_bufsize, me.level = Pe, me.strategy = H, me.method = z, re(V);
      }
      s = [new ge(0, 0, 0, 0, function(V, Pe) {
        var z = 65535;
        for (z > V.pending_buf_size - 5 && (z = V.pending_buf_size - 5); ; ) {
          if (V.lookahead <= 1) {
            if (pe(V), V.lookahead === 0 && Pe === d)
              return I;
            if (V.lookahead === 0)
              break;
          }
          V.strstart += V.lookahead, V.lookahead = 0;
          var A = V.block_start + z;
          if ((V.strstart === 0 || V.strstart >= A) && (V.lookahead = V.strstart - A, V.strstart = A, G(V, !1), V.strm.avail_out === 0) || V.strstart - V.block_start >= V.w_size - U && (G(V, !1), V.strm.avail_out === 0))
            return I;
        }
        return V.insert = 0, Pe === p ? (G(V, !0), V.strm.avail_out === 0 ? ae : Q) : (V.strstart > V.block_start && (G(V, !1), V.strm.avail_out), I);
      }), new ge(4, 4, 8, 4, $), new ge(4, 5, 16, 8, $), new ge(4, 6, 32, 32, $), new ge(4, 4, 16, 16, F), new ge(8, 16, 32, 32, F), new ge(8, 16, 128, 128, F), new ge(8, 32, 128, 256, F), new ge(32, 128, 258, 1024, F), new ge(32, 258, 258, 4096, F)], a.deflateInit = function(V, Pe) {
        return Te(V, Pe, v, 15, 8, 0);
      }, a.deflateInit2 = Te, a.deflateReset = re, a.deflateResetKeep = ie, a.deflateSetHeader = function(V, Pe) {
        return V && V.state ? V.state.wrap !== 2 ? h : (V.state.gzhead = Pe, f) : h;
      }, a.deflate = function(V, Pe) {
        var z, A, R, H;
        if (!V || !V.state || 5 < Pe || Pe < 0)
          return V ? ne(V, h) : h;
        if (A = V.state, !V.output || !V.input && V.avail_in !== 0 || A.status === 666 && Pe !== p)
          return ne(V, V.avail_out === 0 ? -5 : h);
        if (A.strm = V, z = A.last_flush, A.last_flush = Pe, A.status === N)
          if (A.wrap === 2)
            V.adler = 0, P(A, 31), P(A, 139), P(A, 8), A.gzhead ? (P(A, (A.gzhead.text ? 1 : 0) + (A.gzhead.hcrc ? 2 : 0) + (A.gzhead.extra ? 4 : 0) + (A.gzhead.name ? 8 : 0) + (A.gzhead.comment ? 16 : 0)), P(A, 255 & A.gzhead.time), P(A, A.gzhead.time >> 8 & 255), P(A, A.gzhead.time >> 16 & 255), P(A, A.gzhead.time >> 24 & 255), P(A, A.level === 9 ? 2 : 2 <= A.strategy || A.level < 2 ? 4 : 0), P(A, 255 & A.gzhead.os), A.gzhead.extra && A.gzhead.extra.length && (P(A, 255 & A.gzhead.extra.length), P(A, A.gzhead.extra.length >> 8 & 255)), A.gzhead.hcrc && (V.adler = u(V.adler, A.pending_buf, A.pending, 0)), A.gzindex = 0, A.status = 69) : (P(A, 0), P(A, 0), P(A, 0), P(A, 0), P(A, 0), P(A, A.level === 9 ? 2 : 2 <= A.strategy || A.level < 2 ? 4 : 0), P(A, 3), A.status = O);
          else {
            var be = v + (A.w_bits - 8 << 4) << 8;
            be |= (2 <= A.strategy || A.level < 2 ? 0 : A.level < 6 ? 1 : A.level === 6 ? 2 : 3) << 6, A.strstart !== 0 && (be |= 32), be += 31 - be % 31, A.status = O, he(A, be), A.strstart !== 0 && (he(A, V.adler >>> 16), he(A, 65535 & V.adler)), V.adler = 1;
          }
        if (A.status === 69)
          if (A.gzhead.extra) {
            for (R = A.pending; A.gzindex < (65535 & A.gzhead.extra.length) && (A.pending !== A.pending_buf_size || (A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), X(V), R = A.pending, A.pending !== A.pending_buf_size)); )
              P(A, 255 & A.gzhead.extra[A.gzindex]), A.gzindex++;
            A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), A.gzindex === A.gzhead.extra.length && (A.gzindex = 0, A.status = 73);
          } else
            A.status = 73;
        if (A.status === 73)
          if (A.gzhead.name) {
            R = A.pending;
            do {
              if (A.pending === A.pending_buf_size && (A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), X(V), R = A.pending, A.pending === A.pending_buf_size)) {
                H = 1;
                break;
              }
              H = A.gzindex < A.gzhead.name.length ? 255 & A.gzhead.name.charCodeAt(A.gzindex++) : 0, P(A, H);
            } while (H !== 0);
            A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), H === 0 && (A.gzindex = 0, A.status = 91);
          } else
            A.status = 91;
        if (A.status === 91)
          if (A.gzhead.comment) {
            R = A.pending;
            do {
              if (A.pending === A.pending_buf_size && (A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), X(V), R = A.pending, A.pending === A.pending_buf_size)) {
                H = 1;
                break;
              }
              H = A.gzindex < A.gzhead.comment.length ? 255 & A.gzhead.comment.charCodeAt(A.gzindex++) : 0, P(A, H);
            } while (H !== 0);
            A.gzhead.hcrc && A.pending > R && (V.adler = u(V.adler, A.pending_buf, A.pending - R, R)), H === 0 && (A.status = 103);
          } else
            A.status = 103;
        if (A.status === 103 && (A.gzhead.hcrc ? (A.pending + 2 > A.pending_buf_size && X(V), A.pending + 2 <= A.pending_buf_size && (P(A, 255 & V.adler), P(A, V.adler >> 8 & 255), V.adler = 0, A.status = O)) : A.status = O), A.pending !== 0) {
          if (X(V), V.avail_out === 0)
            return A.last_flush = -1, f;
        } else if (V.avail_in === 0 && le(Pe) <= le(z) && Pe !== p)
          return ne(V, -5);
        if (A.status === 666 && V.avail_in !== 0)
          return ne(V, -5);
        if (V.avail_in !== 0 || A.lookahead !== 0 || Pe !== d && A.status !== 666) {
          var me = A.strategy === 2 ? function(Ce, We) {
            for (var xe; ; ) {
              if (Ce.lookahead === 0 && (pe(Ce), Ce.lookahead === 0)) {
                if (We === d)
                  return I;
                break;
              }
              if (Ce.match_length = 0, xe = o._tr_tally(Ce, 0, Ce.window[Ce.strstart]), Ce.lookahead--, Ce.strstart++, xe && (G(Ce, !1), Ce.strm.avail_out === 0))
                return I;
            }
            return Ce.insert = 0, We === p ? (G(Ce, !0), Ce.strm.avail_out === 0 ? ae : Q) : Ce.last_lit && (G(Ce, !1), Ce.strm.avail_out === 0) ? I : q;
          }(A, Pe) : A.strategy === 3 ? function(Ce, We) {
            for (var xe, we, te, Fe, Y = Ce.window; ; ) {
              if (Ce.lookahead <= B) {
                if (pe(Ce), Ce.lookahead <= B && We === d)
                  return I;
                if (Ce.lookahead === 0)
                  break;
              }
              if (Ce.match_length = 0, Ce.lookahead >= S && 0 < Ce.strstart && (we = Y[te = Ce.strstart - 1]) === Y[++te] && we === Y[++te] && we === Y[++te]) {
                Fe = Ce.strstart + B;
                do
                  ;
                while (we === Y[++te] && we === Y[++te] && we === Y[++te] && we === Y[++te] && we === Y[++te] && we === Y[++te] && we === Y[++te] && we === Y[++te] && te < Fe);
                Ce.match_length = B - (Fe - te), Ce.match_length > Ce.lookahead && (Ce.match_length = Ce.lookahead);
              }
              if (Ce.match_length >= S ? (xe = o._tr_tally(Ce, 1, Ce.match_length - S), Ce.lookahead -= Ce.match_length, Ce.strstart += Ce.match_length, Ce.match_length = 0) : (xe = o._tr_tally(Ce, 0, Ce.window[Ce.strstart]), Ce.lookahead--, Ce.strstart++), xe && (G(Ce, !1), Ce.strm.avail_out === 0))
                return I;
            }
            return Ce.insert = 0, We === p ? (G(Ce, !0), Ce.strm.avail_out === 0 ? ae : Q) : Ce.last_lit && (G(Ce, !1), Ce.strm.avail_out === 0) ? I : q;
          }(A, Pe) : s[A.level].func(A, Pe);
          if (me !== ae && me !== Q || (A.status = 666), me === I || me === ae)
            return V.avail_out === 0 && (A.last_flush = -1), f;
          if (me === q && (Pe === 1 ? o._tr_align(A) : Pe !== 5 && (o._tr_stored_block(A, 0, 0, !1), Pe === 3 && (W(A.head), A.lookahead === 0 && (A.strstart = 0, A.block_start = 0, A.insert = 0))), X(V), V.avail_out === 0))
            return A.last_flush = -1, f;
        }
        return Pe !== p ? f : A.wrap <= 0 ? 1 : (A.wrap === 2 ? (P(A, 255 & V.adler), P(A, V.adler >> 8 & 255), P(A, V.adler >> 16 & 255), P(A, V.adler >> 24 & 255), P(A, 255 & V.total_in), P(A, V.total_in >> 8 & 255), P(A, V.total_in >> 16 & 255), P(A, V.total_in >> 24 & 255)) : (he(A, V.adler >>> 16), he(A, 65535 & V.adler)), X(V), 0 < A.wrap && (A.wrap = -A.wrap), A.pending !== 0 ? f : 1);
      }, a.deflateEnd = function(V) {
        var Pe;
        return V && V.state ? (Pe = V.state.status) !== N && Pe !== 69 && Pe !== 73 && Pe !== 91 && Pe !== 103 && Pe !== O && Pe !== 666 ? ne(V, h) : (V.state = null, Pe === O ? ne(V, -3) : f) : h;
      }, a.deflateSetDictionary = function(V, Pe) {
        var z, A, R, H, be, me, Ce, We, xe = Pe.length;
        if (!V || !V.state || (H = (z = V.state).wrap) === 2 || H === 1 && z.status !== N || z.lookahead)
          return h;
        for (H === 1 && (V.adler = l(V.adler, Pe, xe, 0)), z.wrap = 0, xe >= z.w_size && (H === 0 && (W(z.head), z.strstart = 0, z.block_start = 0, z.insert = 0), We = new i.Buf8(z.w_size), i.arraySet(We, Pe, xe - z.w_size, z.w_size, 0), Pe = We, xe = z.w_size), be = V.avail_in, me = V.next_in, Ce = V.input, V.avail_in = xe, V.next_in = 0, V.input = Pe, pe(z); z.lookahead >= S; ) {
          for (A = z.strstart, R = z.lookahead - (S - 1); z.ins_h = (z.ins_h << z.hash_shift ^ z.window[A + S - 1]) & z.hash_mask, z.prev[A & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = A, A++, --R; )
            ;
          z.strstart = A, z.lookahead = S - 1, pe(z);
        }
        return z.strstart += z.lookahead, z.block_start = z.strstart, z.insert = z.lookahead, z.lookahead = 0, z.match_length = z.prev_length = S - 1, z.match_available = 0, V.next_in = me, V.input = Ce, V.avail_in = be, z.wrap = H, f;
      }, a.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(r, n, a) {
      n.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(r, n, a) {
      n.exports = function(s, i) {
        var o, l, u, c, d, p, f, h, m, y, b, v, x, _, E, w, C, k, S, B, U, N, O, I, q;
        o = s.state, l = s.next_in, I = s.input, u = l + (s.avail_in - 5), c = s.next_out, q = s.output, d = c - (i - s.avail_out), p = c + (s.avail_out - 257), f = o.dmax, h = o.wsize, m = o.whave, y = o.wnext, b = o.window, v = o.hold, x = o.bits, _ = o.lencode, E = o.distcode, w = (1 << o.lenbits) - 1, C = (1 << o.distbits) - 1;
        e:
          do {
            x < 15 && (v += I[l++] << x, x += 8, v += I[l++] << x, x += 8), k = _[v & w];
            t:
              for (; ; ) {
                if (v >>>= S = k >>> 24, x -= S, (S = k >>> 16 & 255) === 0)
                  q[c++] = 65535 & k;
                else {
                  if (!(16 & S)) {
                    if (!(64 & S)) {
                      k = _[(65535 & k) + (v & (1 << S) - 1)];
                      continue t;
                    }
                    if (32 & S) {
                      o.mode = 12;
                      break e;
                    }
                    s.msg = "invalid literal/length code", o.mode = 30;
                    break e;
                  }
                  B = 65535 & k, (S &= 15) && (x < S && (v += I[l++] << x, x += 8), B += v & (1 << S) - 1, v >>>= S, x -= S), x < 15 && (v += I[l++] << x, x += 8, v += I[l++] << x, x += 8), k = E[v & C];
                  r:
                    for (; ; ) {
                      if (v >>>= S = k >>> 24, x -= S, !(16 & (S = k >>> 16 & 255))) {
                        if (!(64 & S)) {
                          k = E[(65535 & k) + (v & (1 << S) - 1)];
                          continue r;
                        }
                        s.msg = "invalid distance code", o.mode = 30;
                        break e;
                      }
                      if (U = 65535 & k, x < (S &= 15) && (v += I[l++] << x, (x += 8) < S && (v += I[l++] << x, x += 8)), f < (U += v & (1 << S) - 1)) {
                        s.msg = "invalid distance too far back", o.mode = 30;
                        break e;
                      }
                      if (v >>>= S, x -= S, (S = c - d) < U) {
                        if (m < (S = U - S) && o.sane) {
                          s.msg = "invalid distance too far back", o.mode = 30;
                          break e;
                        }
                        if (O = b, (N = 0) === y) {
                          if (N += h - S, S < B) {
                            for (B -= S; q[c++] = b[N++], --S; )
                              ;
                            N = c - U, O = q;
                          }
                        } else if (y < S) {
                          if (N += h + y - S, (S -= y) < B) {
                            for (B -= S; q[c++] = b[N++], --S; )
                              ;
                            if (N = 0, y < B) {
                              for (B -= S = y; q[c++] = b[N++], --S; )
                                ;
                              N = c - U, O = q;
                            }
                          }
                        } else if (N += y - S, S < B) {
                          for (B -= S; q[c++] = b[N++], --S; )
                            ;
                          N = c - U, O = q;
                        }
                        for (; 2 < B; )
                          q[c++] = O[N++], q[c++] = O[N++], q[c++] = O[N++], B -= 3;
                        B && (q[c++] = O[N++], 1 < B && (q[c++] = O[N++]));
                      } else {
                        for (N = c - U; q[c++] = q[N++], q[c++] = q[N++], q[c++] = q[N++], 2 < (B -= 3); )
                          ;
                        B && (q[c++] = q[N++], 1 < B && (q[c++] = q[N++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < u && c < p);
        l -= B = x >> 3, v &= (1 << (x -= B << 3)) - 1, s.next_in = l, s.next_out = c, s.avail_in = l < u ? u - l + 5 : 5 - (l - u), s.avail_out = c < p ? p - c + 257 : 257 - (c - p), o.hold = v, o.bits = x;
      };
    }, {}], 49: [function(r, n, a) {
      var s = r("../utils/common"), i = r("./adler32"), o = r("./crc32"), l = r("./inffast"), u = r("./inftrees"), c = 1, d = 2, p = 0, f = -2, h = 1, m = 852, y = 592;
      function b(N) {
        return (N >>> 24 & 255) + (N >>> 8 & 65280) + ((65280 & N) << 8) + ((255 & N) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(N) {
        var O;
        return N && N.state ? (O = N.state, N.total_in = N.total_out = O.total = 0, N.msg = "", O.wrap && (N.adler = 1 & O.wrap), O.mode = h, O.last = 0, O.havedict = 0, O.dmax = 32768, O.head = null, O.hold = 0, O.bits = 0, O.lencode = O.lendyn = new s.Buf32(m), O.distcode = O.distdyn = new s.Buf32(y), O.sane = 1, O.back = -1, p) : f;
      }
      function _(N) {
        var O;
        return N && N.state ? ((O = N.state).wsize = 0, O.whave = 0, O.wnext = 0, x(N)) : f;
      }
      function E(N, O) {
        var I, q;
        return N && N.state ? (q = N.state, O < 0 ? (I = 0, O = -O) : (I = 1 + (O >> 4), O < 48 && (O &= 15)), O && (O < 8 || 15 < O) ? f : (q.window !== null && q.wbits !== O && (q.window = null), q.wrap = I, q.wbits = O, _(N))) : f;
      }
      function w(N, O) {
        var I, q;
        return N ? (q = new v(), (N.state = q).window = null, (I = E(N, O)) !== p && (N.state = null), I) : f;
      }
      var C, k, S = !0;
      function B(N) {
        if (S) {
          var O;
          for (C = new s.Buf32(512), k = new s.Buf32(32), O = 0; O < 144; )
            N.lens[O++] = 8;
          for (; O < 256; )
            N.lens[O++] = 9;
          for (; O < 280; )
            N.lens[O++] = 7;
          for (; O < 288; )
            N.lens[O++] = 8;
          for (u(c, N.lens, 0, 288, C, 0, N.work, { bits: 9 }), O = 0; O < 32; )
            N.lens[O++] = 5;
          u(d, N.lens, 0, 32, k, 0, N.work, { bits: 5 }), S = !1;
        }
        N.lencode = C, N.lenbits = 9, N.distcode = k, N.distbits = 5;
      }
      function U(N, O, I, q) {
        var ae, Q = N.state;
        return Q.window === null && (Q.wsize = 1 << Q.wbits, Q.wnext = 0, Q.whave = 0, Q.window = new s.Buf8(Q.wsize)), q >= Q.wsize ? (s.arraySet(Q.window, O, I - Q.wsize, Q.wsize, 0), Q.wnext = 0, Q.whave = Q.wsize) : (q < (ae = Q.wsize - Q.wnext) && (ae = q), s.arraySet(Q.window, O, I - q, ae, Q.wnext), (q -= ae) ? (s.arraySet(Q.window, O, I - q, q, 0), Q.wnext = q, Q.whave = Q.wsize) : (Q.wnext += ae, Q.wnext === Q.wsize && (Q.wnext = 0), Q.whave < Q.wsize && (Q.whave += ae))), 0;
      }
      a.inflateReset = _, a.inflateReset2 = E, a.inflateResetKeep = x, a.inflateInit = function(N) {
        return w(N, 15);
      }, a.inflateInit2 = w, a.inflate = function(N, O) {
        var I, q, ae, Q, ne, le, W, X, G, P, he, ye, pe, $, F, ge, ce, ie, re, Te, V, Pe, z, A, R = 0, H = new s.Buf8(4), be = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!N || !N.state || !N.output || !N.input && N.avail_in !== 0)
          return f;
        (I = N.state).mode === 12 && (I.mode = 13), ne = N.next_out, ae = N.output, W = N.avail_out, Q = N.next_in, q = N.input, le = N.avail_in, X = I.hold, G = I.bits, P = le, he = W, Pe = p;
        e:
          for (; ; )
            switch (I.mode) {
              case h:
                if (I.wrap === 0) {
                  I.mode = 13;
                  break;
                }
                for (; G < 16; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if (2 & I.wrap && X === 35615) {
                  H[I.check = 0] = 255 & X, H[1] = X >>> 8 & 255, I.check = o(I.check, H, 2, 0), G = X = 0, I.mode = 2;
                  break;
                }
                if (I.flags = 0, I.head && (I.head.done = !1), !(1 & I.wrap) || (((255 & X) << 8) + (X >> 8)) % 31) {
                  N.msg = "incorrect header check", I.mode = 30;
                  break;
                }
                if ((15 & X) != 8) {
                  N.msg = "unknown compression method", I.mode = 30;
                  break;
                }
                if (G -= 4, V = 8 + (15 & (X >>>= 4)), I.wbits === 0)
                  I.wbits = V;
                else if (V > I.wbits) {
                  N.msg = "invalid window size", I.mode = 30;
                  break;
                }
                I.dmax = 1 << V, N.adler = I.check = 1, I.mode = 512 & X ? 10 : 12, G = X = 0;
                break;
              case 2:
                for (; G < 16; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if (I.flags = X, (255 & I.flags) != 8) {
                  N.msg = "unknown compression method", I.mode = 30;
                  break;
                }
                if (57344 & I.flags) {
                  N.msg = "unknown header flags set", I.mode = 30;
                  break;
                }
                I.head && (I.head.text = X >> 8 & 1), 512 & I.flags && (H[0] = 255 & X, H[1] = X >>> 8 & 255, I.check = o(I.check, H, 2, 0)), G = X = 0, I.mode = 3;
              case 3:
                for (; G < 32; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                I.head && (I.head.time = X), 512 & I.flags && (H[0] = 255 & X, H[1] = X >>> 8 & 255, H[2] = X >>> 16 & 255, H[3] = X >>> 24 & 255, I.check = o(I.check, H, 4, 0)), G = X = 0, I.mode = 4;
              case 4:
                for (; G < 16; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                I.head && (I.head.xflags = 255 & X, I.head.os = X >> 8), 512 & I.flags && (H[0] = 255 & X, H[1] = X >>> 8 & 255, I.check = o(I.check, H, 2, 0)), G = X = 0, I.mode = 5;
              case 5:
                if (1024 & I.flags) {
                  for (; G < 16; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  I.length = X, I.head && (I.head.extra_len = X), 512 & I.flags && (H[0] = 255 & X, H[1] = X >>> 8 & 255, I.check = o(I.check, H, 2, 0)), G = X = 0;
                } else
                  I.head && (I.head.extra = null);
                I.mode = 6;
              case 6:
                if (1024 & I.flags && (le < (ye = I.length) && (ye = le), ye && (I.head && (V = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), s.arraySet(I.head.extra, q, Q, ye, V)), 512 & I.flags && (I.check = o(I.check, q, ye, Q)), le -= ye, Q += ye, I.length -= ye), I.length))
                  break e;
                I.length = 0, I.mode = 7;
              case 7:
                if (2048 & I.flags) {
                  if (le === 0)
                    break e;
                  for (ye = 0; V = q[Q + ye++], I.head && V && I.length < 65536 && (I.head.name += String.fromCharCode(V)), V && ye < le; )
                    ;
                  if (512 & I.flags && (I.check = o(I.check, q, ye, Q)), le -= ye, Q += ye, V)
                    break e;
                } else
                  I.head && (I.head.name = null);
                I.length = 0, I.mode = 8;
              case 8:
                if (4096 & I.flags) {
                  if (le === 0)
                    break e;
                  for (ye = 0; V = q[Q + ye++], I.head && V && I.length < 65536 && (I.head.comment += String.fromCharCode(V)), V && ye < le; )
                    ;
                  if (512 & I.flags && (I.check = o(I.check, q, ye, Q)), le -= ye, Q += ye, V)
                    break e;
                } else
                  I.head && (I.head.comment = null);
                I.mode = 9;
              case 9:
                if (512 & I.flags) {
                  for (; G < 16; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  if (X !== (65535 & I.check)) {
                    N.msg = "header crc mismatch", I.mode = 30;
                    break;
                  }
                  G = X = 0;
                }
                I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), N.adler = I.check = 0, I.mode = 12;
                break;
              case 10:
                for (; G < 32; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                N.adler = I.check = b(X), G = X = 0, I.mode = 11;
              case 11:
                if (I.havedict === 0)
                  return N.next_out = ne, N.avail_out = W, N.next_in = Q, N.avail_in = le, I.hold = X, I.bits = G, 2;
                N.adler = I.check = 1, I.mode = 12;
              case 12:
                if (O === 5 || O === 6)
                  break e;
              case 13:
                if (I.last) {
                  X >>>= 7 & G, G -= 7 & G, I.mode = 27;
                  break;
                }
                for (; G < 3; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                switch (I.last = 1 & X, G -= 1, 3 & (X >>>= 1)) {
                  case 0:
                    I.mode = 14;
                    break;
                  case 1:
                    if (B(I), I.mode = 20, O !== 6)
                      break;
                    X >>>= 2, G -= 2;
                    break e;
                  case 2:
                    I.mode = 17;
                    break;
                  case 3:
                    N.msg = "invalid block type", I.mode = 30;
                }
                X >>>= 2, G -= 2;
                break;
              case 14:
                for (X >>>= 7 & G, G -= 7 & G; G < 32; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if ((65535 & X) != (X >>> 16 ^ 65535)) {
                  N.msg = "invalid stored block lengths", I.mode = 30;
                  break;
                }
                if (I.length = 65535 & X, G = X = 0, I.mode = 15, O === 6)
                  break e;
              case 15:
                I.mode = 16;
              case 16:
                if (ye = I.length) {
                  if (le < ye && (ye = le), W < ye && (ye = W), ye === 0)
                    break e;
                  s.arraySet(ae, q, Q, ye, ne), le -= ye, Q += ye, W -= ye, ne += ye, I.length -= ye;
                  break;
                }
                I.mode = 12;
                break;
              case 17:
                for (; G < 14; ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if (I.nlen = 257 + (31 & X), X >>>= 5, G -= 5, I.ndist = 1 + (31 & X), X >>>= 5, G -= 5, I.ncode = 4 + (15 & X), X >>>= 4, G -= 4, 286 < I.nlen || 30 < I.ndist) {
                  N.msg = "too many length or distance symbols", I.mode = 30;
                  break;
                }
                I.have = 0, I.mode = 18;
              case 18:
                for (; I.have < I.ncode; ) {
                  for (; G < 3; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  I.lens[be[I.have++]] = 7 & X, X >>>= 3, G -= 3;
                }
                for (; I.have < 19; )
                  I.lens[be[I.have++]] = 0;
                if (I.lencode = I.lendyn, I.lenbits = 7, z = { bits: I.lenbits }, Pe = u(0, I.lens, 0, 19, I.lencode, 0, I.work, z), I.lenbits = z.bits, Pe) {
                  N.msg = "invalid code lengths set", I.mode = 30;
                  break;
                }
                I.have = 0, I.mode = 19;
              case 19:
                for (; I.have < I.nlen + I.ndist; ) {
                  for (; ge = (R = I.lencode[X & (1 << I.lenbits) - 1]) >>> 16 & 255, ce = 65535 & R, !((F = R >>> 24) <= G); ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  if (ce < 16)
                    X >>>= F, G -= F, I.lens[I.have++] = ce;
                  else {
                    if (ce === 16) {
                      for (A = F + 2; G < A; ) {
                        if (le === 0)
                          break e;
                        le--, X += q[Q++] << G, G += 8;
                      }
                      if (X >>>= F, G -= F, I.have === 0) {
                        N.msg = "invalid bit length repeat", I.mode = 30;
                        break;
                      }
                      V = I.lens[I.have - 1], ye = 3 + (3 & X), X >>>= 2, G -= 2;
                    } else if (ce === 17) {
                      for (A = F + 3; G < A; ) {
                        if (le === 0)
                          break e;
                        le--, X += q[Q++] << G, G += 8;
                      }
                      G -= F, V = 0, ye = 3 + (7 & (X >>>= F)), X >>>= 3, G -= 3;
                    } else {
                      for (A = F + 7; G < A; ) {
                        if (le === 0)
                          break e;
                        le--, X += q[Q++] << G, G += 8;
                      }
                      G -= F, V = 0, ye = 11 + (127 & (X >>>= F)), X >>>= 7, G -= 7;
                    }
                    if (I.have + ye > I.nlen + I.ndist) {
                      N.msg = "invalid bit length repeat", I.mode = 30;
                      break;
                    }
                    for (; ye--; )
                      I.lens[I.have++] = V;
                  }
                }
                if (I.mode === 30)
                  break;
                if (I.lens[256] === 0) {
                  N.msg = "invalid code -- missing end-of-block", I.mode = 30;
                  break;
                }
                if (I.lenbits = 9, z = { bits: I.lenbits }, Pe = u(c, I.lens, 0, I.nlen, I.lencode, 0, I.work, z), I.lenbits = z.bits, Pe) {
                  N.msg = "invalid literal/lengths set", I.mode = 30;
                  break;
                }
                if (I.distbits = 6, I.distcode = I.distdyn, z = { bits: I.distbits }, Pe = u(d, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, z), I.distbits = z.bits, Pe) {
                  N.msg = "invalid distances set", I.mode = 30;
                  break;
                }
                if (I.mode = 20, O === 6)
                  break e;
              case 20:
                I.mode = 21;
              case 21:
                if (6 <= le && 258 <= W) {
                  N.next_out = ne, N.avail_out = W, N.next_in = Q, N.avail_in = le, I.hold = X, I.bits = G, l(N, he), ne = N.next_out, ae = N.output, W = N.avail_out, Q = N.next_in, q = N.input, le = N.avail_in, X = I.hold, G = I.bits, I.mode === 12 && (I.back = -1);
                  break;
                }
                for (I.back = 0; ge = (R = I.lencode[X & (1 << I.lenbits) - 1]) >>> 16 & 255, ce = 65535 & R, !((F = R >>> 24) <= G); ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if (ge && !(240 & ge)) {
                  for (ie = F, re = ge, Te = ce; ge = (R = I.lencode[Te + ((X & (1 << ie + re) - 1) >> ie)]) >>> 16 & 255, ce = 65535 & R, !(ie + (F = R >>> 24) <= G); ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  X >>>= ie, G -= ie, I.back += ie;
                }
                if (X >>>= F, G -= F, I.back += F, I.length = ce, ge === 0) {
                  I.mode = 26;
                  break;
                }
                if (32 & ge) {
                  I.back = -1, I.mode = 12;
                  break;
                }
                if (64 & ge) {
                  N.msg = "invalid literal/length code", I.mode = 30;
                  break;
                }
                I.extra = 15 & ge, I.mode = 22;
              case 22:
                if (I.extra) {
                  for (A = I.extra; G < A; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  I.length += X & (1 << I.extra) - 1, X >>>= I.extra, G -= I.extra, I.back += I.extra;
                }
                I.was = I.length, I.mode = 23;
              case 23:
                for (; ge = (R = I.distcode[X & (1 << I.distbits) - 1]) >>> 16 & 255, ce = 65535 & R, !((F = R >>> 24) <= G); ) {
                  if (le === 0)
                    break e;
                  le--, X += q[Q++] << G, G += 8;
                }
                if (!(240 & ge)) {
                  for (ie = F, re = ge, Te = ce; ge = (R = I.distcode[Te + ((X & (1 << ie + re) - 1) >> ie)]) >>> 16 & 255, ce = 65535 & R, !(ie + (F = R >>> 24) <= G); ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  X >>>= ie, G -= ie, I.back += ie;
                }
                if (X >>>= F, G -= F, I.back += F, 64 & ge) {
                  N.msg = "invalid distance code", I.mode = 30;
                  break;
                }
                I.offset = ce, I.extra = 15 & ge, I.mode = 24;
              case 24:
                if (I.extra) {
                  for (A = I.extra; G < A; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  I.offset += X & (1 << I.extra) - 1, X >>>= I.extra, G -= I.extra, I.back += I.extra;
                }
                if (I.offset > I.dmax) {
                  N.msg = "invalid distance too far back", I.mode = 30;
                  break;
                }
                I.mode = 25;
              case 25:
                if (W === 0)
                  break e;
                if (ye = he - W, I.offset > ye) {
                  if ((ye = I.offset - ye) > I.whave && I.sane) {
                    N.msg = "invalid distance too far back", I.mode = 30;
                    break;
                  }
                  pe = ye > I.wnext ? (ye -= I.wnext, I.wsize - ye) : I.wnext - ye, ye > I.length && (ye = I.length), $ = I.window;
                } else
                  $ = ae, pe = ne - I.offset, ye = I.length;
                for (W < ye && (ye = W), W -= ye, I.length -= ye; ae[ne++] = $[pe++], --ye; )
                  ;
                I.length === 0 && (I.mode = 21);
                break;
              case 26:
                if (W === 0)
                  break e;
                ae[ne++] = I.length, W--, I.mode = 21;
                break;
              case 27:
                if (I.wrap) {
                  for (; G < 32; ) {
                    if (le === 0)
                      break e;
                    le--, X |= q[Q++] << G, G += 8;
                  }
                  if (he -= W, N.total_out += he, I.total += he, he && (N.adler = I.check = I.flags ? o(I.check, ae, he, ne - he) : i(I.check, ae, he, ne - he)), he = W, (I.flags ? X : b(X)) !== I.check) {
                    N.msg = "incorrect data check", I.mode = 30;
                    break;
                  }
                  G = X = 0;
                }
                I.mode = 28;
              case 28:
                if (I.wrap && I.flags) {
                  for (; G < 32; ) {
                    if (le === 0)
                      break e;
                    le--, X += q[Q++] << G, G += 8;
                  }
                  if (X !== (4294967295 & I.total)) {
                    N.msg = "incorrect length check", I.mode = 30;
                    break;
                  }
                  G = X = 0;
                }
                I.mode = 29;
              case 29:
                Pe = 1;
                break e;
              case 30:
                Pe = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return f;
            }
        return N.next_out = ne, N.avail_out = W, N.next_in = Q, N.avail_in = le, I.hold = X, I.bits = G, (I.wsize || he !== N.avail_out && I.mode < 30 && (I.mode < 27 || O !== 4)) && U(N, N.output, N.next_out, he - N.avail_out) ? (I.mode = 31, -4) : (P -= N.avail_in, he -= N.avail_out, N.total_in += P, N.total_out += he, I.total += he, I.wrap && he && (N.adler = I.check = I.flags ? o(I.check, ae, he, N.next_out - he) : i(I.check, ae, he, N.next_out - he)), N.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === 12 ? 128 : 0) + (I.mode === 20 || I.mode === 15 ? 256 : 0), (P == 0 && he === 0 || O === 4) && Pe === p && (Pe = -5), Pe);
      }, a.inflateEnd = function(N) {
        if (!N || !N.state)
          return f;
        var O = N.state;
        return O.window && (O.window = null), N.state = null, p;
      }, a.inflateGetHeader = function(N, O) {
        var I;
        return N && N.state && 2 & (I = N.state).wrap ? ((I.head = O).done = !1, p) : f;
      }, a.inflateSetDictionary = function(N, O) {
        var I, q = O.length;
        return N && N.state ? (I = N.state).wrap !== 0 && I.mode !== 11 ? f : I.mode === 11 && i(1, O, q, 0) !== I.check ? -3 : U(N, O, q, q) ? (I.mode = 31, -4) : (I.havedict = 1, p) : f;
      }, a.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(r, n, a) {
      var s = r("../utils/common"), i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      n.exports = function(c, d, p, f, h, m, y, b) {
        var v, x, _, E, w, C, k, S, B, U = b.bits, N = 0, O = 0, I = 0, q = 0, ae = 0, Q = 0, ne = 0, le = 0, W = 0, X = 0, G = null, P = 0, he = new s.Buf16(16), ye = new s.Buf16(16), pe = null, $ = 0;
        for (N = 0; N <= 15; N++)
          he[N] = 0;
        for (O = 0; O < f; O++)
          he[d[p + O]]++;
        for (ae = U, q = 15; 1 <= q && he[q] === 0; q--)
          ;
        if (q < ae && (ae = q), q === 0)
          return h[m++] = 20971520, h[m++] = 20971520, b.bits = 1, 0;
        for (I = 1; I < q && he[I] === 0; I++)
          ;
        for (ae < I && (ae = I), N = le = 1; N <= 15; N++)
          if (le <<= 1, (le -= he[N]) < 0)
            return -1;
        if (0 < le && (c === 0 || q !== 1))
          return -1;
        for (ye[1] = 0, N = 1; N < 15; N++)
          ye[N + 1] = ye[N] + he[N];
        for (O = 0; O < f; O++)
          d[p + O] !== 0 && (y[ye[d[p + O]]++] = O);
        if (C = c === 0 ? (G = pe = y, 19) : c === 1 ? (G = i, P -= 257, pe = o, $ -= 257, 256) : (G = l, pe = u, -1), N = I, w = m, ne = O = X = 0, _ = -1, E = (W = 1 << (Q = ae)) - 1, c === 1 && 852 < W || c === 2 && 592 < W)
          return 1;
        for (; ; ) {
          for (k = N - ne, B = y[O] < C ? (S = 0, y[O]) : y[O] > C ? (S = pe[$ + y[O]], G[P + y[O]]) : (S = 96, 0), v = 1 << N - ne, I = x = 1 << Q; h[w + (X >> ne) + (x -= v)] = k << 24 | S << 16 | B | 0, x !== 0; )
            ;
          for (v = 1 << N - 1; X & v; )
            v >>= 1;
          if (v !== 0 ? (X &= v - 1, X += v) : X = 0, O++, --he[N] == 0) {
            if (N === q)
              break;
            N = d[p + y[O]];
          }
          if (ae < N && (X & E) !== _) {
            for (ne === 0 && (ne = ae), w += I, le = 1 << (Q = N - ne); Q + ne < q && !((le -= he[Q + ne]) <= 0); )
              Q++, le <<= 1;
            if (W += 1 << Q, c === 1 && 852 < W || c === 2 && 592 < W)
              return 1;
            h[_ = X & E] = ae << 24 | Q << 16 | w - m | 0;
          }
        }
        return X !== 0 && (h[w + X] = N - ne << 24 | 64 << 16 | 0), b.bits = ae, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(r, n, a) {
      n.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(r, n, a) {
      var s = r("../utils/common"), i = 0, o = 1;
      function l(R) {
        for (var H = R.length; 0 <= --H; )
          R[H] = 0;
      }
      var u = 0, c = 29, d = 256, p = d + 1 + c, f = 30, h = 19, m = 2 * p + 1, y = 15, b = 16, v = 7, x = 256, _ = 16, E = 17, w = 18, C = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (p + 2));
      l(U);
      var N = new Array(2 * f);
      l(N);
      var O = new Array(512);
      l(O);
      var I = new Array(256);
      l(I);
      var q = new Array(c);
      l(q);
      var ae, Q, ne, le = new Array(f);
      function W(R, H, be, me, Ce) {
        this.static_tree = R, this.extra_bits = H, this.extra_base = be, this.elems = me, this.max_length = Ce, this.has_stree = R && R.length;
      }
      function X(R, H) {
        this.dyn_tree = R, this.max_code = 0, this.stat_desc = H;
      }
      function G(R) {
        return R < 256 ? O[R] : O[256 + (R >>> 7)];
      }
      function P(R, H) {
        R.pending_buf[R.pending++] = 255 & H, R.pending_buf[R.pending++] = H >>> 8 & 255;
      }
      function he(R, H, be) {
        R.bi_valid > b - be ? (R.bi_buf |= H << R.bi_valid & 65535, P(R, R.bi_buf), R.bi_buf = H >> b - R.bi_valid, R.bi_valid += be - b) : (R.bi_buf |= H << R.bi_valid & 65535, R.bi_valid += be);
      }
      function ye(R, H, be) {
        he(R, be[2 * H], be[2 * H + 1]);
      }
      function pe(R, H) {
        for (var be = 0; be |= 1 & R, R >>>= 1, be <<= 1, 0 < --H; )
          ;
        return be >>> 1;
      }
      function $(R, H, be) {
        var me, Ce, We = new Array(y + 1), xe = 0;
        for (me = 1; me <= y; me++)
          We[me] = xe = xe + be[me - 1] << 1;
        for (Ce = 0; Ce <= H; Ce++) {
          var we = R[2 * Ce + 1];
          we !== 0 && (R[2 * Ce] = pe(We[we]++, we));
        }
      }
      function F(R) {
        var H;
        for (H = 0; H < p; H++)
          R.dyn_ltree[2 * H] = 0;
        for (H = 0; H < f; H++)
          R.dyn_dtree[2 * H] = 0;
        for (H = 0; H < h; H++)
          R.bl_tree[2 * H] = 0;
        R.dyn_ltree[2 * x] = 1, R.opt_len = R.static_len = 0, R.last_lit = R.matches = 0;
      }
      function ge(R) {
        8 < R.bi_valid ? P(R, R.bi_buf) : 0 < R.bi_valid && (R.pending_buf[R.pending++] = R.bi_buf), R.bi_buf = 0, R.bi_valid = 0;
      }
      function ce(R, H, be, me) {
        var Ce = 2 * H, We = 2 * be;
        return R[Ce] < R[We] || R[Ce] === R[We] && me[H] <= me[be];
      }
      function ie(R, H, be) {
        for (var me = R.heap[be], Ce = be << 1; Ce <= R.heap_len && (Ce < R.heap_len && ce(H, R.heap[Ce + 1], R.heap[Ce], R.depth) && Ce++, !ce(H, me, R.heap[Ce], R.depth)); )
          R.heap[be] = R.heap[Ce], be = Ce, Ce <<= 1;
        R.heap[be] = me;
      }
      function re(R, H, be) {
        var me, Ce, We, xe, we = 0;
        if (R.last_lit !== 0)
          for (; me = R.pending_buf[R.d_buf + 2 * we] << 8 | R.pending_buf[R.d_buf + 2 * we + 1], Ce = R.pending_buf[R.l_buf + we], we++, me === 0 ? ye(R, Ce, H) : (ye(R, (We = I[Ce]) + d + 1, H), (xe = C[We]) !== 0 && he(R, Ce -= q[We], xe), ye(R, We = G(--me), be), (xe = k[We]) !== 0 && he(R, me -= le[We], xe)), we < R.last_lit; )
            ;
        ye(R, x, H);
      }
      function Te(R, H) {
        var be, me, Ce, We = H.dyn_tree, xe = H.stat_desc.static_tree, we = H.stat_desc.has_stree, te = H.stat_desc.elems, Fe = -1;
        for (R.heap_len = 0, R.heap_max = m, be = 0; be < te; be++)
          We[2 * be] !== 0 ? (R.heap[++R.heap_len] = Fe = be, R.depth[be] = 0) : We[2 * be + 1] = 0;
        for (; R.heap_len < 2; )
          We[2 * (Ce = R.heap[++R.heap_len] = Fe < 2 ? ++Fe : 0)] = 1, R.depth[Ce] = 0, R.opt_len--, we && (R.static_len -= xe[2 * Ce + 1]);
        for (H.max_code = Fe, be = R.heap_len >> 1; 1 <= be; be--)
          ie(R, We, be);
        for (Ce = te; be = R.heap[1], R.heap[1] = R.heap[R.heap_len--], ie(R, We, 1), me = R.heap[1], R.heap[--R.heap_max] = be, R.heap[--R.heap_max] = me, We[2 * Ce] = We[2 * be] + We[2 * me], R.depth[Ce] = (R.depth[be] >= R.depth[me] ? R.depth[be] : R.depth[me]) + 1, We[2 * be + 1] = We[2 * me + 1] = Ce, R.heap[1] = Ce++, ie(R, We, 1), 2 <= R.heap_len; )
          ;
        R.heap[--R.heap_max] = R.heap[1], function(Y, Je) {
          var xt, Ze, rt, Mt, Qt, kr, tr = Je.dyn_tree, Oe = Je.max_code, Ie = Je.stat_desc.static_tree, Me = Je.stat_desc.has_stree, je = Je.stat_desc.extra_bits, tt = Je.stat_desc.extra_base, Ct = Je.stat_desc.max_length, Kt = 0;
          for (Mt = 0; Mt <= y; Mt++)
            Y.bl_count[Mt] = 0;
          for (tr[2 * Y.heap[Y.heap_max] + 1] = 0, xt = Y.heap_max + 1; xt < m; xt++)
            Ct < (Mt = tr[2 * tr[2 * (Ze = Y.heap[xt]) + 1] + 1] + 1) && (Mt = Ct, Kt++), tr[2 * Ze + 1] = Mt, Oe < Ze || (Y.bl_count[Mt]++, Qt = 0, tt <= Ze && (Qt = je[Ze - tt]), kr = tr[2 * Ze], Y.opt_len += kr * (Mt + Qt), Me && (Y.static_len += kr * (Ie[2 * Ze + 1] + Qt)));
          if (Kt !== 0) {
            do {
              for (Mt = Ct - 1; Y.bl_count[Mt] === 0; )
                Mt--;
              Y.bl_count[Mt]--, Y.bl_count[Mt + 1] += 2, Y.bl_count[Ct]--, Kt -= 2;
            } while (0 < Kt);
            for (Mt = Ct; Mt !== 0; Mt--)
              for (Ze = Y.bl_count[Mt]; Ze !== 0; )
                Oe < (rt = Y.heap[--xt]) || (tr[2 * rt + 1] !== Mt && (Y.opt_len += (Mt - tr[2 * rt + 1]) * tr[2 * rt], tr[2 * rt + 1] = Mt), Ze--);
          }
        }(R, H), $(We, Fe, R.bl_count);
      }
      function V(R, H, be) {
        var me, Ce, We = -1, xe = H[1], we = 0, te = 7, Fe = 4;
        for (xe === 0 && (te = 138, Fe = 3), H[2 * (be + 1) + 1] = 65535, me = 0; me <= be; me++)
          Ce = xe, xe = H[2 * (me + 1) + 1], ++we < te && Ce === xe || (we < Fe ? R.bl_tree[2 * Ce] += we : Ce !== 0 ? (Ce !== We && R.bl_tree[2 * Ce]++, R.bl_tree[2 * _]++) : we <= 10 ? R.bl_tree[2 * E]++ : R.bl_tree[2 * w]++, We = Ce, Fe = (we = 0) === xe ? (te = 138, 3) : Ce === xe ? (te = 6, 3) : (te = 7, 4));
      }
      function Pe(R, H, be) {
        var me, Ce, We = -1, xe = H[1], we = 0, te = 7, Fe = 4;
        for (xe === 0 && (te = 138, Fe = 3), me = 0; me <= be; me++)
          if (Ce = xe, xe = H[2 * (me + 1) + 1], !(++we < te && Ce === xe)) {
            if (we < Fe)
              for (; ye(R, Ce, R.bl_tree), --we != 0; )
                ;
            else
              Ce !== 0 ? (Ce !== We && (ye(R, Ce, R.bl_tree), we--), ye(R, _, R.bl_tree), he(R, we - 3, 2)) : we <= 10 ? (ye(R, E, R.bl_tree), he(R, we - 3, 3)) : (ye(R, w, R.bl_tree), he(R, we - 11, 7));
            We = Ce, Fe = (we = 0) === xe ? (te = 138, 3) : Ce === xe ? (te = 6, 3) : (te = 7, 4);
          }
      }
      l(le);
      var z = !1;
      function A(R, H, be, me) {
        he(R, (u << 1) + (me ? 1 : 0), 3), function(Ce, We, xe, we) {
          ge(Ce), P(Ce, xe), P(Ce, ~xe), s.arraySet(Ce.pending_buf, Ce.window, We, xe, Ce.pending), Ce.pending += xe;
        }(R, H, be);
      }
      a._tr_init = function(R) {
        z || (function() {
          var H, be, me, Ce, We, xe = new Array(y + 1);
          for (Ce = me = 0; Ce < c - 1; Ce++)
            for (q[Ce] = me, H = 0; H < 1 << C[Ce]; H++)
              I[me++] = Ce;
          for (I[me - 1] = Ce, Ce = We = 0; Ce < 16; Ce++)
            for (le[Ce] = We, H = 0; H < 1 << k[Ce]; H++)
              O[We++] = Ce;
          for (We >>= 7; Ce < f; Ce++)
            for (le[Ce] = We << 7, H = 0; H < 1 << k[Ce] - 7; H++)
              O[256 + We++] = Ce;
          for (be = 0; be <= y; be++)
            xe[be] = 0;
          for (H = 0; H <= 143; )
            U[2 * H + 1] = 8, H++, xe[8]++;
          for (; H <= 255; )
            U[2 * H + 1] = 9, H++, xe[9]++;
          for (; H <= 279; )
            U[2 * H + 1] = 7, H++, xe[7]++;
          for (; H <= 287; )
            U[2 * H + 1] = 8, H++, xe[8]++;
          for ($(U, p + 1, xe), H = 0; H < f; H++)
            N[2 * H + 1] = 5, N[2 * H] = pe(H, 5);
          ae = new W(U, C, d + 1, p, y), Q = new W(N, k, 0, f, y), ne = new W(new Array(0), S, 0, h, v);
        }(), z = !0), R.l_desc = new X(R.dyn_ltree, ae), R.d_desc = new X(R.dyn_dtree, Q), R.bl_desc = new X(R.bl_tree, ne), R.bi_buf = 0, R.bi_valid = 0, F(R);
      }, a._tr_stored_block = A, a._tr_flush_block = function(R, H, be, me) {
        var Ce, We, xe = 0;
        0 < R.level ? (R.strm.data_type === 2 && (R.strm.data_type = function(we) {
          var te, Fe = 4093624447;
          for (te = 0; te <= 31; te++, Fe >>>= 1)
            if (1 & Fe && we.dyn_ltree[2 * te] !== 0)
              return i;
          if (we.dyn_ltree[18] !== 0 || we.dyn_ltree[20] !== 0 || we.dyn_ltree[26] !== 0)
            return o;
          for (te = 32; te < d; te++)
            if (we.dyn_ltree[2 * te] !== 0)
              return o;
          return i;
        }(R)), Te(R, R.l_desc), Te(R, R.d_desc), xe = function(we) {
          var te;
          for (V(we, we.dyn_ltree, we.l_desc.max_code), V(we, we.dyn_dtree, we.d_desc.max_code), Te(we, we.bl_desc), te = h - 1; 3 <= te && we.bl_tree[2 * B[te] + 1] === 0; te--)
            ;
          return we.opt_len += 3 * (te + 1) + 5 + 5 + 4, te;
        }(R), Ce = R.opt_len + 3 + 7 >>> 3, (We = R.static_len + 3 + 7 >>> 3) <= Ce && (Ce = We)) : Ce = We = be + 5, be + 4 <= Ce && H !== -1 ? A(R, H, be, me) : R.strategy === 4 || We === Ce ? (he(R, 2 + (me ? 1 : 0), 3), re(R, U, N)) : (he(R, 4 + (me ? 1 : 0), 3), function(we, te, Fe, Y) {
          var Je;
          for (he(we, te - 257, 5), he(we, Fe - 1, 5), he(we, Y - 4, 4), Je = 0; Je < Y; Je++)
            he(we, we.bl_tree[2 * B[Je] + 1], 3);
          Pe(we, we.dyn_ltree, te - 1), Pe(we, we.dyn_dtree, Fe - 1);
        }(R, R.l_desc.max_code + 1, R.d_desc.max_code + 1, xe + 1), re(R, R.dyn_ltree, R.dyn_dtree)), F(R), me && ge(R);
      }, a._tr_tally = function(R, H, be) {
        return R.pending_buf[R.d_buf + 2 * R.last_lit] = H >>> 8 & 255, R.pending_buf[R.d_buf + 2 * R.last_lit + 1] = 255 & H, R.pending_buf[R.l_buf + R.last_lit] = 255 & be, R.last_lit++, H === 0 ? R.dyn_ltree[2 * be]++ : (R.matches++, H--, R.dyn_ltree[2 * (I[be] + d + 1)]++, R.dyn_dtree[2 * G(H)]++), R.last_lit === R.lit_bufsize - 1;
      }, a._tr_align = function(R) {
        he(R, 2, 3), ye(R, x, U), function(H) {
          H.bi_valid === 16 ? (P(H, H.bi_buf), H.bi_buf = 0, H.bi_valid = 0) : 8 <= H.bi_valid && (H.pending_buf[H.pending++] = 255 & H.bi_buf, H.bi_buf >>= 8, H.bi_valid -= 8);
        }(R);
      };
    }, { "../utils/common": 41 }], 53: [function(r, n, a) {
      n.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(r, n, a) {
      (function(s) {
        (function(i, o) {
          if (!i.setImmediate) {
            var l, u, c, d, p = 1, f = {}, h = !1, m = i.document, y = Object.getPrototypeOf && Object.getPrototypeOf(i);
            y = y && y.setTimeout ? y : i, l = {}.toString.call(i.process) === "[object process]" ? function(_) {
              an.nextTick(function() {
                v(_);
              });
            } : function() {
              if (i.postMessage && !i.importScripts) {
                var _ = !0, E = i.onmessage;
                return i.onmessage = function() {
                  _ = !1;
                }, i.postMessage("", "*"), i.onmessage = E, _;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", i.addEventListener ? i.addEventListener("message", x, !1) : i.attachEvent("onmessage", x), function(_) {
              i.postMessage(d + _, "*");
            }) : i.MessageChannel ? ((c = new MessageChannel()).port1.onmessage = function(_) {
              v(_.data);
            }, function(_) {
              c.port2.postMessage(_);
            }) : m && "onreadystatechange" in m.createElement("script") ? (u = m.documentElement, function(_) {
              var E = m.createElement("script");
              E.onreadystatechange = function() {
                v(_), E.onreadystatechange = null, u.removeChild(E), E = null;
              }, u.appendChild(E);
            }) : function(_) {
              setTimeout(v, 0, _);
            }, y.setImmediate = function(_) {
              typeof _ != "function" && (_ = new Function("" + _));
              for (var E = new Array(arguments.length - 1), w = 0; w < E.length; w++)
                E[w] = arguments[w + 1];
              var C = { callback: _, args: E };
              return f[p] = C, l(p), p++;
            }, y.clearImmediate = b;
          }
          function b(_) {
            delete f[_];
          }
          function v(_) {
            if (h)
              setTimeout(v, 0, _);
            else {
              var E = f[_];
              if (E) {
                h = !0;
                try {
                  (function(w) {
                    var C = w.callback, k = w.args;
                    switch (k.length) {
                      case 0:
                        C();
                        break;
                      case 1:
                        C(k[0]);
                        break;
                      case 2:
                        C(k[0], k[1]);
                        break;
                      case 3:
                        C(k[0], k[1], k[2]);
                        break;
                      default:
                        C.apply(o, k);
                    }
                  })(E);
                } finally {
                  b(_), h = !1;
                }
              }
            }
          }
          function x(_) {
            _.source === i && typeof _.data == "string" && _.data.indexOf(d) === 0 && v(+_.data.slice(d.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof no < "u" ? no : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(zG);
var Jke = zG.exports;
const Qke = /* @__PURE__ */ AV(Jke);
var Yg = { exports: {} }, eCe = {
  "&": "&amp;",
  '"': "&quot;",
  "'": "&apos;",
  "<": "&lt;",
  ">": "&gt;"
};
function tCe(e) {
  return e && e.replace ? e.replace(/([&"<>'])/g, function(t, r) {
    return eCe[r];
  }) : e;
}
var rCe = tCe, DR = rCe, l5 = BN.Stream, nCe = "    ";
function iCe(e, t) {
  typeof t != "object" && (t = {
    indent: t
  });
  var r = t.stream ? new l5() : null, n = "", a = !1, s = t.indent ? t.indent === !0 ? nCe : t.indent : "", i = !0;
  function o(p) {
    i ? an.nextTick(p) : p();
  }
  function l(p, f) {
    if (f !== void 0 && (n += f), p && !a && (r = r || new l5(), a = !0), p && a) {
      var h = n;
      o(function() {
        r.emit("data", h);
      }), n = "";
    }
  }
  function u(p, f) {
    QN(l, Xg(p, s, s ? 1 : 0), f);
  }
  function c() {
    if (r) {
      var p = n;
      o(function() {
        r.emit("data", p), r.emit("end"), r.readable = !1, r.emit("close");
      });
    }
  }
  function d(p) {
    var f = p.encoding || "UTF-8", h = { version: "1.0", encoding: f };
    p.standalone && (h.standalone = p.standalone), u({ "?xml": { _attr: h } }), n = n.replace("/>", "?>");
  }
  return o(function() {
    i = !1;
  }), t.declaration && d(t.declaration), e && e.forEach ? e.forEach(function(p, f) {
    var h;
    f + 1 === e.length && (h = c), u(p, h);
  }) : u(e, c), r ? (r.readable = !0, r) : n;
}
function aCe() {
  var e = Array.prototype.slice.call(arguments), t = {
    _elem: Xg(e)
  };
  return t.push = function(r) {
    if (!this.append)
      throw new Error("not assigned to a parent!");
    var n = this, a = this._elem.indent;
    QN(
      this.append,
      Xg(
        r,
        a,
        this._elem.icount + (a ? 1 : 0)
      ),
      function() {
        n.append(!0);
      }
    );
  }, t.close = function(r) {
    r !== void 0 && this.push(r), this.end && this.end();
  }, t;
}
function sCe(e, t) {
  return new Array(t || 0).join(e || "");
}
function Xg(e, t, r) {
  r = r || 0;
  var n = sCe(t, r), a, s = e, i = !1;
  if (typeof e == "object") {
    var o = Object.keys(e);
    if (a = o[0], s = e[a], s && s._elem)
      return s._elem.name = a, s._elem.icount = r, s._elem.indent = t, s._elem.indents = n, s._elem.interrupt = s, s._elem;
  }
  var l = [], u = [], c;
  function d(p) {
    var f = Object.keys(p);
    f.forEach(function(h) {
      l.push(oCe(h, p[h]));
    });
  }
  switch (typeof s) {
    case "object":
      if (s === null)
        break;
      s._attr && d(s._attr), s._cdata && u.push(
        ("<![CDATA[" + s._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
      ), s.forEach && (c = !1, u.push(""), s.forEach(function(p) {
        if (typeof p == "object") {
          var f = Object.keys(p)[0];
          f == "_attr" ? d(p._attr) : u.push(Xg(
            p,
            t,
            r + 1
          ));
        } else
          u.pop(), c = !0, u.push(DR(p));
      }), c || u.push(""));
      break;
    default:
      u.push(DR(s));
  }
  return {
    name: a,
    interrupt: i,
    attributes: l,
    content: u,
    icount: r,
    indents: n,
    indent: t
  };
}
function QN(e, t, r) {
  if (typeof t != "object")
    return e(!1, t);
  var n = t.interrupt ? 1 : t.content.length;
  function a() {
    for (; t.content.length; ) {
      var i = t.content.shift();
      if (i !== void 0) {
        if (s(i))
          return;
        QN(e, i);
      }
    }
    e(!1, (n > 1 ? t.indents : "") + (t.name ? "</" + t.name + ">" : "") + (t.indent && !r ? `
` : "")), r && r();
  }
  function s(i) {
    return i.interrupt ? (i.interrupt.append = e, i.interrupt.end = a, i.interrupt = !1, e(!0), !0) : !1;
  }
  if (e(!1, t.indents + (t.name ? "<" + t.name : "") + (t.attributes.length ? " " + t.attributes.join(" ") : "") + (n ? t.name ? ">" : "" : t.name ? "/>" : "") + (t.indent && n > 1 ? `
` : "")), !n)
    return e(!1, t.indent ? `
` : "");
  s(t) || a();
}
function oCe(e, t) {
  return e + '="' + DR(t) + '"';
}
Yg.exports = iCe;
Yg.exports.element = Yg.exports.Element = aCe;
var lCe = Yg.exports;
const ui = /* @__PURE__ */ AV(lCe), u5 = 0, c5 = 32, uCe = 32, cCe = (e, t) => {
  const r = t.replace(/-/g, "");
  if (r.length !== uCe)
    throw new Error(`Error: Cannot extract GUID from font filename: ${t}`);
  const a = r.replace(/(..)/g, "$1 ").trim().split(" ").map((l) => parseInt(l, 16));
  a.reverse();
  const i = e.slice(u5, c5).map((l, u) => l ^ a[u % a.length]);
  return Buffer.concat([e.slice(0, u5), i, e.slice(c5)]);
};
class dCe {
  // tslint:disable-next-line: no-object-literal-type-assertion
  format(t, r = { stack: [] }) {
    const n = t.prepForXml(r);
    if (n)
      return n;
    throw Error("XMLComponent did not format correctly");
  }
}
class fCe {
  replace(t, r, n) {
    let a = t;
    return r.forEach((s, i) => {
      a = a.replace(new RegExp(`{${s.fileName}}`, "g"), (n + i).toString());
    }), a;
  }
  getMediaData(t, r) {
    return r.Array.filter((n) => t.search(`{${n.fileName}}`) > 0);
  }
}
class pCe {
  replace(t, r) {
    let n = t;
    for (const a of r)
      n = n.replace(
        new RegExp(`{${a.reference}-${a.instance}}`, "g"),
        a.numId.toString()
      );
    return n;
  }
}
class hCe {
  constructor() {
    st(this, "formatter"), st(this, "imageReplacer"), st(this, "numberingReplacer"), this.formatter = new dCe(), this.imageReplacer = new fCe(), this.numberingReplacer = new pCe();
  }
  compile(t, r) {
    const n = new Qke(), a = this.xmlifyFile(t, r), s = new Map(Object.entries(a));
    for (const [, i] of s)
      if (Array.isArray(i))
        for (const o of i)
          n.file(o.path, o.data);
      else
        n.file(i.path, i.data);
    for (const { stream: i, fileName: o } of t.Media.Array)
      n.file(`word/media/${o}`, i);
    for (const { data: i, name: o, fontKey: l } of t.FontTable.fontOptionsWithKey) {
      const [u] = o.split(".");
      n.file(`word/fonts/${u}.odttf`, cCe(i, l));
    }
    return n;
  }
  xmlifyFile(t, r) {
    const n = t.Document.Relationships.RelationshipCount + 1, a = ui(
      this.formatter.format(t.Document.View, {
        viewWrapper: t.Document,
        file: t,
        stack: []
      }),
      {
        indent: r,
        declaration: {
          standalone: "yes",
          encoding: "UTF-8"
        }
      }
    ), s = this.imageReplacer.getMediaData(a, t.Media);
    return {
      Relationships: {
        data: (s.forEach((i, o) => {
          t.Document.Relationships.createRelationship(
            n + o,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${i.fileName}`
          );
        }), ui(
          this.formatter.format(t.Document.Relationships, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        )),
        path: "word/_rels/document.xml.rels"
      },
      Document: {
        data: (() => {
          const i = this.imageReplacer.replace(a, s, n);
          return this.numberingReplacer.replace(i, t.Numbering.ConcreteNumbering);
        })(),
        path: "word/document.xml"
      },
      Styles: {
        data: (() => {
          const i = ui(
            this.formatter.format(t.Styles, {
              viewWrapper: t.Document,
              file: t,
              stack: []
            }),
            {
              indent: r,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          );
          return this.numberingReplacer.replace(i, t.Numbering.ConcreteNumbering);
        })(),
        path: "word/styles.xml"
      },
      Properties: {
        data: ui(
          this.formatter.format(t.CoreProperties, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/core.xml"
      },
      Numbering: {
        data: ui(
          this.formatter.format(t.Numbering, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/numbering.xml"
      },
      FileRelationships: {
        data: ui(
          this.formatter.format(t.FileRelationships, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "_rels/.rels"
      },
      HeaderRelationships: t.Headers.map((i, o) => {
        const l = ui(
          this.formatter.format(i.View, {
            viewWrapper: i,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        return this.imageReplacer.getMediaData(l, t.Media).forEach((c, d) => {
          i.Relationships.createRelationship(
            d,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${c.fileName}`
          );
        }), {
          data: ui(
            this.formatter.format(i.Relationships, {
              viewWrapper: i,
              file: t,
              stack: []
            }),
            {
              indent: r,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/header${o + 1}.xml.rels`
        };
      }),
      FooterRelationships: t.Footers.map((i, o) => {
        const l = ui(
          this.formatter.format(i.View, {
            viewWrapper: i,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        return this.imageReplacer.getMediaData(l, t.Media).forEach((c, d) => {
          i.Relationships.createRelationship(
            d,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${c.fileName}`
          );
        }), {
          data: ui(
            this.formatter.format(i.Relationships, {
              viewWrapper: i,
              file: t,
              stack: []
            }),
            {
              indent: r,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/footer${o + 1}.xml.rels`
        };
      }),
      Headers: t.Headers.map((i, o) => {
        const l = ui(
          this.formatter.format(i.View, {
            viewWrapper: i,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ), u = this.imageReplacer.getMediaData(l, t.Media), c = this.imageReplacer.replace(l, u, 0);
        return {
          data: this.numberingReplacer.replace(c, t.Numbering.ConcreteNumbering),
          path: `word/header${o + 1}.xml`
        };
      }),
      Footers: t.Footers.map((i, o) => {
        const l = ui(
          this.formatter.format(i.View, {
            viewWrapper: i,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ), u = this.imageReplacer.getMediaData(l, t.Media), c = this.imageReplacer.replace(l, u, 0);
        return {
          data: this.numberingReplacer.replace(c, t.Numbering.ConcreteNumbering),
          path: `word/footer${o + 1}.xml`
        };
      }),
      ContentTypes: {
        data: ui(
          this.formatter.format(t.ContentTypes, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "[Content_Types].xml"
      },
      CustomProperties: {
        data: ui(
          this.formatter.format(t.CustomProperties, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/custom.xml"
      },
      AppProperties: {
        data: ui(
          this.formatter.format(t.AppProperties, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/app.xml"
      },
      FootNotes: {
        data: ui(
          this.formatter.format(t.FootNotes.View, {
            viewWrapper: t.FootNotes,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/footnotes.xml"
      },
      FootNotesRelationships: {
        data: ui(
          this.formatter.format(t.FootNotes.Relationships, {
            viewWrapper: t.FootNotes,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/_rels/footnotes.xml.rels"
      },
      Settings: {
        data: ui(
          this.formatter.format(t.Settings, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/settings.xml"
      },
      Comments: {
        data: ui(
          this.formatter.format(t.Comments, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/comments.xml"
      },
      FontTable: {
        data: ui(
          this.formatter.format(t.FontTable.View, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/fontTable.xml"
      },
      FontTableRelationships: {
        data: ui(
          this.formatter.format(t.FontTable.Relationships, {
            viewWrapper: t.Document,
            file: t,
            stack: []
          }),
          {
            indent: r,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/_rels/fontTable.xml.rels"
      }
    };
  }
}
const mCe = {
  NONE: "",
  WITH_2_BLANKS: "  ",
  WITH_4_BLANKS: "    ",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  WITH_TAB: "	"
}, yf = (e) => e === !0 ? mCe.WITH_2_BLANKS : e === !1 ? void 0 : e;
class OR {
  static toString(t, r) {
    return bm(this, null, function* () {
      return yield this.compiler.compile(t, yf(r)).generateAsync({
        type: "string",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBuffer(t, r) {
    return bm(this, null, function* () {
      return yield this.compiler.compile(t, yf(r)).generateAsync({
        type: "nodebuffer",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBase64String(t, r) {
    return bm(this, null, function* () {
      return yield this.compiler.compile(t, yf(r)).generateAsync({
        type: "base64",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBlob(t, r) {
    return bm(this, null, function* () {
      return yield this.compiler.compile(t, yf(r)).generateAsync({
        type: "blob",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toStream(t, r) {
    const n = new BN.Stream();
    return this.compiler.compile(t, yf(r)).generateAsync({
      type: "nodebuffer",
      mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      compression: "DEFLATE"
    }).then((s) => {
      n.emit("data", s), n.emit("end");
    }), n;
  }
}
st(OR, "compiler", new hCe());
function Zg(e) {
  if (e)
    throw e;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Px, d5;
function gCe() {
  return d5 || (d5 = 1, Px = function(t) {
    return t != null && t.constructor != null && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
  }), Px;
}
var bCe = gCe();
const qG = /* @__PURE__ */ da(bCe);
var Lx, f5;
function yCe() {
  if (f5) return Lx;
  f5 = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, r = Object.defineProperty, n = Object.getOwnPropertyDescriptor, a = function(u) {
    return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
  }, s = function(u) {
    if (!u || t.call(u) !== "[object Object]")
      return !1;
    var c = e.call(u, "constructor"), d = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
    if (u.constructor && !c && !d)
      return !1;
    var p;
    for (p in u)
      ;
    return typeof p > "u" || e.call(u, p);
  }, i = function(u, c) {
    r && c.name === "__proto__" ? r(u, c.name, {
      enumerable: !0,
      configurable: !0,
      value: c.newValue,
      writable: !0
    }) : u[c.name] = c.newValue;
  }, o = function(u, c) {
    if (c === "__proto__")
      if (e.call(u, c)) {
        if (n)
          return n(u, c).value;
      } else return;
    return u[c];
  };
  return Lx = function l() {
    var u, c, d, p, f, h, m = arguments[0], y = 1, b = arguments.length, v = !1;
    for (typeof m == "boolean" && (v = m, m = arguments[1] || {}, y = 2), (m == null || typeof m != "object" && typeof m != "function") && (m = {}); y < b; ++y)
      if (u = arguments[y], u != null)
        for (c in u)
          d = o(m, c), p = o(u, c), m !== p && (v && p && (s(p) || (f = a(p))) ? (f ? (f = !1, h = d && a(d) ? d : []) : h = d && s(d) ? d : {}, i(m, { name: c, newValue: l(v, h, p) })) : typeof p < "u" && i(m, { name: c, newValue: p }));
    return m;
  }, Lx;
}
var vCe = yCe();
const ep = /* @__PURE__ */ da(vCe);
function md(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function jG() {
  const e = [], t = { run: r, use: n };
  return t;
  function r(...a) {
    let s = -1;
    const i = a.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...a);
    function o(l, ...u) {
      const c = e[++s];
      let d = -1;
      if (l) {
        i(l);
        return;
      }
      for (; ++d < a.length; )
        (u[d] === null || u[d] === void 0) && (u[d] = a[d]);
      a = u, c ? wCe(c, o)(...u) : i(null, ...u);
    }
  }
  function n(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function wCe(e, t) {
  let r;
  return n;
  function n(...i) {
    const o = e.length > i.length;
    let l;
    o && i.push(a);
    try {
      l = e.apply(this, i);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (o && r)
        throw c;
      return a(c);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(s, a) : l instanceof Error ? a(l) : s(l));
  }
  function a(i, ...o) {
    r || (r = !0, t(i, ...o));
  }
  function s(i) {
    a(null, i);
  }
}
function xCe(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? p5(e.position) : "start" in e || "end" in e ? p5(e) : "line" in e || "column" in e ? PR(e) : "";
}
function PR(e) {
  return h5(e && e.line) + ":" + h5(e && e.column);
}
function p5(e) {
  return PR(e && e.start) + "-" + PR(e && e.end);
}
function h5(e) {
  return e && typeof e == "number" ? e : 1;
}
let hs = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(t, r, n) {
    const a = [null, null];
    let s = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof r == "string" && (n = r, r = void 0), typeof n == "string") {
      const i = n.indexOf(":");
      i === -1 ? a[1] = n : (a[0] = n.slice(0, i), a[1] = n.slice(i + 1));
    }
    r && ("type" in r || "position" in r ? r.position && (s = r.position) : "start" in r || "end" in r ? s = r : ("line" in r || "column" in r) && (s.start = r)), this.name = xCe(r) || "1:1", this.message = typeof t == "object" ? t.message : t, this.stack = "", typeof t == "object" && t.stack && (this.stack = t.stack), this.reason = this.message, this.fatal, this.line = s.start.line, this.column = s.start.column, this.position = s, this.source = a[0], this.ruleId = a[1], this.file, this.actual, this.expected, this.url, this.note;
  }
};
hs.prototype.file = "";
hs.prototype.name = "";
hs.prototype.reason = "";
hs.prototype.message = "";
hs.prototype.stack = "";
hs.prototype.fatal = null;
hs.prototype.column = null;
hs.prototype.line = null;
hs.prototype.source = null;
hs.prototype.ruleId = null;
hs.prototype.position = null;
const Xs = { basename: ECe, dirname: SCe, extname: _Ce, join: kCe, sep: "/" };
function ECe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  kh(e);
  let r = 0, n = -1, a = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.charCodeAt(a) === 47) {
        if (s) {
          r = a + 1;
          break;
        }
      } else n < 0 && (s = !0, n = a + 1);
    return n < 0 ? "" : e.slice(r, n);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; a--; )
    if (e.charCodeAt(a) === 47) {
      if (s) {
        r = a + 1;
        break;
      }
    } else
      i < 0 && (s = !0, i = a + 1), o > -1 && (e.charCodeAt(a) === t.charCodeAt(o--) ? o < 0 && (n = a) : (o = -1, n = i));
  return r === n ? n = i : n < 0 && (n = e.length), e.slice(r, n);
}
function SCe(e) {
  if (kh(e), e.length === 0)
    return ".";
  let t = -1, r = e.length, n;
  for (; --r; )
    if (e.charCodeAt(r) === 47) {
      if (n) {
        t = r;
        break;
      }
    } else n || (n = !0);
  return t < 0 ? e.charCodeAt(0) === 47 ? "/" : "." : t === 1 && e.charCodeAt(0) === 47 ? "//" : e.slice(0, t);
}
function _Ce(e) {
  kh(e);
  let t = e.length, r = -1, n = 0, a = -1, s = 0, i;
  for (; t--; ) {
    const o = e.charCodeAt(t);
    if (o === 47) {
      if (i) {
        n = t + 1;
        break;
      }
      continue;
    }
    r < 0 && (i = !0, r = t + 1), o === 46 ? a < 0 ? a = t : s !== 1 && (s = 1) : a > -1 && (s = -1);
  }
  return a < 0 || r < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && a === r - 1 && a === n + 1 ? "" : e.slice(a, r);
}
function kCe(...e) {
  let t = -1, r;
  for (; ++t < e.length; )
    kh(e[t]), e[t] && (r = r === void 0 ? e[t] : r + "/" + e[t]);
  return r === void 0 ? "." : CCe(r);
}
function CCe(e) {
  kh(e);
  const t = e.charCodeAt(0) === 47;
  let r = ACe(e, !t);
  return r.length === 0 && !t && (r = "."), r.length > 0 && e.charCodeAt(e.length - 1) === 47 && (r += "/"), t ? "/" + r : r;
}
function ACe(e, t) {
  let r = "", n = 0, a = -1, s = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.charCodeAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(a === i - 1 || s === 1)) if (a !== i - 1 && s === 2) {
        if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            if (l = r.lastIndexOf("/"), l !== r.length - 1) {
              l < 0 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), a = i, s = 0;
              continue;
            }
          } else if (r.length > 0) {
            r = "", n = 0, a = i, s = 0;
            continue;
          }
        }
        t && (r = r.length > 0 ? r + "/.." : "..", n = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(a + 1, i) : r = e.slice(a + 1, i), n = i - a - 1;
      a = i, s = 0;
    } else o === 46 && s > -1 ? s++ : s = -1;
  }
  return r;
}
function kh(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const TCe = { cwd: RCe };
function RCe() {
  return "/";
}
function LR(e) {
  return e !== null && typeof e == "object" && // @ts-expect-error: indexable.
  e.href && // @ts-expect-error: indexable.
  e.origin;
}
function ICe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!LR(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return NCe(e);
}
function NCe(e) {
  if (e.hostname !== "") {
    const n = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw n.code = "ERR_INVALID_FILE_URL_HOST", n;
  }
  const t = e.pathname;
  let r = -1;
  for (; ++r < t.length; )
    if (t.charCodeAt(r) === 37 && t.charCodeAt(r + 1) === 50) {
      const n = t.charCodeAt(r + 2);
      if (n === 70 || n === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const Mx = ["history", "path", "basename", "stem", "extname", "dirname"];
let DCe = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let r;
    t ? typeof t == "string" || OCe(t) ? r = { value: t } : LR(t) ? r = { path: t } : r = t : r = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = TCe.cwd(), this.value, this.stored, this.result, this.map;
    let n = -1;
    for (; ++n < Mx.length; ) {
      const s = Mx[n];
      s in r && r[s] !== void 0 && r[s] !== null && (this[s] = s === "history" ? [...r[s]] : r[s]);
    }
    let a;
    for (a in r)
      Mx.includes(a) || (this[a] = r[a]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(t) {
    LR(t) && (t = ICe(t)), $x(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Xs.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(t) {
    m5(this.basename, "dirname"), this.path = Xs.join(t || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Xs.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(t) {
    $x(t, "basename"), Fx(t, "basename"), this.path = Xs.join(this.dirname || "", t);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Xs.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(t) {
    if (Fx(t, "extname"), m5(this.dirname, "extname"), t) {
      if (t.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Xs.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Xs.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(t) {
    $x(t, "stem"), Fx(t, "stem"), this.path = Xs.join(this.dirname || "", t + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return (this.value || "").toString(t || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, r, n) {
    const a = new hs(t, r, n);
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, r, n) {
    const a = this.message(t, r, n);
    return a.fatal = null, a;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, r, n) {
    const a = this.message(t, r, n);
    throw a.fatal = !0, a;
  }
};
function Fx(e, t) {
  if (e && e.includes(Xs.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Xs.sep + "`"
    );
}
function $x(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function m5(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function OCe(e) {
  return qG(e);
}
const eD = VG().freeze(), HG = {}.hasOwnProperty;
function VG() {
  const e = jG(), t = [];
  let r = {}, n, a = -1;
  return s.data = i, s.Parser = void 0, s.Compiler = void 0, s.freeze = o, s.attachers = t, s.use = l, s.parse = u, s.stringify = c, s.run = d, s.runSync = p, s.process = f, s.processSync = h, s;
  function s() {
    const m = VG();
    let y = -1;
    for (; ++y < t.length; )
      m.use(...t[y]);
    return m.data(ep(!0, {}, r)), m;
  }
  function i(m, y) {
    return typeof m == "string" ? arguments.length === 2 ? (zx("data", n), r[m] = y, s) : HG.call(r, m) && r[m] || null : m ? (zx("data", n), r = m, s) : r;
  }
  function o() {
    if (n)
      return s;
    for (; ++a < t.length; ) {
      const [m, ...y] = t[a];
      if (y[0] === !1)
        continue;
      y[0] === !0 && (y[0] = void 0);
      const b = m.call(s, ...y);
      typeof b == "function" && e.use(b);
    }
    return n = !0, a = Number.POSITIVE_INFINITY, s;
  }
  function l(m, ...y) {
    let b;
    if (zx("use", n), m != null) if (typeof m == "function")
      E(m, ...y);
    else if (typeof m == "object")
      Array.isArray(m) ? _(m) : x(m);
    else
      throw new TypeError("Expected usable value, not `" + m + "`");
    return b && (r.settings = Object.assign(r.settings || {}, b)), s;
    function v(w) {
      if (typeof w == "function")
        E(w);
      else if (typeof w == "object")
        if (Array.isArray(w)) {
          const [C, ...k] = w;
          E(C, ...k);
        } else
          x(w);
      else
        throw new TypeError("Expected usable value, not `" + w + "`");
    }
    function x(w) {
      _(w.plugins), w.settings && (b = Object.assign(b || {}, w.settings));
    }
    function _(w) {
      let C = -1;
      if (w != null) if (Array.isArray(w))
        for (; ++C < w.length; ) {
          const k = w[C];
          v(k);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + w + "`");
    }
    function E(w, C) {
      let k = -1, S;
      for (; ++k < t.length; )
        if (t[k][0] === w) {
          S = t[k];
          break;
        }
      S ? (md(S[1]) && md(C) && (C = ep(!0, S[1], C)), S[1] = C) : t.push([...arguments]);
    }
  }
  function u(m) {
    s.freeze();
    const y = vf(m), b = s.Parser;
    return Bx("parse", b), g5(b, "parse") ? new b(String(y), y).parse() : b(String(y), y);
  }
  function c(m, y) {
    s.freeze();
    const b = vf(y), v = s.Compiler;
    return Ux("stringify", v), b5(m), g5(v, "compile") ? new v(m, b).compile() : v(m, b);
  }
  function d(m, y, b) {
    if (b5(m), s.freeze(), !b && typeof y == "function" && (b = y, y = void 0), !b)
      return new Promise(v);
    v(null, b);
    function v(x, _) {
      e.run(m, vf(y), E);
      function E(w, C, k) {
        C = C || m, w ? _(w) : x ? x(C) : b(null, C, k);
      }
    }
  }
  function p(m, y) {
    let b, v;
    return s.run(m, y, x), y5("runSync", "run", v), b;
    function x(_, E) {
      Zg(_), b = E, v = !0;
    }
  }
  function f(m, y) {
    if (s.freeze(), Bx("process", s.Parser), Ux("process", s.Compiler), !y)
      return new Promise(b);
    b(null, y);
    function b(v, x) {
      const _ = vf(m);
      s.run(s.parse(_), _, (w, C, k) => {
        if (w || !C || !k)
          E(w);
        else {
          const S = s.stringify(C, k);
          S == null || (MCe(S) ? k.value = S : k.result = S), E(w, k);
        }
      });
      function E(w, C) {
        w || !C ? x(w) : v ? v(C) : y(null, C);
      }
    }
  }
  function h(m) {
    let y;
    s.freeze(), Bx("processSync", s.Parser), Ux("processSync", s.Compiler);
    const b = vf(m);
    return s.process(b, v), y5("processSync", "process", y), b;
    function v(x) {
      y = !0, Zg(x);
    }
  }
}
function g5(e, t) {
  return typeof e == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  e.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (PCe(e.prototype) || t in e.prototype);
}
function PCe(e) {
  let t;
  for (t in e)
    if (HG.call(e, t))
      return !0;
  return !1;
}
function Bx(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `Parser`");
}
function Ux(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `Compiler`");
}
function zx(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function b5(e) {
  if (!md(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function y5(e, t, r) {
  if (!r)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function vf(e) {
  return LCe(e) ? e : new DCe(e);
}
function LCe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function MCe(e) {
  return typeof e == "string" || qG(e);
}
const FCe = {
  author: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  address: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  curraddr: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  email: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  title: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  urladdr: {
    signature: "o m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  }
}, $Ce = {}, BCe = {
  cref: { signature: "s m" },
  Cref: { signature: "s m" },
  crefrange: { signature: "s m m" },
  Crefrange: { signature: "s m m" },
  cpageref: { signature: "s m" },
  Cpageref: { signature: "s m" },
  ref: { signature: "m" },
  pageref: { signature: "m" },
  namecref: { signature: "m" },
  nameCref: { signature: "m" },
  lcnamecref: { signature: "m" },
  namecrefs: { signature: "m" },
  nameCrefs: { signature: "m" },
  lcnamecrefs: { signature: "m" },
  labelcref: { signature: "m" },
  labelcpageref: { signature: "m" },
  crefalias: { signature: "m m" },
  crefname: { signature: "m m m" },
  // XXX there are many more obscure commands to add here
  // https://ctan.org/pkg/cleveref
  crefdefaultlabelformat: { signature: "m" },
  crefrangeconjunction: { signature: "m" }
}, UCe = {}, GG = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
}, zCe = new Set(
  Object.values(GG).map((e) => e.closeMark).filter((e) => e)
);
function qCe(e) {
  const t = [];
  for (const r of e.split("")) {
    if (zCe.has(r))
      continue;
    const n = GG[r];
    if (n == null)
      throw new Error(`Unknown open/close mark type "${r}"`);
    t.push(n);
  }
  return t;
}
function Ai(e, t) {
  if (e == null)
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  if (typeof e == "string" && (e = jCe(e)), !Array.isArray(e) && e.type === "argument")
    return e;
  let r = t?.openMark ?? "{", n = t?.closeMark ?? "}";
  if (t?.braces) {
    const a = qCe(t.braces);
    a[0] && (r = a[0].openMark, n = a[0].closeMark);
  }
  return Array.isArray(e) || (e = [e]), { type: "argument", content: e, openMark: r, closeMark: n };
}
function jCe(e) {
  return typeof e == "string" ? { type: "string", content: e } : e;
}
const Bf = Symbol("linebreak"), gc = "\\";
function ra(e) {
  if (typeof e == "string")
    return [e];
  if (Array.isArray(e))
    return [].concat(
      ...e.map((n) => ra(n))
    );
  let t, r;
  switch (e.type) {
    case "root":
      return ra(e.content);
    case "argument":
      return [e.openMark, ...ra(e.content), e.closeMark];
    case "comment":
      let n = e.suffixParbreak ? "" : Bf, a = "";
      return e.sameline && e.leadingWhitespace && (a = " "), e.sameline ? [
        a,
        "%",
        ...ra(e.content),
        n
      ] : [Bf, "%", ...ra(e.content), n];
    case "environment":
    case "mathenv":
    case "verbatim":
      let s = ra(e.env), i = [gc + "begin{", ...s, "}"], o = [gc + "end{", ...s, "}"];
      return t = e.args == null ? [] : ra(e.args), [
        ...i,
        ...t,
        ...ra(e.content),
        ...o
      ];
    case "displaymath":
      return [gc + "[", ...ra(e.content), gc + "]"];
    case "group":
      return ["{", ...ra(e.content), "}"];
    case "inlinemath":
      return ["$", ...ra(e.content), "$"];
    case "macro":
      return t = e.args == null ? [] : ra(e.args), r = e.escapeToken == null ? gc : e.escapeToken, [r, ...ra(e.content), ...t];
    case "parbreak":
      return [Bf, Bf];
    case "string":
      return [e.content];
    case "verb":
      return [
        gc,
        e.env,
        e.escape,
        ...ra(e.content),
        e.escape
      ];
    case "whitespace":
      return [" "];
    default:
      return console.warn(
        "Cannot find render for node ",
        e,
        `(of type ${typeof e})`
      ), ["" + e];
  }
}
function Ho(e, t) {
  return ra(e).map((n) => n === Bf ? `
` : n).join("");
}
function HCe(e) {
  const t = Array.isArray(e) ? e.length > 0 ? typeof e[0] == "string" ? Object.fromEntries(
    e.map((r) => {
      if (typeof r != "string")
        throw new Error("Wrong branch of map function");
      return [r, {}];
    })
  ) : Object.fromEntries(
    e.map((r) => {
      if (typeof r == "string")
        throw new Error("Wrong branch of map function");
      return r.escapeToken != null ? [
        r.content,
        { escapeToken: r.escapeToken }
      ] : [r.content, {}];
    })
  ) : {} : e;
  return function(n) {
    if (n == null || n.type !== "macro")
      return !1;
    const a = t[n.content];
    return a ? typeof a == "object" && "escapeToken" in a ? a.escapeToken == null || a.escapeToken === n.escapeToken : !0 : !1;
  };
}
function VCe(e) {
  const t = Array.isArray(e) ? Object.fromEntries(
    e.map((r) => [r, {}])
  ) : e;
  return function(n) {
    if (!vr.anyEnvironment(n))
      return !1;
    const a = Ho(n.env);
    return !!t[a];
  };
}
const vr = {
  macro(e, t) {
    return e == null ? !1 : e.type === "macro" && (t == null || e.content === t);
  },
  anyMacro(e) {
    return vr.macro(e);
  },
  environment(e, t) {
    return e == null ? !1 : (e.type === "environment" || e.type === "mathenv") && (t == null || Ho(e.env) === t);
  },
  anyEnvironment(e) {
    return vr.environment(e);
  },
  comment(e) {
    return e == null ? !1 : e.type === "comment";
  },
  parbreak(e) {
    return e == null ? !1 : e.type === "parbreak";
  },
  whitespace(e) {
    return e == null ? !1 : e.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(e) {
    return e == null ? !1 : e.type === "whitespace" || e.type === "whitespace" && e.leadingWhitespace === !0;
  },
  string(e, t) {
    return e == null ? !1 : e.type === "string" && (t == null || e.content === t);
  },
  anyString(e) {
    return vr.string(e);
  },
  group(e) {
    return e == null ? !1 : e.type === "group";
  },
  argument(e) {
    return e == null ? !1 : e.type === "argument";
  },
  blankArgument(e) {
    return vr.argument(e) ? e.openMark === "" && e.closeMark === "" && e.content.length === 0 : !1;
  },
  math(e) {
    return e == null ? !1 : e.type === "displaymath" || e.type === "inlinemath";
  },
  createMacroMatcher: HCe,
  createEnvironmentMatcher: VCe
};
function GCe(e) {
  const t = { enter: [], leave: [] };
  if (Array.isArray(e))
    return t;
  if (vr.math(e))
    return { enter: ["content"], leave: [] };
  const r = e._renderInfo || {};
  if (r.inMathMode == null)
    return t;
  if (vr.macro(e)) {
    if (r.inMathMode === !0)
      return { enter: ["args"], leave: [] };
    if (r.inMathMode === !1)
      return { enter: [], leave: ["args"] };
  }
  return vr.environment(e) ? r.inMathMode === !0 ? { enter: ["content"], leave: [] } : { enter: [], leave: ["content"] } : t;
}
const MR = Symbol("continue"), WG = Symbol("skip"), pg = Symbol("exit"), WCe = {
  inMathMode: !1,
  hasMathModeAncestor: !1
};
function Tu(e, t, r) {
  const {
    startingContext: n = WCe,
    test: a = () => !0,
    includeArrays: s = !1
  } = r || {};
  let i, o;
  typeof t == "function" ? i = t : t && typeof t == "object" && (i = t.enter, o = t.leave), l(e, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: { ...n }
  });
  function l(u, { key: c, index: d, parents: p, context: f, containingArray: h }) {
    const m = s ? a(u, { key: c, index: d, parents: p, context: f, containingArray: h }) : !Array.isArray(u) && a(u, { key: c, index: d, parents: p, context: f, containingArray: h }), y = i && m ? qx(
      i(u, {
        key: c,
        index: d,
        parents: p,
        context: f,
        containingArray: h
      })
    ) : [MR];
    if (y[0] === pg)
      return y;
    if (y[0] === WG)
      return o && m ? qx(
        o(u, {
          key: c,
          index: d,
          parents: p,
          context: f,
          containingArray: h
        })
      ) : y;
    if (Array.isArray(u))
      for (let b = 0; b > -1 && b < u.length; b++) {
        const v = u[b], x = l(v, {
          key: c,
          index: b,
          parents: p,
          context: f,
          containingArray: u
        });
        if (x[0] === pg)
          return x;
        typeof x[1] == "number" && (b = x[1] - 1);
      }
    else {
      let b = ["content", "args"];
      switch (u.type) {
        case "macro":
          b = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          b = [];
          break;
      }
      const v = GCe(u);
      for (const x of b) {
        const _ = u[x], E = [u].concat(p);
        if (_ == null)
          continue;
        const w = { ...f };
        v.enter.includes(x) ? (w.inMathMode = !0, w.hasMathModeAncestor = !0) : v.leave.includes(x) && (w.inMathMode = !1);
        const C = l(_, {
          key: x,
          index: void 0,
          parents: E,
          context: w,
          containingArray: void 0
        });
        if (C[0] === pg)
          return C;
      }
    }
    return o && m ? qx(
      o(u, {
        key: c,
        index: d,
        parents: p,
        context: f,
        containingArray: h
      })
    ) : y;
  }
}
function qx(e) {
  return e == null ? [MR] : Array.isArray(e) ? e : typeof e == "number" ? [MR, e] : [e];
}
function gy(e, t) {
  return t != null && (e._renderInfo = { ...e._renderInfo || {}, ...t }), e;
}
function gd(e) {
  if (!Array.isArray(e))
    return console.warn("Trying to trim a non-array ast", e), e;
  const { trimmedStart: t } = KG(e), { trimmedEnd: r } = tD(e);
  return { trimmedStart: t, trimmedEnd: r };
}
function KG(e) {
  const { start: t } = YG(e);
  e.splice(0, t);
  for (const r of e) {
    if (!vr.comment(r))
      break;
    (r.leadingWhitespace || r.sameline) && (r.leadingWhitespace = !1), t > 0 && r.sameline && (r.sameline = !1);
  }
  return { trimmedStart: t };
}
function tD(e) {
  const { end: t } = YG(e);
  e.splice(e.length - t, t);
  for (let r = e.length - 1; r >= 0; r--) {
    const n = e[r];
    if (!vr.comment(n))
      break;
    delete n.suffixParbreak, vr.comment(n) && n.leadingWhitespace && !n.sameline && (n.leadingWhitespace = !1);
  }
  return { trimmedEnd: t };
}
function YG(e) {
  let t = 0, r = 0;
  for (const n of e)
    if (vr.whitespace(n) || vr.parbreak(n))
      t++;
    else
      break;
  if (t === e.length)
    return { start: t, end: 0 };
  for (let n = e.length - 1; n >= 0; n--) {
    const a = e[n];
    if (vr.whitespace(a) || vr.parbreak(a))
      r++;
    else
      break;
  }
  return { start: t, end: r };
}
const KCe = function() {
  return (t) => {
    Tu(t, (r) => {
      if (!(vr.math(r) || vr.anyEnvironment(r)))
        return;
      let n = r.content[0];
      if (vr.comment(n) && n.sameline) {
        n.suffixParbreak = !1, tD(r.content);
        const { trimmedStart: a } = KG(r.content.slice(1));
        r.content.splice(1, a);
      } else
        gd(r.content);
    });
  };
}, YCe = function() {
  return (t) => {
    gd(t.content);
  };
};
function XCe(e, t = () => !1, r) {
  if (!Array.isArray(e))
    throw new Error(`Can only split an Array, not ${e}`);
  const { onlySplitOnFirstOccurrence: n = !1 } = {}, a = [];
  for (let o = 0; o < e.length && !(t(e[o]) && (a.push(o), n)); o++)
    ;
  if (a.length === 0)
    return { segments: [e], separators: [] };
  let s = a.map((o) => e[o]), i = a.map((o, l) => {
    const u = l === 0 ? 0 : a[l - 1] + 1;
    return e.slice(u, o);
  });
  return i.push(
    e.slice(a[a.length - 1] + 1, e.length)
  ), { segments: i, separators: s };
}
function ZCe(e, t) {
  if (typeof t == "string" && (t = [t]), !Array.isArray(t))
    throw new Error("Type coercion failed");
  const r = vr.createMacroMatcher(t), { segments: n, separators: a } = XCe(e, r);
  return { segments: n, macros: a };
}
function JCe(e, t) {
  for (let r = e.length - 1; r >= 0; r--) {
    const n = e[r];
    if (!(vr.whitespace(n) || vr.comment(n) || vr.parbreak(n)))
      return r;
  }
}
function Ea(e, t = "item") {
  let { segments: r, macros: n } = ZCe(e, t);
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    i === 0 ? tD(o) : gd(o), o.length > 0 && i > 0 && o.unshift({ type: "whitespace" });
  }
  let a = /* @__PURE__ */ new WeakSet(), s = n.flatMap((i, o) => {
    var l;
    const u = r[o + 1], c = QCe(u);
    return i.args = i.args || [], i.args.push(Ai(u, { openMark: "", closeMark: "" })), gy(i, { inParMode: !0 }), (o > 0 || ((l = r[0]) == null ? void 0 : l.length) > 0) && a.add(i), [i, ...c];
  });
  s = s.flatMap(
    (i) => a.has(i) ? [{ type: "parbreak" }, i] : i
  ), s.unshift(...r[0]);
  for (let i = 0; i < s.length - 1; i++) {
    const o = s[i], l = s[i + 1];
    if (vr.parbreak(l) && (vr.comment(o) && (o.suffixParbreak = !0), vr.macro(o) && o.args && o.args[o.args.length - 1].closeMark === "")) {
      const u = o.args[o.args.length - 1].content, c = u[u.length - 1];
      vr.comment(c) && (c.suffixParbreak = !0);
    }
  }
  return s;
}
function QCe(e) {
  let t = JCe(e);
  return t === e.length - 1 || t == null && e.length === 0 ? [] : (t == null && (t = -1), e.splice(t + 1));
}
const eAe = {
  answerline: { signature: "o" },
  fillin: { signature: "o o" },
  fullwidth: { signature: "m" },
  fillwidthlines: { signature: "m" },
  fillwidthdottedlines: { signature: "m" },
  fillwidthgrid: { signature: "m" },
  makeemptybox: { signature: "m" },
  CorrectChoiceEmphasis: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  SolutionEmphasis: { signature: "m", renderInfo: { breakAround: !0 } },
  uplevel: { signature: "m", renderInfo: { breakAround: !0 } },
  checkboxchar: { signature: "m", renderInfo: { breakAround: !0 } },
  checkedchar: { signature: "m", renderInfo: { breakAround: !0 } },
  pointname: { signature: "m", renderInfo: { breakAround: !0 } },
  marginpointname: { signature: "m", renderInfo: { breakAround: !0 } },
  extrawidth: { signature: "m", renderInfo: { breakAround: !0 } },
  pointformat: { signature: "m", renderInfo: { breakAround: !0 } },
  bonuspointformat: { signature: "m", renderInfo: { breakAround: !0 } },
  totalformat: { signature: "m", renderInfo: { breakAround: !0 } },
  qformat: { signature: "m", renderInfo: { breakAround: !0 } },
  titledquestion: { signature: "m o", renderInfo: { breakAround: !0 } },
  pointpoints: { signature: "m m", renderInfo: { breakAround: !0 } },
  bonuspointpoints: { signature: "m m", renderInfo: { breakAround: !0 } }
}, tAe = {
  choices: {
    signature: "o",
    processContent: (e) => Ea(e, "choice")
  },
  checkboxes: {
    signature: "o",
    processContent: (e) => Ea(e, "choice")
  },
  oneparchoices: {
    signature: "o",
    processContent: (e) => Ea(e, "choice")
  },
  oneparcheckboxes: {
    signature: "o",
    processContent: (e) => Ea(e, "choice")
  },
  parts: {
    signature: "o",
    processContent: (e) => Ea(e, "part")
  },
  subparts: {
    signature: "o",
    processContent: (e) => Ea(e, "subpart")
  },
  subsubparts: {
    signature: "o",
    processContent: (e) => Ea(e, "subsubpart")
  },
  questions: {
    signature: "o",
    processContent: (e) => Ea(e, "question")
  }
}, rAe = {
  geometry: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  }
}, nAe = {}, iAe = {
  hypersetup: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  href: { signature: "o m m" },
  url: { signature: "m" },
  nolinkurl: { signature: "m" },
  hyperbaseurl: { signature: "m" },
  hyperimage: { signature: "m m" },
  hyperdef: { signature: "m m m" },
  hyperref: { signature: "o m" },
  hyperlink: { signature: "m m" },
  hypertarget: { signature: "m m" },
  autoref: { signature: "s m" },
  pageref: { signature: "s m" },
  autopageref: { signature: "s m" },
  pdfstringdef: { signature: "m m" },
  pdfbookmark: { signature: "o m m" },
  currentpdfbookmark: { signature: "m m" },
  subpdfbookmark: { signature: "m m" },
  belowpdfbookmark: { signature: "m m" },
  texorpdfstring: { signature: "m m" },
  thispdfpagelabel: { signature: "m" },
  hypercalcbp: { signature: "m" }
}, aAe = {}, sAe = {
  // Special
  "\\": { signature: "!s !o", renderInfo: { breakAfter: !0 } },
  _: { signature: "m", escapeToken: "" },
  "^": { signature: "m", escapeToken: "" },
  // \newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands
  // List can be found in latex2e.pdf "An unofficial reference manual"
  newcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  renewcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  providecommand: {
    signature: "s +m o +o +m",
    renderInfo: { breakAround: !0 }
  },
  // Counters
  newcounter: {
    signature: "m o",
    renderInfo: { breakAround: !0 }
  },
  usecounter: {
    signature: "m"
  },
  setcounter: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  addtocounter: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  stepcounter: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  refstepcounter: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  // Lengths
  newlength: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  addtolength: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  settodepth: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  settoheight: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  settowidth: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  // Spaces
  stretch: { signature: "m" },
  hspace: { signature: "s m" },
  vspace: { signature: "s m", renderInfo: { breakAround: !0 } },
  vfill: { renderInfo: { breakAround: !0 } },
  indent: { renderInfo: { breakAround: !0 } },
  phantom: { signature: "m" },
  vphantom: { signature: "m" },
  hphantom: { signature: "m" },
  noindent: { renderInfo: { breakAround: !0 } },
  smallskip: { renderInfo: { breakAround: !0 } },
  medskip: { renderInfo: { breakAround: !0 } },
  bigskip: { renderInfo: { breakAround: !0 } },
  smallbreak: { renderInfo: { breakAround: !0 } },
  medbreak: { renderInfo: { breakAround: !0 } },
  bigbreak: { renderInfo: { breakAround: !0 } },
  newline: { renderInfo: { breakAround: !0 } },
  linebreak: { signature: "o", renderInfo: { breakAround: !0 } },
  nolinebreak: { signature: "o", renderInfo: { breakAround: !0 } },
  clearpage: { renderInfo: { breakAround: !0 } },
  cleardoublepage: { renderInfo: { breakAround: !0 } },
  newpage: { renderInfo: { breakAround: !0 } },
  enlargethispage: { signature: "s", renderInfo: { breakAround: !0 } },
  pagebreak: { signature: "o", renderInfo: { breakAround: !0 } },
  nopagebreak: { signature: "o", renderInfo: { breakAround: !0 } },
  // Boxes
  newsavebox: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  sbox: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  savebox: {
    signature: "m o o m",
    renderInfo: { breakAround: !0 }
  },
  mbox: { signature: "m" },
  makebox: { signature: "d() o o m", renderInfo: { breakAround: !0 } },
  fbox: { signature: "m" },
  framebox: { signature: "o o m", renderInfo: { breakAround: !0 } },
  frame: { signature: "m", renderInfo: { breakAround: !0 } },
  parbox: { signature: "o o o m m", renderInfo: { breakAround: !0 } },
  raisebox: { signature: "m o o m" },
  marginpar: { signature: "o m", renderInfo: { breakAround: !0 } },
  colorbox: { signature: "o m m", renderInfo: { breakAround: !0 } },
  fcolorbox: { signature: "o m m", renderInfo: { breakAround: !0 } },
  rotatebox: { signature: "o m m" },
  scalebox: { signature: "m o m" },
  reflectbox: { signature: "m" },
  resizebox: { signature: "s m m m" },
  // Define environments
  newenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: !0 }
  },
  renewenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: !0 }
  },
  newtheorem: {
    signature: "s m o m o",
    renderInfo: { breakAround: !0 }
  },
  newfont: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  // Counters
  alph: { signature: "m" },
  Alph: { signature: "m" },
  arabic: { signature: "m" },
  roman: { signature: "m" },
  Roman: { signature: "m" },
  fnsymbol: { signature: "m" },
  // Other
  documentclass: {
    signature: "o m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  usepackage: {
    signature: "o m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  item: {
    signature: "o",
    renderInfo: { hangingIndent: !0, namedArguments: ["label"] }
  },
  value: { signature: "m" },
  centering: { renderInfo: { breakAround: !0 } },
  input: { signature: "m", renderInfo: { breakAround: !0 } },
  include: { signature: "m", renderInfo: { breakAround: !0 } },
  includeonly: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  discretionary: { signature: "m m m" },
  hyphenation: { signature: "m" },
  footnote: { signature: "o m", renderInfo: { inParMode: !0 } },
  footnotemark: { signature: "o" },
  footnotetext: { signature: "o m", renderInfo: { inParMode: !0 } },
  caption: {
    signature: "o m",
    renderInfo: { inParMode: !0, breakAround: !0 }
  },
  // Math Commands
  sqrt: { signature: "o m", renderInfo: { inMathMode: !0 } },
  frac: { signature: "m m", renderInfo: { inMathMode: !0 } },
  stackrel: { signature: "m m" },
  ensuremath: { signature: "m", renderInfo: { inMathMode: !0 } },
  // Layout commands
  abstract: {
    signature: "m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  maketitle: { renderInfo: { breakAround: !0 } },
  doublespacing: { renderInfo: { breakAround: !0 } },
  singlespacing: { renderInfo: { breakAround: !0 } },
  date: { signature: "o m", renderInfo: { breakAround: !0 } },
  thanks: {
    signature: "m",
    renderInfo: { breakAround: !0, inParMode: !0 }
  },
  pagenumbering: { signature: "m", renderInfo: { breakAround: !0 } },
  pagestyle: { signature: "m", renderInfo: { breakAround: !0 } },
  thispagestyle: { signature: "m", renderInfo: { breakAround: !0 } },
  // Colors
  definecolor: { signature: "m m m", renderInfo: { breakAround: !0 } },
  pagecolor: { signature: "o m", renderInfo: { breakAround: !0 } },
  nopagecolor: { renderInfo: { breakAround: !0 } },
  multicolumn: { signature: "m m m" },
  // Graphics
  includegraphics: {
    signature: "s o o m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  rule: { signature: "o m m" },
  // Sectioning
  part: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  chapter: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  section: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  paragraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subparagraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: !0,
      inParMode: !0,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  appendix: { renderInfo: { breakAround: !0, inParMode: !0 } },
  frontmatter: { renderInfo: { breakAround: !0, inParMode: !0 } },
  mainmatter: { renderInfo: { breakAround: !0, inParMode: !0 } },
  backmatter: { renderInfo: { breakAround: !0, inParMode: !0 } },
  // Citing and references
  bibitem: { signature: "o m", renderInfo: { hangingIndent: !0 } },
  cite: { signature: "o m" },
  // Fonts
  textrm: { signature: "m", renderInfo: { inParMode: !0 } },
  textit: { signature: "m", renderInfo: { inParMode: !0 } },
  textmd: { signature: "m", renderInfo: { inParMode: !0 } },
  textbf: { signature: "m", renderInfo: { inParMode: !0 } },
  textup: { signature: "m", renderInfo: { inParMode: !0 } },
  textsl: { signature: "m", renderInfo: { inParMode: !0 } },
  textsf: { signature: "m", renderInfo: { inParMode: !0 } },
  textsc: { signature: "m", renderInfo: { inParMode: !0 } },
  texttt: { signature: "m", renderInfo: { inParMode: !0 } },
  underline: { signature: "m", renderInfo: { inParMode: !0 } },
  emph: { signature: "m", renderInfo: { inParMode: !0 } },
  textnormal: { signature: "m", renderInfo: { inParMode: !0 } },
  uppercase: { signature: "m", renderInfo: { inParMode: !0 } },
  mathbf: { signature: "m" },
  mathsf: { signature: "m" },
  mathtt: { signature: "m" },
  mathit: { signature: "m" },
  mathnormal: { signature: "m" },
  mathcal: { signature: "m" },
  mathrm: { signature: "m" },
  // Other
  setlength: { signature: "m m", renderInfo: { breakAround: !0 } },
  ref: { signature: "s m" },
  label: { signature: "o m" },
  // cleveref changes \label to have this signature
  printbibliography: { renderInfo: { breakAround: !0 } },
  addtocontents: { signature: "m m", renderInfo: { breakAround: !0 } },
  addcontentsline: { signature: "m m m", renderInfo: { breakAround: !0 } },
  contentsline: { signature: "m m m", renderInfo: { breakAround: !0 } },
  bibliography: { signature: "m", renderInfo: { breakAround: !0 } },
  bibliographystyle: { signature: "m", renderInfo: { breakAround: !0 } }
}, oAe = {
  document: {
    processContent: (e) => (gd(e), e)
  },
  array: { signature: "o m", renderInfo: { alignContent: !0 } },
  description: { signature: "o", processContent: Ea },
  enumerate: {
    signature: "o",
    processContent: Ea,
    renderInfo: { pgfkeysArgs: !0 }
  },
  itemize: { signature: "o", processContent: Ea },
  trivlist: { signature: "o", processContent: Ea },
  list: { signature: "m m", processContent: Ea },
  figure: { signature: "o" },
  "figure*": { signature: "o" },
  filecontents: { signature: "o m" },
  "filecontents*": { signature: "o m" },
  minipage: { signature: "o o o m" },
  picture: { signature: "r() d()" },
  tabbing: { renderInfo: { alignContent: !0 } },
  table: { signature: "o" },
  tabular: { signature: "o m", renderInfo: { alignContent: !0 } },
  "tabular*": { signature: "m o m", renderInfo: { alignContent: !0 } },
  thebibliography: {
    signature: "m",
    processContent: (e) => Ea(e, "bibitem")
  },
  // Math
  math: { renderInfo: { inMathMode: !0 } }
}, lAe = (
  // Generated by Peggy 3.0.2.
  //
  // https://peggyjs.org/
  function() {
    function e(a, s) {
      function i() {
        this.constructor = a;
      }
      i.prototype = s.prototype, a.prototype = new i();
    }
    function t(a, s, i, o) {
      var l = Error.call(this, a);
      return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
    }
    e(t, Error);
    function r(a, s, i) {
      return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
    }
    t.prototype.format = function(a) {
      var s = "Error: " + this.message;
      if (this.location) {
        var i = null, o;
        for (o = 0; o < a.length; o++)
          if (a[o].source === this.location.source) {
            i = a[o].text.split(/\r\n|\n|\r/g);
            break;
          }
        var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
        if (i) {
          var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
          s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
        } else
          s += `
 at ` + c;
      }
      return s;
    }, t.buildMessage = function(a, s) {
      var i = {
        literal: function(f) {
          return '"' + l(f.text) + '"';
        },
        class: function(f) {
          var h = f.parts.map(function(m) {
            return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
          });
          return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(f) {
          return f.description;
        }
      };
      function o(f) {
        return f.charCodeAt(0).toString(16).toUpperCase();
      }
      function l(f) {
        return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
          return "\\x0" + o(h);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
          return "\\x" + o(h);
        });
      }
      function u(f) {
        return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
          return "\\x0" + o(h);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
          return "\\x" + o(h);
        });
      }
      function c(f) {
        return i[f.type](f);
      }
      function d(f) {
        var h = f.map(c), m, y;
        if (h.sort(), h.length > 0) {
          for (m = 1, y = 1; m < h.length; m++)
            h[m - 1] !== h[m] && (h[y] = h[m], y++);
          h.length = y;
        }
        switch (h.length) {
          case 1:
            return h[0];
          case 2:
            return h[0] + " or " + h[1];
          default:
            return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
        }
      }
      function p(f) {
        return f ? '"' + l(f) + '"' : "end of input";
      }
      return "Expected " + d(a) + " but " + p(s) + " found.";
    };
    function n(a, s) {
      s = s !== void 0 ? s : {};
      var i = {}, o = s.grammarSource, l = { document: qh, math: ll }, u = qh, c = "%", d = ".", p = "verb*", f = "verb", h = "[", m = "]", y = "lstinline", b = "mintinline", v = "mint", x = "minted", _ = "verbatim*", E = "verbatim", w = "filecontents*", C = "filecontents", k = "comment", S = "lstlisting", B = "(", U = ")", N = "begin", O = "end", I = "equation*", q = "equation", ae = "align*", Q = "align", ne = "alignat*", le = "alignat", W = "gather*", X = "gather", G = "multline*", P = "multline", he = "flalign*", ye = "flalign", pe = "split", $ = "math", F = "displaymath", ge = "\\", ce = "{", ie = "}", re = "$", Te = "&", V = "\r", Pe = `
`, z = `\r
`, A = "#", R = "^", H = "_", be = "\0", me = /^[^ \t\n\r]/, Ce = /^[ \t]/, We = /^[a-zA-Z]/, xe = /^[0-9]/, we = /^[.,;:\-*\/()!?=+<>[\]`'"~]/, te = An("document"), Fe = An("math"), Y = An("token"), Je = Vy(), xt = An("parbreak"), Ze = An("math token"), rt = An("nonchar token"), Mt = Nr("%", !1), Qt = An("whitespace"), kr = An("number"), tr = Nr(".", !1), Oe = An("special macro"), Ie = Nr("verb*", !1), Me = Nr("verb", !1), je = Nr("[", !1), tt = Nr("]", !1), Ct = Ks([" ", "	", `
`, "\r"], !0, !1), Kt = An("verbatim listings"), ct = Nr("lstinline", !1), ir = An("verbatim minted"), xr = Nr("mintinline", !1), Rr = Nr("mint", !1), Nt = An("verbatim minted environment"), dr = Nr("minted", !1), $e = An("verbatim environment"), at = Nr("verbatim*", !1), Rt = Nr("verbatim", !1), sr = Nr("filecontents*", !1), bt = Nr("filecontents", !1), Ur = Nr("comment", !1), or = Nr("lstlisting", !1), Ae = An("macro"), Ve = An("group"), Ge = An("environment"), lr = An("math environment"), br = Nr("(", !1), Ut = Nr(")", !1), cn = Nr("begin", !1), Re = Nr("end", !1), J = Nr("equation*", !1), He = Nr("equation", !1), fr = Nr("align*", !1), Mr = Nr("align", !1), ut = Nr("alignat*", !1), qn = Nr("alignat", !1), En = Nr("gather*", !1), yi = Nr("gather", !1), Yi = Nr("multline*", !1), Xi = Nr("multline", !1), mn = Nr("flalign*", !1), Ri = Nr("flalign", !1), Ht = Nr("split", !1), jt = Nr("math", !1), jn = Nr("displaymath", !1), Ii = An("escape"), ti = Nr("\\", !1), Dn = Nr("{", !1), ue = Nr("}", !1), Ue = Nr("$", !1), ze = Nr("&", !1), At = An("newline"), yt = Nr("\r", !1), wt = Nr(`
`, !1), Se = Nr(`\r
`, !1), qe = Nr("#", !1), lt = Nr("^", !1), St = Nr("_", !1), Yt = Nr("\0", !1), Vr = Ks([" ", "	"], !1, !1), gn = An("letter"), On = Ks([["a", "z"], ["A", "Z"]], !1, !1), bs = An("digit"), ys = Ks([["0", "9"]], !1, !1), _i = An("punctuation"), ri = Ks([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], !1, !1), Ir = An("full comment"), dt = An("comment"), Sn = function(L) {
        return Vt("root", { content: L.flatMap((Z) => Z) });
      }, Mi = function(L) {
        return L;
      }, vs = function(L) {
        return Vt("inlinemath", { content: L.flatMap((Z) => Z) });
      }, Zi = function(L) {
        return Vt("string", { content: L });
      }, ws = function(L) {
        return Vt("string", { content: L });
      }, pa = function() {
        return Vt("parbreak");
      }, g = function(L) {
        return L;
      }, T = function(L) {
        return L;
      }, ee = function() {
        return Vt("macro", { content: "^", escapeToken: "" });
      }, fe = function() {
        return Vt("macro", { content: "_", escapeToken: "" });
      }, j = function(L) {
        return Vt("string", { content: L });
      }, de = function() {
        return Vt("whitespace");
      }, _e = function(L, Z) {
        return L.join("") + "." + Z.join("");
      }, Le = function(L) {
        return "." + L.join("");
      }, et = function(L) {
        return L.join("") + ".";
      }, vt = function(L) {
        return Vt("string", { content: L });
      }, Wt = function(L, Z, ve) {
        return ve == Z;
      }, en = function(L, Z, ve) {
        return ve;
      }, pi = function(L, Z, ve, oe) {
        return oe == Z;
      }, it = function(L, Z, ve) {
        return Vt("verb", {
          env: L,
          escape: Z,
          content: ve.join("")
        });
      }, Tt = function(L) {
        return L;
      }, rr = function(L) {
        return Vt("displaymath", { content: L.flatMap((Z) => Z) });
      }, Xt = function(L) {
        return L;
      }, Dt = function(L) {
        return Vt("inlinemath", { content: L.flatMap((Z) => Z) });
      }, ur = function(L) {
        return L;
      }, Lr = function(L) {
        return Vt("displaymath", { content: L.flatMap((Z) => Z) });
      }, pr = function(L) {
        return L.type === "string" && L.content === "]";
      }, Sr = function(L) {
        return L;
      }, zr = function(L) {
        return [
          Vt("string", { content: "[" }),
          ...L,
          Vt("string", { content: "]" })
        ];
      }, Yn = function(L) {
        return L;
      }, Xn = function(L) {
        return Vt("group", {
          content: Vt("string", { content: L.join("") })
        });
      }, _n = function(L, Z) {
        return Z == L;
      }, nn = function(L, Z) {
        return Z;
      }, Hn = function(L, Z, ve) {
        return ve == L;
      }, Hr = function(L, Z) {
        return [
          Vt("string", { content: L }),
          Vt("string", { content: Z.join("") }),
          Vt("string", { content: L })
        ];
      }, Bn = function(L, Z, ve) {
        return [
          Vt("macro", { content: L }),
          ...Z || [],
          ...[].concat(ve)
        ];
      }, wo = function(L, Z, ve, oe) {
        return [
          Vt("macro", { content: L }),
          ...Z || [],
          ve,
          ...[].concat(oe)
        ];
      }, ni = function(L, Z, ve, oe) {
        return mr({ content: [L] }, oe);
      }, xo = function(L, Z, ve, oe) {
        const De = [
          ...Z || [],
          ve,
          { type: "string", content: oe }
        ];
        return Vt("environment", {
          env: L,
          content: De
        });
      }, bn = function(L, Z) {
        return mr({ content: [L] }, Z);
      }, li = function(L, Z) {
        return Z;
      }, Ji = function(L, Z) {
        return Vt("verbatim", {
          env: L,
          content: Z
        });
      }, Wa = function(L) {
        return L.join("");
      }, Na = function(L) {
        return L;
      }, nl = function(L) {
        return Vt("macro", { content: L });
      }, Hs = function(L) {
        return L;
      }, Yu = function(L) {
        return Vt("group", { content: L.flatMap((Z) => Z) });
      }, Fi = function(L) {
        return jd().slice(1, -1);
      }, ki = function(L, Z, ve) {
        return mr(L, ve);
      }, vi = function(L, Z, ve) {
        return ve;
      }, ha = function(L, Z, ve) {
        return ve = ve.flatMap((oe) => oe), Vt("environment", {
          env: L,
          content: Z ? [Z, ...ve] : ve
        });
      }, Vs = function(L, Z, ve) {
        return mr({ content: [L] }, ve);
      }, Xu = function(L, Z, ve) {
        return ve;
      }, Zu = function(L, Z, ve) {
        return ve = ve.flatMap((oe) => oe), Vt("mathenv", {
          env: L,
          content: Z ? [Z, ...ve] : ve
        });
      }, Fh = function(L) {
        return Vt("string", { content: L });
      }, Ju = function() {
        return Vt("string", { content: "\\" });
      }, Qu = function(L) {
        return Vt("string", { content: L });
      }, Hy = function(L) {
        return Vt("string", { content: L });
      }, $h = function(L) {
        return Vt("string", { content: L });
      }, Qi = function(L) {
        return Vt("string", { content: L });
      }, qd = function(L) {
        return Vt("string", { content: L });
      }, ec = function(L) {
        return Vt("string", { content: L });
      }, il = function(L) {
        return Vt("string", { content: L });
      }, Bh = function() {
        return " ";
      }, ii = function(L) {
        return Vt("string", { content: L });
      }, Uh = function(L, Z) {
        return Vt("comment", {
          ...Z,
          sameline: !1,
          leadingWhitespace: L.length > 0
        });
      }, zh = function(L, Z) {
        return Vt("comment", {
          ...Z,
          sameline: !0,
          leadingWhitespace: L.length > 0
        });
      }, tc = function(L) {
        return L;
      }, al = function(L) {
        return { content: L.join(""), suffixParbreak: !0 };
      }, nu = function(L) {
        return L;
      }, Gs = function(L) {
        return { content: L.join("") };
      }, sl = function() {
        var L = Hd();
        return L.start.column === 1;
      }, M = 0, Lt = 0, Ws = [{ line: 1, column: 1 }], Ci = 0, rc = [], Be = 0, It = {}, ol;
      if ("startRule" in s) {
        if (!(s.startRule in l))
          throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
        u = l[s.startRule];
      }
      function jd() {
        return a.substring(Lt, M);
      }
      function Hd() {
        return nc(Lt, M);
      }
      function Nr(L, Z) {
        return { type: "literal", text: L, ignoreCase: Z };
      }
      function Ks(L, Z, ve) {
        return { type: "class", parts: L, inverted: Z, ignoreCase: ve };
      }
      function Vy() {
        return { type: "any" };
      }
      function Vd() {
        return { type: "end" };
      }
      function An(L) {
        return { type: "other", description: L };
      }
      function Gd(L) {
        var Z = Ws[L], ve;
        if (Z)
          return Z;
        for (ve = L - 1; !Ws[ve]; )
          ve--;
        for (Z = Ws[ve], Z = {
          line: Z.line,
          column: Z.column
        }; ve < L; )
          a.charCodeAt(ve) === 10 ? (Z.line++, Z.column = 1) : Z.column++, ve++;
        return Ws[L] = Z, Z;
      }
      function nc(L, Z, ve) {
        var oe = Gd(L), De = Gd(Z), Ne = {
          source: o,
          start: {
            offset: L,
            line: oe.line,
            column: oe.column
          },
          end: {
            offset: Z,
            line: De.line,
            column: De.column
          }
        };
        return Ne;
      }
      function Et(L) {
        M < Ci || (M > Ci && (Ci = M, rc = []), rc.push(L));
      }
      function Gy(L, Z, ve) {
        return new t(
          t.buildMessage(L, Z),
          L,
          Z,
          ve
        );
      }
      function qh() {
        var L, Z, ve, oe = M * 52 + 0, De = It[oe];
        if (De)
          return M = De.nextPos, De.result;
        for (Be++, L = M, Z = [], ve = Ka(); ve !== i; )
          Z.push(ve), ve = Ka();
        return Lt = L, Z = Sn(Z), L = Z, Be--, Z = i, Be === 0 && Et(te), It[oe] = { nextPos: M, result: L }, L;
      }
      function ll() {
        var L, Z, ve = M * 52 + 1, oe = It[ve];
        if (oe)
          return M = oe.nextPos, oe.result;
        for (Be++, L = [], Z = $i(); Z !== i; )
          L.push(Z), Z = $i();
        return Be--, Z = i, Be === 0 && Et(Fe), It[ve] = { nextPos: M, result: L }, L;
      }
      function Ka() {
        var L, Z, ve, oe, De, Ne, Qe = M * 52 + 2, Ke = It[Qe];
        if (Ke)
          return M = Ke.nextPos, Ke.result;
        if (Be++, L = ic(), L === i && (L = ul(), L === i && (L = Xe(), L === i && (L = Da(), L === i)))) {
          if (L = M, Z = Di(), Z !== i) {
            if (ve = [], oe = M, De = M, Be++, Ne = Di(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Mi(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i), oe !== i)
              for (; oe !== i; )
                ve.push(oe), oe = M, De = M, Be++, Ne = Di(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Mi(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
            else
              ve = i;
            ve !== i ? (oe = Di(), oe !== i ? (Lt = L, L = vs(ve)) : (M = L, L = i)) : (M = L, L = i);
          } else
            M = L, L = i;
          if (L === i && (L = Xd(), L === i && (L = jh(), L === i && (L = Zd(), L === i && (L = Jd(), L === i && (L = Wd(), L === i && (L = hi(), L === i && (L = Ee(), L === i)))))))) {
            if (L = M, Z = M, ve = [], oe = M, De = M, Be++, Ne = Hh(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (De = [De, Ne], oe = De) : (M = oe, oe = i)) : (M = oe, oe = i), oe !== i)
              for (; oe !== i; )
                ve.push(oe), oe = M, De = M, Be++, Ne = Hh(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (De = [De, Ne], oe = De) : (M = oe, oe = i)) : (M = oe, oe = i);
            else
              ve = i;
            ve !== i ? Z = a.substring(Z, M) : Z = ve, Z !== i && (Lt = L, Z = Zi(Z)), L = Z, L === i && (L = Ya(), L === i && (L = Ni(), L === i && (L = Di(), L === i && (L = M, a.length > M ? (Z = a.charAt(M), M++) : (Z = i, Be === 0 && Et(Je)), Z !== i && (Lt = L, Z = ws(Z)), L = Z))));
          }
        }
        return Be--, L === i && (Z = i, Be === 0 && Et(Y)), It[Qe] = { nextPos: M, result: L }, L;
      }
      function jh() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt = M * 52 + 3, gt = It[Jt];
        if (gt)
          return M = gt.nextPos, gt.result;
        for (Be++, L = M, Z = M, ve = [], oe = yn(); oe !== i; )
          ve.push(oe), oe = yn();
        if (oe = wi(), oe !== i) {
          for (De = [], Ne = M, Qe = [], Ke = yn(); Ke !== i; )
            Qe.push(Ke), Ke = yn();
          if (Ke = wi(), Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i), Ne !== i)
            for (; Ne !== i; ) {
              for (De.push(Ne), Ne = M, Qe = [], Ke = yn(); Ke !== i; )
                Qe.push(Ke), Ke = yn();
              Ke = wi(), Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i);
            }
          else
            De = i;
          if (De !== i) {
            for (Ne = [], Qe = yn(); Qe !== i; )
              Ne.push(Qe), Qe = yn();
            Qe = M, Be++, Ke = Ye(), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (ve = [ve, oe, De, Ne, Qe], Z = ve) : (M = Z, Z = i);
          } else
            M = Z, Z = i;
        } else
          M = Z, Z = i;
        if (Z === i) {
          for (Z = M, ve = [], oe = yn(); oe !== i; )
            ve.push(oe), oe = yn();
          if (oe = wi(), oe !== i) {
            for (De = [], Ne = M, Qe = [], Ke = yn(); Ke !== i; )
              Qe.push(Ke), Ke = yn();
            if (Ke = wi(), Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i), Ne !== i)
              for (; Ne !== i; ) {
                for (De.push(Ne), Ne = M, Qe = [], Ke = yn(); Ke !== i; )
                  Qe.push(Ke), Ke = yn();
                Ke = wi(), Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i);
              }
            else
              De = i;
            De !== i ? (ve = [ve, oe, De], Z = ve) : (M = Z, Z = i);
          } else
            M = Z, Z = i;
        }
        return Z !== i && (Lt = L, Z = pa()), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(xt)), It[Jt] = { nextPos: M, result: L }, L;
      }
      function $i() {
        var L, Z, ve, oe, De, Ne = M * 52 + 4, Qe = It[Ne];
        if (Qe)
          return M = Qe.nextPos, Qe.result;
        if (Be++, L = ic(), L === i && (L = ul(), L === i && (L = Xe(), L === i))) {
          for (L = M, Z = [], ve = hi(); ve !== i; )
            Z.push(ve), ve = hi();
          if (ve = Da(), ve !== i) {
            for (oe = [], De = hi(); De !== i; )
              oe.push(De), De = hi();
            Lt = L, L = g(ve);
          } else
            M = L, L = i;
          if (L === i) {
            for (L = M, Z = [], ve = hi(); ve !== i; )
              Z.push(ve), ve = hi();
            if (ve = Xd(), ve !== i) {
              for (oe = [], De = hi(); De !== i; )
                oe.push(De), De = hi();
              Lt = L, L = T(ve);
            } else
              M = L, L = i;
            if (L === i && (L = Zd(), L === i)) {
              for (L = M, Z = [], ve = hi(); ve !== i; )
                Z.push(ve), ve = hi();
              if (ve = Gh(), ve !== i) {
                for (oe = [], De = hi(); De !== i; )
                  oe.push(De), De = hi();
                Lt = L, L = ee();
              } else
                M = L, L = i;
              if (L === i) {
                for (L = M, Z = [], ve = hi(); ve !== i; )
                  Z.push(ve), ve = hi();
                if (ve = Zy(), ve !== i) {
                  for (oe = [], De = hi(); De !== i; )
                    oe.push(De), De = hi();
                  Lt = L, L = fe();
                } else
                  M = L, L = i;
                L === i && (L = Jd(), L === i && (L = hi(), L === i && (L = M, a.length > M ? (Z = a.charAt(M), M++) : (Z = i, Be === 0 && Et(Je)), Z !== i && (Lt = L, Z = j(Z)), L = Z)));
              }
            }
          }
        }
        return Be--, L === i && (Z = i, Be === 0 && Et(Ze)), It[Ne] = { nextPos: M, result: L }, L;
      }
      function Hh() {
        var L, Z = M * 52 + 5, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (Be++, L = ba(), L === i && (a.charCodeAt(M) === 37 ? (L = c, M++) : (L = i, Be === 0 && Et(Mt)), L === i && (L = Ya(), L === i && (L = Ni(), L === i && (L = Di(), L === i && (L = Xd(), L === i && (L = wi(), L === i && (L = Zd(), L === i && (L = Jd(), L === i && (L = yn(), L === i && (L = Ee(), L === i && (L = Ft()))))))))))), Be--, L === i && Be === 0 && Et(rt), It[Z] = { nextPos: M, result: L }, L);
      }
      function hi() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt = M * 52 + 6, gt = It[Jt];
        if (gt)
          return M = gt.nextPos, gt.result;
        if (Be++, L = M, Z = M, ve = wi(), ve !== i) {
          for (oe = [], De = yn(); De !== i; )
            oe.push(De), De = yn();
          ve = [ve, oe], Z = ve;
        } else
          M = Z, Z = i;
        if (Z === i) {
          if (Z = M, ve = [], oe = yn(), oe !== i)
            for (; oe !== i; )
              ve.push(oe), oe = yn();
          else
            ve = i;
          if (ve !== i)
            if (oe = wi(), oe !== i)
              if (De = M, Be++, Ne = Ye(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i) {
                for (Ne = [], Qe = yn(); Qe !== i; )
                  Ne.push(Qe), Qe = yn();
                Qe = M, Be++, Ke = wi(), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (ve = [ve, oe, De, Ne, Qe], Z = ve) : (M = Z, Z = i);
              } else
                M = Z, Z = i;
            else
              M = Z, Z = i;
          else
            M = Z, Z = i;
          if (Z === i)
            if (Z = [], ve = yn(), ve !== i)
              for (; ve !== i; )
                Z.push(ve), ve = yn();
            else
              Z = i;
        }
        return Z !== i && (Lt = L, Z = de()), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(Qt)), It[Jt] = { nextPos: M, result: L }, L;
      }
      function Wd() {
        var L, Z, ve, oe, De, Ne, Qe = M * 52 + 7, Ke = It[Qe];
        if (Ke)
          return M = Ke.nextPos, Ke.result;
        if (Be++, L = M, Z = M, ve = [], oe = Ys(), oe !== i)
          for (; oe !== i; )
            ve.push(oe), oe = Ys();
        else
          ve = i;
        if (ve !== i)
          if (a.charCodeAt(M) === 46 ? (oe = d, M++) : (oe = i, Be === 0 && Et(tr)), oe !== i) {
            if (De = [], Ne = Ys(), Ne !== i)
              for (; Ne !== i; )
                De.push(Ne), Ne = Ys();
            else
              De = i;
            De !== i ? (Lt = Z, Z = _e(ve, De)) : (M = Z, Z = i);
          } else
            M = Z, Z = i;
        else
          M = Z, Z = i;
        if (Z === i) {
          if (Z = M, a.charCodeAt(M) === 46 ? (ve = d, M++) : (ve = i, Be === 0 && Et(tr)), ve !== i) {
            if (oe = [], De = Ys(), De !== i)
              for (; De !== i; )
                oe.push(De), De = Ys();
            else
              oe = i;
            oe !== i ? (Lt = Z, Z = Le(oe)) : (M = Z, Z = i);
          } else
            M = Z, Z = i;
          if (Z === i) {
            if (Z = M, ve = [], oe = Ys(), oe !== i)
              for (; oe !== i; )
                ve.push(oe), oe = Ys();
            else
              ve = i;
            ve !== i ? (a.charCodeAt(M) === 46 ? (oe = d, M++) : (oe = i, Be === 0 && Et(tr)), oe !== i ? (Lt = Z, Z = et(ve)) : (M = Z, Z = i)) : (M = Z, Z = i);
          }
        }
        return Z !== i && (Lt = L, Z = vt(Z)), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(kr)), It[Qe] = { nextPos: M, result: L }, L;
      }
      function ic() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt, gt, yr = M * 52 + 8, Cr = It[yr];
        if (Cr)
          return M = Cr.nextPos, Cr.result;
        if (Be++, L = M, Z = ba(), Z !== i)
          if (a.substr(M, 5) === p ? (ve = p, M += 5) : (ve = i, Be === 0 && Et(Ie)), ve === i && (a.substr(M, 4) === f ? (ve = f, M += 4) : (ve = i, Be === 0 && Et(Me))), ve !== i)
            if (a.length > M ? (oe = a.charAt(M), M++) : (oe = i, Be === 0 && Et(Je)), oe !== i) {
              for (De = [], Ne = M, Qe = M, Be++, Ke = M, a.length > M ? (Jt = a.charAt(M), M++) : (Jt = i, Be === 0 && Et(Je)), Jt !== i ? (Lt = M, gt = Wt(ve, oe, Jt), gt ? gt = void 0 : gt = i, gt !== i ? (Jt = [Jt, gt], Ke = Jt) : (M = Ke, Ke = i)) : (M = Ke, Ke = i), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (a.length > M ? (Ke = a.charAt(M), M++) : (Ke = i, Be === 0 && Et(Je)), Ke !== i ? (Lt = Ne, Ne = en(ve, oe, Ke)) : (M = Ne, Ne = i)) : (M = Ne, Ne = i); Ne !== i; )
                De.push(Ne), Ne = M, Qe = M, Be++, Ke = M, a.length > M ? (Jt = a.charAt(M), M++) : (Jt = i, Be === 0 && Et(Je)), Jt !== i ? (Lt = M, gt = Wt(ve, oe, Jt), gt ? gt = void 0 : gt = i, gt !== i ? (Jt = [Jt, gt], Ke = Jt) : (M = Ke, Ke = i)) : (M = Ke, Ke = i), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (a.length > M ? (Ke = a.charAt(M), M++) : (Ke = i, Be === 0 && Et(Je)), Ke !== i ? (Lt = Ne, Ne = en(ve, oe, Ke)) : (M = Ne, Ne = i)) : (M = Ne, Ne = i);
              Ne = M, a.length > M ? (Qe = a.charAt(M), M++) : (Qe = i, Be === 0 && Et(Je)), Qe !== i ? (Lt = M, Ke = pi(ve, oe, De, Qe), Ke ? Ke = void 0 : Ke = i, Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i)) : (M = Ne, Ne = i), Ne !== i ? (Lt = L, L = it(ve, oe, De)) : (M = L, L = i);
            } else
              M = L, L = i;
          else
            M = L, L = i;
        else
          M = L, L = i;
        if (L === i && (L = Wy(), L === i && (L = Ky(), L === i && (L = Eo(), L === i && (L = iu(), L === i))))) {
          if (L = M, Z = Xy(), Z !== i) {
            for (ve = [], oe = M, De = M, Be++, Ne = dl(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Tt(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
              ve.push(oe), oe = M, De = M, Be++, Ne = dl(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Tt(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
            oe = dl(), oe !== i ? (Lt = L, L = rr(ve)) : (M = L, L = i);
          } else
            M = L, L = i;
          if (L === i) {
            if (L = M, Z = ac(), Z !== i) {
              for (ve = [], oe = M, De = M, Be++, Ne = fl(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Xt(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
                ve.push(oe), oe = M, De = M, Be++, Ne = fl(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = $i(), Ne !== i ? (Lt = oe, oe = Xt(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
              oe = fl(), oe !== i ? (Lt = L, L = Dt(ve)) : (M = L, L = i);
            } else
              M = L, L = i;
            if (L === i) {
              if (L = M, Z = Di(), Z !== i)
                if (ve = Di(), ve !== i) {
                  for (oe = [], De = M, Ne = M, Be++, Qe = M, Ke = Di(), Ke !== i ? (Jt = Di(), Jt !== i ? (Ke = [Ke, Jt], Qe = Ke) : (M = Qe, Qe = i)) : (M = Qe, Qe = i), Be--, Qe === i ? Ne = void 0 : (M = Ne, Ne = i), Ne !== i ? (Qe = $i(), Qe !== i ? (Lt = De, De = ur(Qe)) : (M = De, De = i)) : (M = De, De = i); De !== i; )
                    oe.push(De), De = M, Ne = M, Be++, Qe = M, Ke = Di(), Ke !== i ? (Jt = Di(), Jt !== i ? (Ke = [Ke, Jt], Qe = Ke) : (M = Qe, Qe = i)) : (M = Qe, Qe = i), Be--, Qe === i ? Ne = void 0 : (M = Ne, Ne = i), Ne !== i ? (Qe = $i(), Qe !== i ? (Lt = De, De = ur(Qe)) : (M = De, De = i)) : (M = De, De = i);
                  De = Di(), De !== i ? (Ne = Di(), Ne !== i ? (Lt = L, L = Lr(oe)) : (M = L, L = i)) : (M = L, L = i);
                } else
                  M = L, L = i;
              else
                M = L, L = i;
              L === i && (L = Yy(), L === i && (L = au()));
            }
          }
        }
        return Be--, L === i && (Z = i, Be === 0 && Et(Oe)), It[yr] = { nextPos: M, result: L }, L;
      }
      function Kd() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt = M * 52 + 9, gt = It[Jt];
        if (gt)
          return M = gt.nextPos, gt.result;
        if (L = M, a.charCodeAt(M) === 91 ? (Z = h, M++) : (Z = i, Be === 0 && Et(je)), Z !== i) {
          for (ve = [], oe = M, De = M, Be++, Ne = M, Qe = Ka(), Qe !== i ? (Lt = M, Ke = pr(Qe), Ke ? Ke = void 0 : Ke = i, Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i)) : (M = Ne, Ne = i), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = Ka(), Ne !== i ? (Lt = oe, oe = Sr(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
            ve.push(oe), oe = M, De = M, Be++, Ne = M, Qe = Ka(), Qe !== i ? (Lt = M, Ke = pr(Qe), Ke ? Ke = void 0 : Ke = i, Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i)) : (M = Ne, Ne = i), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = Ka(), Ne !== i ? (Lt = oe, oe = Sr(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
          a.charCodeAt(M) === 93 ? (oe = m, M++) : (oe = i, Be === 0 && Et(tt)), oe !== i ? (Lt = L, L = zr(ve)) : (M = L, L = i);
        } else
          M = L, L = i;
        return It[Jt] = { nextPos: M, result: L }, L;
      }
      function ma() {
        var L, Z, ve, oe, De, Ne, Qe = M * 52 + 10, Ke = It[Qe];
        if (Ke)
          return M = Ke.nextPos, Ke.result;
        if (L = M, Z = Ya(), Z !== i) {
          for (ve = [], oe = M, De = M, Be++, Ne = Ni(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = Yn(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
            ve.push(oe), oe = M, De = M, Be++, Ne = Ni(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = Yn(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
          oe = Ni(), oe !== i ? (Lt = L, L = Xn(ve)) : (M = L, L = i);
        } else
          M = L, L = i;
        return It[Qe] = { nextPos: M, result: L }, L;
      }
      function xs() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt = M * 52 + 11, gt = It[Jt];
        if (gt)
          return M = gt.nextPos, gt.result;
        if (L = M, me.test(a.charAt(M)) ? (Z = a.charAt(M), M++) : (Z = i, Be === 0 && Et(Ct)), Z !== i) {
          for (ve = [], oe = M, De = M, Be++, Ne = M, a.length > M ? (Qe = a.charAt(M), M++) : (Qe = i, Be === 0 && Et(Je)), Qe !== i ? (Lt = M, Ke = _n(Z, Qe), Ke ? Ke = void 0 : Ke = i, Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i)) : (M = Ne, Ne = i), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = nn(Z, Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
            ve.push(oe), oe = M, De = M, Be++, Ne = M, a.length > M ? (Qe = a.charAt(M), M++) : (Qe = i, Be === 0 && Et(Je)), Qe !== i ? (Lt = M, Ke = _n(Z, Qe), Ke ? Ke = void 0 : Ke = i, Ke !== i ? (Qe = [Qe, Ke], Ne = Qe) : (M = Ne, Ne = i)) : (M = Ne, Ne = i), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = nn(Z, Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
          oe = M, a.length > M ? (De = a.charAt(M), M++) : (De = i, Be === 0 && Et(Je)), De !== i ? (Lt = M, Ne = Hn(Z, ve, De), Ne ? Ne = void 0 : Ne = i, Ne !== i ? (De = [De, Ne], oe = De) : (M = oe, oe = i)) : (M = oe, oe = i), oe !== i ? (Lt = L, L = Hr(Z, ve)) : (M = L, L = i);
        } else
          M = L, L = i;
        return It[Jt] = { nextPos: M, result: L }, L;
      }
      function Wy() {
        var L, Z, ve, oe, De, Ne = M * 52 + 12, Qe = It[Ne];
        return Qe ? (M = Qe.nextPos, Qe.result) : (Be++, L = M, Z = ba(), Z !== i ? (a.substr(M, 9) === y ? (ve = y, M += 9) : (ve = i, Be === 0 && Et(ct)), ve !== i ? (oe = Kd(), oe === i && (oe = null), De = ma(), De === i && (De = xs()), De !== i ? (Lt = L, L = Bn(ve, oe, De)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i), Be--, L === i && (Z = i, Be === 0 && Et(Kt)), It[Ne] = { nextPos: M, result: L }, L);
      }
      function Ky() {
        var L, Z, ve, oe, De, Ne, Qe = M * 52 + 13, Ke = It[Qe];
        return Ke ? (M = Ke.nextPos, Ke.result) : (Be++, L = M, Z = ba(), Z !== i ? (a.substr(M, 10) === b ? (ve = b, M += 10) : (ve = i, Be === 0 && Et(xr)), ve === i && (a.substr(M, 4) === v ? (ve = v, M += 4) : (ve = i, Be === 0 && Et(Rr))), ve !== i ? (oe = Kd(), oe === i && (oe = null), De = Da(), De !== i ? (Ne = ma(), Ne === i && (Ne = xs()), Ne !== i ? (Lt = L, L = wo(ve, oe, De, Ne)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i), Be--, L === i && (Z = i, Be === 0 && Et(ir)), It[Qe] = { nextPos: M, result: L }, L);
      }
      function Eo() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt, gt, yr, Cr, Br, xi, Zn, sc = M * 52 + 14, Jy = It[sc];
        if (Jy)
          return M = Jy.nextPos, Jy.result;
        if (Be++, L = M, Z = su(), Z !== i)
          if (ve = Ya(), ve !== i)
            if (a.substr(M, 6) === x ? (oe = x, M += 6) : (oe = i, Be === 0 && Et(dr)), oe !== i)
              if (De = Ni(), De !== i)
                if (Ne = Kd(), Ne === i && (Ne = null), Qe = Da(), Qe !== i) {
                  for (Ke = M, Jt = [], gt = M, yr = M, Be++, Cr = M, Br = ga(), Br !== i ? (xi = Da(), xi !== i ? (Lt = M, Zn = ni(oe, Ne, Qe, xi), Zn ? Zn = void 0 : Zn = i, Zn !== i ? (Br = [Br, xi, Zn], Cr = Br) : (M = Cr, Cr = i)) : (M = Cr, Cr = i)) : (M = Cr, Cr = i), Be--, Cr === i ? yr = void 0 : (M = yr, yr = i), yr !== i ? (a.length > M ? (Cr = a.charAt(M), M++) : (Cr = i, Be === 0 && Et(Je)), Cr !== i ? (yr = [yr, Cr], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i); gt !== i; )
                    Jt.push(gt), gt = M, yr = M, Be++, Cr = M, Br = ga(), Br !== i ? (xi = Da(), xi !== i ? (Lt = M, Zn = ni(oe, Ne, Qe, xi), Zn ? Zn = void 0 : Zn = i, Zn !== i ? (Br = [Br, xi, Zn], Cr = Br) : (M = Cr, Cr = i)) : (M = Cr, Cr = i)) : (M = Cr, Cr = i), Be--, Cr === i ? yr = void 0 : (M = yr, yr = i), yr !== i ? (a.length > M ? (Cr = a.charAt(M), M++) : (Cr = i, Be === 0 && Et(Je)), Cr !== i ? (yr = [yr, Cr], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i);
                  Ke = a.substring(Ke, M), Jt = ga(), Jt !== i ? (gt = Ya(), gt !== i ? (a.substr(M, 6) === x ? (yr = x, M += 6) : (yr = i, Be === 0 && Et(dr)), yr !== i ? (Cr = Ni(), Cr !== i ? (Lt = L, L = xo(oe, Ne, Qe, Ke)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i);
                } else
                  M = L, L = i;
              else
                M = L, L = i;
            else
              M = L, L = i;
          else
            M = L, L = i;
        else
          M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et(Nt)), It[sc] = { nextPos: M, result: L }, L;
      }
      function iu() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt, gt, yr, Cr, Br, xi = M * 52 + 15, Zn = It[xi];
        if (Zn)
          return M = Zn.nextPos, Zn.result;
        if (Be++, L = M, Z = su(), Z !== i)
          if (ve = Ya(), ve !== i)
            if (oe = Yd(), oe !== i)
              if (De = Ni(), De !== i) {
                for (Ne = M, Qe = [], Ke = M, Jt = M, Be++, gt = M, yr = ga(), yr !== i ? (Cr = Da(), Cr !== i ? (Lt = M, Br = bn(oe, Cr), Br ? Br = void 0 : Br = i, Br !== i ? (yr = [yr, Cr, Br], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i)) : (M = gt, gt = i), Be--, gt === i ? Jt = void 0 : (M = Jt, Jt = i), Jt !== i ? (a.length > M ? (gt = a.charAt(M), M++) : (gt = i, Be === 0 && Et(Je)), gt !== i ? (Lt = Ke, Ke = li(oe, gt)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i); Ke !== i; )
                  Qe.push(Ke), Ke = M, Jt = M, Be++, gt = M, yr = ga(), yr !== i ? (Cr = Da(), Cr !== i ? (Lt = M, Br = bn(oe, Cr), Br ? Br = void 0 : Br = i, Br !== i ? (yr = [yr, Cr, Br], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i)) : (M = gt, gt = i), Be--, gt === i ? Jt = void 0 : (M = Jt, Jt = i), Jt !== i ? (a.length > M ? (gt = a.charAt(M), M++) : (gt = i, Be === 0 && Et(Je)), gt !== i ? (Lt = Ke, Ke = li(oe, gt)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i);
                Ne = a.substring(Ne, M), Qe = ga(), Qe !== i ? (Ke = Ya(), Ke !== i ? (Jt = Yd(), Jt !== i ? (gt = Ni(), gt !== i ? (Lt = L, L = Ji(oe, Ne)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i);
              } else
                M = L, L = i;
            else
              M = L, L = i;
          else
            M = L, L = i;
        else
          M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et($e)), It[xi] = { nextPos: M, result: L }, L;
      }
      function Yd() {
        var L, Z = M * 52 + 16, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (a.substr(M, 9) === _ ? (L = _, M += 9) : (L = i, Be === 0 && Et(at)), L === i && (a.substr(M, 8) === E ? (L = E, M += 8) : (L = i, Be === 0 && Et(Rt)), L === i && (a.substr(M, 13) === w ? (L = w, M += 13) : (L = i, Be === 0 && Et(sr)), L === i && (a.substr(M, 12) === C ? (L = C, M += 12) : (L = i, Be === 0 && Et(bt)), L === i && (a.substr(M, 7) === k ? (L = k, M += 7) : (L = i, Be === 0 && Et(Ur)), L === i && (a.substr(M, 10) === S ? (L = S, M += 10) : (L = i, Be === 0 && Et(or))))))), It[Z] = { nextPos: M, result: L }, L);
      }
      function ul() {
        var L, Z, ve, oe, De, Ne = M * 52 + 17, Qe = It[Ne];
        if (Qe)
          return M = Qe.nextPos, Qe.result;
        if (Be++, L = M, Z = M, ve = ba(), ve !== i) {
          if (oe = [], De = Wh(), De !== i)
            for (; De !== i; )
              oe.push(De), De = Wh();
          else
            oe = i;
          oe !== i ? (Lt = Z, Z = Wa(oe)) : (M = Z, Z = i);
        } else
          M = Z, Z = i;
        return Z === i && (Z = M, ve = ba(), ve !== i ? (a.length > M ? (oe = a.charAt(M), M++) : (oe = i, Be === 0 && Et(Je)), oe !== i ? (Lt = Z, Z = Na(oe)) : (M = Z, Z = i)) : (M = Z, Z = i)), Z !== i && (Lt = L, Z = nl(Z)), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(Ae)), It[Ne] = { nextPos: M, result: L }, L;
      }
      function Da() {
        var L, Z, ve, oe, De, Ne, Qe = M * 52 + 18, Ke = It[Qe];
        if (Ke)
          return M = Ke.nextPos, Ke.result;
        if (Be++, L = M, Z = Ya(), Z !== i) {
          for (ve = [], oe = M, De = M, Be++, Ne = Ni(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = Ka(), Ne !== i ? (Lt = oe, oe = Hs(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
            ve.push(oe), oe = M, De = M, Be++, Ne = Ni(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (Ne = Ka(), Ne !== i ? (Lt = oe, oe = Hs(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
          oe = Ni(), oe !== i ? (Lt = L, L = Yu(ve)) : (M = L, L = i);
        } else
          M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et(Ve)), It[Qe] = { nextPos: M, result: L }, L;
      }
      function cl() {
        var L, Z, ve = M * 52 + 19, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, Z = Da(), Z !== i && (Lt = L, Z = Fi()), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function au() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt, gt, yr, Cr = M * 52 + 20, Br = It[Cr];
        if (Br)
          return M = Br.nextPos, Br.result;
        if (Be++, L = M, Z = su(), Z !== i)
          if (ve = cl(), ve !== i) {
            for (oe = mt(), oe === i && (oe = null), De = [], Ne = M, Qe = M, Be++, Ke = M, Jt = ga(), Jt !== i ? (gt = cl(), gt !== i ? (Lt = M, yr = ki(ve, oe, gt), yr ? yr = void 0 : yr = i, yr !== i ? (Jt = [Jt, gt, yr], Ke = Jt) : (M = Ke, Ke = i)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (Ke = Ka(), Ke !== i ? (Lt = Ne, Ne = vi(ve, oe, Ke)) : (M = Ne, Ne = i)) : (M = Ne, Ne = i); Ne !== i; )
              De.push(Ne), Ne = M, Qe = M, Be++, Ke = M, Jt = ga(), Jt !== i ? (gt = cl(), gt !== i ? (Lt = M, yr = ki(ve, oe, gt), yr ? yr = void 0 : yr = i, yr !== i ? (Jt = [Jt, gt, yr], Ke = Jt) : (M = Ke, Ke = i)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (Ke = Ka(), Ke !== i ? (Lt = Ne, Ne = vi(ve, oe, Ke)) : (M = Ne, Ne = i)) : (M = Ne, Ne = i);
            Ne = ga(), Ne !== i ? (Qe = cl(), Qe !== i ? (Lt = L, L = ha(ve, oe, De)) : (M = L, L = i)) : (M = L, L = i);
          } else
            M = L, L = i;
        else
          M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et(Ge)), It[Cr] = { nextPos: M, result: L }, L;
      }
      function Yy() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt, gt, yr, Cr, Br, xi = M * 52 + 21, Zn = It[xi];
        if (Zn)
          return M = Zn.nextPos, Zn.result;
        if (Be++, L = M, Z = su(), Z !== i)
          if (ve = Ya(), ve !== i)
            if (oe = Vh(), oe !== i)
              if (De = Ni(), De !== i) {
                for (Ne = mt(), Ne === i && (Ne = null), Qe = [], Ke = M, Jt = M, Be++, gt = M, yr = ga(), yr !== i ? (Cr = Da(), Cr !== i ? (Lt = M, Br = Vs(oe, Ne, Cr), Br ? Br = void 0 : Br = i, Br !== i ? (yr = [yr, Cr, Br], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i)) : (M = gt, gt = i), Be--, gt === i ? Jt = void 0 : (M = Jt, Jt = i), Jt !== i ? (gt = $i(), gt !== i ? (Lt = Ke, Ke = Xu(oe, Ne, gt)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i); Ke !== i; )
                  Qe.push(Ke), Ke = M, Jt = M, Be++, gt = M, yr = ga(), yr !== i ? (Cr = Da(), Cr !== i ? (Lt = M, Br = Vs(oe, Ne, Cr), Br ? Br = void 0 : Br = i, Br !== i ? (yr = [yr, Cr, Br], gt = yr) : (M = gt, gt = i)) : (M = gt, gt = i)) : (M = gt, gt = i), Be--, gt === i ? Jt = void 0 : (M = Jt, Jt = i), Jt !== i ? (gt = $i(), gt !== i ? (Lt = Ke, Ke = Xu(oe, Ne, gt)) : (M = Ke, Ke = i)) : (M = Ke, Ke = i);
                Ke = ga(), Ke !== i ? (Jt = Ya(), Jt !== i ? (gt = Vh(), gt !== i ? (yr = Ni(), yr !== i ? (Lt = L, L = Zu(oe, Ne, Qe)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i)) : (M = L, L = i);
              } else
                M = L, L = i;
            else
              M = L, L = i;
          else
            M = L, L = i;
        else
          M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et(lr)), It[xi] = { nextPos: M, result: L }, L;
      }
      function Xy() {
        var L, Z, ve, oe = M * 52 + 23, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.charCodeAt(M) === 91 ? (ve = h, M++) : (ve = i, Be === 0 && Et(je)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function dl() {
        var L, Z, ve, oe = M * 52 + 24, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.charCodeAt(M) === 93 ? (ve = m, M++) : (ve = i, Be === 0 && Et(tt)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function ac() {
        var L, Z, ve, oe = M * 52 + 25, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.charCodeAt(M) === 40 ? (ve = B, M++) : (ve = i, Be === 0 && Et(br)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function fl() {
        var L, Z, ve, oe = M * 52 + 26, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.charCodeAt(M) === 41 ? (ve = U, M++) : (ve = i, Be === 0 && Et(Ut)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function su() {
        var L, Z, ve, oe = M * 52 + 27, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.substr(M, 5) === N ? (ve = N, M += 5) : (ve = i, Be === 0 && Et(cn)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function ga() {
        var L, Z, ve, oe = M * 52 + 28, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (L = M, Z = ba(), Z !== i ? (a.substr(M, 3) === O ? (ve = O, M += 3) : (ve = i, Be === 0 && Et(Re)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L);
      }
      function Vh() {
        var L, Z, ve = M * 52 + 29, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.substr(M, 9) === I ? (Z = I, M += 9) : (Z = i, Be === 0 && Et(J)), Z === i && (a.substr(M, 8) === q ? (Z = q, M += 8) : (Z = i, Be === 0 && Et(He)), Z === i && (a.substr(M, 6) === ae ? (Z = ae, M += 6) : (Z = i, Be === 0 && Et(fr)), Z === i && (a.substr(M, 5) === Q ? (Z = Q, M += 5) : (Z = i, Be === 0 && Et(Mr)), Z === i && (a.substr(M, 8) === ne ? (Z = ne, M += 8) : (Z = i, Be === 0 && Et(ut)), Z === i && (a.substr(M, 7) === le ? (Z = le, M += 7) : (Z = i, Be === 0 && Et(qn)), Z === i && (a.substr(M, 7) === W ? (Z = W, M += 7) : (Z = i, Be === 0 && Et(En)), Z === i && (a.substr(M, 6) === X ? (Z = X, M += 6) : (Z = i, Be === 0 && Et(yi)), Z === i && (a.substr(M, 9) === G ? (Z = G, M += 9) : (Z = i, Be === 0 && Et(Yi)), Z === i && (a.substr(M, 8) === P ? (Z = P, M += 8) : (Z = i, Be === 0 && Et(Xi)), Z === i && (a.substr(M, 8) === he ? (Z = he, M += 8) : (Z = i, Be === 0 && Et(mn)), Z === i && (a.substr(M, 7) === ye ? (Z = ye, M += 7) : (Z = i, Be === 0 && Et(Ri)), Z === i && (a.substr(M, 5) === pe ? (Z = pe, M += 5) : (Z = i, Be === 0 && Et(Ht)), Z === i && (a.substr(M, 4) === $ ? (Z = $, M += 4) : (Z = i, Be === 0 && Et(jt)), Z === i && (a.substr(M, 11) === F ? (Z = F, M += 11) : (Z = i, Be === 0 && Et(jn)))))))))))))))), Z !== i && (Lt = L, Z = Fh(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function ba() {
        var L, Z, ve = M * 52 + 30, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (Be++, L = M, a.charCodeAt(M) === 92 ? (Z = ge, M++) : (Z = i, Be === 0 && Et(ti)), Z !== i && (Lt = L, Z = Ju()), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(Ii)), It[ve] = { nextPos: M, result: L }, L);
      }
      function Ya() {
        var L, Z, ve = M * 52 + 31, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 123 ? (Z = ce, M++) : (Z = i, Be === 0 && Et(Dn)), Z !== i && (Lt = L, Z = Qu(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Ni() {
        var L, Z, ve = M * 52 + 32, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 125 ? (Z = ie, M++) : (Z = i, Be === 0 && Et(ue)), Z !== i && (Lt = L, Z = Hy(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Di() {
        var L, Z, ve = M * 52 + 33, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 36 ? (Z = re, M++) : (Z = i, Be === 0 && Et(Ue)), Z !== i && (Lt = L, Z = $h(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Xd() {
        var L, Z, ve = M * 52 + 34, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 38 ? (Z = Te, M++) : (Z = i, Be === 0 && Et(ze)), Z !== i && (Lt = L, Z = Qi(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function wi() {
        var L, Z, ve, oe = M * 52 + 35, De = It[oe];
        return De ? (M = De.nextPos, De.result) : (Be++, L = M, Z = M, Be++, a.charCodeAt(M) === 13 ? (ve = V, M++) : (ve = i, Be === 0 && Et(yt)), Be--, ve === i ? Z = void 0 : (M = Z, Z = i), Z !== i ? (a.charCodeAt(M) === 10 ? (ve = Pe, M++) : (ve = i, Be === 0 && Et(wt)), ve !== i ? (Z = [Z, ve], L = Z) : (M = L, L = i)) : (M = L, L = i), L === i && (a.charCodeAt(M) === 13 ? (L = V, M++) : (L = i, Be === 0 && Et(yt)), L === i && (a.substr(M, 2) === z ? (L = z, M += 2) : (L = i, Be === 0 && Et(Se)))), Be--, L === i && (Z = i, Be === 0 && Et(At)), It[oe] = { nextPos: M, result: L }, L);
      }
      function Zd() {
        var L, Z, ve = M * 52 + 36, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 35 ? (Z = A, M++) : (Z = i, Be === 0 && Et(qe)), Z !== i && (Lt = L, Z = qd(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Gh() {
        var L, Z, ve = M * 52 + 37, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 94 ? (Z = R, M++) : (Z = i, Be === 0 && Et(lt)), Z !== i && (Lt = L, Z = ec(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Zy() {
        var L, Z, ve = M * 52 + 38, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, a.charCodeAt(M) === 95 ? (Z = H, M++) : (Z = i, Be === 0 && Et(St)), Z !== i && (Lt = L, Z = il(Z)), L = Z, It[ve] = { nextPos: M, result: L }, L);
      }
      function Jd() {
        var L, Z = M * 52 + 39, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (a.charCodeAt(M) === 0 ? (L = be, M++) : (L = i, Be === 0 && Et(Yt)), It[Z] = { nextPos: M, result: L }, L);
      }
      function yn() {
        var L, Z, ve, oe = M * 52 + 40, De = It[oe];
        if (De)
          return M = De.nextPos, De.result;
        if (Be++, L = M, Z = [], Ce.test(a.charAt(M)) ? (ve = a.charAt(M), M++) : (ve = i, Be === 0 && Et(Vr)), ve !== i)
          for (; ve !== i; )
            Z.push(ve), Ce.test(a.charAt(M)) ? (ve = a.charAt(M), M++) : (ve = i, Be === 0 && Et(Vr));
        else
          Z = i;
        return Z !== i && (Lt = L, Z = Bh()), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(Qt)), It[oe] = { nextPos: M, result: L }, L;
      }
      function Wh() {
        var L, Z = M * 52 + 41, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (Be++, We.test(a.charAt(M)) ? (L = a.charAt(M), M++) : (L = i, Be === 0 && Et(On)), Be--, L === i && Be === 0 && Et(gn), It[Z] = { nextPos: M, result: L }, L);
      }
      function Ys() {
        var L, Z = M * 52 + 42, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (Be++, xe.test(a.charAt(M)) ? (L = a.charAt(M), M++) : (L = i, Be === 0 && Et(ys)), Be--, L === i && Be === 0 && Et(bs), It[Z] = { nextPos: M, result: L }, L);
      }
      function Ee() {
        var L, Z, ve = M * 52 + 43, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (Be++, L = M, we.test(a.charAt(M)) ? (Z = a.charAt(M), M++) : (Z = i, Be === 0 && Et(ri)), Z !== i && (Lt = L, Z = ii(Z)), L = Z, Be--, L === i && (Z = i, Be === 0 && Et(_i)), It[ve] = { nextPos: M, result: L }, L);
      }
      function Ye() {
        var L, Z = M * 52 + 44, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (a.charCodeAt(M) === 37 ? (L = c, M++) : (L = i, Be === 0 && Et(Mt)), It[Z] = { nextPos: M, result: L }, L);
      }
      function Xe() {
        var L, Z = M * 52 + 45, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (Be++, L = ht(), L === i && (L = mt()), Be--, L === i && Be === 0 && Et(Ir), It[Z] = { nextPos: M, result: L }, L);
      }
      function ht() {
        var L, Z, ve, oe, De = M * 52 + 46, Ne = It[De];
        if (Ne)
          return M = Ne.nextPos, Ne.result;
        for (L = M, Z = M, ve = [], oe = yn(); oe !== i; )
          ve.push(oe), oe = yn();
        return oe = wi(), oe !== i ? (ve = [ve, oe], Z = ve) : (M = Z, Z = i), Z === i && (Z = null), ve = ot(), ve !== i ? (oe = _t(), oe !== i ? (Lt = L, L = Uh(ve, oe)) : (M = L, L = i)) : (M = L, L = i), It[De] = { nextPos: M, result: L }, L;
      }
      function mt() {
        var L, Z, ve, oe = M * 52 + 47, De = It[oe];
        if (De)
          return M = De.nextPos, De.result;
        for (L = M, Z = [], ve = yn(); ve !== i; )
          Z.push(ve), ve = yn();
        return ve = _t(), ve !== i ? (Lt = L, L = zh(Z, ve)) : (M = L, L = i), It[oe] = { nextPos: M, result: L }, L;
      }
      function _t() {
        var L, Z, ve, oe, De, Ne, Qe, Ke, Jt = M * 52 + 48, gt = It[Jt];
        if (gt)
          return M = gt.nextPos, gt.result;
        if (Be++, L = M, Z = Ye(), Z !== i) {
          for (ve = [], oe = M, De = M, Be++, Ne = wi(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = tc(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
            ve.push(oe), oe = M, De = M, Be++, Ne = wi(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = tc(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
          oe = M, Be++, De = jh(), Be--, De !== i ? (M = oe, oe = void 0) : oe = i, oe !== i ? (Lt = L, L = al(ve)) : (M = L, L = i);
        } else
          M = L, L = i;
        if (L === i)
          if (L = M, Z = Ye(), Z !== i) {
            for (ve = [], oe = M, De = M, Be++, Ne = wi(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = nu(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i); oe !== i; )
              ve.push(oe), oe = M, De = M, Be++, Ne = wi(), Be--, Ne === i ? De = void 0 : (M = De, De = i), De !== i ? (a.length > M ? (Ne = a.charAt(M), M++) : (Ne = i, Be === 0 && Et(Je)), Ne !== i ? (Lt = oe, oe = nu(Ne)) : (M = oe, oe = i)) : (M = oe, oe = i);
            if (oe = M, De = wi(), De !== i) {
              for (Ne = [], Qe = yn(); Qe !== i; )
                Ne.push(Qe), Qe = yn();
              Qe = M, Be++, Ke = Ye(), Be--, Ke === i ? Qe = void 0 : (M = Qe, Qe = i), Qe !== i ? (De = [De, Ne, Qe], oe = De) : (M = oe, oe = i);
            } else
              M = oe, oe = i;
            oe === i && (oe = wi(), oe === i && (oe = Ft())), oe !== i ? (Lt = L, L = Gs(ve)) : (M = L, L = i);
          } else
            M = L, L = i;
        return Be--, L === i && (Z = i, Be === 0 && Et(dt)), It[Jt] = { nextPos: M, result: L }, L;
      }
      function ot() {
        var L, Z, ve, oe, De, Ne = M * 52 + 49, Qe = It[Ne];
        if (Qe)
          return M = Qe.nextPos, Qe.result;
        if (L = M, Z = M, ve = pt(), ve !== i) {
          for (oe = [], De = yn(); De !== i; )
            oe.push(De), De = yn();
          ve = [ve, oe], Z = ve;
        } else
          M = Z, Z = i;
        return Z !== i ? L = a.substring(L, M) : L = Z, It[Ne] = { nextPos: M, result: L }, L;
      }
      function pt() {
        var L, Z = M * 52 + 50, ve = It[Z];
        return ve ? (M = ve.nextPos, ve.result) : (Lt = M, L = sl(), L ? L = void 0 : L = i, It[Z] = { nextPos: M, result: L }, L);
      }
      function Ft() {
        var L, Z, ve = M * 52 + 51, oe = It[ve];
        return oe ? (M = oe.nextPos, oe.result) : (L = M, Be++, a.length > M ? (Z = a.charAt(M), M++) : (Z = i, Be === 0 && Et(Je)), Be--, Z === i ? L = void 0 : (M = L, L = i), It[ve] = { nextPos: M, result: L }, L);
      }
      function Zt(L) {
        return typeof L == "string" ? L : typeof L.content == "string" ? L.content : L && L.type === "whitespace" ? " " : L;
      }
      function mr(L, Z) {
        const ve = typeof L == "string" ? L : L.content.map(Zt).join(""), oe = typeof Z == "string" ? Z : Z.content.map(Zt).join("");
        return ve === oe;
      }
      function Vt(L, Z = {}) {
        return { type: L, ...Z, position: Hd() };
      }
      if (ol = u(), ol !== i && M === a.length)
        return ol;
      throw ol !== i && M < a.length && Et(Vd()), Gy(
        rc,
        Ci < a.length ? a.charAt(Ci) : null,
        Ci < a.length ? nc(Ci, Ci + 1) : nc(Ci, Ci)
      );
    }
    return {
      SyntaxError: t,
      parse: n
    };
  }()
);
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: F }, u = F, c = G(), d = function() {
      return [];
    }, p = function(xe) {
      return { cells: [], colSeps: [], ...xe };
    }, f = function(xe, we, te) {
      return { ...xe, rowSep: we, trailingComment: te };
    }, h = function(xe, we) {
      return { ...xe, rowSep: null, trailingComment: we };
    }, m = function(xe) {
      return xe;
    }, y = function(xe) {
      return {
        cells: [],
        colSeps: [],
        rowSep: null,
        trailingComment: xe
      };
    }, b = function(xe) {
      return xe;
    }, v = function(xe, we) {
      return { colSep: xe, cell: we };
    }, x = function(xe) {
      return { colSep: xe };
    }, _ = function(xe, we) {
      return We(xe, we);
    }, E = function(xe) {
      return We(null, xe);
    }, w = function(xe) {
      return s.isSameLineComment(xe);
    }, C = function(xe) {
      return xe;
    }, k = function(xe) {
      return s.isOwnLineComment(xe);
    }, S = function(xe) {
      return xe;
    }, B = function(xe) {
      return s.isWhitespace(xe);
    }, U = function(xe) {
      return xe;
    }, N = function(xe) {
      return s.isRowSep(xe);
    }, O = function(xe) {
      return xe;
    }, I = function(xe) {
      return s.isColSep(xe);
    }, q = function(xe) {
      return xe;
    }, ae = 0, Q = [{ line: 1, column: 1 }], ne = 0, le = [], W = 0, X;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function G() {
      return { type: "any" };
    }
    function P() {
      return { type: "end" };
    }
    function he(xe) {
      var we = Q[xe], te;
      if (we)
        return we;
      for (te = xe - 1; !Q[te]; )
        te--;
      for (we = Q[te], we = {
        line: we.line,
        column: we.column
      }; te < xe; )
        a.charCodeAt(te) === 10 ? (we.line++, we.column = 1) : we.column++, te++;
      return Q[xe] = we, we;
    }
    function ye(xe, we, te) {
      var Fe = he(xe), Y = he(we), Je = {
        source: o,
        start: {
          offset: xe,
          line: Fe.line,
          column: Fe.column
        },
        end: {
          offset: we,
          line: Y.line,
          column: Y.column
        }
      };
      return Je;
    }
    function pe(xe) {
      ae < ne || (ae > ne && (ne = ae, le = []), le.push(xe));
    }
    function $(xe, we, te) {
      return new t(
        t.buildMessage(xe, we),
        xe,
        we,
        te
      );
    }
    function F() {
      var xe, we;
      if (xe = [], we = re(), we === i && (we = ge(), we === i && (we = ce())), we !== i)
        for (; we !== i; )
          xe.push(we), we = re(), we === i && (we = ge(), we === i && (we = ce()));
      else
        xe = i;
      return xe === i && (xe = ae, we = Ce(), we !== i && (we = d()), xe = we), xe;
    }
    function ge() {
      var xe, we, te, Fe;
      return xe = ae, we = ae, te = z(), te === i && (te = null), te = p(te), we = te, te = be(), te !== i ? (Fe = ie(), Fe === i && (Fe = null), xe = f(we, te, Fe)) : (ae = xe, xe = i), xe;
    }
    function ce() {
      var xe, we, te;
      return xe = ae, we = z(), we !== i ? (te = ie(), te === i && (te = null), xe = h(we, te)) : (ae = xe, xe = i), xe;
    }
    function ie() {
      var xe, we, te;
      for (xe = ae, we = [], te = H(); te !== i; )
        we.push(te), te = H();
      return te = A(), te !== i ? xe = m(te) : (ae = xe, xe = i), xe;
    }
    function re() {
      var xe, we, te;
      for (xe = ae, we = [], te = H(); te !== i; )
        we.push(te), te = H();
      return te = R(), te !== i ? xe = y(te) : (ae = xe, xe = i), xe;
    }
    function Te() {
      var xe, we, te;
      return xe = ae, we = ae, W++, te = be(), te === i && (te = me(), te === i && (te = ie(), te === i && (te = R()))), W--, te === i ? we = void 0 : (ae = we, we = i), we !== i ? (a.length > ae ? (te = a.charAt(ae), ae++) : (te = i, W === 0 && pe(c)), te !== i ? xe = b(te) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function V() {
      var xe, we, te;
      if (xe = ae, we = [], te = Te(), te !== i)
        for (; te !== i; )
          we.push(te), te = Te();
      else
        we = i;
      return we !== i ? xe = a.substring(xe, ae) : xe = we, xe;
    }
    function Pe() {
      var xe, we, te;
      return xe = ae, we = me(), we !== i ? (te = V(), te !== i ? xe = v(we, te) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe === i && (xe = ae, we = me(), we !== i && (we = x(we)), xe = we), xe;
    }
    function z() {
      var xe, we, te, Fe;
      if (xe = ae, we = V(), we !== i) {
        for (te = [], Fe = Pe(); Fe !== i; )
          te.push(Fe), Fe = Pe();
        xe = _(we, te);
      } else
        ae = xe, xe = i;
      if (xe === i) {
        if (xe = ae, we = [], te = Pe(), te !== i)
          for (; te !== i; )
            we.push(te), te = Pe();
        else
          we = i;
        we !== i && (we = E(we)), xe = we;
      }
      return xe;
    }
    function A() {
      var xe, we, te;
      return xe = ae, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), we !== i ? (te = w(we), te ? te = void 0 : te = i, te !== i ? xe = C(we) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function R() {
      var xe, we, te;
      return xe = ae, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), we !== i ? (te = k(we), te ? te = void 0 : te = i, te !== i ? xe = S(we) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function H() {
      var xe, we, te;
      return xe = ae, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), we !== i ? (te = B(we), te ? te = void 0 : te = i, te !== i ? xe = U(we) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function be() {
      var xe, we, te;
      return xe = ae, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), we !== i ? (te = N(we), te ? te = void 0 : te = i, te !== i ? xe = O(we) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function me() {
      var xe, we, te;
      return xe = ae, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), we !== i ? (te = I(we), te ? te = void 0 : te = i, te !== i ? xe = q(we) : (ae = xe, xe = i)) : (ae = xe, xe = i), xe;
    }
    function Ce() {
      var xe, we;
      return xe = ae, W++, a.length > ae ? (we = a.charAt(ae), ae++) : (we = i, W === 0 && pe(c)), W--, we === i ? xe = void 0 : (ae = xe, xe = i), xe;
    }
    function We(xe, we) {
      const te = [xe || []], Fe = [];
      for (const Y of we)
        te.push(Y.cell || []), Fe.push(Y.colSep);
      return { cells: te, colSeps: Fe };
    }
    if (!s.isWhitespace)
      try {
        Object.assign(
          s,
          createMatchers(["\\", "hline", "cr"], ["&"])
        );
      } catch (xe) {
        console.warn("Error when initializing parser", xe);
      }
    if (X = u(), X !== i && ae === a.length)
      return X;
    throw X !== i && ae < a.length && pe(P()), $(
      le,
      ne < a.length ? a.charAt(ne) : null,
      ne < a.length ? ye(ne, ne + 1) : ye(ne, ne)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
const uAe = (
  // Generated by Peggy 3.0.2.
  //
  // https://peggyjs.org/
  function() {
    function e(a, s) {
      function i() {
        this.constructor = a;
      }
      i.prototype = s.prototype, a.prototype = new i();
    }
    function t(a, s, i, o) {
      var l = Error.call(this, a);
      return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
    }
    e(t, Error);
    function r(a, s, i) {
      return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
    }
    t.prototype.format = function(a) {
      var s = "Error: " + this.message;
      if (this.location) {
        var i = null, o;
        for (o = 0; o < a.length; o++)
          if (a[o].source === this.location.source) {
            i = a[o].text.split(/\r\n|\n|\r/g);
            break;
          }
        var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
        if (i) {
          var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
          s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
        } else
          s += `
 at ` + c;
      }
      return s;
    }, t.buildMessage = function(a, s) {
      var i = {
        literal: function(f) {
          return '"' + l(f.text) + '"';
        },
        class: function(f) {
          var h = f.parts.map(function(m) {
            return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
          });
          return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(f) {
          return f.description;
        }
      };
      function o(f) {
        return f.charCodeAt(0).toString(16).toUpperCase();
      }
      function l(f) {
        return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
          return "\\x0" + o(h);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
          return "\\x" + o(h);
        });
      }
      function u(f) {
        return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
          return "\\x0" + o(h);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
          return "\\x" + o(h);
        });
      }
      function c(f) {
        return i[f.type](f);
      }
      function d(f) {
        var h = f.map(c), m, y;
        if (h.sort(), h.length > 0) {
          for (m = 1, y = 1; m < h.length; m++)
            h[m - 1] !== h[m] && (h[y] = h[m], y++);
          h.length = y;
        }
        switch (h.length) {
          case 1:
            return h[0];
          case 2:
            return h[0] + " or " + h[1];
          default:
            return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
        }
      }
      function p(f) {
        return f ? '"' + l(f) + '"' : "end of input";
      }
      return "Expected " + d(a) + " but " + p(s) + " found.";
    };
    function n(a, s) {
      s = s !== void 0 ? s : {};
      var i = {}, o = s.grammarSource, l = { args_spec_list: Re }, u = Re, c = "v", d = "b", p = "!", f = "D", h = "d", m = "s", y = "O", b = "o", v = "e", x = "E", _ = "t", E = "R", w = "r", C = "u", k = "m", S = "{", B = "}", U = " ", N = `
`, O = "\r", I = "\\", q = /^[{ ]/, ae = /^[a-zA-Z]/, Q = /^[{}]/, ne = or("+", !1), le = or("v", !1), W = Ve(), X = or("b", !1), G = or("!", !1), P = or("D", !1), he = or("d", !1), ye = or("s", !1), pe = or("O", !1), $ = or("o", !1), F = or("e", !1), ge = or("E", !1), ce = or("t", !1), ie = or("R", !1), re = or("r", !1), Te = or("u", !1), V = Ae(["{", " "], !1, !1), Pe = or("m", !1), z = or("{", !1), A = or("}", !1), R = or(" ", !1), H = or(`
`, !1), be = or("\r", !1), me = or("\\", !1), Ce = Ae([["a", "z"], ["A", "Z"]], !1, !1), We = Ae(["{", "}"], !1, !1), xe = function(Se) {
        return Se;
      }, we = function(Se) {
        return Se;
      }, te = function(Se) {
        return Se;
      }, Fe = function(Se) {
        return yt("verbatim", { openBrace: Se, closeBrace: Se });
      }, Y = function() {
        return yt("body");
      }, Je = function(Se, qe) {
        return Se ? { ...qe, noLeadingWhitespace: !0 } : qe;
      }, xt = function(Se, qe) {
        return yt("optional", { ...Se, defaultArg: qe });
      }, Ze = function(Se) {
        return yt("optional", Se);
      }, rt = function() {
        return yt("optionalStar");
      }, Mt = function(Se) {
        return yt("optional", { defaultArg: Se });
      }, Qt = function() {
        return yt("optional");
      }, kr = function(Se) {
        return yt("embellishment", {
          embellishmentTokens: Se
        });
      }, tr = function(Se, qe) {
        return yt("embellishment", {
          embellishmentTokens: Se,
          defaultArg: qe
        });
      }, Oe = function(Se) {
        return yt("optionalToken", { token: Se });
      }, Ie = function(Se, qe) {
        return yt("mandatory", { ...Se, defaultArg: qe });
      }, Me = function(Se) {
        return yt("mandatory", Se);
      }, je = function(Se) {
        return yt("until", { stopTokens: Se });
      }, tt = function(Se) {
        return [Se];
      }, Ct = function(Se) {
        return Se.content;
      }, Kt = function() {
        return yt("mandatory");
      }, ct = function(Se, qe) {
        return { openBrace: Se, closeBrace: qe };
      }, ir = function(Se) {
        return Se.content.map(wt).join("");
      }, xr = function(Se) {
        return [Se];
      }, Rr = function(Se) {
        return Se.filter((qe) => !qe.match(/^\s*$/));
      }, Nt = function(Se) {
        return { type: "group", content: Se };
      }, dr = function() {
        return "";
      }, $e = 0, at = [{ line: 1, column: 1 }], Rt = 0, sr = [], bt = 0, Ur;
      if ("startRule" in s) {
        if (!(s.startRule in l))
          throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
        u = l[s.startRule];
      }
      function or(Se, qe) {
        return { type: "literal", text: Se, ignoreCase: qe };
      }
      function Ae(Se, qe, lt) {
        return { type: "class", parts: Se, inverted: qe, ignoreCase: lt };
      }
      function Ve() {
        return { type: "any" };
      }
      function Ge() {
        return { type: "end" };
      }
      function lr(Se) {
        var qe = at[Se], lt;
        if (qe)
          return qe;
        for (lt = Se - 1; !at[lt]; )
          lt--;
        for (qe = at[lt], qe = {
          line: qe.line,
          column: qe.column
        }; lt < Se; )
          a.charCodeAt(lt) === 10 ? (qe.line++, qe.column = 1) : qe.column++, lt++;
        return at[Se] = qe, qe;
      }
      function br(Se, qe, lt) {
        var St = lr(Se), Yt = lr(qe), Vr = {
          source: o,
          start: {
            offset: Se,
            line: St.line,
            column: St.column
          },
          end: {
            offset: qe,
            line: Yt.line,
            column: Yt.column
          }
        };
        return Vr;
      }
      function Ut(Se) {
        $e < Rt || ($e > Rt && (Rt = $e, sr = []), sr.push(Se));
      }
      function cn(Se, qe, lt) {
        return new t(
          t.buildMessage(Se, qe),
          Se,
          qe,
          lt
        );
      }
      function Re() {
        var Se, qe, lt, St;
        for (Se = $e, qe = [], lt = $e, Dn(), St = J(), St !== i ? lt = xe(St) : ($e = lt, lt = i); lt !== i; )
          qe.push(lt), lt = $e, Dn(), St = J(), St !== i ? lt = xe(St) : ($e = lt, lt = i);
        return lt = Dn(), Se = we(qe), Se;
      }
      function J() {
        var Se, qe;
        return Se = $e, a.charCodeAt($e) === 43 ? $e++ : bt === 0 && Ut(ne), qe = Mr(), qe === i && (qe = Ht(), qe === i && (qe = He(), qe === i && (qe = Xi(), qe === i && (qe = fr(), qe === i && (qe = mn()))))), qe !== i ? Se = te(qe) : ($e = Se, Se = i), Se;
      }
      function He() {
        var Se, qe, lt;
        return Se = $e, a.charCodeAt($e) === 118 ? (qe = c, $e++) : (qe = i, bt === 0 && Ut(le)), qe !== i ? (a.length > $e ? (lt = a.charAt($e), $e++) : (lt = i, bt === 0 && Ut(W)), lt !== i ? Se = Fe(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se;
      }
      function fr() {
        var Se, qe;
        return Se = $e, a.charCodeAt($e) === 98 ? (qe = d, $e++) : (qe = i, bt === 0 && Ut(X)), qe !== i && (qe = Y()), Se = qe, Se;
      }
      function Mr() {
        var Se, qe, lt;
        return Se = $e, a.charCodeAt($e) === 33 ? (qe = p, $e++) : (qe = i, bt === 0 && Ut(G)), qe === i && (qe = null), lt = qn(), lt === i && (lt = En(), lt === i && (lt = ut(), lt === i && (lt = yi(), lt === i && (lt = Yi())))), lt !== i ? Se = Je(qe, lt) : ($e = Se, Se = i), Se;
      }
      function ut() {
        var Se, qe, lt, St;
        return Se = $e, a.charCodeAt($e) === 68 ? (qe = f, $e++) : (qe = i, bt === 0 && Ut(P)), qe !== i ? (lt = jt(), St = jn(), St !== i ? Se = xt(lt, St) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se === i && (Se = $e, a.charCodeAt($e) === 100 ? (qe = h, $e++) : (qe = i, bt === 0 && Ut(he)), qe !== i ? (lt = jt(), Se = Ze(lt)) : ($e = Se, Se = i)), Se;
      }
      function qn() {
        var Se, qe;
        return Se = $e, a.charCodeAt($e) === 115 ? (qe = m, $e++) : (qe = i, bt === 0 && Ut(ye)), qe !== i && (qe = rt()), Se = qe, Se;
      }
      function En() {
        var Se, qe, lt;
        return Se = $e, a.charCodeAt($e) === 79 ? (qe = y, $e++) : (qe = i, bt === 0 && Ut(pe)), qe !== i ? (Dn(), lt = jn(), lt !== i ? Se = Mt(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se === i && (Se = $e, a.charCodeAt($e) === 111 ? (qe = b, $e++) : (qe = i, bt === 0 && Ut($)), qe !== i && (qe = Qt()), Se = qe), Se;
      }
      function yi() {
        var Se, qe, lt, St;
        return Se = $e, a.charCodeAt($e) === 101 ? (qe = v, $e++) : (qe = i, bt === 0 && Ut(F)), qe !== i ? (Dn(), lt = Ii(), lt !== i ? Se = kr(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se === i && (Se = $e, a.charCodeAt($e) === 69 ? (qe = x, $e++) : (qe = i, bt === 0 && Ut(ge)), qe !== i ? (Dn(), lt = Ii(), lt !== i ? (Dn(), St = Ii(), St !== i ? Se = tr(lt, St) : ($e = Se, Se = i)) : ($e = Se, Se = i)) : ($e = Se, Se = i)), Se;
      }
      function Yi() {
        var Se, qe, lt;
        return Se = $e, a.charCodeAt($e) === 116 ? (qe = _, $e++) : (qe = i, bt === 0 && Ut(ce)), qe !== i ? (a.length > $e ? (lt = a.charAt($e), $e++) : (lt = i, bt === 0 && Ut(W)), lt !== i ? Se = Oe(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se;
      }
      function Xi() {
        var Se, qe, lt, St;
        return Se = $e, a.charCodeAt($e) === 82 ? (qe = E, $e++) : (qe = i, bt === 0 && Ut(ie)), qe !== i ? (lt = jt(), St = jn(), St !== i ? Se = Ie(lt, St) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se === i && (Se = $e, a.charCodeAt($e) === 114 ? (qe = w, $e++) : (qe = i, bt === 0 && Ut(re)), qe !== i ? (lt = jt(), Se = Me(lt)) : ($e = Se, Se = i)), Se;
      }
      function mn() {
        var Se, qe, lt;
        return Se = $e, a.charCodeAt($e) === 117 ? (qe = C, $e++) : (qe = i, bt === 0 && Ut(Te)), qe !== i ? (lt = Ri(), lt !== i ? Se = je(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se;
      }
      function Ri() {
        var Se, qe, lt;
        return Se = $e, qe = $e, bt++, q.test(a.charAt($e)) ? (lt = a.charAt($e), $e++) : (lt = i, bt === 0 && Ut(V)), bt--, lt === i ? qe = void 0 : ($e = qe, qe = i), qe !== i ? (a.length > $e ? (lt = a.charAt($e), $e++) : (lt = i, bt === 0 && Ut(W)), lt !== i ? Se = tt(lt) : ($e = Se, Se = i)) : ($e = Se, Se = i), Se === i && (Se = $e, qe = ti(), qe !== i && (qe = Ct(qe)), Se = qe), Se;
      }
      function Ht() {
        var Se, qe;
        return Se = $e, a.charCodeAt($e) === 109 ? (qe = k, $e++) : (qe = i, bt === 0 && Ut(Pe)), qe !== i && (qe = Kt()), Se = qe, Se;
      }
      function jt() {
        var Se, qe, lt, St, Yt, Vr;
        return Se = $e, qe = $e, lt = $e, St = $e, bt++, Yt = ue(), bt--, Yt === i ? St = void 0 : ($e = St, St = i), St !== i ? (Yt = Ue(), Yt === i && (a.length > $e ? (Yt = a.charAt($e), $e++) : (Yt = i, bt === 0 && Ut(W))), Yt !== i ? (St = [St, Yt], lt = St) : ($e = lt, lt = i)) : ($e = lt, lt = i), lt === i && (lt = null), qe = a.substring(qe, $e), lt = $e, St = $e, Yt = $e, bt++, Vr = ue(), bt--, Vr === i ? Yt = void 0 : ($e = Yt, Yt = i), Yt !== i ? (Vr = Ue(), Vr === i && (a.length > $e ? (Vr = a.charAt($e), $e++) : (Vr = i, bt === 0 && Ut(W))), Vr !== i ? (Yt = [Yt, Vr], St = Yt) : ($e = St, St = i)) : ($e = St, St = i), St === i && (St = null), lt = a.substring(lt, $e), Se = ct(qe, lt), Se;
      }
      function jn() {
        var Se, qe;
        return Se = ze(), Se === i && (Se = $e, qe = ti(), qe !== i && (qe = ir(qe)), Se = qe), Se;
      }
      function Ii() {
        var Se, qe, lt, St;
        if (Se = $e, qe = ze(), qe !== i && (qe = xr(qe)), Se = qe, Se === i)
          if (Se = $e, a.charCodeAt($e) === 123 ? (qe = S, $e++) : (qe = i, bt === 0 && Ut(z)), qe !== i) {
            for (lt = [], St = jn(), St === i && (St = ue()); St !== i; )
              lt.push(St), St = jn(), St === i && (St = ue());
            a.charCodeAt($e) === 125 ? (St = B, $e++) : (St = i, bt === 0 && Ut(A)), St !== i ? Se = Rr(lt) : ($e = Se, Se = i);
          } else
            $e = Se, Se = i;
        return Se;
      }
      function ti() {
        var Se, qe, lt, St, Yt, Vr, gn, On;
        if (Se = $e, a.charCodeAt($e) === 123 ? (qe = S, $e++) : (qe = i, bt === 0 && Ut(z)), qe !== i) {
          for (lt = [], St = $e, Yt = $e, Vr = $e, bt++, a.charCodeAt($e) === 125 ? (gn = B, $e++) : (gn = i, bt === 0 && Ut(A)), bt--, gn === i ? Vr = void 0 : ($e = Vr, Vr = i), Vr !== i ? (gn = $e, bt++, On = ti(), bt--, On === i ? gn = void 0 : ($e = gn, gn = i), gn !== i ? (On = ze(), On === i && (On = ue()), On !== i ? (Vr = [Vr, gn, On], Yt = Vr) : ($e = Yt, Yt = i)) : ($e = Yt, Yt = i)) : ($e = Yt, Yt = i), Yt !== i ? St = a.substring(St, $e) : St = Yt, St === i && (St = ti()); St !== i; )
            lt.push(St), St = $e, Yt = $e, Vr = $e, bt++, a.charCodeAt($e) === 125 ? (gn = B, $e++) : (gn = i, bt === 0 && Ut(A)), bt--, gn === i ? Vr = void 0 : ($e = Vr, Vr = i), Vr !== i ? (gn = $e, bt++, On = ti(), bt--, On === i ? gn = void 0 : ($e = gn, gn = i), gn !== i ? (On = ze(), On === i && (On = ue()), On !== i ? (Vr = [Vr, gn, On], Yt = Vr) : ($e = Yt, Yt = i)) : ($e = Yt, Yt = i)) : ($e = Yt, Yt = i), Yt !== i ? St = a.substring(St, $e) : St = Yt, St === i && (St = ti());
          a.charCodeAt($e) === 125 ? (St = B, $e++) : (St = i, bt === 0 && Ut(A)), St !== i ? Se = Nt(lt) : ($e = Se, Se = i);
        } else
          $e = Se, Se = i;
        return Se;
      }
      function Dn() {
        var Se, qe, lt;
        for (Se = $e, qe = [], lt = ue(); lt !== i; )
          qe.push(lt), lt = ue();
        return qe = dr(), Se = qe, Se;
      }
      function ue() {
        var Se;
        return a.charCodeAt($e) === 32 ? (Se = U, $e++) : (Se = i, bt === 0 && Ut(R)), Se === i && (a.charCodeAt($e) === 10 ? (Se = N, $e++) : (Se = i, bt === 0 && Ut(H)), Se === i && (a.charCodeAt($e) === 13 ? (Se = O, $e++) : (Se = i, bt === 0 && Ut(be)))), Se;
      }
      function Ue() {
        var Se, qe, lt, St, Yt;
        if (Se = $e, qe = $e, a.charCodeAt($e) === 92 ? (lt = I, $e++) : (lt = i, bt === 0 && Ut(me)), lt !== i) {
          if (St = [], ae.test(a.charAt($e)) ? (Yt = a.charAt($e), $e++) : (Yt = i, bt === 0 && Ut(Ce)), Yt !== i)
            for (; Yt !== i; )
              St.push(Yt), ae.test(a.charAt($e)) ? (Yt = a.charAt($e), $e++) : (Yt = i, bt === 0 && Ut(Ce));
          else
            St = i;
          St !== i ? (lt = [lt, St], qe = lt) : ($e = qe, qe = i);
        } else
          $e = qe, qe = i;
        return qe !== i ? Se = a.substring(Se, $e) : Se = qe, Se === i && (Se = $e, qe = $e, a.charCodeAt($e) === 92 ? (lt = I, $e++) : (lt = i, bt === 0 && Ut(me)), lt !== i ? (St = $e, bt++, ae.test(a.charAt($e)) ? (Yt = a.charAt($e), $e++) : (Yt = i, bt === 0 && Ut(Ce)), bt--, Yt === i ? St = void 0 : ($e = St, St = i), St !== i ? (a.length > $e ? (Yt = a.charAt($e), $e++) : (Yt = i, bt === 0 && Ut(W)), Yt !== i ? (lt = [lt, St, Yt], qe = lt) : ($e = qe, qe = i)) : ($e = qe, qe = i)) : ($e = qe, qe = i), qe !== i ? Se = a.substring(Se, $e) : Se = qe), Se;
      }
      function ze() {
        var Se, qe, lt, St;
        return Se = Ue(), Se === i && (Se = $e, qe = $e, bt++, Q.test(a.charAt($e)) ? (lt = a.charAt($e), $e++) : (lt = i, bt === 0 && Ut(We)), bt--, lt === i ? qe = void 0 : ($e = qe, qe = i), qe !== i ? (lt = $e, bt++, St = ue(), bt--, St === i ? lt = void 0 : ($e = lt, lt = i), lt !== i ? (a.length > $e ? (St = a.charAt($e), $e++) : (St = i, bt === 0 && Ut(W)), St !== i ? Se = St : ($e = Se, Se = i)) : ($e = Se, Se = i)) : ($e = Se, Se = i)), Se;
      }
      const At = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function yt(Se, qe) {
        const lt = At[Se] || {};
        return { type: Se, ...lt, ...qe };
      }
      function wt(Se) {
        return typeof Se != "object" || !Se ? Se : Se.type === "group" ? `{${Se.content.map(wt).join("")}}` : Se;
      }
      if (Ur = u(), Ur !== i && $e === a.length)
        return Ur;
      throw Ur !== i && $e < a.length && Ut(Ge()), cn(
        sr,
        Rt < a.length ? a.charAt(Rt) : null,
        Rt < a.length ? br(Rt, Rt + 1) : br(Rt, Rt)
      );
    }
    return {
      SyntaxError: t,
      parse: n
    };
  }()
);
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: Pe }, u = Pe, c = ge(), d = function() {
      return [];
    }, p = function(Ie, Me) {
      return {
        itemParts: [],
        ...Ie,
        trailingComment: Me,
        trailingComma: !0
      };
    }, f = function(Ie, Me) {
      return { ...Ie, trailingComment: Me };
    }, h = function(Ie, Me) {
      return Oe(Ie, Me);
    }, m = function(Ie) {
      return Oe(null, Ie);
    }, y = function(Ie) {
      return { cell: Ie };
    }, b = function() {
      return {};
    }, v = function(Ie) {
      return Ie;
    }, x = function(Ie) {
      return Ie;
    }, _ = function(Ie, Me) {
      return {
        trailingComment: Me,
        leadingParbreak: Ie.parbreak > 0
      };
    }, E = function(Ie) {
      return {
        whitespace: Ie.filter((Me) => s.isWhitespace(Me)).length,
        parbreak: Ie.filter((Me) => s.isParbreak(Me)).length
      };
    }, w = function() {
      return !s.allowParenGroups;
    }, C = function(Ie) {
      return s.isSameLineComment(Ie);
    }, k = function(Ie) {
      return Ie;
    }, S = function(Ie) {
      return s.isOwnLineComment(Ie);
    }, B = function(Ie) {
      return Ie;
    }, U = function(Ie) {
      return s.isWhitespace(Ie);
    }, N = function(Ie) {
      return Ie;
    }, O = function(Ie) {
      return s.isParbreak(Ie);
    }, I = function(Ie) {
      return Ie;
    }, q = function(Ie) {
      return s.isComma(Ie);
    }, ae = function(Ie) {
      return Ie;
    }, Q = function(Ie) {
      return s.isEquals(Ie);
    }, ne = function(Ie) {
      return Ie;
    }, le = function(Ie) {
      return s.isChar(Ie, "(");
    }, W = function(Ie) {
      return Ie;
    }, X = function(Ie) {
      return s.isChar(Ie, ")");
    }, G = function(Ie) {
      return Ie;
    }, P = 0, he = [{ line: 1, column: 1 }], ye = 0, pe = [], $ = 0, F;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function ge() {
      return { type: "any" };
    }
    function ce() {
      return { type: "end" };
    }
    function ie(Ie) {
      var Me = he[Ie], je;
      if (Me)
        return Me;
      for (je = Ie - 1; !he[je]; )
        je--;
      for (Me = he[je], Me = {
        line: Me.line,
        column: Me.column
      }; je < Ie; )
        a.charCodeAt(je) === 10 ? (Me.line++, Me.column = 1) : Me.column++, je++;
      return he[Ie] = Me, Me;
    }
    function re(Ie, Me, je) {
      var tt = ie(Ie), Ct = ie(Me), Kt = {
        source: o,
        start: {
          offset: Ie,
          line: tt.line,
          column: tt.column
        },
        end: {
          offset: Me,
          line: Ct.line,
          column: Ct.column
        }
      };
      return Kt;
    }
    function Te(Ie) {
      P < ye || (P > ye && (ye = P, pe = []), pe.push(Ie));
    }
    function V(Ie, Me, je) {
      return new t(
        t.buildMessage(Ie, Me),
        Ie,
        Me,
        je
      );
    }
    function Pe() {
      var Ie, Me, je;
      if (Ie = [], Me = Ce(), Me === i && (Me = z(), Me === i && (Me = A())), Me !== i)
        for (; Me !== i; )
          Ie.push(Me), Me = Ce(), Me === i && (Me = z(), Me === i && (Me = A()));
      else
        Ie = i;
      if (Ie === i) {
        for (Ie = P, Me = [], je = xt(); je !== i; )
          Me.push(je), je = xt();
        je = tr(), je !== i ? Ie = d() : (P = Ie, Ie = i);
      }
      return Ie;
    }
    function z() {
      var Ie, Me, je, tt, Ct, Kt, ct;
      if (Ie = P, te(), Me = R(), Me === i && (Me = null), te(), je = rt(), je !== i) {
        for (tt = [], Ct = xt(); Ct !== i; )
          tt.push(Ct), Ct = xt();
        for (Ct = me(), Ct === i && (Ct = null), Kt = [], ct = xt(); ct !== i; )
          Kt.push(ct), ct = xt();
        Ie = p(Me, Ct);
      } else
        P = Ie, Ie = i;
      return Ie;
    }
    function A() {
      var Ie, Me, je;
      return Ie = P, te(), Me = R(), Me !== i ? (je = me(), je === i && (je = null), Ie = f(Me, je)) : (P = Ie, Ie = i), Ie;
    }
    function R() {
      var Ie, Me, je, tt;
      if (Ie = P, Me = be(), Me !== i) {
        for (je = [], tt = H(); tt !== i; )
          je.push(tt), tt = H();
        Ie = h(Me, je);
      } else
        P = Ie, Ie = i;
      if (Ie === i) {
        if (Ie = P, Me = [], je = H(), je !== i)
          for (; je !== i; )
            Me.push(je), je = H();
        else
          Me = i;
        Me !== i && (Me = m(Me)), Ie = Me;
      }
      return Ie;
    }
    function H() {
      var Ie, Me, je, tt, Ct;
      for (Ie = P, Me = [], je = Ze(); je !== i; )
        Me.push(je), je = Ze();
      if (je = Mt(), je !== i) {
        for (tt = [], Ct = Ze(); Ct !== i; )
          tt.push(Ct), Ct = Ze();
        Ct = be(), Ct !== i ? Ie = y(Ct) : (P = Ie, Ie = i);
      } else
        P = Ie, Ie = i;
      if (Ie === i) {
        for (Ie = P, Me = [], je = Ze(); je !== i; )
          Me.push(je), je = Ze();
        je = Mt(), je !== i ? Ie = b() : (P = Ie, Ie = i);
      }
      return Ie;
    }
    function be() {
      var Ie, Me, je, tt, Ct, Kt, ct, ir, xr, Rr;
      for (Ie = P, Me = [], je = xt(); je !== i; )
        Me.push(je), je = xt();
      if (je = P, tt = [], Ct = xe(), Ct === i)
        if (Ct = P, Kt = xt(), Kt === i && (Kt = Ze()), Kt !== i) {
          for (ct = P, $++, ir = P, xr = [], Rr = xt(), Rr === i && (Rr = Ze()); Rr !== i; )
            xr.push(Rr), Rr = xt(), Rr === i && (Rr = Ze());
          Rr = xe(), Rr !== i ? (xr = [xr, Rr], ir = xr) : (P = ir, ir = i), $--, ir !== i ? (P = ct, ct = void 0) : ct = i, ct !== i ? (Kt = [Kt, ct], Ct = Kt) : (P = Ct, Ct = i);
        } else
          P = Ct, Ct = i;
      if (Ct !== i) {
        for (; Ct !== i; )
          if (tt.push(Ct), Ct = xe(), Ct === i)
            if (Ct = P, Kt = xt(), Kt === i && (Kt = Ze()), Kt !== i) {
              for (ct = P, $++, ir = P, xr = [], Rr = xt(), Rr === i && (Rr = Ze()); Rr !== i; )
                xr.push(Rr), Rr = xt(), Rr === i && (Rr = Ze());
              Rr = xe(), Rr !== i ? (xr = [xr, Rr], ir = xr) : (P = ir, ir = i), $--, ir !== i ? (P = ct, ct = void 0) : ct = i, ct !== i ? (Kt = [Kt, ct], Ct = Kt) : (P = Ct, Ct = i);
            } else
              P = Ct, Ct = i;
      } else
        tt = i;
      if (tt !== i ? je = a.substring(je, P) : je = tt, je !== i) {
        for (tt = [], Ct = xt(); Ct !== i; )
          tt.push(Ct), Ct = xt();
        Ie = v(je);
      } else
        P = Ie, Ie = i;
      return Ie;
    }
    function me() {
      var Ie, Me, je;
      for (Ie = P, Me = [], je = xt(); je !== i; )
        Me.push(je), je = xt();
      return je = Y(), je !== i ? Ie = x(je) : (P = Ie, Ie = i), Ie;
    }
    function Ce() {
      var Ie, Me, je;
      return Ie = P, Me = te(), je = Je(), je !== i ? Ie = _(Me, je) : (P = Ie, Ie = i), Ie;
    }
    function We() {
      var Ie, Me, je, tt;
      return Ie = P, Me = P, je = P, $++, tt = we(), $--, tt === i ? je = void 0 : (P = je, je = i), je !== i ? (a.length > P ? (tt = a.charAt(P), P++) : (tt = i, $ === 0 && Te(c)), tt !== i ? (je = [je, tt], Me = je) : (P = Me, Me = i)) : (P = Me, Me = i), Me !== i ? Ie = a.substring(Ie, P) : Ie = Me, Ie;
    }
    function xe() {
      var Ie, Me, je, tt;
      return Ie = P, Me = P, je = P, $++, tt = xt(), tt === i && (tt = Ze()), $--, tt === i ? je = void 0 : (P = je, je = i), je !== i ? (tt = Fe(), tt === i && (tt = We()), tt !== i ? (je = [je, tt], Me = je) : (P = Me, Me = i)) : (P = Me, Me = i), Me !== i ? Ie = a.substring(Ie, P) : Ie = Me, Ie;
    }
    function we() {
      var Ie;
      return Ie = rt(), Ie === i && (Ie = Mt(), Ie === i && (Ie = me(), Ie === i && (Ie = Je()))), Ie;
    }
    function te() {
      var Ie, Me, je;
      for (Ie = P, Me = [], je = xt(), je === i && (je = Ze()); je !== i; )
        Me.push(je), je = xt(), je === i && (je = Ze());
      return Me = E(Me), Ie = Me, Ie;
    }
    function Fe() {
      var Ie, Me, je, tt, Ct, Kt, ct, ir, xr;
      if (Ie = P, Me = w(), Me ? Me = i : Me = void 0, Me !== i) {
        if (je = P, tt = P, Ct = Qt(), Ct !== i) {
          for (Kt = [], ct = P, ir = P, $++, xr = kr(), $--, xr === i ? ir = void 0 : (P = ir, ir = i), ir !== i ? (a.length > P ? (xr = a.charAt(P), P++) : (xr = i, $ === 0 && Te(c)), xr !== i ? (ir = [ir, xr], ct = ir) : (P = ct, ct = i)) : (P = ct, ct = i); ct !== i; )
            Kt.push(ct), ct = P, ir = P, $++, xr = kr(), $--, xr === i ? ir = void 0 : (P = ir, ir = i), ir !== i ? (a.length > P ? (xr = a.charAt(P), P++) : (xr = i, $ === 0 && Te(c)), xr !== i ? (ir = [ir, xr], ct = ir) : (P = ct, ct = i)) : (P = ct, ct = i);
          ct = kr(), ct !== i ? (Ct = [Ct, Kt, ct], tt = Ct) : (P = tt, tt = i);
        } else
          P = tt, tt = i;
        tt !== i ? je = a.substring(je, P) : je = tt, je !== i ? (Me = [Me, je], Ie = Me) : (P = Ie, Ie = i);
      } else
        P = Ie, Ie = i;
      return Ie;
    }
    function Y() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = C(Me), je ? je = void 0 : je = i, je !== i ? Ie = k(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function Je() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = S(Me), je ? je = void 0 : je = i, je !== i ? Ie = B(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function xt() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = U(Me), je ? je = void 0 : je = i, je !== i ? Ie = N(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function Ze() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = O(Me), je ? je = void 0 : je = i, je !== i ? Ie = I(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function rt() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = q(Me), je ? je = void 0 : je = i, je !== i ? Ie = ae(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function Mt() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = Q(Me), je ? je = void 0 : je = i, je !== i ? Ie = ne(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function Qt() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = le(Me), je ? je = void 0 : je = i, je !== i ? Ie = W(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function kr() {
      var Ie, Me, je;
      return Ie = P, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), Me !== i ? (je = X(Me), je ? je = void 0 : je = i, je !== i ? Ie = G(Me) : (P = Ie, Ie = i)) : (P = Ie, Ie = i), Ie;
    }
    function tr() {
      var Ie, Me;
      return Ie = P, $++, a.length > P ? (Me = a.charAt(P), P++) : (Me = i, $ === 0 && Te(c)), $--, Me === i ? Ie = void 0 : (P = Ie, Ie = i), Ie;
    }
    function Oe(Ie, Me) {
      const je = [Ie || []];
      for (const tt of Me)
        je.push(tt.cell || []);
      return { itemParts: je };
    }
    if (!s.isWhitespace)
      try {
        Object.assign(s, {
          isChar: (Ie, Me) => Ie.type === "string" && Ie.content === Me,
          isComma(Ie) {
            return Ie.type === "string" && Ie.content === ",";
          },
          isEquals(Ie) {
            return Ie.type === "string" && Ie.content === "=";
          },
          isParbreak(Ie) {
            return Ie.type === "parbreak";
          },
          isWhitespace(Ie) {
            return Ie.type === "whitespace";
          },
          isSameLineComment: (Ie) => Ie.type === "comment" && Ie.sameline,
          isOwnLineComment: (Ie) => Ie.type === "comment" && !Ie.sameline,
          isComment: (Ie) => Ie.type === "comment",
          allowParenGroups: !0
        });
      } catch (Ie) {
        console.warn("Error when initializing parser", Ie);
      }
    if (F = u(), F !== i && P === a.length)
      return F;
    throw F !== i && P < a.length && Te(ce()), V(
      pe,
      ye < a.length ? a.charAt(ye) : null,
      ye < a.length ? re(ye, ye + 1) : re(ye, ye)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: q }, u = q, c = S(), d = function(X) {
      return [].concat(...X).filter((G) => !!G);
    }, p = function() {
      return [];
    }, f = function(X) {
      return s.isHash(X);
    }, h = function(X) {
      return X;
    }, m = function(X) {
      return s.isNumber(X);
    }, y = function(X) {
      return X;
    }, b = function() {
      return { type: "string", content: "#" };
    }, v = function(X) {
      const G = s.splitNumber(X);
      return [{ type: "hash_number", number: G.number }, G.rest];
    }, x = 0, _ = [{ line: 1, column: 1 }], E = 0, w = [], C = 0, k;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function S() {
      return { type: "any" };
    }
    function B() {
      return { type: "end" };
    }
    function U(X) {
      var G = _[X], P;
      if (G)
        return G;
      for (P = X - 1; !_[P]; )
        P--;
      for (G = _[P], G = {
        line: G.line,
        column: G.column
      }; P < X; )
        a.charCodeAt(P) === 10 ? (G.line++, G.column = 1) : G.column++, P++;
      return _[X] = G, G;
    }
    function N(X, G, P) {
      var he = U(X), ye = U(G), pe = {
        source: o,
        start: {
          offset: X,
          line: he.line,
          column: he.column
        },
        end: {
          offset: G,
          line: ye.line,
          column: ye.column
        }
      };
      return pe;
    }
    function O(X) {
      x < E || (x > E && (E = x, w = []), w.push(X));
    }
    function I(X, G, P) {
      return new t(
        t.buildMessage(X, G),
        X,
        G,
        P
      );
    }
    function q() {
      var X, G, P;
      if (X = x, G = [], P = ne(), P === i && (P = le(), P === i && (a.length > x ? (P = a.charAt(x), x++) : (P = i, C === 0 && O(c)))), P !== i)
        for (; P !== i; )
          G.push(P), P = ne(), P === i && (P = le(), P === i && (a.length > x ? (P = a.charAt(x), x++) : (P = i, C === 0 && O(c))));
      else
        G = i;
      return G !== i && (G = d(G)), X = G, X === i && (X = x, G = W(), G !== i && (G = p()), X = G), X;
    }
    function ae() {
      var X, G, P;
      return X = x, a.length > x ? (G = a.charAt(x), x++) : (G = i, C === 0 && O(c)), G !== i ? (P = f(G), P ? P = void 0 : P = i, P !== i ? X = h(G) : (x = X, X = i)) : (x = X, X = i), X;
    }
    function Q() {
      var X, G, P;
      return X = x, a.length > x ? (G = a.charAt(x), x++) : (G = i, C === 0 && O(c)), G !== i ? (P = m(G), P ? P = void 0 : P = i, P !== i ? X = y(G) : (x = X, X = i)) : (x = X, X = i), X;
    }
    function ne() {
      var X, G, P;
      return X = x, G = ae(), G !== i ? (P = ae(), P !== i ? X = b() : (x = X, X = i)) : (x = X, X = i), X;
    }
    function le() {
      var X, G, P;
      return X = x, G = ae(), G !== i ? (P = Q(), P !== i ? X = v(P) : (x = X, X = i)) : (x = X, X = i), X;
    }
    function W() {
      var X, G;
      return X = x, C++, a.length > x ? (G = a.charAt(x), x++) : (G = i, C === 0 && O(c)), C--, G === i ? X = void 0 : (x = X, X = i), X;
    }
    if (!s.isHash)
      try {
        Object.assign(s, {
          isHash: (X) => X.type === "string" && X.content === "#",
          isNumber: (X) => X.type === "string" && 0 < +X.content.charAt(0),
          splitNumber: (X) => {
            const G = +X.content.charAt(0);
            return X.content.length > 1 ? {
              number: G,
              rest: {
                type: "string",
                content: X.content.slice(1)
              }
            } : { number: G };
          }
        });
      } catch (X) {
        console.warn("Error when initializing parser", X);
      }
    if (k = u(), k !== i && x === a.length)
      return k;
    throw k !== i && x < a.length && O(B()), I(
      w,
      E < a.length ? a.charAt(E) : null,
      E < a.length ? N(E, E + 1) : N(E, E)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: ye }, u = ye, c = le(), d = function(z) {
      return [].concat(...z).filter((A) => !!A);
    }, p = function() {
      return [];
    }, f = function(z) {
      return s.isRecognized(z);
    }, h = function(z) {
      return s.isRecognized(z);
    }, m = function(z, A) {
      const R = s.split(A);
      return s.isRecognized([z, R[0]]);
    }, y = function(z, A) {
      const R = s.split(A);
      return [s.isRecognized([z, R[0]]), R[1]];
    }, b = function(z, A) {
      return s.isRecognized([z, A]);
    }, v = function(z, A) {
      return s.isRecognized([z, A]);
    }, x = function(z) {
      return s.isRecognized(z);
    }, _ = function(z) {
      return s.isRecognized(z);
    }, E = function(z) {
      return s.isRecognized([z]);
    }, w = function(z) {
      return s.isRecognized([z]);
    }, C = function(z) {
      return s.isMacro(z);
    }, k = function(z) {
      return z;
    }, S = function(z) {
      return s.isWhitespace(z);
    }, B = function(z) {
      return z;
    }, U = function(z) {
      return s.isSplitable(z);
    }, N = function(z) {
      return z;
    }, O = 0, I = [{ line: 1, column: 1 }], q = 0, ae = [], Q = 0, ne;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function le() {
      return { type: "any" };
    }
    function W() {
      return { type: "end" };
    }
    function X(z) {
      var A = I[z], R;
      if (A)
        return A;
      for (R = z - 1; !I[R]; )
        R--;
      for (A = I[R], A = {
        line: A.line,
        column: A.column
      }; R < z; )
        a.charCodeAt(R) === 10 ? (A.line++, A.column = 1) : A.column++, R++;
      return I[z] = A, A;
    }
    function G(z, A, R) {
      var H = X(z), be = X(A), me = {
        source: o,
        start: {
          offset: z,
          line: H.line,
          column: H.column
        },
        end: {
          offset: A,
          line: be.line,
          column: be.column
        }
      };
      return me;
    }
    function P(z) {
      O < q || (O > q && (q = O, ae = []), ae.push(z));
    }
    function he(z, A, R) {
      return new t(
        t.buildMessage(z, A),
        z,
        A,
        R
      );
    }
    function ye() {
      var z, A, R;
      if (z = O, A = [], R = pe(), R === i && (R = $(), R === i && (R = ie(), R === i && (a.length > O ? (R = a.charAt(O), O++) : (R = i, Q === 0 && P(c))))), R !== i)
        for (; R !== i; )
          A.push(R), R = pe(), R === i && (R = $(), R === i && (R = ie(), R === i && (a.length > O ? (R = a.charAt(O), O++) : (R = i, Q === 0 && P(c)))));
      else
        A = i;
      return A !== i && (A = d(A)), z = A, z === i && (z = O, A = Pe(), A !== i && (A = p()), z = A), z;
    }
    function pe() {
      var z, A, R, H, be;
      return z = O, A = O, a.length > O ? (R = a.charAt(O), O++) : (R = i, Q === 0 && P(c)), R !== i ? (a.length > O ? (H = a.charAt(O), O++) : (H = i, Q === 0 && P(c)), H !== i ? (a.length > O ? (be = a.charAt(O), O++) : (be = i, Q === 0 && P(c)), be !== i ? (R = [R, H, be], A = R) : (O = A, A = i)) : (O = A, A = i)) : (O = A, A = i), A !== i ? (R = f(A), R ? R = void 0 : R = i, R !== i ? z = h(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function $() {
      var z;
      return z = ge(), z === i && (z = F(), z === i && (z = ce())), z;
    }
    function F() {
      var z, A, R, H, be;
      if (z = O, A = re(), A !== i) {
        for (R = [], H = Te(); H !== i; )
          R.push(H), H = Te();
        H = V(), H !== i ? (be = m(A, H), be ? be = void 0 : be = i, be !== i ? z = y(A, H) : (O = z, z = i)) : (O = z, z = i);
      } else
        O = z, z = i;
      return z;
    }
    function ge() {
      var z, A, R, H, be;
      if (z = O, A = re(), A !== i) {
        for (R = [], H = Te(); H !== i; )
          R.push(H), H = Te();
        a.length > O ? (H = a.charAt(O), O++) : (H = i, Q === 0 && P(c)), H !== i ? (be = b(A, H), be ? be = void 0 : be = i, be !== i ? z = v(A, H) : (O = z, z = i)) : (O = z, z = i);
      } else
        O = z, z = i;
      return z;
    }
    function ce() {
      var z, A, R, H;
      return z = O, A = O, a.length > O ? (R = a.charAt(O), O++) : (R = i, Q === 0 && P(c)), R !== i ? (a.length > O ? (H = a.charAt(O), O++) : (H = i, Q === 0 && P(c)), H !== i ? (R = [R, H], A = R) : (O = A, A = i)) : (O = A, A = i), A !== i ? (R = x(A), R ? R = void 0 : R = i, R !== i ? z = _(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function ie() {
      var z, A, R;
      return z = O, a.length > O ? (A = a.charAt(O), O++) : (A = i, Q === 0 && P(c)), A !== i ? (R = E(A), R ? R = void 0 : R = i, R !== i ? z = w(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function re() {
      var z, A, R;
      return z = O, a.length > O ? (A = a.charAt(O), O++) : (A = i, Q === 0 && P(c)), A !== i ? (R = C(A), R ? R = void 0 : R = i, R !== i ? z = k(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function Te() {
      var z, A, R;
      return z = O, a.length > O ? (A = a.charAt(O), O++) : (A = i, Q === 0 && P(c)), A !== i ? (R = S(A), R ? R = void 0 : R = i, R !== i ? z = B(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function V() {
      var z, A, R;
      return z = O, a.length > O ? (A = a.charAt(O), O++) : (A = i, Q === 0 && P(c)), A !== i ? (R = U(A), R ? R = void 0 : R = i, R !== i ? z = N(A) : (O = z, z = i)) : (O = z, z = i), z;
    }
    function Pe() {
      var z, A;
      return z = O, Q++, a.length > O ? (A = a.charAt(O), O++) : (A = i, Q === 0 && P(c)), Q--, A === i ? z = void 0 : (O = z, z = i), z;
    }
    if (!s.isWhitespace)
      try {
        Object.assign(s, {
          isMacro: (z) => z.type === "macro",
          isWhitespace: (z) => z.type === "whitespace",
          isRecognized: (z) => z.length == 2 && z[0].content === "^" && z[1].content === "o" ? { type: "string", content: "ô" } : null,
          isSplitable: (z) => z.type === "string" && z.content.length > 1,
          split: (z) => [
            { type: "string", content: z.content.charAt(0) },
            { type: "string", content: z.content.slice(1) }
          ]
        });
      } catch (z) {
        console.warn("Error when initializing parser", z);
      }
    if (ne = u(), ne !== i && O === a.length)
      return ne;
    throw ne !== i && O < a.length && P(W()), he(
      ae,
      q < a.length ? a.charAt(q) : null,
      q < a.length ? G(q, q + 1) : G(q, q)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { start: Ii }, u = Ii, c = ";", d = ",", p = ":", f = "/", h = ">", m = "!", y = ".", b = "!![", v = "]", x = "!!", _ = "+", E = "-", w = /^[a-zA-Z0-9]/, C = /^[0-9]/, k = /^[ \t\n\r]/, S = /^[0-9a-fA-F]/, B = Yi(), U = En(";", !1), N = En(",", !1), O = mn("model list"), I = En(":", !1), q = En("/", !1), ae = mn("model"), Q = mn("color spec list"), ne = mn("color spec"), le = mn("color"), W = mn("function expression"), X = En(">", !1), G = mn("function"), P = mn("extended expression"), he = mn("core model"), ye = mn("expr"), pe = En("!", !1), $ = mn("mix expr"), F = mn("name"), ge = En(".", !1), ce = yi([["a", "z"], ["A", "Z"], ["0", "9"]], !1, !1), ie = mn("postfix"), re = En("!![", !1), Te = En("]", !1), V = En("!!", !1), Pe = mn("prefix"), z = mn("plus"), A = En("+", !1), R = mn("minus"), H = En("-", !1), be = mn("num"), me = yi([["0", "9"]], !1, !1), Ce = mn("positive float"), We = mn("divisor"), xe = mn("int"), we = yi([" ", "	", `
`, "\r"], !1, !1), te = yi([["0", "9"], ["a", "f"], ["A", "F"]], !1, !1), Fe = function(j) {
      return j;
    }, Y = function(j) {
      return j;
    }, Je = function(j) {
      return j;
    }, xt = function(j) {
      return j;
    }, Ze = function(j) {
      return j;
    }, rt = function(j) {
      return { type: "invalid_spec", content: j };
    }, Mt = function(j, de) {
      return de;
    }, Qt = function(j, de) {
      return { type: "color_set", content: [j].concat(de) };
    }, kr = function(j, de) {
      return { type: "color_set_item", name: j, spec_list: de };
    }, tr = function(j, de) {
      return { type: "model_list", contents: de, core_model: j };
    }, Oe = function(j) {
      return { type: "model_list", contents: j, core_model: null };
    }, Ie = function(j, de) {
      return de;
    }, Me = function(j, de) {
      return [j].concat(de);
    }, je = function(j, de) {
      return de;
    }, tt = function(j, de) {
      return { type: "spec_list", content: [j].concat(de) };
    }, Ct = function(j) {
      return { type: "hex_spec", content: [j] };
    }, Kt = function(j, de) {
      return de;
    }, ct = function(j, de) {
      return de;
    }, ir = function(j, de) {
      return { type: "num_spec", content: de ? [j].concat(de) : [j] };
    }, xr = function(j, de) {
      return { type: "color", color: j, functions: de };
    }, Rr = function(j, de) {
      return de;
    }, Nt = function(j, de) {
      return { type: "function", name: j, args: de };
    }, dr = function(j, de, _e, Le) {
      return {
        type: "extended_expr",
        core_model: j,
        div: de,
        expressions: [_e].concat(Le)
      };
    }, $e = function(j, de, _e) {
      return {
        type: "extended_expr",
        core_model: j,
        div: null,
        expressions: [de].concat(_e)
      };
    }, at = function(j, de) {
      return { type: "weighted_expr", color: j, weight: de };
    }, Rt = function(j) {
      return j;
    }, sr = function(j, de, _e, Le) {
      return {
        type: "expr",
        prefix: j,
        name: de,
        mix_expr: _e,
        postfix: Le
      };
    }, bt = function(j, de) {
      return { type: "complete_mix", mix_percent: j, name: de };
    }, Ur = function(j) {
      return { type: "partial_mix", mix_percent: j };
    }, or = function(j, de) {
      return j.concat(de || []);
    }, Ae = function(j) {
      return { type: "postfix", num: j };
    }, Ve = function(j) {
      return { type: "postfix", plusses: j };
    }, Ge = function(j) {
      return parseInt(j, 10);
    }, lr = function(j) {
      return parseFloat(j);
    }, br = function(j) {
      return j;
    }, Ut = function(j) {
      return -j;
    }, cn = function(j, de) {
      return j ? -de : de;
    }, Re = function(j) {
      return j.toUpperCase();
    }, J = 0, He = [{ line: 1, column: 1 }], fr = 0, Mr = [], ut = 0, qn;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function En(j, de) {
      return { type: "literal", text: j, ignoreCase: de };
    }
    function yi(j, de, _e) {
      return { type: "class", parts: j, inverted: de, ignoreCase: _e };
    }
    function Yi() {
      return { type: "any" };
    }
    function Xi() {
      return { type: "end" };
    }
    function mn(j) {
      return { type: "other", description: j };
    }
    function Ri(j) {
      var de = He[j], _e;
      if (de)
        return de;
      for (_e = j - 1; !He[_e]; )
        _e--;
      for (de = He[_e], de = {
        line: de.line,
        column: de.column
      }; _e < j; )
        a.charCodeAt(_e) === 10 ? (de.line++, de.column = 1) : de.column++, _e++;
      return He[j] = de, de;
    }
    function Ht(j, de, _e) {
      var Le = Ri(j), et = Ri(de), vt = {
        source: o,
        start: {
          offset: j,
          line: Le.line,
          column: Le.column
        },
        end: {
          offset: de,
          line: et.line,
          column: et.column
        }
      };
      return vt;
    }
    function jt(j) {
      J < fr || (J > fr && (fr = J, Mr = []), Mr.push(j));
    }
    function jn(j, de, _e) {
      return new t(
        t.buildMessage(j, de),
        j,
        de,
        _e
      );
    }
    function Ii() {
      var j, de, _e, Le;
      if (j = J, de = yt(), de !== i ? (_e = fe(), _e !== i ? j = Fe(de) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, de = At(), de !== i ? (_e = fe(), _e !== i ? j = Y(de) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, de = wt(), de !== i ? (_e = fe(), _e !== i ? j = Je(de) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, de = ue(), de !== i ? (_e = fe(), _e !== i ? j = xt(de) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, de = ti(), de !== i ? (_e = fe(), _e !== i ? j = Ze(de) : (J = j, j = i)) : (J = j, j = i), j === i))))) {
        for (j = J, de = J, _e = [], a.length > J ? (Le = a.charAt(J), J++) : (Le = i, ut === 0 && jt(B)); Le !== i; )
          _e.push(Le), a.length > J ? (Le = a.charAt(J), J++) : (Le = i, ut === 0 && jt(B));
        de = a.substring(de, J), de = rt(de), j = de;
      }
      return j;
    }
    function ti() {
      var j, de, _e, Le, et, vt;
      if (j = J, de = Dn(), de !== i) {
        for (_e = [], Le = J, a.charCodeAt(J) === 59 ? (et = c, J++) : (et = i, ut === 0 && jt(U)), et !== i ? (vt = Dn(), vt !== i ? Le = Mt(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i); Le !== i; )
          _e.push(Le), Le = J, a.charCodeAt(J) === 59 ? (et = c, J++) : (et = i, ut === 0 && jt(U)), et !== i ? (vt = Dn(), vt !== i ? Le = Mt(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i);
        j = Qt(de, _e);
      } else
        J = j, j = i;
      return j;
    }
    function Dn() {
      var j, de, _e, Le;
      return j = J, de = ri(), de !== i ? (a.charCodeAt(J) === 44 ? (_e = d, J++) : (_e = i, ut === 0 && jt(N)), _e !== i ? (Le = At(), Le !== i ? j = kr(de, Le) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i), j;
    }
    function ue() {
      var j, de, _e, Le;
      return ut++, j = J, de = gn(), de !== i ? (a.charCodeAt(J) === 58 ? (_e = p, J++) : (_e = i, ut === 0 && jt(I)), _e !== i ? (Le = Ue(), Le !== i ? j = tr(de, Le) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, de = Ue(), de !== i && (de = Oe(de)), j = de), ut--, j === i && (de = i, ut === 0 && jt(O)), j;
    }
    function Ue() {
      var j, de, _e, Le, et, vt;
      if (j = J, de = ze(), de !== i) {
        for (_e = [], Le = J, a.charCodeAt(J) === 47 ? (et = f, J++) : (et = i, ut === 0 && jt(q)), et !== i ? (vt = ze(), vt !== i ? Le = Ie(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i); Le !== i; )
          _e.push(Le), Le = J, a.charCodeAt(J) === 47 ? (et = f, J++) : (et = i, ut === 0 && jt(q)), et !== i ? (vt = ze(), vt !== i ? Le = Ie(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i);
        j = Me(de, _e);
      } else
        J = j, j = i;
      return j;
    }
    function ze() {
      var j;
      return ut++, j = gn(), ut--, j === i && ut === 0 && jt(ae), j;
    }
    function At() {
      var j, de, _e, Le, et, vt;
      if (ut++, j = J, de = yt(), de !== i) {
        for (_e = [], Le = J, a.charCodeAt(J) === 47 ? (et = f, J++) : (et = i, ut === 0 && jt(q)), et !== i ? (vt = yt(), vt !== i ? Le = je(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i); Le !== i; )
          _e.push(Le), Le = J, a.charCodeAt(J) === 47 ? (et = f, J++) : (et = i, ut === 0 && jt(q)), et !== i ? (vt = yt(), vt !== i ? Le = je(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i);
        j = tt(de, _e);
      } else
        J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(Q)), j;
    }
    function yt() {
      var j, de, _e, Le, et, vt, Wt, en, pi;
      if (ut++, j = J, de = J, _e = J, Le = ee(), Le !== i ? (et = ee(), et !== i ? (vt = ee(), vt !== i ? (Wt = ee(), Wt !== i ? (en = ee(), en !== i ? (pi = ee(), pi !== i ? (Le = [Le, et, vt, Wt, en, pi], _e = Le) : (J = _e, _e = i)) : (J = _e, _e = i)) : (J = _e, _e = i)) : (J = _e, _e = i)) : (J = _e, _e = i)) : (J = _e, _e = i), _e !== i ? de = a.substring(de, J) : de = _e, de !== i && (de = Ct(de)), j = de, j === i)
        if (j = J, de = pa(), de !== i) {
          if (_e = [], Le = J, a.charCodeAt(J) === 44 ? (et = d, J++) : (et = i, ut === 0 && jt(N)), et !== i ? (vt = pa(), vt !== i ? Le = Kt(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i), Le !== i)
            for (; Le !== i; )
              _e.push(Le), Le = J, a.charCodeAt(J) === 44 ? (et = d, J++) : (et = i, ut === 0 && jt(N)), et !== i ? (vt = pa(), vt !== i ? Le = Kt(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i);
          else
            _e = i;
          if (_e === i)
            if (_e = [], Le = J, et = T(), et !== i ? (vt = pa(), vt !== i ? Le = ct(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i), Le !== i)
              for (; Le !== i; )
                _e.push(Le), Le = J, et = T(), et !== i ? (vt = pa(), vt !== i ? Le = ct(de, vt) : (J = Le, Le = i)) : (J = Le, Le = i);
            else
              _e = i;
          _e === i && (_e = null), j = ir(de, _e);
        } else
          J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(ne)), j;
    }
    function wt() {
      var j, de, _e, Le;
      if (ut++, j = J, de = Se(), de !== i) {
        for (_e = [], Le = qe(); Le !== i; )
          _e.push(Le), Le = qe();
        j = xr(de, _e);
      } else
        J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(le)), j;
    }
    function Se() {
      var j;
      return j = St(), j === i && (j = On(), j === i && (j = ri())), j;
    }
    function qe() {
      var j, de, _e, Le, et, vt, Wt;
      if (ut++, j = J, a.charCodeAt(J) === 62 ? (de = h, J++) : (de = i, ut === 0 && jt(X)), de !== i)
        if (_e = lt(), _e !== i) {
          for (Le = [], et = J, a.charCodeAt(J) === 44 ? (vt = d, J++) : (vt = i, ut === 0 && jt(N)), vt !== i ? (Wt = g(), Wt !== i ? et = Rr(_e, Wt) : (J = et, et = i)) : (J = et, et = i); et !== i; )
            Le.push(et), et = J, a.charCodeAt(J) === 44 ? (vt = d, J++) : (vt = i, ut === 0 && jt(N)), vt !== i ? (Wt = g(), Wt !== i ? et = Rr(_e, Wt) : (J = et, et = i)) : (J = et, et = i);
          j = Nt(_e, Le);
        } else
          J = j, j = i;
      else
        J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(W)), j;
    }
    function lt() {
      var j;
      return ut++, j = ri(), ut--, j === i && ut === 0 && jt(G), j;
    }
    function St() {
      var j, de, _e, Le, et, vt, Wt, en;
      if (ut++, j = J, de = gn(), de !== i)
        if (a.charCodeAt(J) === 44 ? (_e = d, J++) : (_e = i, ut === 0 && jt(N)), _e !== i)
          if (Le = ws(), Le !== i)
            if (a.charCodeAt(J) === 58 ? (et = p, J++) : (et = i, ut === 0 && jt(I)), et !== i)
              if (vt = Yt(), vt !== i) {
                for (Wt = [], en = Vr(); en !== i; )
                  Wt.push(en), en = Vr();
                j = dr(de, Le, vt, Wt);
              } else
                J = j, j = i;
            else
              J = j, j = i;
          else
            J = j, j = i;
        else
          J = j, j = i;
      else
        J = j, j = i;
      if (j === i)
        if (j = J, de = gn(), de !== i)
          if (a.charCodeAt(J) === 58 ? (_e = p, J++) : (_e = i, ut === 0 && jt(I)), _e !== i)
            if (Le = Yt(), Le !== i) {
              for (et = [], vt = Vr(); vt !== i; )
                et.push(vt), vt = Vr();
              j = $e(de, Le, et);
            } else
              J = j, j = i;
          else
            J = j, j = i;
        else
          J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(P)), j;
    }
    function Yt() {
      var j, de, _e, Le;
      return j = J, de = On(), de !== i ? (a.charCodeAt(J) === 44 ? (_e = d, J++) : (_e = i, ut === 0 && jt(N)), _e !== i ? (Le = pa(), Le !== i ? j = at(de, Le) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i), j;
    }
    function Vr() {
      var j, de, _e;
      return j = J, a.charCodeAt(J) === 59 ? (de = c, J++) : (de = i, ut === 0 && jt(U)), de !== i ? (_e = Yt(), _e !== i ? j = Rt(_e) : (J = j, j = i)) : (J = j, j = i), j;
    }
    function gn() {
      var j;
      return ut++, j = ri(), ut--, j === i && ut === 0 && jt(he), j;
    }
    function On() {
      var j, de, _e, Le, et;
      return ut++, j = J, de = dt(), _e = ri(), _e !== i ? (Le = _i(), et = Ir(), et === i && (et = null), j = sr(de, _e, Le, et)) : (J = j, j = i), ut--, j === i && (de = i, ut === 0 && jt(ye)), j;
    }
    function bs() {
      var j, de, _e, Le, et;
      return j = J, a.charCodeAt(J) === 33 ? (de = m, J++) : (de = i, ut === 0 && jt(pe)), de !== i ? (_e = Zi(), _e !== i ? (a.charCodeAt(J) === 33 ? (Le = m, J++) : (Le = i, ut === 0 && jt(pe)), Le !== i ? (et = ri(), et !== i ? j = bt(_e, et) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i), j;
    }
    function ys() {
      var j, de, _e;
      return j = J, a.charCodeAt(J) === 33 ? (de = m, J++) : (de = i, ut === 0 && jt(pe)), de !== i ? (_e = Zi(), _e !== i ? j = Ur(_e) : (J = j, j = i)) : (J = j, j = i), j;
    }
    function _i() {
      var j, de, _e;
      for (ut++, j = J, de = [], _e = bs(); _e !== i; )
        de.push(_e), _e = bs();
      return _e = ys(), _e === i && (_e = null), j = or(de, _e), ut--, de = i, ut === 0 && jt($), j;
    }
    function ri() {
      var j, de, _e;
      if (ut++, a.charCodeAt(J) === 46 ? (j = y, J++) : (j = i, ut === 0 && jt(ge)), j === i) {
        if (j = J, de = [], w.test(a.charAt(J)) ? (_e = a.charAt(J), J++) : (_e = i, ut === 0 && jt(ce)), _e !== i)
          for (; _e !== i; )
            de.push(_e), w.test(a.charAt(J)) ? (_e = a.charAt(J), J++) : (_e = i, ut === 0 && jt(ce));
        else
          de = i;
        de !== i ? j = a.substring(j, J) : j = de;
      }
      return ut--, j === i && (de = i, ut === 0 && jt(F)), j;
    }
    function Ir() {
      var j, de, _e, Le, et;
      if (ut++, j = J, a.substr(J, 3) === b ? (de = b, J += 3) : (de = i, ut === 0 && jt(re)), de !== i ? (_e = vs(), _e !== i ? (a.charCodeAt(J) === 93 ? (Le = v, J++) : (Le = i, ut === 0 && jt(Te)), Le !== i ? j = Ae(_e) : (J = j, j = i)) : (J = j, j = i)) : (J = j, j = i), j === i)
        if (j = J, a.substr(J, 2) === x ? (de = x, J += 2) : (de = i, ut === 0 && jt(V)), de !== i) {
          if (_e = J, Le = [], et = Sn(), et !== i)
            for (; et !== i; )
              Le.push(et), et = Sn();
          else
            Le = i;
          Le !== i ? _e = a.substring(_e, J) : _e = Le, _e !== i ? j = Ve(_e) : (J = j, j = i);
        } else
          J = j, j = i;
      return ut--, j === i && (de = i, ut === 0 && jt(ie)), j;
    }
    function dt() {
      var j;
      return ut++, j = Mi(), j === i && (j = null), ut--, ut === 0 && jt(Pe), j;
    }
    function Sn() {
      var j, de, _e;
      if (ut++, j = J, de = [], a.charCodeAt(J) === 43 ? (_e = _, J++) : (_e = i, ut === 0 && jt(A)), _e !== i)
        for (; _e !== i; )
          de.push(_e), a.charCodeAt(J) === 43 ? (_e = _, J++) : (_e = i, ut === 0 && jt(A));
      else
        de = i;
      return de !== i ? j = a.substring(j, J) : j = de, ut--, j === i && (de = i, ut === 0 && jt(z)), j;
    }
    function Mi() {
      var j, de, _e;
      if (ut++, j = J, de = [], a.charCodeAt(J) === 45 ? (_e = E, J++) : (_e = i, ut === 0 && jt(H)), _e !== i)
        for (; _e !== i; )
          de.push(_e), a.charCodeAt(J) === 45 ? (_e = E, J++) : (_e = i, ut === 0 && jt(H));
      else
        de = i;
      return de !== i ? j = a.substring(j, J) : j = de, ut--, j === i && (de = i, ut === 0 && jt(R)), j;
    }
    function vs() {
      var j, de, _e, Le;
      if (ut++, j = J, de = J, _e = [], C.test(a.charAt(J)) ? (Le = a.charAt(J), J++) : (Le = i, ut === 0 && jt(me)), Le !== i)
        for (; Le !== i; )
          _e.push(Le), C.test(a.charAt(J)) ? (Le = a.charAt(J), J++) : (Le = i, ut === 0 && jt(me));
      else
        _e = i;
      return _e !== i ? de = a.substring(de, J) : de = _e, de !== i && (de = Ge(de)), j = de, ut--, j === i && (de = i, ut === 0 && jt(be)), j;
    }
    function Zi() {
      var j, de, _e, Le, et, vt, Wt, en, pi, it;
      if (ut++, j = J, de = J, _e = J, Le = J, et = [], C.test(a.charAt(J)) ? (vt = a.charAt(J), J++) : (vt = i, ut === 0 && jt(me)), vt !== i)
        for (; vt !== i; )
          et.push(vt), C.test(a.charAt(J)) ? (vt = a.charAt(J), J++) : (vt = i, ut === 0 && jt(me));
      else
        et = i;
      if (et !== i ? Le = a.substring(Le, J) : Le = et, Le !== i) {
        if (et = J, vt = J, a.charCodeAt(J) === 46 ? (Wt = y, J++) : (Wt = i, ut === 0 && jt(ge)), Wt !== i) {
          for (en = J, pi = [], C.test(a.charAt(J)) ? (it = a.charAt(J), J++) : (it = i, ut === 0 && jt(me)); it !== i; )
            pi.push(it), C.test(a.charAt(J)) ? (it = a.charAt(J), J++) : (it = i, ut === 0 && jt(me));
          en = a.substring(en, J), Wt = [Wt, en], vt = Wt;
        } else
          J = vt, vt = i;
        vt === i && (vt = null), et = a.substring(et, J), Le = [Le, et], _e = Le;
      } else
        J = _e, _e = i;
      if (_e !== i ? de = a.substring(de, J) : de = _e, de === i) {
        if (de = J, _e = J, a.charCodeAt(J) === 46 ? (Le = y, J++) : (Le = i, ut === 0 && jt(ge)), Le !== i) {
          if (et = J, vt = [], C.test(a.charAt(J)) ? (Wt = a.charAt(J), J++) : (Wt = i, ut === 0 && jt(me)), Wt !== i)
            for (; Wt !== i; )
              vt.push(Wt), C.test(a.charAt(J)) ? (Wt = a.charAt(J), J++) : (Wt = i, ut === 0 && jt(me));
          else
            vt = i;
          vt !== i ? et = a.substring(et, J) : et = vt, et !== i ? (Le = [Le, et], _e = Le) : (J = _e, _e = i);
        } else
          J = _e, _e = i;
        _e !== i ? de = a.substring(de, J) : de = _e;
      }
      return de !== i && (de = lr(de)), j = de, ut--, j === i && (de = i, ut === 0 && jt(Ce)), j;
    }
    function ws() {
      var j;
      return ut++, j = Zi(), ut--, j === i && ut === 0 && jt(We), j;
    }
    function pa() {
      var j, de, _e;
      return j = Zi(), j === i && (j = J, a.charCodeAt(J) === 43 ? (de = _, J++) : (de = i, ut === 0 && jt(A)), de !== i ? (_e = Zi(), _e !== i ? j = br(_e) : (J = j, j = i)) : (J = j, j = i), j === i && (j = J, a.charCodeAt(J) === 45 ? (de = E, J++) : (de = i, ut === 0 && jt(H)), de !== i ? (_e = Zi(), _e !== i ? j = Ut(_e) : (J = j, j = i)) : (J = j, j = i))), j;
    }
    function g() {
      var j, de, _e;
      return ut++, j = J, de = Mi(), de === i && (de = null), _e = vs(), _e !== i ? j = cn(de, _e) : (J = j, j = i), ut--, j === i && (de = i, ut === 0 && jt(xe)), j;
    }
    function T() {
      var j, de;
      if (j = [], k.test(a.charAt(J)) ? (de = a.charAt(J), J++) : (de = i, ut === 0 && jt(we)), de !== i)
        for (; de !== i; )
          j.push(de), k.test(a.charAt(J)) ? (de = a.charAt(J), J++) : (de = i, ut === 0 && jt(we));
      else
        j = i;
      return j;
    }
    function ee() {
      var j, de;
      return j = J, S.test(a.charAt(J)) ? (de = a.charAt(J), J++) : (de = i, ut === 0 && jt(te)), de !== i && (de = Re(de)), j = de, j;
    }
    function fe() {
      var j, de;
      return j = J, ut++, a.length > J ? (de = a.charAt(J), J++) : (de = i, ut === 0 && jt(B)), ut--, de === i ? j = void 0 : (J = j, j = i), j;
    }
    if (qn = u(), qn !== i && J === a.length)
      return qn;
    throw qn !== i && J < a.length && jt(Xi()), jn(
      Mr,
      fr < a.length ? a.charAt(fr) : null,
      fr < a.length ? Ht(fr, fr + 1) : Ht(fr, fr)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: tt }, u = tt, c = tr("decl_start"), d = tr("decl_end"), p = tr("vert"), f = Qt(), h = tr("l"), m = tr("r"), y = tr("c"), b = tr("p"), v = tr("m"), x = tr("b"), _ = tr("w"), E = tr("W"), w = tr("X"), C = tr("!"), k = tr("@"), S = tr("<"), B = tr(">"), U = tr("group"), N = tr("whitespace"), O = function(Re) {
      return Re;
    }, I = function(Re) {
      return Re;
    }, q = function() {
      return [];
    }, ae = function(Re, J, He, fr, Mr) {
      return {
        type: "column",
        pre_dividers: Re,
        post_dividers: Mr,
        before_start_code: J,
        before_end_code: fr,
        alignment: He
      };
    }, Q = function() {
      return {
        type: "vert_divider"
      };
    }, ne = function(Re, J) {
      return {
        type: "bang_divider",
        content: J[0].content
      };
    }, le = function(Re) {
      return {
        type: "at_divider",
        content: Re[0].content
      };
    }, W = function(Re) {
      return Re;
    }, X = function(Re) {
      return { type: "decl_code", code: Re[0].content };
    }, G = function(Re) {
      return { type: "decl_code", code: Re[0].content };
    }, P = function() {
      return { type: "alignment", alignment: "left" };
    }, he = function() {
      return { type: "alignment", alignment: "center" };
    }, ye = function() {
      return { type: "alignment", alignment: "right" };
    }, pe = function() {
      return { type: "alignment", alignment: "X" };
    }, $ = function() {
      return "top";
    }, F = function() {
      return "default";
    }, ge = function() {
      return "bottom";
    }, ce = function(Re, J) {
      return {
        type: "alignment",
        alignment: "parbox",
        baseline: Re,
        size: J[0].content
      };
    }, ie = function(Re, J) {
      return {
        type: "alignment",
        alignment: "parbox",
        baseline: Re[0].content,
        size: J[0].content
      };
    }, re = function(Re) {
      return s.matchChar(Re, "|");
    }, Te = function(Re) {
      return s.matchChar(Re, "l");
    }, V = function(Re) {
      return s.matchChar(Re, "r");
    }, Pe = function(Re) {
      return s.matchChar(Re, "c");
    }, z = function(Re) {
      return s.matchChar(Re, "p");
    }, A = function(Re) {
      return s.matchChar(Re, "m");
    }, R = function(Re) {
      return s.matchChar(Re, "b");
    }, H = function(Re) {
      return s.matchChar(Re, "w");
    }, be = function(Re) {
      return s.matchChar(Re, "W");
    }, me = function(Re) {
      return s.matchChar(Re, "X");
    }, Ce = function(Re) {
      return s.matchChar(Re, "!");
    }, We = function(Re) {
      return s.matchChar(Re, "@");
    }, xe = function(Re) {
      return s.matchChar(Re, "<");
    }, we = function(Re) {
      return s.matchChar(Re, ">");
    }, te = function(Re) {
      return s.isGroup(Re);
    }, Fe = function(Re) {
      return s.isWhitespace(Re);
    }, Y = 0, Je = [{ line: 1, column: 1 }], xt = 0, Ze = [], rt = 0, Mt;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function Qt() {
      return { type: "any" };
    }
    function kr() {
      return { type: "end" };
    }
    function tr(Re) {
      return { type: "other", description: Re };
    }
    function Oe(Re) {
      var J = Je[Re], He;
      if (J)
        return J;
      for (He = Re - 1; !Je[He]; )
        He--;
      for (J = Je[He], J = {
        line: J.line,
        column: J.column
      }; He < Re; )
        a.charCodeAt(He) === 10 ? (J.line++, J.column = 1) : J.column++, He++;
      return Je[Re] = J, J;
    }
    function Ie(Re, J, He) {
      var fr = Oe(Re), Mr = Oe(J), ut = {
        source: o,
        start: {
          offset: Re,
          line: fr.line,
          column: fr.column
        },
        end: {
          offset: J,
          line: Mr.line,
          column: Mr.column
        }
      };
      return ut;
    }
    function Me(Re) {
      Y < xt || (Y > xt && (xt = Y, Ze = []), Ze.push(Re));
    }
    function je(Re, J, He) {
      return new t(
        t.buildMessage(Re, J),
        Re,
        J,
        He
      );
    }
    function tt() {
      var Re, J, He, fr, Mr, ut;
      if (Re = Y, J = [], He = Y, fr = Ct(), fr !== i) {
        for (Mr = [], ut = Ut(); ut !== i; )
          Mr.push(ut), ut = Ut();
        He = O(fr);
      } else
        Y = He, He = i;
      if (He !== i)
        for (; He !== i; )
          if (J.push(He), He = Y, fr = Ct(), fr !== i) {
            for (Mr = [], ut = Ut(); ut !== i; )
              Mr.push(ut), ut = Ut();
            He = O(fr);
          } else
            Y = He, He = i;
      else
        J = i;
      return J !== i && (J = I(J)), Re = J, Re === i && (Re = Y, J = cn(), J !== i && (J = q()), Re = J), Re;
    }
    function Ct() {
      var Re, J, He, fr, Mr, ut, qn;
      for (Re = Y, J = [], He = Kt(); He !== i; )
        J.push(He), He = Kt();
      if (He = ct(), He === i && (He = null), fr = xr(), fr !== i) {
        for (Mr = ir(), Mr === i && (Mr = null), ut = [], qn = Kt(); qn !== i; )
          ut.push(qn), qn = Kt();
        Re = ae(J, He, fr, Mr, ut);
      } else
        Y = Re, Re = i;
      return Re;
    }
    function Kt() {
      var Re, J, He, fr, Mr;
      for (Re = Y, J = [], He = Ut(); He !== i; )
        J.push(He), He = Ut();
      if (He = Y, fr = Rr(), fr !== i && (fr = Q()), He = fr, He === i && (He = Y, fr = Ae(), fr !== i ? (Mr = br(), Mr !== i ? He = ne(fr, Mr) : (Y = He, He = i)) : (Y = He, He = i), He === i && (He = Y, fr = Ve(), fr !== i ? (Mr = br(), Mr !== i ? He = le(Mr) : (Y = He, He = i)) : (Y = He, He = i))), He !== i) {
        for (fr = [], Mr = Ut(); Mr !== i; )
          fr.push(Mr), Mr = Ut();
        Re = W(He);
      } else
        Y = Re, Re = i;
      return Re;
    }
    function ct() {
      var Re, J, He;
      return rt++, Re = Y, J = lr(), J !== i ? (He = br(), He !== i ? Re = X(He) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(c)), Re;
    }
    function ir() {
      var Re, J, He;
      return rt++, Re = Y, J = Ge(), J !== i ? (He = br(), He !== i ? Re = G(He) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(d)), Re;
    }
    function xr() {
      var Re, J, He, fr, Mr, ut;
      if (Re = Y, J = Nt(), J !== i && (J = P()), Re = J, Re === i && (Re = Y, J = $e(), J !== i && (J = he()), Re = J, Re === i && (Re = Y, J = dr(), J !== i && (J = ye()), Re = J, Re === i && (Re = Y, J = or(), J !== i && (J = pe()), Re = J, Re === i)))) {
        if (Re = Y, J = Y, He = at(), He !== i && (He = $()), J = He, J === i && (J = Y, He = Rt(), He !== i && (He = F()), J = He, J === i && (J = Y, He = sr(), He !== i && (He = ge()), J = He)), J !== i) {
          for (He = [], fr = Ut(); fr !== i; )
            He.push(fr), fr = Ut();
          fr = br(), fr !== i ? Re = ce(J, fr) : (Y = Re, Re = i);
        } else
          Y = Re, Re = i;
        if (Re === i)
          if (Re = Y, J = bt(), J === i && (J = Ur()), J !== i) {
            for (He = [], fr = Ut(); fr !== i; )
              He.push(fr), fr = Ut();
            if (fr = br(), fr !== i) {
              for (Mr = [], ut = Ut(); ut !== i; )
                Mr.push(ut), ut = Ut();
              ut = br(), ut !== i ? Re = ie(fr, ut) : (Y = Re, Re = i);
            } else
              Y = Re, Re = i;
          } else
            Y = Re, Re = i;
      }
      return Re;
    }
    function Rr() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = re(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(p)), Re;
    }
    function Nt() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = Te(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(h)), Re;
    }
    function dr() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = V(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(m)), Re;
    }
    function $e() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = Pe(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(y)), Re;
    }
    function at() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = z(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(b)), Re;
    }
    function Rt() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = A(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(v)), Re;
    }
    function sr() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = R(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(x)), Re;
    }
    function bt() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = H(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(_)), Re;
    }
    function Ur() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = be(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(E)), Re;
    }
    function or() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = me(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(w)), Re;
    }
    function Ae() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = Ce(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(C)), Re;
    }
    function Ve() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = We(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(k)), Re;
    }
    function Ge() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = xe(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(S)), Re;
    }
    function lr() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = we(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(B)), Re;
    }
    function br() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = te(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(U)), Re;
    }
    function Ut() {
      var Re, J, He;
      return rt++, Re = Y, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), J !== i ? (He = Fe(J), He ? He = void 0 : He = i, He !== i ? (J = [J, He], Re = J) : (Y = Re, Re = i)) : (Y = Re, Re = i), rt--, Re === i && (J = i, rt === 0 && Me(N)), Re;
    }
    function cn() {
      var Re, J;
      return Re = Y, rt++, a.length > Y ? (J = a.charAt(Y), Y++) : (J = i, rt === 0 && Me(f)), rt--, J === i ? Re = void 0 : (Y = Re, Re = i), Re;
    }
    if (!s.isHash)
      try {
        Object.assign(s, {
          matchChar: (Re, J) => Re.type === "string" && Re.content === J,
          isGroup: (Re) => Re.type === "group",
          isWhitespace: (Re) => Re.type === "whitespace"
        });
      } catch (Re) {
        console.warn("Error when initializing parser", Re);
      }
    if (Mt = u(), Mt !== i && Y === a.length)
      return Mt;
    throw Mt !== i && Y < a.length && Me(kr()), je(
      Ze,
      xt < a.length ? a.charAt(xt) : null,
      xt < a.length ? Ie(xt, xt + 1) : Ie(xt, xt)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { body: Qt }, u = Qt, c = Je("item"), d = Fe(), p = Je("equation"), f = Je("trailing comment"), h = Je("comment only line"), m = Je("non-var token"), y = Je("token"), b = Je("same line comment"), v = Je("own line comment"), x = Je(","), _ = Je("@"), E = Je("variable token"), w = Je("+/-"), C = Je("="), k = function(Ae, Ve) {
      return Ae.concat(Ve || []);
    }, S = function() {
      return [];
    }, B = function(Ae, Ve, Ge, lr) {
      return { type: "item", op: Ae, variable: Ge, content: Ve.concat(Ge, lr) };
    }, U = function(Ae, Ve) {
      return { type: "item", op: Ae, variable: null, content: Ve };
    }, N = function(Ae, Ve, Ge) {
      return { ...Ae, sep: [].concat(Ve), trailingComment: Ge };
    }, O = function(Ae, Ve) {
      return { ...Ae, trailingComment: Ve };
    }, I = function(Ae, Ve) {
      return {
        type: "line",
        equation: Ae,
        annotation: Ve,
        sep: null
      };
    }, q = function(Ae, Ve) {
      return Ae ? { type: "annotation", marker: Ae, content: Ve } : null;
    }, ae = function(Ae, Ve, Ge) {
      return { type: "equation", left: Ae, right: Ge, equals: Ve };
    }, Q = function(Ae) {
      return Ae;
    }, ne = function(Ae) {
      return {
        type: "line",
        trailingComment: Ae
      };
    }, le = function(Ae, Ve) {
      return [Ae].concat(Ve || []);
    }, W = function(Ae) {
      return Ae;
    }, X = function(Ae) {
      return Ae;
    }, G = function(Ae) {
      return Ae;
    }, P = function(Ae) {
      return s.isSameLineComment(Ae);
    }, he = function(Ae) {
      return Ae;
    }, ye = function(Ae) {
      return s.isOwnLineComment(Ae);
    }, pe = function(Ae) {
      return Ae;
    }, $ = function(Ae) {
      return s.isWhitespace(Ae);
    }, F = function(Ae) {
      return Ae;
    }, ge = function(Ae) {
      return s.isSep(Ae);
    }, ce = function(Ae) {
      return Ae;
    }, ie = function(Ae) {
      return s.isAt(Ae);
    }, re = function(Ae) {
      return Ae;
    }, Te = function(Ae) {
      return s.isVar(Ae);
    }, V = function(Ae) {
      return Ae;
    }, Pe = function(Ae) {
      return s.isOperation(Ae);
    }, z = function(Ae) {
      return Ae;
    }, A = function(Ae) {
      return s.isEquals(Ae);
    }, R = function(Ae) {
      return Ae;
    }, H = function(Ae) {
      return s.isSubscript(Ae);
    }, be = function(Ae) {
      return Ae;
    }, me = 0, Ce = [{ line: 1, column: 1 }], We = 0, xe = [], we = 0, te;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function Fe() {
      return { type: "any" };
    }
    function Y() {
      return { type: "end" };
    }
    function Je(Ae) {
      return { type: "other", description: Ae };
    }
    function xt(Ae) {
      var Ve = Ce[Ae], Ge;
      if (Ve)
        return Ve;
      for (Ge = Ae - 1; !Ce[Ge]; )
        Ge--;
      for (Ve = Ce[Ge], Ve = {
        line: Ve.line,
        column: Ve.column
      }; Ge < Ae; )
        a.charCodeAt(Ge) === 10 ? (Ve.line++, Ve.column = 1) : Ve.column++, Ge++;
      return Ce[Ae] = Ve, Ve;
    }
    function Ze(Ae, Ve, Ge) {
      var lr = xt(Ae), br = xt(Ve), Ut = {
        source: o,
        start: {
          offset: Ae,
          line: lr.line,
          column: lr.column
        },
        end: {
          offset: Ve,
          line: br.line,
          column: br.column
        }
      };
      return Ut;
    }
    function rt(Ae) {
      me < We || (me > We && (We = me, xe = []), xe.push(Ae));
    }
    function Mt(Ae, Ve, Ge) {
      return new t(
        t.buildMessage(Ae, Ve),
        Ae,
        Ve,
        Ge
      );
    }
    function Qt() {
      var Ae, Ve, Ge;
      for (Ae = me, Ve = [], Ge = Ct(), Ge === i && (Ge = tr(), Ge === i && (Ge = Oe())); Ge !== i; )
        Ve.push(Ge), Ge = Ct(), Ge === i && (Ge = tr(), Ge === i && (Ge = Oe()));
      return Ge = Ie(), Ge === i && (Ge = or()), Ge !== i ? Ae = k(Ve, Ge) : (me = Ae, Ae = i), Ae === i && (Ae = me, Ve = or(), Ve !== i && (Ve = S()), Ae = Ve), Ae;
    }
    function kr() {
      var Ae, Ve, Ge, lr, br, Ut, cn, Re, J, He;
      for (we++, Ae = me, Ve = sr(), Ve === i && (Ve = null), Ge = [], lr = dr(); lr !== i; )
        Ge.push(lr), lr = dr();
      for (lr = [], br = ct(); br !== i; )
        lr.push(br), br = ct();
      for (br = [], Ut = dr(); Ut !== i; )
        br.push(Ut), Ut = dr();
      if (Ut = Kt(), Ut !== i) {
        for (cn = [], Re = dr(); Re !== i; )
          cn.push(Re), Re = dr();
        for (Re = [], J = xr(); J !== i; )
          Re.push(J), J = xr();
        for (J = [], He = dr(); He !== i; )
          J.push(He), He = dr();
        Ae = B(Ve, lr, Ut, Re);
      } else
        me = Ae, Ae = i;
      if (Ae === i) {
        for (Ae = me, Ve = sr(), Ve === i && (Ve = null), Ge = [], lr = dr(); lr !== i; )
          Ge.push(lr), lr = dr();
        if (lr = [], br = ct(), br !== i)
          for (; br !== i; )
            lr.push(br), br = ct();
        else
          lr = i;
        if (lr !== i) {
          for (br = [], Ut = dr(); Ut !== i; )
            br.push(Ut), Ut = dr();
          Ae = U(Ve, lr);
        } else
          me = Ae, Ae = i;
      }
      return we--, Ae === i && (Ve = i, we === 0 && rt(c)), Ae;
    }
    function tr() {
      var Ae, Ve, Ge, lr;
      return Ae = me, Ve = Ie(), Ve !== i ? (Ge = $e(), Ge !== i ? (lr = tt(), lr === i && (lr = null), Ae = N(Ve, Ge, lr)) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), Ae;
    }
    function Oe() {
      var Ae, Ve, Ge;
      return Ae = me, Ve = Ie(), Ve !== i ? (Ge = tt(), Ge !== i ? Ae = O(Ve, Ge) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), Ae;
    }
    function Ie() {
      var Ae, Ve, Ge, lr;
      return Ae = me, Ve = me, we++, a.length > me ? (Ge = a.charAt(me), me++) : (Ge = i, we === 0 && rt(d)), we--, Ge !== i ? (me = Ve, Ve = void 0) : Ve = i, Ve !== i ? (Ge = je(), lr = Me(), lr === i && (lr = null), Ae = I(Ge, lr)) : (me = Ae, Ae = i), Ae;
    }
    function Me() {
      var Ae, Ve, Ge, lr;
      if (Ae = me, Ve = at(), Ve !== i) {
        for (Ge = [], lr = ir(); lr !== i; )
          Ge.push(lr), lr = ir();
        Ae = q(Ve, Ge);
      } else
        me = Ae, Ae = i;
      return Ae;
    }
    function je() {
      var Ae, Ve, Ge, lr, br;
      for (we++, Ae = me, Ve = [], Ge = kr(); Ge !== i; )
        Ve.push(Ge), Ge = kr();
      for (Ge = bt(), Ge === i && (Ge = null), lr = [], br = xr(), br === i && (br = sr()); br !== i; )
        lr.push(br), br = xr(), br === i && (br = sr());
      return Ae = ae(Ve, Ge, lr), we--, Ve = i, we === 0 && rt(p), Ae;
    }
    function tt() {
      var Ae, Ve, Ge;
      for (we++, Ae = me, Ve = [], Ge = dr(); Ge !== i; )
        Ve.push(Ge), Ge = dr();
      return Ge = Rr(), Ge !== i ? Ae = Q(Ge) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(f)), Ae;
    }
    function Ct() {
      var Ae, Ve, Ge;
      for (we++, Ae = me, Ve = [], Ge = dr(); Ge !== i; )
        Ve.push(Ge), Ge = dr();
      return Ge = Nt(), Ge !== i ? Ae = ne(Ge) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(h)), Ae;
    }
    function Kt() {
      var Ae, Ve, Ge, lr;
      if (Ae = me, Ve = Rt(), Ve !== i) {
        for (Ge = [], lr = dr(); lr !== i; )
          Ge.push(lr), lr = dr();
        lr = Ur(), lr === i && (lr = null), Ae = le(Ve, lr);
      } else
        me = Ae, Ae = i;
      return Ae;
    }
    function ct() {
      var Ae, Ve, Ge;
      return we++, Ae = me, Ve = me, we++, Ge = Kt(), we--, Ge === i ? Ve = void 0 : (me = Ve, Ve = i), Ve !== i ? (Ge = xr(), Ge !== i ? Ae = W(Ge) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(m)), Ae;
    }
    function ir() {
      var Ae, Ve, Ge;
      return Ae = me, Ve = me, we++, Ge = $e(), Ge === i && (Ge = tt(), Ge === i && (Ge = Nt())), we--, Ge === i ? Ve = void 0 : (me = Ve, Ve = i), Ve !== i ? (a.length > me ? (Ge = a.charAt(me), me++) : (Ge = i, we === 0 && rt(d)), Ge !== i ? Ae = X(Ge) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), Ae;
    }
    function xr() {
      var Ae, Ve, Ge;
      return we++, Ae = me, Ve = me, we++, Ge = $e(), Ge === i && (Ge = at(), Ge === i && (Ge = sr(), Ge === i && (Ge = bt(), Ge === i && (Ge = tt(), Ge === i && (Ge = Nt()))))), we--, Ge === i ? Ve = void 0 : (me = Ve, Ve = i), Ve !== i ? (a.length > me ? (Ge = a.charAt(me), me++) : (Ge = i, we === 0 && rt(d)), Ge !== i ? Ae = G(Ge) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(y)), Ae;
    }
    function Rr() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = P(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = he(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(b)), Ae;
    }
    function Nt() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = ye(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = pe(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(v)), Ae;
    }
    function dr() {
      var Ae, Ve, Ge;
      return Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = $(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = F(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), Ae;
    }
    function $e() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = ge(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = ce(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(x)), Ae;
    }
    function at() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = ie(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = re(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(_)), Ae;
    }
    function Rt() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = Te(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = V(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(E)), Ae;
    }
    function sr() {
      var Ae, Ve, Ge, lr, br;
      for (we++, Ae = me, Ve = [], Ge = dr(); Ge !== i; )
        Ve.push(Ge), Ge = dr();
      if (a.length > me ? (Ge = a.charAt(me), me++) : (Ge = i, we === 0 && rt(d)), Ge !== i) {
        for (lr = [], br = dr(); br !== i; )
          lr.push(br), br = dr();
        br = Pe(Ge), br ? br = void 0 : br = i, br !== i ? Ae = z(Ge) : (me = Ae, Ae = i);
      } else
        me = Ae, Ae = i;
      return we--, Ae === i && (Ve = i, we === 0 && rt(w)), Ae;
    }
    function bt() {
      var Ae, Ve, Ge;
      return we++, Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = A(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = R(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), we--, Ae === i && (Ve = i, we === 0 && rt(C)), Ae;
    }
    function Ur() {
      var Ae, Ve, Ge;
      return Ae = me, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), Ve !== i ? (Ge = H(Ve), Ge ? Ge = void 0 : Ge = i, Ge !== i ? Ae = be(Ve) : (me = Ae, Ae = i)) : (me = Ae, Ae = i), Ae;
    }
    function or() {
      var Ae, Ve;
      return Ae = me, we++, a.length > me ? (Ve = a.charAt(me), me++) : (Ve = i, we === 0 && rt(d)), we--, Ve === i ? Ae = void 0 : (me = Ae, Ae = i), Ae;
    }
    if (!s.isWhitespace)
      try {
        Object.assign(s, {
          isSep: (Ae) => Ae.type === "string" && Ae.content === ",",
          isVar: (Ae) => Ae.type === "string" && Ae.content.match(/[a-zA-Z]/),
          isOperation: (Ae) => Ae.type === "string" && Ae.content.match(/[+-]/),
          isEquals: (Ae) => Ae.type === "string" && Ae.content === "=",
          isAt: (Ae) => Ae.type === "string" && Ae.content === "@",
          isSubscript: (Ae) => Ae.content === "_",
          isWhitespace: (Ae) => Ae.type === "whitespace",
          isSameLineComment: (Ae) => Ae.type === "comment" && Ae.sameline,
          isOwnLineComment: (Ae) => Ae.type === "comment" && !Ae.sameline
        });
      } catch (Ae) {
        console.warn("Error when initializing parser", Ae);
      }
    if (te = u(), te !== i && me === a.length)
      return te;
    throw te !== i && me < a.length && rt(Y()), Mt(
      xe,
      We < a.length ? a.charAt(We) : null,
      We < a.length ? Ze(We, We + 1) : Ze(We, We)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { root: Kt }, u = Kt, c = "plus", d = "minus", p = "pt", f = "mm", h = "cm", m = "in", y = "ex", b = "em", v = "bp", x = "pc", _ = "dd", E = "cc", w = "nd", C = "nc", k = "sp", S = "filll", B = "fill", U = "fil", N = ".", O = "+", I = "-", q = /^[0-9]/, ae = tr(), Q = Qt("plus", !1), ne = Qt("minus", !1), le = Qt("pt", !1), W = Qt("mm", !1), X = Qt("cm", !1), G = Qt("in", !1), P = Qt("ex", !1), he = Qt("em", !1), ye = Qt("bp", !1), pe = Qt("pc", !1), $ = Qt("dd", !1), F = Qt("cc", !1), ge = Qt("nd", !1), ce = Qt("nc", !1), ie = Qt("sp", !1), re = Qt("filll", !1), Te = Qt("fill", !1), V = Qt("fil", !1), Pe = Ie("number"), z = kr([["0", "9"]], !1, !1), A = Qt(".", !1), R = Qt("+", !1), H = Qt("-", !1), be = function(at, Rt, sr) {
      return {
        type: "glue",
        fixed: at,
        stretchable: Rt,
        shrinkable: sr,
        position: Mt()
      };
    }, me = function(at) {
      return at;
    }, Ce = function(at, Rt) {
      return { type: "dim", value: at, unit: Rt };
    }, We = function(at, Rt) {
      return { type: "dim", value: at, unit: Rt };
    }, xe = function(at, Rt) {
      return { type: "dim", value: at, unit: Rt };
    }, we = function(at) {
      return parseFloat(at);
    }, te = 0, Fe = 0, Y = [{ line: 1, column: 1 }], Je = 0, xt = [], Ze = 0, rt;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function Mt() {
      return je(Fe, te);
    }
    function Qt(at, Rt) {
      return { type: "literal", text: at, ignoreCase: Rt };
    }
    function kr(at, Rt, sr) {
      return { type: "class", parts: at, inverted: Rt, ignoreCase: sr };
    }
    function tr() {
      return { type: "any" };
    }
    function Oe() {
      return { type: "end" };
    }
    function Ie(at) {
      return { type: "other", description: at };
    }
    function Me(at) {
      var Rt = Y[at], sr;
      if (Rt)
        return Rt;
      for (sr = at - 1; !Y[sr]; )
        sr--;
      for (Rt = Y[sr], Rt = {
        line: Rt.line,
        column: Rt.column
      }; sr < at; )
        a.charCodeAt(sr) === 10 ? (Rt.line++, Rt.column = 1) : Rt.column++, sr++;
      return Y[at] = Rt, Rt;
    }
    function je(at, Rt, sr) {
      var bt = Me(at), Ur = Me(Rt), or = {
        source: o,
        start: {
          offset: at,
          line: bt.line,
          column: bt.column
        },
        end: {
          offset: Rt,
          line: Ur.line,
          column: Ur.column
        }
      };
      return or;
    }
    function tt(at) {
      te < Je || (te > Je && (Je = te, xt = []), xt.push(at));
    }
    function Ct(at, Rt, sr) {
      return new t(
        t.buildMessage(at, Rt),
        at,
        Rt,
        sr
      );
    }
    function Kt() {
      var at, Rt, sr, bt, Ur;
      if (at = te, Rt = te, sr = ct(), sr !== i ? (bt = ir(), bt === i && (bt = null), Ur = xr(), Ur === i && (Ur = null), Fe = Rt, Rt = be(sr, bt, Ur)) : (te = Rt, Rt = i), Rt !== i) {
        for (sr = [], a.length > te ? (bt = a.charAt(te), te++) : (bt = i, Ze === 0 && tt(ae)); bt !== i; )
          sr.push(bt), a.length > te ? (bt = a.charAt(te), te++) : (bt = i, Ze === 0 && tt(ae));
        Fe = at, at = me(Rt);
      } else
        te = at, at = i;
      return at;
    }
    function ct() {
      var at, Rt, sr;
      return at = te, Rt = dr(), Rt !== i ? (sr = Rr(), sr !== i ? (Fe = at, at = Ce(Rt, sr)) : (te = at, at = i)) : (te = at, at = i), at;
    }
    function ir() {
      var at, Rt, sr, bt;
      return at = te, a.substr(te, 4) === c ? (Rt = c, te += 4) : (Rt = i, Ze === 0 && tt(Q)), Rt !== i ? (sr = dr(), sr !== i ? (bt = Nt(), bt !== i ? (Fe = at, at = We(sr, bt)) : (te = at, at = i)) : (te = at, at = i)) : (te = at, at = i), at;
    }
    function xr() {
      var at, Rt, sr, bt;
      return at = te, a.substr(te, 5) === d ? (Rt = d, te += 5) : (Rt = i, Ze === 0 && tt(ne)), Rt !== i ? (sr = dr(), sr !== i ? (bt = Nt(), bt !== i ? (Fe = at, at = xe(sr, bt)) : (te = at, at = i)) : (te = at, at = i)) : (te = at, at = i), at;
    }
    function Rr() {
      var at;
      return a.substr(te, 2) === p ? (at = p, te += 2) : (at = i, Ze === 0 && tt(le)), at === i && (a.substr(te, 2) === f ? (at = f, te += 2) : (at = i, Ze === 0 && tt(W)), at === i && (a.substr(te, 2) === h ? (at = h, te += 2) : (at = i, Ze === 0 && tt(X)), at === i && (a.substr(te, 2) === m ? (at = m, te += 2) : (at = i, Ze === 0 && tt(G)), at === i && (a.substr(te, 2) === y ? (at = y, te += 2) : (at = i, Ze === 0 && tt(P)), at === i && (a.substr(te, 2) === b ? (at = b, te += 2) : (at = i, Ze === 0 && tt(he)), at === i && (a.substr(te, 2) === v ? (at = v, te += 2) : (at = i, Ze === 0 && tt(ye)), at === i && (a.substr(te, 2) === x ? (at = x, te += 2) : (at = i, Ze === 0 && tt(pe)), at === i && (a.substr(te, 2) === _ ? (at = _, te += 2) : (at = i, Ze === 0 && tt($)), at === i && (a.substr(te, 2) === E ? (at = E, te += 2) : (at = i, Ze === 0 && tt(F)), at === i && (a.substr(te, 2) === w ? (at = w, te += 2) : (at = i, Ze === 0 && tt(ge)), at === i && (a.substr(te, 2) === C ? (at = C, te += 2) : (at = i, Ze === 0 && tt(ce)), at === i && (a.substr(te, 2) === k ? (at = k, te += 2) : (at = i, Ze === 0 && tt(ie)))))))))))))), at;
    }
    function Nt() {
      var at;
      return at = Rr(), at === i && (a.substr(te, 5) === S ? (at = S, te += 5) : (at = i, Ze === 0 && tt(re)), at === i && (a.substr(te, 4) === B ? (at = B, te += 4) : (at = i, Ze === 0 && tt(Te)), at === i && (a.substr(te, 3) === U ? (at = U, te += 3) : (at = i, Ze === 0 && tt(V))))), at;
    }
    function dr() {
      var at, Rt, sr, bt, Ur, or, Ae, Ve, Ge;
      for (Ze++, at = te, Rt = te, sr = te, bt = $e(), bt === i && (bt = null), Ur = te, or = [], q.test(a.charAt(te)) ? (Ae = a.charAt(te), te++) : (Ae = i, Ze === 0 && tt(z)); Ae !== i; )
        or.push(Ae), q.test(a.charAt(te)) ? (Ae = a.charAt(te), te++) : (Ae = i, Ze === 0 && tt(z));
      if (a.charCodeAt(te) === 46 ? (Ae = N, te++) : (Ae = i, Ze === 0 && tt(A)), Ae !== i) {
        if (Ve = [], q.test(a.charAt(te)) ? (Ge = a.charAt(te), te++) : (Ge = i, Ze === 0 && tt(z)), Ge !== i)
          for (; Ge !== i; )
            Ve.push(Ge), q.test(a.charAt(te)) ? (Ge = a.charAt(te), te++) : (Ge = i, Ze === 0 && tt(z));
        else
          Ve = i;
        Ve !== i ? (or = [or, Ae, Ve], Ur = or) : (te = Ur, Ur = i);
      } else
        te = Ur, Ur = i;
      if (Ur === i)
        if (Ur = [], q.test(a.charAt(te)) ? (or = a.charAt(te), te++) : (or = i, Ze === 0 && tt(z)), or !== i)
          for (; or !== i; )
            Ur.push(or), q.test(a.charAt(te)) ? (or = a.charAt(te), te++) : (or = i, Ze === 0 && tt(z));
        else
          Ur = i;
      return Ur !== i ? (bt = [bt, Ur], sr = bt) : (te = sr, sr = i), sr !== i ? Rt = a.substring(Rt, te) : Rt = sr, Rt !== i && (Fe = at, Rt = we(Rt)), at = Rt, Ze--, at === i && (Rt = i, Ze === 0 && tt(Pe)), at;
    }
    function $e() {
      var at;
      return a.charCodeAt(te) === 43 ? (at = O, te++) : (at = i, Ze === 0 && tt(R)), at === i && (a.charCodeAt(te) === 45 ? (at = I, te++) : (at = i, Ze === 0 && tt(H))), at;
    }
    if (rt = u(), rt !== i && te === a.length)
      return rt;
    throw rt !== i && te < a.length && tt(Oe()), Ct(
      xt,
      Je < a.length ? a.charAt(Je) : null,
      Je < a.length ? je(Je, Je + 1) : je(Je, Je)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
(function() {
  function e(a, s) {
    function i() {
      this.constructor = a;
    }
    i.prototype = s.prototype, a.prototype = new i();
  }
  function t(a, s, i, o) {
    var l = Error.call(this, a);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = i, l.location = o, l.name = "SyntaxError", l;
  }
  e(t, Error);
  function r(a, s, i) {
    return i = i || " ", a.length > s ? a : (s -= a.length, i += i.repeat(s), a + i.slice(0, s));
  }
  t.prototype.format = function(a) {
    var s = "Error: " + this.message;
    if (this.location) {
      var i = null, o;
      for (o = 0; o < a.length; o++)
        if (a[o].source === this.location.source) {
          i = a[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, c = this.location.source + ":" + u.line + ":" + u.column;
      if (i) {
        var d = this.location.end, p = r("", u.line.toString().length, " "), f = i[l.line - 1], h = l.line === d.line ? d.column : f.length + 1, m = h - l.column || 1;
        s += `
 --> ` + c + `
` + p + ` |
` + u.line + " | " + f + `
` + p + " | " + r("", l.column - 1, " ") + r("", m, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(a, s) {
    var i = {
      literal: function(f) {
        return '"' + l(f.text) + '"';
      },
      class: function(f) {
        var h = f.parts.map(function(m) {
          return Array.isArray(m) ? u(m[0]) + "-" + u(m[1]) : u(m);
        });
        return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(f) {
        return f.description;
      }
    };
    function o(f) {
      return f.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function u(f) {
      return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
        return "\\x0" + o(h);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
        return "\\x" + o(h);
      });
    }
    function c(f) {
      return i[f.type](f);
    }
    function d(f) {
      var h = f.map(c), m, y;
      if (h.sort(), h.length > 0) {
        for (m = 1, y = 1; m < h.length; m++)
          h[m - 1] !== h[m] && (h[y] = h[m], y++);
        h.length = y;
      }
      switch (h.length) {
        case 1:
          return h[0];
        case 2:
          return h[0] + " or " + h[1];
        default:
          return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
      }
    }
    function p(f) {
      return f ? '"' + l(f) + '"' : "end of input";
    }
    return "Expected " + d(a) + " but " + p(s) + " found.";
  };
  function n(a, s) {
    s = s !== void 0 ? s : {};
    var i = {}, o = s.grammarSource, l = { path_spec: $e, foreach_body: sr }, u = $e, c = Kt(), d = ir("comment"), p = ir("floating comment"), f = ir("operation"), h = ir("="), m = function(ue) {
      return ue;
    }, y = function(ue) {
      return { type: "path_spec", content: ue };
    }, b = function(ue, Ue, ze) {
      return { op: Ue, comment: ze };
    }, v = function(ue, Ue, ze, At) {
      const yt = [ue, ...Ue.map((Se) => Se.comment), ze].filter(
        (Se) => Se
      ), wt = Ue.map((Se) => Se.op.content.content).join(" ");
      return {
        type: "animation",
        comments: yt,
        attribute: wt,
        content: At.content
      };
    }, x = function(ue, Ue) {
      return { ...Ue, start: ue, type: "foreach" };
    }, _ = function(ue, Ue, ze, At, yt, wt, Se, qe) {
      const lt = [ue, At, yt, Se].filter((St) => St);
      return {
        type: "foreach_body",
        variables: Ue,
        options: ze && ze.content,
        list: wt,
        command: qe,
        comments: lt
      };
    }, E = function(ue, Ue, ze, At) {
      const yt = [ue, ze].filter((wt) => wt);
      return {
        type: "svg_operation",
        options: Ue && Ue.content,
        content: At,
        comments: yt
      };
    }, w = function(ue, Ue, ze, At, yt, wt) {
      return { coord: wt, comment: yt };
    }, C = function(ue, Ue, ze, At, yt, wt) {
      const Se = [ue, Ue, At, yt && yt.comment, wt].filter((qe) => qe);
      return {
        type: "curve_to",
        controls: yt ? [ze, yt.coord] : [ze],
        comments: Se
      };
    }, k = function() {
      return { type: "line_to", command: "|-" };
    }, S = function() {
      return { type: "line_to", command: "-|" };
    }, B = function() {
      return { type: "line_to", command: "--" };
    }, U = function(ue, Ue) {
      return { type: "coordinate", content: Ue, prefix: ue };
    }, N = function(ue) {
      return { type: "square_brace_group", content: ue };
    }, O = function(ue) {
      return { type: "unknown", content: ue };
    }, I = function(ue) {
      return s.isComment(ue);
    }, q = function(ue) {
      return ue;
    }, ae = function(ue) {
      return s.isWhitespace(ue);
    }, Q = function(ue) {
      return ue;
    }, ne = function(ue) {
      return ue;
    }, le = function(ue) {
      return s.isOperation(ue);
    }, W = function(ue) {
      return { type: "operation", content: ue };
    }, X = function(ue) {
      return s.isChar(ue, "=");
    }, G = function(ue) {
      return ue;
    }, P = function(ue) {
      return s.isChar(ue, "[");
    }, he = function(ue) {
      return ue;
    }, ye = function(ue) {
      return s.isChar(ue, "]");
    }, pe = function(ue) {
      return ue;
    }, $ = function(ue) {
      return s.isChar(ue, "(");
    }, F = function(ue) {
      return ue;
    }, ge = function(ue) {
      return s.isChar(ue, ")");
    }, ce = function(ue) {
      return ue;
    }, ie = function(ue) {
      return s.isChar(ue, "+");
    }, re = function(ue) {
      return ue;
    }, Te = function(ue) {
      return s.isChar(ue, "-");
    }, V = function(ue) {
      return ue;
    }, Pe = function(ue) {
      return s.isChar(ue, "|");
    }, z = function(ue) {
      return ue;
    }, A = function(ue) {
      return s.isChar(ue, ".");
    }, R = function(ue) {
      return ue;
    }, H = function(ue) {
      return s.isChar(ue, "controls");
    }, be = function(ue) {
      return ue;
    }, me = function(ue) {
      return s.isChar(ue, "and");
    }, Ce = function(ue) {
      return ue;
    }, We = function(ue) {
      return s.isChar(ue, "svg");
    }, xe = function(ue) {
      return ue;
    }, we = function(ue) {
      return s.isGroup(ue);
    }, te = function(ue) {
      return ue;
    }, Fe = function(ue) {
      return s.isAnyMacro(ue);
    }, Y = function(ue) {
      return ue;
    }, Je = function(ue) {
      return s.isChar(ue, "foreach");
    }, xt = function(ue) {
      return ue;
    }, Ze = function(ue) {
      return s.isMacro(ue, "foreach");
    }, rt = function(ue) {
      return ue;
    }, Mt = function(ue) {
      return s.isChar(ue, "in");
    }, Qt = function(ue) {
      return ue;
    }, kr = function(ue) {
      return s.isChar(ue, ":");
    }, tr = function(ue) {
      return ue;
    }, Oe = 0, Ie = [{ line: 1, column: 1 }], Me = 0, je = [], tt = 0, Ct;
    if ("startRule" in s) {
      if (!(s.startRule in l))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      u = l[s.startRule];
    }
    function Kt() {
      return { type: "any" };
    }
    function ct() {
      return { type: "end" };
    }
    function ir(ue) {
      return { type: "other", description: ue };
    }
    function xr(ue) {
      var Ue = Ie[ue], ze;
      if (Ue)
        return Ue;
      for (ze = ue - 1; !Ie[ze]; )
        ze--;
      for (Ue = Ie[ze], Ue = {
        line: Ue.line,
        column: Ue.column
      }; ze < ue; )
        a.charCodeAt(ze) === 10 ? (Ue.line++, Ue.column = 1) : Ue.column++, ze++;
      return Ie[ue] = Ue, Ue;
    }
    function Rr(ue, Ue, ze) {
      var At = xr(ue), yt = xr(Ue), wt = {
        source: o,
        start: {
          offset: ue,
          line: At.line,
          column: At.column
        },
        end: {
          offset: Ue,
          line: yt.line,
          column: yt.column
        }
      };
      return wt;
    }
    function Nt(ue) {
      Oe < Me || (Oe > Me && (Me = Oe, je = []), je.push(ue));
    }
    function dr(ue, Ue, ze) {
      return new t(
        t.buildMessage(ue, Ue),
        ue,
        Ue,
        ze
      );
    }
    function $e() {
      var ue, Ue, ze, At, yt, wt;
      if (ue = Oe, Ue = [], ze = Oe, At = Ve(), At === i && (At = Ae(), At === i && (At = Ur(), At === i && (At = or(), At === i && (At = bt(), At === i && (At = Rt(), At === i && (At = Re(), At === i && (At = br(), At === i && (At = at(), At === i && (At = lr()))))))))), At !== i) {
        for (yt = [], wt = Ut(); wt !== i; )
          yt.push(wt), wt = Ut();
        ze = m(At);
      } else
        Oe = ze, ze = i;
      if (ze !== i)
        for (; ze !== i; )
          if (Ue.push(ze), ze = Oe, At = Ve(), At === i && (At = Ae(), At === i && (At = Ur(), At === i && (At = or(), At === i && (At = bt(), At === i && (At = Rt(), At === i && (At = Re(), At === i && (At = br(), At === i && (At = at(), At === i && (At = lr()))))))))), At !== i) {
            for (yt = [], wt = Ut(); wt !== i; )
              yt.push(wt), wt = Ut();
            ze = m(At);
          } else
            Oe = ze, ze = i;
      else
        Ue = i;
      return Ue !== i && (Ue = y(Ue)), ue = Ue, ue;
    }
    function at() {
      var ue, Ue, ze, At, yt, wt, Se;
      if (ue = Oe, Ue = Dn(), Ue !== i) {
        if (ze = cn(), At = [], yt = Oe, wt = Re(), wt !== i ? (Se = cn(), yt = b(ze, wt, Se)) : (Oe = yt, yt = i), yt !== i)
          for (; yt !== i; )
            At.push(yt), yt = Oe, wt = Re(), wt !== i ? (Se = cn(), yt = b(ze, wt, Se)) : (Oe = yt, yt = i);
        else
          At = i;
        At !== i ? (yt = J(), yt !== i ? (wt = cn(), Se = Ht(), Se !== i ? ue = v(ze, At, wt, Se) : (Oe = ue, ue = i)) : (Oe = ue, ue = i)) : (Oe = ue, ue = i);
      } else
        Oe = ue, ue = i;
      return ue;
    }
    function Rt() {
      var ue, Ue, ze;
      return ue = Oe, Ue = jn(), Ue === i && (Ue = Ii()), Ue !== i ? (ze = sr(), ze !== i ? ue = x(Ue, ze) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function sr() {
      var ue, Ue, ze, At, yt, wt, Se, qe, lt, St;
      for (ue = Oe, Ue = cn(), ze = Oe, At = [], yt = Oe, wt = Oe, tt++, Se = ti(), Se === i && (Se = Ve()), tt--, Se === i ? wt = void 0 : (Oe = wt, wt = i), wt !== i ? (a.length > Oe ? (Se = a.charAt(Oe), Oe++) : (Se = i, tt === 0 && Nt(c)), Se !== i ? (wt = [wt, Se], yt = wt) : (Oe = yt, yt = i)) : (Oe = yt, yt = i); yt !== i; )
        At.push(yt), yt = Oe, wt = Oe, tt++, Se = ti(), Se === i && (Se = Ve()), tt--, Se === i ? wt = void 0 : (Oe = wt, wt = i), wt !== i ? (a.length > Oe ? (Se = a.charAt(Oe), Oe++) : (Se = i, tt === 0 && Nt(c)), Se !== i ? (wt = [wt, Se], yt = wt) : (Oe = yt, yt = i)) : (Oe = yt, yt = i);
      return ze = a.substring(ze, Oe), At = Ve(), At === i && (At = null), yt = cn(), wt = ti(), wt !== i ? (Se = cn(), qe = Ht(), qe === i && (qe = jt()), qe !== i ? (lt = cn(), St = Rt(), St === i && (St = Ht(), St === i && (St = jt())), St !== i ? ue = _(Ue, ze, At, yt, Se, qe, lt, St) : (Oe = ue, ue = i)) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function bt() {
      var ue, Ue, ze, At, yt, wt;
      return ue = Oe, Ue = Ri(), Ue !== i ? (ze = cn(), At = Ve(), At === i && (At = null), yt = cn(), wt = Ht(), wt !== i ? ue = E(ze, At, yt, wt) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Ur() {
      var ue, Ue, ze, At, yt, wt, Se, qe, lt, St, Yt;
      return ue = Oe, Ue = Ge(), Ue !== i ? (ze = cn(), At = Xi(), At !== i ? (yt = cn(), wt = Ae(), wt !== i ? (Se = cn(), qe = Oe, lt = mn(), lt !== i ? (St = cn(), Yt = Ae(), Yt !== i ? qe = w(ze, yt, wt, Se, St, Yt) : (Oe = qe, qe = i)) : (Oe = qe, qe = i), qe === i && (qe = null), lt = cn(), St = Ge(), St !== i ? ue = C(ze, yt, wt, Se, qe, lt) : (Oe = ue, ue = i)) : (Oe = ue, ue = i)) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function or() {
      var ue, Ue, ze;
      return ue = Oe, Ue = yi(), Ue !== i ? (ze = En(), ze !== i ? ue = k() : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue === i && (ue = Oe, Ue = En(), Ue !== i ? (ze = yi(), ze !== i ? ue = S() : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue === i && (ue = Oe, Ue = En(), Ue !== i ? (ze = En(), ze !== i ? ue = B() : (Oe = ue, ue = i)) : (Oe = ue, ue = i))), ue;
    }
    function Ae() {
      var ue, Ue, ze, At, yt, wt, Se, qe;
      if (ue = Oe, Ue = Oe, ze = Oe, At = qn(), At !== i ? (yt = qn(), yt === i && (yt = null), At = [At, yt], ze = At) : (Oe = ze, ze = i), ze === i && (ze = null), Ue = a.substring(Ue, Oe), ze = Mr(), ze !== i) {
        for (At = Oe, yt = [], wt = Oe, Se = Oe, tt++, qe = ut(), tt--, qe === i ? Se = void 0 : (Oe = Se, Se = i), Se !== i ? (a.length > Oe ? (qe = a.charAt(Oe), Oe++) : (qe = i, tt === 0 && Nt(c)), qe !== i ? (Se = [Se, qe], wt = Se) : (Oe = wt, wt = i)) : (Oe = wt, wt = i); wt !== i; )
          yt.push(wt), wt = Oe, Se = Oe, tt++, qe = ut(), tt--, qe === i ? Se = void 0 : (Oe = Se, Se = i), Se !== i ? (a.length > Oe ? (qe = a.charAt(Oe), Oe++) : (qe = i, tt === 0 && Nt(c)), qe !== i ? (Se = [Se, qe], wt = Se) : (Oe = wt, wt = i)) : (Oe = wt, wt = i);
        At = a.substring(At, Oe), yt = ut(), yt !== i ? ue = U(Ue, At) : (Oe = ue, ue = i);
      } else
        Oe = ue, ue = i;
      return ue;
    }
    function Ve() {
      var ue, Ue, ze, At, yt, wt, Se;
      if (ue = Oe, Ue = He(), Ue !== i) {
        for (ze = Oe, At = [], yt = Oe, wt = Oe, tt++, Se = fr(), tt--, Se === i ? wt = void 0 : (Oe = wt, wt = i), wt !== i ? (a.length > Oe ? (Se = a.charAt(Oe), Oe++) : (Se = i, tt === 0 && Nt(c)), Se !== i ? (wt = [wt, Se], yt = wt) : (Oe = yt, yt = i)) : (Oe = yt, yt = i); yt !== i; )
          At.push(yt), yt = Oe, wt = Oe, tt++, Se = fr(), tt--, Se === i ? wt = void 0 : (Oe = wt, wt = i), wt !== i ? (a.length > Oe ? (Se = a.charAt(Oe), Oe++) : (Se = i, tt === 0 && Nt(c)), Se !== i ? (wt = [wt, Se], yt = wt) : (Oe = yt, yt = i)) : (Oe = yt, yt = i);
        ze = a.substring(ze, Oe), At = fr(), At !== i ? ue = N(ze) : (Oe = ue, ue = i);
      } else
        Oe = ue, ue = i;
      return ue;
    }
    function Ge() {
      var ue, Ue, ze;
      return ue = Oe, Ue = Yi(), Ue !== i ? (ze = Yi(), ze !== i ? (Ue = [Ue, ze], ue = Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function lr() {
      var ue, Ue;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i && (Ue = O(Ue)), ue = Ue, ue;
    }
    function br() {
      var ue, Ue, ze;
      return tt++, ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = I(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = q(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), tt--, ue === i && (Ue = i, tt === 0 && Nt(d)), ue;
    }
    function Ut() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = ae(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = Q(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function cn() {
      var ue, Ue, ze, At, yt;
      for (tt++, ue = Oe, Ue = [], ze = Ut(); ze !== i; )
        Ue.push(ze), ze = Ut();
      for (ze = br(), ze === i && (ze = null), At = [], yt = Ut(); yt !== i; )
        At.push(yt), yt = Ut();
      return ue = ne(ze), tt--, Ue = i, tt === 0 && Nt(p), ue;
    }
    function Re() {
      var ue, Ue, ze;
      return tt++, ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = le(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = W(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), tt--, ue === i && (Ue = i, tt === 0 && Nt(f)), ue;
    }
    function J() {
      var ue, Ue, ze;
      return tt++, ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = X(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = G(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), tt--, ue === i && (Ue = i, tt === 0 && Nt(h)), ue;
    }
    function He() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = P(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = he(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function fr() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = ye(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = pe(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Mr() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = $(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = F(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function ut() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = ge(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = ce(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function qn() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = ie(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = re(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function En() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Te(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = V(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function yi() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Pe(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = z(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Yi() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = A(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = R(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Xi() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = H(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = be(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function mn() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = me(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = Ce(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Ri() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = We(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = xe(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Ht() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = we(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = te(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function jt() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Fe(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = Y(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function jn() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Je(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = xt(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Ii() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Ze(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = rt(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function ti() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = Mt(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = Qt(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    function Dn() {
      var ue, Ue, ze;
      return ue = Oe, a.length > Oe ? (Ue = a.charAt(Oe), Oe++) : (Ue = i, tt === 0 && Nt(c)), Ue !== i ? (ze = kr(Ue), ze ? ze = void 0 : ze = i, ze !== i ? ue = tr(Ue) : (Oe = ue, ue = i)) : (Oe = ue, ue = i), ue;
    }
    if (!s.isWhitespace)
      try {
        Object.assign(s, {
          isChar: (ue, Ue) => ue.type === "string" && ue.content === Ue,
          isOperation: (ue) => ue.type === "string" && ue.content.match(/[a-zA-Z]/),
          isWhitespace: (ue) => ue.type === "whitespace" || ue.type === "parbreak",
          isSameLineComment: (ue) => ue.type === "comment" && ue.sameline,
          isOwnLineComment: (ue) => ue.type === "comment" && !ue.sameline,
          isComment: (ue) => ue.type === "comment",
          isGroup: (ue) => ue.type === "group",
          isMacro: (ue, Ue) => ue.type === "macro" && ue.content === Ue,
          isAnyMacro: (ue) => ue.type === "macro"
        });
      } catch (ue) {
        console.warn("Error when initializing parser", ue);
      }
    if (Ct = u(), Ct !== i && Oe === a.length)
      return Ct;
    throw Ct !== i && Oe < a.length && Nt(ct()), dr(
      je,
      Me < a.length ? a.charAt(Me) : null,
      Me < a.length ? Rr(Me, Me + 1) : Rr(Me, Me)
    );
  }
  return {
    SyntaxError: t,
    parse: n
  };
})();
const XG = lAe, cAe = uAe, jx = {};
function Zl(e = "") {
  return jx[e] = jx[e] || cAe.parse(e), jx[e];
}
var Tm = { exports: {} }, Rm = { exports: {} }, Im = { exports: {} }, Nm = { exports: {} }, v5;
function Ch() {
  return v5 || (v5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    }, e.exports = t.default;
  }(Nm, Nm.exports)), Nm.exports;
}
var w5;
function ZG() {
  return w5 || (w5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = s;
    var r = Ch(), n = a(r);
    function a(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s(i, o, l, u) {
      var c = o === n.default.END_WORD, d = l === u.length - 1;
      return c && !d ? (i[n.default.END_WORD] = 1, i[n.default.END_WORD_REPLACER] = {}, i = i[n.default.END_WORD_REPLACER]) : (i[o] = i[o] || {}, i = i[o]), d && (i[n.default.END_WORD] = 1), i;
    }
    e.exports = t.default;
  }(Im, Im.exports)), Im.exports;
}
var x5;
function dAe() {
  return x5 || (x5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    };
    t.default = i;
    var n = ZG(), a = s(n);
    function s(o) {
      return o && o.__esModule ? o : { default: o };
    }
    function i(o) {
      if (!Array.isArray(o))
        throw "Expected parameter Array, received " + (typeof o > "u" ? "undefined" : r(o));
      var l = o.reduce(function(u, c) {
        return c.toLowerCase().split("").reduce(a.default, u), u;
      }, {});
      return l;
    }
    e.exports = t.default;
  }(Rm, Rm.exports)), Rm.exports;
}
var Dm = { exports: {} }, Om = { exports: {} }, E5;
function JG() {
  return E5 || (E5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = {
      objectCopy: function(n) {
        return typeof n > "u" ? {} : JSON.parse(JSON.stringify(n));
      },
      stringify: function(n) {
        var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        return typeof n > "u" ? "" : JSON.stringify(n, null, a);
      }
    }, e.exports = t.default;
  }(Om, Om.exports)), Om.exports;
}
var S5;
function fAe() {
  return S5 || (S5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = a;
    var r = JG();
    n(r);
    function n(s) {
      return s && s.__esModule ? s : { default: s };
    }
    function a(s, i) {
      var o = i.toLowerCase().split(""), l = o.every(function(u, c) {
        return s[u] ? s = s[u] : !1;
      });
      return {
        prefixFound: l,
        prefixNode: s
      };
    }
    e.exports = t.default;
  }(Dm, Dm.exports)), Dm.exports;
}
var Pm = { exports: {} }, _5;
function pAe() {
  return _5 || (_5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = i;
    var r = Ch(), n = a(r);
    function a(o) {
      return o && o.__esModule ? o : { default: o };
    }
    var s = function(l, u) {
      for (var c = 0; c < u.length && !(l < u[c]); )
        c += 1;
      return u.splice(c, 0, l), u;
    };
    function i(o, l, u) {
      var c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], d = l;
      for (var p in o) {
        var f = p;
        p === n.default.END_WORD && typeof o[p] == "number" ? (u ? s(d, c) : c.push(d), d = "") : p === n.default.END_WORD_REPLACER && (f = n.default.END_WORD), i(o[p], l + f, u, c);
      }
      return c;
    }
    e.exports = t.default;
  }(Pm, Pm.exports)), Pm.exports;
}
var Lm = { exports: {} }, k5;
function hAe() {
  return k5 || (k5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = s;
    var r = Ch(), n = a(r);
    function a(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s(i, o) {
      var l = o, u = Object.keys(i), c = u[Math.floor(Math.random() * u.length)];
      return c === n.default.END_WORD ? l : s(i[c], o + c);
    }
    e.exports = t.default;
  }(Lm, Lm.exports)), Lm.exports;
}
var Mm = { exports: {} }, C5;
function mAe() {
  return C5 || (C5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    };
    t.default = i;
    var n = Ch(), a = s(n);
    function s(o) {
      return o && o.__esModule ? o : { default: o };
    }
    function i(o, l) {
      var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof o != "string")
        throw "Permutations expects string letters, received " + (typeof o > "u" ? "undefined" : r(o));
      var c = [], d = function p(f, h) {
        var m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", y = f.length === 0, b = c.indexOf(m) !== -1, v = h[a.default.END_WORD] === 1;
        y && v && !b && c.push(m);
        for (var x = 0, _ = f.length; x < _; x++) {
          var E = f[x];
          if (u.type === "sub-anagram" && v && c.indexOf(m) === -1 && c.push(m), h[E]) {
            var w = f.substring(0, x) + f.substring(x + 1, _);
            p(w, h[E], m + E, c);
          }
        }
        return c.sort();
      };
      return d(o, l);
    }
    e.exports = t.default;
  }(Mm, Mm.exports)), Mm.exports;
}
var A5;
function gAe() {
  return A5 || (A5 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
      return typeof w;
    } : function(w) {
      return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
    };
    t.default = function(w) {
      if (!Array.isArray(w))
        throw "Expected parameter Array, received " + (typeof w > "u" ? "undefined" : r(w));
      var C = (0, a.default)([].concat(_(w)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function() {
          return C;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return h.default.stringify(C, S);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function(S) {
          if (typeof S != "string" || S === "")
            throw "Expected parameter string, received " + (typeof S > "u" ? "undefined" : r(S));
          var B = function() {
            return i.default.apply(void 0, arguments);
          }, U = S.toLowerCase().split("");
          return U.reduce(B, C), this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function(S) {
          if (typeof S != "string" || S === "")
            throw "Expected parameter string, received " + (typeof S > "u" ? "undefined" : r(S));
          var B = (0, l.default)(C, S), U = B.prefixFound, N = B.prefixNode;
          return U && delete N[y.default.END_WORD], this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function(S) {
          if (typeof S != "string")
            throw "Expected string prefix, received " + (typeof S > "u" ? "undefined" : r(S));
          var B = (0, l.default)(C, S), U = B.prefixFound;
          return U;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function(S) {
          var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          if (typeof S != "string")
            throw "Expected string prefix, received " + (typeof S > "u" ? "undefined" : r(S));
          if (typeof B != "boolean")
            throw "Expected sort parameter as boolean, received " + (typeof B > "u" ? "undefined" : r(B));
          if (!this.isPrefix(S))
            return [];
          var U = S.length ? (0, l.default)(C, S).prefixNode : C;
          return (0, c.default)(U, S, B);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function(S) {
          if (typeof S != "string")
            throw "Expected string prefix, received " + (typeof S > "u" ? "undefined" : r(S));
          if (!this.isPrefix(S))
            return "";
          var B = (0, l.default)(C, S), U = B.prefixNode;
          return (0, p.default)(U, S);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function(S) {
          var B = this.getPrefix(S);
          return B.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          return this.getPrefix("", S);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function(S) {
          if (typeof S != "string")
            throw "Expected string word, received " + (typeof S > "u" ? "undefined" : r(S));
          var B = (0, l.default)(C, S), U = B.prefixFound, N = B.prefixNode;
          return U ? N[y.default.END_WORD] === 1 : !1;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function(S) {
          if (typeof S != "string")
            throw "Anagrams expected string letters, received " + (typeof S > "u" ? "undefined" : r(S));
          if (S.length < E)
            throw "getAnagrams expects at least " + E + " letters";
          return (0, v.default)(S, C, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function(S) {
          if (typeof S != "string")
            throw "Expected string letters, received " + (typeof S > "u" ? "undefined" : r(S));
          if (S.length < E)
            throw "getSubAnagrams expects at least " + E + " letters";
          return (0, v.default)(S, C, {
            type: "sub-anagram"
          });
        }
      };
    };
    var n = dAe(), a = x(n), s = ZG(), i = x(s), o = fAe(), l = x(o), u = pAe(), c = x(u), d = hAe(), p = x(d), f = JG(), h = x(f), m = Ch(), y = x(m), b = mAe(), v = x(b);
    function x(w) {
      return w && w.__esModule ? w : { default: w };
    }
    function _(w) {
      if (Array.isArray(w)) {
        for (var C = 0, k = Array(w.length); C < w.length; C++)
          k[C] = w[C];
        return k;
      } else
        return Array.from(w);
    }
    var E = y.default.PERMS_MIN_LEN;
    e.exports = t.default;
  }(Tm, Tm.exports)), Tm.exports;
}
gAe();
function Jg(e, t, r) {
  const { startIndex: n, onlySkipWhitespaceAndComments: a, allowSubstringMatches: s } = r || {};
  typeof t == "string" && (t = { type: "string", content: t });
  for (let i = n || 0; i < e.length; i++) {
    const o = e[i];
    if (o.type === t.type)
      switch (o.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (o.content === t.content)
            return i;
          break;
        case "environment":
        case "mathenv":
          if (Ho(o.env) === Ho(t.env))
            return i;
          break;
        case "string":
          if (o.content === t.content || s && o.content.indexOf(t.content) >= 0)
            return i;
          break;
      }
    if (a && !vr.whitespace(o) && !vr.comment(o))
      return null;
  }
  return null;
}
function Os(e, t, r = 0) {
  if (typeof t == "string" || !t.type)
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        t
      )}"`
    );
  let n = null, a = r;
  const s = t.noLeadingWhitespace ? () => {
  } : () => {
    for (; a < e.length && vr.whitespace(e[a]); )
      a++;
  }, i = t.openBrace || "", o = t.closeBrace || "", l = (t.type === "mandatory" || t.type === "optional") && i === "{" && o === "}";
  s();
  const u = e[a];
  if (u == null || vr.comment(u) || vr.parbreak(u))
    return {
      argument: n,
      nodesRemoved: 0
    };
  switch (t.type) {
    case "mandatory":
      if (l) {
        let p = [u];
        vr.group(u) && (p = u.content), n = Ai(p, {
          openMark: i,
          closeMark: o
        }), a++;
        break;
      } else {
        const p = wf(
          e,
          a,
          i,
          o
        );
        if (p) {
          n = Ai(e.slice(p[0] + 1, p[1]), {
            openMark: i,
            closeMark: o
          }), a = p[1] + 1;
          break;
        }
      }
    case "optional":
      if (l && vr.group(u)) {
        n = Ai(u.content, {
          openMark: i,
          closeMark: o
        }), a++;
        break;
      }
      const d = wf(
        e,
        a,
        i,
        o
      );
      if (d) {
        n = Ai(e.slice(d[0] + 1, d[1]), {
          openMark: i,
          closeMark: o
        }), a = d[1] + 1;
        break;
      }
      break;
    case "optionalStar":
    case "optionalToken": {
      const p = wf(
        e,
        a,
        t.type === "optionalStar" ? "*" : t.token
      );
      p && (n = Ai(u, { openMark: "", closeMark: "" }), a = p[0] + 1);
      break;
    }
    case "until": {
      if (t.stopTokens.length > 1) {
        console.warn(
          '"until" matches with multi-token stop conditions are not yet implemented'
        );
        break;
      }
      const p = t.stopTokens[0];
      let h = wf(
        e,
        r,
        void 0,
        p === " " ? { type: "whitespace" } : p
      );
      if (!h)
        break;
      n = Ai(e.slice(r, h[1]), {
        openMark: "",
        closeMark: p
      }), a = h[1], a < e.length && a++;
      break;
    }
    case "embellishment": {
      for (const p of t.embellishmentTokens) {
        const f = wf(e, a, p);
        if (!f)
          continue;
        let h = e[f[0] + 1];
        n = Ai(
          vr.group(h) ? h.content : h,
          {
            openMark: p,
            closeMark: ""
          }
        ), a = f[1] + 1;
        break;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${t.type}"`
      );
  }
  const c = n ? a - r : 0;
  return e.splice(r, c), { argument: n, nodesRemoved: c };
}
function Fm(e, t) {
  return Object.assign({}, e, { content: t });
}
function wf(e, t, r, n) {
  const a = e[t];
  let s = t, i = t;
  if (r) {
    if (!vr.anyString(a) || !a.content.startsWith(r))
      return;
    if (s = t, a.content.length > r.length) {
      const u = a.content;
      a.content = r, e.splice(
        s + 1,
        0,
        Fm(a, u.slice(r.length))
      );
    }
    i = s + 1;
  }
  if (!n) {
    const l = e[i];
    if (!l)
      return;
    if (vr.anyString(l) && l.content.length > 1) {
      const u = l.content;
      l.content = u[0], e.splice(
        i + 1,
        0,
        Fm(l, u.slice(1))
      );
    }
    return [s, i];
  }
  if (i = Jg(e, n, {
    startIndex: i,
    allowSubstringMatches: !0
  }), i === null)
    return;
  const o = e[i];
  if (vr.anyString(o) && typeof n == "string") {
    const l = o.content;
    let u = l.indexOf(n);
    if (l.length > n.length) {
      o.content = n;
      const c = l.slice(0, u), d = l.slice(
        u + n.length
      );
      c && (e.splice(
        i,
        0,
        Fm(o, c)
      ), i++), d && e.splice(
        i + 1,
        0,
        Fm(o, d)
      );
    }
  }
  return [s, i];
}
function QG(e, t, r = 0) {
  if (typeof t == "function")
    return t(e, r);
  typeof t == "string" && (t = Zl(t));
  const n = [];
  let a = 0;
  for (const s of t)
    if (s.type === "embellishment") {
      const i = new Set(s.embellishmentTokens), o = Object.fromEntries(
        s.embellishmentTokens.map((c, d) => {
          var p;
          const f = "defaultArg" in s ? (p = s.defaultArg) == null ? void 0 : p[d] : void 0;
          return [c, R5(f)];
        })
      );
      let { argument: l, nodesRemoved: u } = Os(
        e,
        T5(i),
        r
      );
      for (; l; ) {
        const c = l.openMark;
        i.delete(c), o[c] = l, a += u;
        const d = T5(i);
        ({ argument: l, nodesRemoved: u } = Os(
          e,
          d,
          r
        ));
      }
      n.push(...s.embellishmentTokens.map((c) => o[c]));
    } else {
      const { argument: i, nodesRemoved: o } = Os(
        e,
        s,
        r
      ), l = "defaultArg" in s ? s.defaultArg : void 0;
      n.push(i || R5(l)), a += o;
    }
  return { args: n, nodesRemoved: a };
}
function T5(e) {
  return {
    type: "embellishment",
    embellishmentTokens: [...e]
  };
}
function R5(e) {
  const t = Ai([], { openMark: "", closeMark: "" });
  return e != null && gy(t, { defaultArg: e }), t;
}
function FR(e, t) {
  let r;
  const n = vr.createMacroMatcher(t);
  function a() {
    for (; r >= 0 && !n(e[r]); )
      r--;
  }
  for (r = e.length - 1; r >= 0; ) {
    if (a(), r < 0)
      return;
    const s = r, i = e[s], o = i.content, l = t[o];
    gy(i, l.renderInfo);
    const u = l.argumentParser || l.signature;
    if (u == null) {
      r--;
      continue;
    }
    if (i.args != null) {
      r = s - 1;
      continue;
    }
    r++;
    const { args: c } = QG(e, u, r);
    i.args = c, r = s - 1;
  }
}
const bAe = Zl("m")[0], yAe = Zl("o")[0], Hx = {}, vAe = (e, t) => {
  const { argument: r, nodesRemoved: n } = Os(e, yAe, t);
  let a = null, s = 0;
  const i = e[t];
  if (vr.group(i)) {
    const o = Os(e, bAe, t);
    a = o.argument, s = o.nodesRemoved;
  } else if (vr.string(i) && i.content.length === 1) {
    const o = i.content;
    Hx[o] = Hx[o] || Zl(`r${o}${o}`)[0];
    const l = Os(
      e,
      Hx[o],
      t
    );
    a = l.argument, s = l.nodesRemoved;
  }
  return {
    args: [r || Ai(null), a || Ai(null)],
    nodesRemoved: n + s
  };
}, wAe = {
  lstset: { signature: "m" },
  lstinline: { argumentParser: vAe },
  lstinputlisting: { signature: "o m" },
  lstdefinestyle: { signature: "m m" },
  lstnewenvironment: { signature: "m o o m m" },
  lstMakeShortInline: { signature: "o m" },
  lstDeleteShortInline: { signature: "m" },
  lstdefineformat: { signature: "m m" },
  lstdefinelanguage: { signature: "o m o m o" },
  lstalias: { signature: "o m o m" },
  lstloadlanguages: { signature: "m" }
}, xAe = {}, EAe = {
  see: { signature: "m m" },
  seealso: { signature: "m m" },
  seename: { signature: "m" },
  alsoname: { signature: "m" },
  index: { signature: "m" }
}, SAe = {}, _Ae = {
  mathtoolsset: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  mathllap: {
    signature: "o m"
  },
  mathrlap: {
    signature: "o m"
  },
  mathclap: {
    signature: "o m"
  },
  clap: {
    signature: "m"
  },
  mathmbox: {
    signature: "m"
  },
  mathmakebox: {
    signature: "o o m"
  },
  cramped: {
    signature: "o m"
  },
  crampedllap: {
    signature: "o m"
  },
  crampedrlap: {
    signature: "o m"
  },
  crampedclap: {
    signature: "o m"
  },
  crampedsubstack: {
    signature: "o m"
  },
  smashoperator: {
    signature: "o m"
  },
  newtagform: {
    signature: "m o m m"
  },
  renewtagform: {
    signature: "m o m m"
  },
  usetagform: {
    signature: "m"
  },
  xleftrightarrow: { signature: "o m" },
  xLeftarrow: { signature: "o m" },
  xhookleftarrow: { signature: "o m" },
  xmapsto: { signature: "o m" },
  xRightarrow: { signature: "o m" },
  xLeftrightarrow: { signature: "o m" },
  xhookrightarrow: { signature: "o m" },
  underbracket: { signature: "o o m" },
  overbracket: { signature: "o o m" },
  underbrace: { signature: "m" },
  overbrace: { signature: "m" },
  shoveleft: { signature: "o m" },
  shoveright: { signature: "o m" },
  ArrowBetweenLines: { signature: "s o" },
  vdotswithin: { signature: "m" },
  shortdotswithin: { signature: "s m" },
  DeclarePairedDelimiter: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  DeclarePairedDelimiterX: {
    signature: "m o m m m",
    renderInfo: { breakAround: !0 }
  },
  DeclarePairedDelimiterXPP: {
    signature: "m o m m m m m",
    renderInfo: { breakAround: !0 }
  },
  prescript: { signature: "m m m" },
  DeclareMathSizes: { signature: "m m m m" },
  newgathered: { signature: "m m m m" },
  renewgathered: { signature: "m m m m" },
  splitfrac: { signature: "m m" },
  splitdfrac: { signature: "m m" },
  xmathstrut: { signature: "o m" },
  // amsthm
  newtheorem: { signature: "s m o m o", renderInfo: { breakAround: !0 } },
  theoremstyle: { signature: "m", renderInfo: { breakAround: !0 } },
  newtheoremstyle: {
    signature: "m m m m m m m m m",
    renderInfo: { breakAround: !0 }
  },
  // amsmath
  text: { signature: "m", renderInfo: { inMathMode: !1 } },
  // amsfonts
  mathbb: { signature: "m" },
  mathscr: { signature: "m" },
  mathfrak: { signature: "m" },
  frak: { signature: "m" },
  Bdd: { signature: "m" },
  bold: { signature: "m" },
  // amsopn
  operatorname: { signature: "s m" },
  DeclareMathOperator: {
    signature: "s m m",
    renderInfo: { breakAround: !0 }
  }
}, kAe = {
  crampedsubarray: {
    signature: "m",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  matrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  bmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  pmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  vmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  Bmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  Vmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  smallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  psmallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  vsmallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  bsmallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  Bsmallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  Vsmallmatrix: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  "matrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "pmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "Bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "Vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "smallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "psmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "Bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  "Vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: !0, inMathMode: !0 }
  },
  multilined: { signature: "o o", renderInfo: { inMathMode: !0 } },
  cases: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  "cases*": { renderInfo: { alignContent: !0, inMathMode: !0 } },
  dcases: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  "dcases*": { renderInfo: { alignContent: !0, inMathMode: !0 } },
  rcases: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  "rcases*": { renderInfo: { alignContent: !0, inMathMode: !0 } },
  drcases: { renderInfo: { alignContent: !0, inMathMode: !0 } },
  "drcases*": { renderInfo: { alignContent: !0, inMathMode: !0 } },
  spreadlines: { signature: "m", renderInfo: { inMathMode: !0 } },
  lgathered: { signature: "o", renderInfo: { inMathMode: !0 } },
  rgathered: { signature: "o", renderInfo: { inMathMode: !0 } },
  // amsmath
  "align*": { renderInfo: { inMathMode: !0, alignContent: !0 } },
  align: { renderInfo: { inMathMode: !0, alignContent: !0 } },
  aligned: { renderInfo: { inMathMode: !0, alignContent: !0 } },
  "alignat*": { renderInfo: { inMathMode: !0, alignContent: !0 } },
  alignat: { renderInfo: { inMathMode: !0, alignContent: !0 } },
  "equation*": { renderInfo: { inMathMode: !0 } },
  equation: { renderInfo: { inMathMode: !0 } },
  "gather*": { renderInfo: { inMathMode: !0 } },
  gather: { renderInfo: { inMathMode: !0 } },
  "multline*": { renderInfo: { inMathMode: !0 } },
  multline: { renderInfo: { inMathMode: !0 } },
  "flalign*": { renderInfo: { inMathMode: !0, alignContent: !0 } },
  flalign: { renderInfo: { inMathMode: !0, alignContent: !0 } },
  split: { renderInfo: { inMathMode: !0 } },
  // Math environments
  displaymath: { renderInfo: { inMathMode: !0 } },
  // Typical amsthm environments
  theorem: { signature: "o" },
  lemma: { signature: "o" },
  definition: { signature: "o" },
  proposition: { signature: "o" },
  corollary: { signature: "o" },
  remark: { signature: "!o" },
  example: { signature: "!o" },
  proof: { signature: "o" }
}, I5 = Zl("m")[0], CAe = Zl("o")[0], Vx = {}, Gx = (e, t) => {
  const { argument: r, nodesRemoved: n } = Os(e, CAe, t), { argument: a, nodesRemoved: s } = Os(e, I5, t);
  let i = null, o = 0;
  const l = e[t];
  if (vr.group(l)) {
    const u = Os(e, I5, t);
    i = u.argument, o = u.nodesRemoved;
  } else if (vr.string(l) && l.content.length === 1) {
    const u = l.content;
    Vx[u] = Vx[u] || Zl(`r${u}${u}`)[0];
    const c = Os(
      e,
      Vx[u],
      t
    );
    i = c.argument, o = c.nodesRemoved;
  }
  return {
    args: [
      r || Ai(null),
      a || Ai(null),
      i || Ai(null)
    ],
    nodesRemoved: n + s + o
  };
}, AAe = {
  mint: { argumentParser: Gx },
  mintinline: { argumentParser: Gx },
  inputminted: { argumentParser: Gx },
  usemintedstyle: { signature: "m" },
  setminted: { signature: "o m" },
  setmintedinline: { signature: "o m" },
  newmint: { signature: "o m m" },
  newminted: { signature: "o m m" },
  newmintinline: { signature: "o m m" },
  newmintedfile: { signature: "o m m" }
}, TAe = {
  minted: { signature: "o m" }
}, RAe = {
  NiceMatrixOptions: {
    signature: "m",
    renderInfo: { pgfkeysArgs: !0, breakAround: !0 }
  }
}, IAe = {
  NiceTabular: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  NiceMatrixBlock: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  NiceArrayWithDelims: {
    signature: "m m o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  NiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  pNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  bNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  BNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  vNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  VNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  NiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  pNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  bNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  BNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  vNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  },
  VNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: !0, alignContent: !0 }
  }
}, NAe = {
  systeme: {
    signature: "s o o m",
    renderInfo: { inMathMode: !0 }
  },
  sysdelim: {
    signature: "m m"
  },
  syseqsep: { signature: "m" },
  sysalign: { signature: "m" },
  syssignspace: { signature: "m" },
  syseqspace: { signature: "m" },
  syslineskipcoeff: { signature: "m" },
  syseqivsign: { signature: "m" },
  sysaddeqsign: { signature: "m" },
  sysremoveeqsign: { signature: "m" },
  sysextracolonsign: { signature: "m" },
  syscodeextracol: { signature: "m" },
  sysautonum: { signature: "m" },
  syssubstitute: { signature: "m" }
}, DAe = {};
(function() {
  typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", {
    get: function() {
      return this;
    },
    configurable: !0
    // This makes it possible to `delete` the getter later.
  }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__);
})();
const OAe = Zl("o")[0];
function $m() {
  return Ai([], { openMark: "", closeMark: "" });
}
const eW = (e, t) => {
  const r = t;
  let n = t, a = 0;
  const s = PAe(e, n);
  let i = $m();
  if (s !== n) {
    const p = e.splice(n, s - n);
    gd(p), i = Ai(p, {
      openMark: " ",
      closeMark: " "
    });
  }
  a += s - n;
  const {
    argument: o,
    nodesRemoved: l
  } = Os(e, OAe, n);
  a += l;
  const u = o || $m();
  for (; vr.whitespace(e[n]); )
    n++;
  const c = e[n];
  if (!c)
    return {
      args: [i, u, $m()],
      nodesRemoved: 0
    };
  if (vr.group(c)) {
    const p = [i, u, Ai(c.content)];
    return e.splice(r, n - r + 1), { args: p, nodesRemoved: n - r + 1 + a };
  }
  const d = Jg(e, ";", { startIndex: n });
  if (d != null) {
    const p = e.splice(
      r,
      d - r + 1
    );
    return gd(p), {
      args: [i, u, Ai(p)],
      nodesRemoved: r - d + 1 + a
    };
  }
  return {
    args: [i, u, $m()],
    nodesRemoved: 0
  };
};
function PAe(e, t) {
  const r = Jg(e, ":", {
    startIndex: t,
    allowSubstringMatches: !0,
    onlySkipWhitespaceAndComments: !0
  });
  if (!r)
    return t;
  let n = t, a = r + 1;
  for (; a < e.length; a++) {
    const s = e[a];
    if (vr.string(s, "["))
      break;
    if (vr.string(s, "=")) {
      for (a++; vr.whitespace(e[a]) || vr.comment(e[a]); )
        a++;
      if (!vr.group(e[a]))
        break;
      n = a + 1;
      const i = Jg(e, ":", {
        startIndex: n,
        allowSubstringMatches: !0,
        onlySkipWhitespaceAndComments: !0
      });
      if (i == null)
        break;
      a = i + 1;
    }
  }
  return n;
}
const LAe = {
  pgfkeys: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  tikzoption: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  tikzstyle: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  usetikzlibrary: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  usepgfmodule: { signature: "m", renderInfo: { pgfkeysArgs: !0 } },
  usepgflibrary: { signature: "m", renderInfo: { pgfkeysArgs: !0 } },
  pgfplotsset: {
    signature: "m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  pgfplotstabletypeset: {
    signature: "o m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  tikz: {
    signature: "o o m",
    argumentParser: eW,
    renderInfo: { namedArguments: ["animation", "options", "command"] }
  }
}, MAe = {
  tikzpicture: {
    signature: "o",
    renderInfo: { pgfkeysArgs: !0, tikzEnvironment: !0 },
    processContent: _o
  },
  axis: {
    signature: "o",
    renderInfo: { pgfkeysArgs: !0, tikzEnvironment: !0 },
    processContent: _o
  },
  scope: {
    signature: "o",
    renderInfo: { pgfkeysArgs: !0, tikzEnvironment: !0 },
    processContent: _o
  },
  pgfonlayer: {
    signature: "m",
    renderInfo: { tikzEnvironment: !0 },
    processContent: _o
  },
  pgflowlevelscope: {
    signature: "m",
    renderInfo: { tikzEnvironment: !0 },
    processContent: _o
  },
  pgfviewboxscope: {
    signature: "m m m m m",
    renderInfo: { tikzEnvironment: !0 },
    processContent: _o
  },
  pgftransparencygroup: {
    signature: "o",
    renderInfo: { pgfkeysArgs: !0, tikzEnvironment: !0 },
    processContent: _o
  },
  behindforegroundpath: {
    signature: "m",
    processContent: _o
  },
  pgfmetadecoration: {
    signature: "m",
    processContent: _o
  },
  colormixin: { signature: "m", renderInfo: { pgfkeysArgs: !0 } }
};
function _o(e) {
  return FR(e, FAe), e;
}
const FAe = {
  pgfextra: { signature: "m" },
  beginpgfgraphicnamed: { signature: "m" },
  pgfrealjobname: { signature: "m" },
  pgfplotstreampoint: { signature: "m" },
  pgfplotstreampointoutlier: { signature: "m" },
  pgfplotstreamspecial: { signature: "m" },
  pgfplotxyfile: { signature: "m" },
  pgfplotxyzfile: { signature: "m" },
  pgfplotfunction: { signature: "mmm" },
  pgfplotgnuplot: { signature: "o m" },
  pgfplothandlerrecord: { signature: "m" },
  pgfdeclareplothandler: { signature: "m m m" },
  pgfdeclarelayer: { signature: "m" },
  pgfsetlayers: { signature: "m", renderInfo: { pgfkeysArgs: !0 } },
  pgfonlayer: { signature: "m" },
  startpgfonlayer: { signature: "m" },
  pgfdeclarehorizontalshading: { signature: "o m m m " },
  pgfdeclareradialshading: { signature: "o m m m" },
  pgfdeclarefunctionalshading: { signature: "o m m m m m" },
  pgfshadecolortorgb: { signature: "m m" },
  pgfshadecolortocmyk: { signature: "m m" },
  pgfshadecolortogray: { signature: "m m" },
  pgfuseshading: { signature: "m" },
  pgfshadepath: { signature: "m m" },
  pgfsetadditionalshadetransform: { signature: "m" },
  pgfsetstrokeopacity: { signature: "m" },
  pgfsetfillopacity: { signature: "m" },
  pgfsetblendmode: { signature: "m" },
  pgfdeclarefading: { signature: "m m" },
  pgfsetfading: { signature: "m m" },
  pgfsetfadingforcurrentpath: { signature: "m m" },
  pgfsetfadingforcurrentpathstroked: { signature: "m m" },
  pgfanimateattribute: { signature: "m m" },
  pgfsnapshot: { signature: "m" },
  pgfqpoint: { signature: "m m" },
  pgfqpointxy: { signature: "m m" },
  pgfqpointxyz: { signature: "m m m" },
  pgfqpointscale: { signature: "m m" },
  pgfpathqmoveto: { signature: "m m" },
  pgfpathqlineto: { signature: "m m" },
  pgfpathqcurveto: { signature: "m m m m m m" },
  pgfpathqcircle: { signature: "m" },
  pgfqbox: { signature: "m" },
  pgfqboxsynced: { signature: "m" },
  pgfaliasimage: { signature: "m m" },
  pgfuseimage: { signature: "m" },
  pgfimage: { signature: "o m", renderInfo: { pgfkeysArgs: !0 } },
  pgfdeclaremask: { signature: "o m m", renderInfo: { pgfkeysArgs: !0 } },
  pgfdeclarepatternformonly: { signature: "o m m m m m" },
  pgfdeclarepatterninherentlycolored: { signature: "o m m m m m" },
  pgfsetfillpattern: { signature: "m m" },
  // Coordinate canvas and nonlinear transformations
  pgftransformshift: { signature: "m" },
  pgftransformxshift: { signature: "m" },
  pgftransformyshift: { signature: "m" },
  pgftransformscale: { signature: "m" },
  pgftransformxscale: { signature: "m" },
  pgftransformyscale: { signature: "m" },
  pgftransformxslant: { signature: "m" },
  pgftransformyslant: { signature: "m" },
  pgftransformrotate: { signature: "m" },
  pgftransformtriangle: { signature: "m m m" },
  pgftransformcm: { signature: "m m m m m" },
  pgftransformarrow: { signature: "m m" },
  pgftransformlineattime: { signature: "m m m" },
  pgftransformcurveattime: { signature: "m m m m m" },
  pgftransformarcaxesattime: { signature: "m m m m m m" },
  pgfgettransform: { signature: "m" },
  pgfsettransform: { signature: "m" },
  pgfgettransformentries: { signature: "m m m m m m" },
  pgfsettransformentries: { signature: "m m m m m m" },
  pgfpointtransformed: { signature: "m" },
  pgflowlevel: { signature: "m" },
  pgflowlevelobj: { signature: "m m" },
  pgflowlevelscope: { signature: "m" },
  startpgflowlevelscope: { signature: "m" },
  pgfviewboxscope: { signature: "m m m m m" },
  startpgfviewboxscope: { signature: "m m m m m" },
  pgftransformnonlinear: { signature: "m" },
  pgfpointtransformednonlinear: { signature: "m" },
  pgfsetcurvilinearbeziercurve: { signature: "m m m m" },
  pgfcurvilineardistancetotime: { signature: "m" },
  pgfpointcurvilinearbezierorthogonal: { signature: "m m" },
  pgfpointcurvilinearbezierpolar: { signature: "m m" },
  // Matrices
  pgfmatrix: { signature: "m m m m m m m" },
  pgfsetmatrixcolumnsep: { signature: "m" },
  pgfmatrixnextcell: { signature: "o" },
  pgfsetmatrixrowsep: { signature: "m" },
  pgfmatrixendrow: { signature: "o" },
  // Nodes and shapes
  pgfnode: { signature: "m m m m m" },
  pgfmultipartnode: { signature: "m m m m" },
  pgfcoordinate: { signature: "m m" },
  pgfnodealias: { signature: "m m" },
  pgfnoderename: { signature: "m m" },
  pgfpositionnodelater: { signature: "m" },
  pgfpositionnodenow: { signature: "m" },
  pgfnodepostsetupcode: { signature: "m m" },
  pgfpointanchor: { signature: "m m" },
  pgfpointshapeborder: { signature: "m m" },
  pgfdeclareshape: { signature: "m m" },
  saveddimen: { signature: "m m" },
  savedmacro: { signature: " m" },
  anchor: { signature: "m m" },
  deferredanchor: { signature: "m m" },
  anchorborder: { signature: "m" },
  backgroundpath: { signature: "m" },
  foregroundpath: { signature: "m" },
  behindbackgroundpath: { signature: "m" },
  beforebackgroundpath: { signature: "m" },
  beforeforegroundpath: { signature: "m" },
  behindforegroundpath: { signature: "m" },
  // Arrows
  pgfdeclarearrow: { signature: "m" },
  pgfarrowssettipend: { signature: "m" },
  pgfarrowssetbackend: { signature: "m" },
  pgfarrowssetlineend: { signature: "m" },
  pgfarrowssetvisualbackend: { signature: "m" },
  pgfarrowssetvisualtipend: { signature: "m" },
  pgfarrowshullpoint: { signature: "m m" },
  pgfarrowsupperhullpoint: { signature: "m m" },
  pgfarrowssave: { signature: "m" },
  pgfarrowssavethe: { signature: "m" },
  pgfarrowsaddtooptions: { signature: "m" },
  pgfarrowsaddtolateoptions: { signature: "m" },
  pgfarrowsaddtolengthscalelist: { signature: "m" },
  pgfarrowsaddtowidthscalelist: { signature: "m" },
  pgfarrowsthreeparameters: { signature: "m" },
  pgfarrowslinewidthdependent: { signature: "m m m" },
  pgfarrowslengthdependent: { signature: "m" },
  // Path
  pgfusepath: { signature: "m" },
  pgfsetlinewidth: { signature: "m" },
  pgfsetmiterlimit: { signature: "m" },
  pgfsetdash: { signature: "m m" },
  pgfsetstrokecolor: { signature: "m" },
  pgfsetcolor: { signature: "m" },
  pgfsetinnerlinewidth: { signature: "m" },
  pgfsetinnerstrokecolor: { signature: "m" },
  pgfsetarrowsstart: { signature: "m" },
  pgfsetarrowsend: { signature: "m" },
  pgfsetarrows: { signature: "m" },
  pgfsetshortenstart: { signature: "m" },
  pgfsetshortenend: { signature: "m" },
  pgfsetfillcolor: { signature: "m" },
  // Decorations
  pgfdeclaredecoration: { signature: "m m m" },
  state: { signature: "m o m" },
  pgfdecoratepath: { signature: "m m" },
  startpgfdecoration: { signature: "m" },
  pgfdecoration: { signature: "m" },
  pgfdecoratecurrentpath: { signature: "m" },
  pgfsetdecorationsegmenttransformation: { signature: "m" },
  pgfdeclaremetadecorate: { signature: "m m m" },
  pgfmetadecoration: { signature: "m" },
  startpgfmetadecoration: { signature: "m" },
  // Constructing paths
  pgfpathmoveto: { signature: "m" },
  pgfpathlineto: { signature: "m" },
  pgfpathcurveto: { signature: "m m m" },
  pgfpathquadraticcurveto: { signature: "m m" },
  pgfpathcurvebetweentime: { signature: "m m m m m m" },
  pgfpathcurvebetweentimecontinue: { signature: "m m m m m m" },
  pgfpatharc: { signature: "m m m" },
  pgfpatharcaxes: { signature: "m m m m" },
  pgfpatharcto: { signature: "m m m m m m" },
  pgfpatharctoprecomputed: { signature: "m m m m m m m m" },
  pgfpathellipse: { signature: "m m m" },
  pgfpathcircle: { signature: "m m" },
  pgfpathrectangle: { signature: "m m" },
  pgfpathrectanglecorners: { signature: "m m" },
  pgfpathgrid: { signature: " o m m" },
  pgfpathparabola: { signature: "m m" },
  pgfpathsine: { signature: "m" },
  pgfpathcosine: { signature: "m" },
  pgfsetcornersarced: { signature: "m" },
  "pgf@protocolsizes": { signature: "m m" },
  // Specifying coordinates
  pgfpoint: { signature: "m m" },
  pgfpointpolar: { signature: "m m m" },
  pgfpointxy: { signature: "m m" },
  pgfsetxvec: { signature: "m" },
  pgfsetyvec: { signature: "m" },
  pgfpointpolarxy: { signature: "m m" },
  pgfpointxyz: { signature: "m m m" },
  pgfsetzvec: { signature: "m" },
  pgfpointcylindrical: { signature: "m m m" },
  pgfpointspherical: { signature: "m m m" },
  pgfpointadd: { signature: "m m" },
  pgfpointscale: { signature: "m m" },
  pgfpointdiff: { signature: "m m" },
  pgfpointnormalised: { signature: "m" },
  pgfpointlineattime: { signature: "m m m" },
  pgfpointlineatdistance: { signature: "m m m" },
  pgfpointarcaxesattime: { signature: "m m m m m m" },
  pgfpointcurveattime: { signature: "m m m m m" },
  pgfpointborderrectangle: { signature: "m m" },
  pgfpointborderellipse: { signature: "m m" },
  pgfpointintersectionoflines: { signature: "m m m m" },
  pgfpointintersectionofcircles: { signature: "m m m m m" },
  pgfintersectionofpaths: { signature: "m m" },
  pgfpointintersectionsolution: { signature: "m" },
  pgfextractx: { signature: "m m" },
  pgfextracty: { signature: "m m" },
  pgfgetlastxy: { signature: "m m" },
  "pgf@process": { signature: "m" },
  // Heirarchical structres ...
  pgfsetbaseline: { signature: "m" },
  pgfsetbaselinepointnow: { signature: "m" },
  pgfsetbaselinepointlater: { signature: "m" },
  pgftext: { signature: "o m", renderInfo: { pgfkeysArgs: !0 } },
  pgfuseid: { signature: "m" },
  pgfusetype: { signature: "m" },
  pgfidrefnextuse: { signature: "m m" },
  pgfidrefprevuse: { signature: "m m" },
  pgfaliasid: { signature: "m m" },
  pgfgaliasid: { signature: "m m" },
  pgfifidreferenced: { signature: "m m m" },
  pgfrdfabout: { signature: "m" },
  pgfrdfcontent: { signature: "m" },
  pgfrdfdatatype: { signature: "m" },
  pgfrdfhref: { signature: "m" },
  pgfrdfprefix: { signature: "m" },
  pgfrdfproperty: { signature: "m" },
  pgfrdfrel: { signature: "m" },
  pgfrdfresource: { signature: "m" },
  pgfrdfrev: { signature: "m" },
  pgfrdfsrc: { signature: "m" },
  pgfrdftypeof: { signature: "m" },
  pgfrdfvocab: { signature: "m" },
  pgferror: { signature: "m" },
  pgfwarning: { signature: "m" },
  path: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  draw: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  fill: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  filldraw: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  pattern: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  shade: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  clip: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  useasboundingbox: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  node: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  coordinate: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  graph: {
    signature: "u;",
    renderInfo: { breakAround: !0, tikzPathCommand: !0 }
  },
  scoped: {
    signature: "o o m",
    argumentParser: eW,
    renderInfo: {
      namedArguments: ["animation", "options", "command"],
      breakAround: !0
    }
  }
};
var Wx = { exports: {} }, Kx, N5;
function tW() {
  return N5 || (N5 = 1, Kx = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Kx;
}
var Yx = { exports: {} }, Xx, D5;
function $Ae() {
  return D5 || (D5 = 1, Xx = function(t) {
    return !t || typeof t == "string" ? !1 : t instanceof Array || Array.isArray(t) || t.length >= 0 && (t.splice instanceof Function || Object.getOwnPropertyDescriptor(t, t.length - 1) && t.constructor.name !== "String");
  }), Xx;
}
var O5;
function BAe() {
  if (O5) return Yx.exports;
  O5 = 1;
  var e = $Ae(), t = Array.prototype.concat, r = Array.prototype.slice, n = Yx.exports = function(s) {
    for (var i = [], o = 0, l = s.length; o < l; o++) {
      var u = s[o];
      e(u) ? i = t.call(i, r.call(u)) : i.push(u);
    }
    return i;
  };
  return n.wrap = function(a) {
    return function() {
      return a(n(arguments));
    };
  }, Yx.exports;
}
var P5;
function UAe() {
  if (P5) return Wx.exports;
  P5 = 1;
  var e = tW(), t = BAe(), r = Object.hasOwnProperty, n = /* @__PURE__ */ Object.create(null);
  for (var a in e)
    r.call(e, a) && (n[e[a]] = a);
  var s = Wx.exports = {
    to: {},
    get: {}
  };
  s.get = function(l) {
    var u = l.substring(0, 3).toLowerCase(), c, d;
    switch (u) {
      case "hsl":
        c = s.get.hsl(l), d = "hsl";
        break;
      case "hwb":
        c = s.get.hwb(l), d = "hwb";
        break;
      default:
        c = s.get.rgb(l), d = "rgb";
        break;
    }
    return c ? { model: d, value: c } : null;
  }, s.get.rgb = function(l) {
    if (!l)
      return null;
    var u = /^#([a-f0-9]{3,4})$/i, c = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i, d = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, p = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, f = /^(\w+)$/, h = [0, 0, 0, 1], m, y, b;
    if (m = l.match(c)) {
      for (b = m[2], m = m[1], y = 0; y < 3; y++) {
        var v = y * 2;
        h[y] = parseInt(m.slice(v, v + 2), 16);
      }
      b && (h[3] = parseInt(b, 16) / 255);
    } else if (m = l.match(u)) {
      for (m = m[1], b = m[3], y = 0; y < 3; y++)
        h[y] = parseInt(m[y] + m[y], 16);
      b && (h[3] = parseInt(b + b, 16) / 255);
    } else if (m = l.match(d)) {
      for (y = 0; y < 3; y++)
        h[y] = parseInt(m[y + 1], 0);
      m[4] && (m[5] ? h[3] = parseFloat(m[4]) * 0.01 : h[3] = parseFloat(m[4]));
    } else if (m = l.match(p)) {
      for (y = 0; y < 3; y++)
        h[y] = Math.round(parseFloat(m[y + 1]) * 2.55);
      m[4] && (m[5] ? h[3] = parseFloat(m[4]) * 0.01 : h[3] = parseFloat(m[4]));
    } else return (m = l.match(f)) ? m[1] === "transparent" ? [0, 0, 0, 0] : r.call(e, m[1]) ? (h = e[m[1]], h[3] = 1, h) : null : null;
    for (y = 0; y < 3; y++)
      h[y] = i(h[y], 0, 255);
    return h[3] = i(h[3], 0, 1), h;
  }, s.get.hsl = function(l) {
    if (!l)
      return null;
    var u = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, c = l.match(u);
    if (c) {
      var d = parseFloat(c[4]), p = (parseFloat(c[1]) % 360 + 360) % 360, f = i(parseFloat(c[2]), 0, 100), h = i(parseFloat(c[3]), 0, 100), m = i(isNaN(d) ? 1 : d, 0, 1);
      return [p, f, h, m];
    }
    return null;
  }, s.get.hwb = function(l) {
    if (!l)
      return null;
    var u = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, c = l.match(u);
    if (c) {
      var d = parseFloat(c[4]), p = (parseFloat(c[1]) % 360 + 360) % 360, f = i(parseFloat(c[2]), 0, 100), h = i(parseFloat(c[3]), 0, 100), m = i(isNaN(d) ? 1 : d, 0, 1);
      return [p, f, h, m];
    }
    return null;
  }, s.to.hex = function() {
    var l = t(arguments);
    return "#" + o(l[0]) + o(l[1]) + o(l[2]) + (l[3] < 1 ? o(Math.round(l[3] * 255)) : "");
  }, s.to.rgb = function() {
    var l = t(arguments);
    return l.length < 4 || l[3] === 1 ? "rgb(" + Math.round(l[0]) + ", " + Math.round(l[1]) + ", " + Math.round(l[2]) + ")" : "rgba(" + Math.round(l[0]) + ", " + Math.round(l[1]) + ", " + Math.round(l[2]) + ", " + l[3] + ")";
  }, s.to.rgb.percent = function() {
    var l = t(arguments), u = Math.round(l[0] / 255 * 100), c = Math.round(l[1] / 255 * 100), d = Math.round(l[2] / 255 * 100);
    return l.length < 4 || l[3] === 1 ? "rgb(" + u + "%, " + c + "%, " + d + "%)" : "rgba(" + u + "%, " + c + "%, " + d + "%, " + l[3] + ")";
  }, s.to.hsl = function() {
    var l = t(arguments);
    return l.length < 4 || l[3] === 1 ? "hsl(" + l[0] + ", " + l[1] + "%, " + l[2] + "%)" : "hsla(" + l[0] + ", " + l[1] + "%, " + l[2] + "%, " + l[3] + ")";
  }, s.to.hwb = function() {
    var l = t(arguments), u = "";
    return l.length >= 4 && l[3] !== 1 && (u = ", " + l[3]), "hwb(" + l[0] + ", " + l[1] + "%, " + l[2] + "%" + u + ")";
  }, s.to.keyword = function(l) {
    return n[l.slice(0, 3)];
  };
  function i(l, u, c) {
    return Math.min(Math.max(u, l), c);
  }
  function o(l) {
    var u = Math.round(l).toString(16).toUpperCase();
    return u.length < 2 ? "0" + u : u;
  }
  return Wx.exports;
}
var Zx, L5;
function rW() {
  if (L5) return Zx;
  L5 = 1;
  const e = tW(), t = {};
  for (const a of Object.keys(e))
    t[e[a]] = a;
  const r = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Zx = r;
  for (const a of Object.keys(r)) {
    if (!("channels" in r[a]))
      throw new Error("missing channels property: " + a);
    if (!("labels" in r[a]))
      throw new Error("missing channel labels property: " + a);
    if (r[a].labels.length !== r[a].channels)
      throw new Error("channel and label counts mismatch: " + a);
    const { channels: s, labels: i } = r[a];
    delete r[a].channels, delete r[a].labels, Object.defineProperty(r[a], "channels", { value: s }), Object.defineProperty(r[a], "labels", { value: i });
  }
  r.rgb.hsl = function(a) {
    const s = a[0] / 255, i = a[1] / 255, o = a[2] / 255, l = Math.min(s, i, o), u = Math.max(s, i, o), c = u - l;
    let d, p;
    u === l ? d = 0 : s === u ? d = (i - o) / c : i === u ? d = 2 + (o - s) / c : o === u && (d = 4 + (s - i) / c), d = Math.min(d * 60, 360), d < 0 && (d += 360);
    const f = (l + u) / 2;
    return u === l ? p = 0 : f <= 0.5 ? p = c / (u + l) : p = c / (2 - u - l), [d, p * 100, f * 100];
  }, r.rgb.hsv = function(a) {
    let s, i, o, l, u;
    const c = a[0] / 255, d = a[1] / 255, p = a[2] / 255, f = Math.max(c, d, p), h = f - Math.min(c, d, p), m = function(y) {
      return (f - y) / 6 / h + 1 / 2;
    };
    return h === 0 ? (l = 0, u = 0) : (u = h / f, s = m(c), i = m(d), o = m(p), c === f ? l = o - i : d === f ? l = 1 / 3 + s - o : p === f && (l = 2 / 3 + i - s), l < 0 ? l += 1 : l > 1 && (l -= 1)), [
      l * 360,
      u * 100,
      f * 100
    ];
  }, r.rgb.hwb = function(a) {
    const s = a[0], i = a[1];
    let o = a[2];
    const l = r.rgb.hsl(a)[0], u = 1 / 255 * Math.min(s, Math.min(i, o));
    return o = 1 - 1 / 255 * Math.max(s, Math.max(i, o)), [l, u * 100, o * 100];
  }, r.rgb.cmyk = function(a) {
    const s = a[0] / 255, i = a[1] / 255, o = a[2] / 255, l = Math.min(1 - s, 1 - i, 1 - o), u = (1 - s - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, d = (1 - o - l) / (1 - l) || 0;
    return [u * 100, c * 100, d * 100, l * 100];
  };
  function n(a, s) {
    return (a[0] - s[0]) ** 2 + (a[1] - s[1]) ** 2 + (a[2] - s[2]) ** 2;
  }
  return r.rgb.keyword = function(a) {
    const s = t[a];
    if (s)
      return s;
    let i = 1 / 0, o;
    for (const l of Object.keys(e)) {
      const u = e[l], c = n(a, u);
      c < i && (i = c, o = l);
    }
    return o;
  }, r.keyword.rgb = function(a) {
    return e[a];
  }, r.rgb.xyz = function(a) {
    let s = a[0] / 255, i = a[1] / 255, o = a[2] / 255;
    s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92, o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92;
    const l = s * 0.4124 + i * 0.3576 + o * 0.1805, u = s * 0.2126 + i * 0.7152 + o * 0.0722, c = s * 0.0193 + i * 0.1192 + o * 0.9505;
    return [l * 100, u * 100, c * 100];
  }, r.rgb.lab = function(a) {
    const s = r.rgb.xyz(a);
    let i = s[0], o = s[1], l = s[2];
    i /= 95.047, o /= 100, l /= 108.883, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
    const u = 116 * o - 16, c = 500 * (i - o), d = 200 * (o - l);
    return [u, c, d];
  }, r.hsl.rgb = function(a) {
    const s = a[0] / 360, i = a[1] / 100, o = a[2] / 100;
    let l, u, c;
    if (i === 0)
      return c = o * 255, [c, c, c];
    o < 0.5 ? l = o * (1 + i) : l = o + i - o * i;
    const d = 2 * o - l, p = [0, 0, 0];
    for (let f = 0; f < 3; f++)
      u = s + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = d + (l - d) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = d + (l - d) * (2 / 3 - u) * 6 : c = d, p[f] = c * 255;
    return p;
  }, r.hsl.hsv = function(a) {
    const s = a[0];
    let i = a[1] / 100, o = a[2] / 100, l = i;
    const u = Math.max(o, 0.01);
    o *= 2, i *= o <= 1 ? o : 2 - o, l *= u <= 1 ? u : 2 - u;
    const c = (o + i) / 2, d = o === 0 ? 2 * l / (u + l) : 2 * i / (o + i);
    return [s, d * 100, c * 100];
  }, r.hsv.rgb = function(a) {
    const s = a[0] / 60, i = a[1] / 100;
    let o = a[2] / 100;
    const l = Math.floor(s) % 6, u = s - Math.floor(s), c = 255 * o * (1 - i), d = 255 * o * (1 - i * u), p = 255 * o * (1 - i * (1 - u));
    switch (o *= 255, l) {
      case 0:
        return [o, p, c];
      case 1:
        return [d, o, c];
      case 2:
        return [c, o, p];
      case 3:
        return [c, d, o];
      case 4:
        return [p, c, o];
      case 5:
        return [o, c, d];
    }
  }, r.hsv.hsl = function(a) {
    const s = a[0], i = a[1] / 100, o = a[2] / 100, l = Math.max(o, 0.01);
    let u, c;
    c = (2 - i) * o;
    const d = (2 - i) * l;
    return u = i * l, u /= d <= 1 ? d : 2 - d, u = u || 0, c /= 2, [s, u * 100, c * 100];
  }, r.hwb.rgb = function(a) {
    const s = a[0] / 360;
    let i = a[1] / 100, o = a[2] / 100;
    const l = i + o;
    let u;
    l > 1 && (i /= l, o /= l);
    const c = Math.floor(6 * s), d = 1 - o;
    u = 6 * s - c, c & 1 && (u = 1 - u);
    const p = i + u * (d - i);
    let f, h, m;
    switch (c) {
      default:
      case 6:
      case 0:
        f = d, h = p, m = i;
        break;
      case 1:
        f = p, h = d, m = i;
        break;
      case 2:
        f = i, h = d, m = p;
        break;
      case 3:
        f = i, h = p, m = d;
        break;
      case 4:
        f = p, h = i, m = d;
        break;
      case 5:
        f = d, h = i, m = p;
        break;
    }
    return [f * 255, h * 255, m * 255];
  }, r.cmyk.rgb = function(a) {
    const s = a[0] / 100, i = a[1] / 100, o = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, s * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), d = 1 - Math.min(1, o * (1 - l) + l);
    return [u * 255, c * 255, d * 255];
  }, r.xyz.rgb = function(a) {
    const s = a[0] / 100, i = a[1] / 100, o = a[2] / 100;
    let l, u, c;
    return l = s * 3.2406 + i * -1.5372 + o * -0.4986, u = s * -0.9689 + i * 1.8758 + o * 0.0415, c = s * 0.0557 + i * -0.204 + o * 1.057, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, u = u > 31308e-7 ? 1.055 * u ** (1 / 2.4) - 0.055 : u * 12.92, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [l * 255, u * 255, c * 255];
  }, r.xyz.lab = function(a) {
    let s = a[0], i = a[1], o = a[2];
    s /= 95.047, i /= 100, o /= 108.883, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const l = 116 * i - 16, u = 500 * (s - i), c = 200 * (i - o);
    return [l, u, c];
  }, r.lab.xyz = function(a) {
    const s = a[0], i = a[1], o = a[2];
    let l, u, c;
    u = (s + 16) / 116, l = i / 500 + u, c = u - o / 200;
    const d = u ** 3, p = l ** 3, f = c ** 3;
    return u = d > 8856e-6 ? d : (u - 16 / 116) / 7.787, l = p > 8856e-6 ? p : (l - 16 / 116) / 7.787, c = f > 8856e-6 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [l, u, c];
  }, r.lab.lch = function(a) {
    const s = a[0], i = a[1], o = a[2];
    let l;
    l = Math.atan2(o, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);
    const c = Math.sqrt(i * i + o * o);
    return [s, c, l];
  }, r.lch.lab = function(a) {
    const s = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI, u = i * Math.cos(l), c = i * Math.sin(l);
    return [s, u, c];
  }, r.rgb.ansi16 = function(a, s = null) {
    const [i, o, l] = a;
    let u = s === null ? r.rgb.hsv(a)[2] : s;
    if (u = Math.round(u / 50), u === 0)
      return 30;
    let c = 30 + (Math.round(l / 255) << 2 | Math.round(o / 255) << 1 | Math.round(i / 255));
    return u === 2 && (c += 60), c;
  }, r.hsv.ansi16 = function(a) {
    return r.rgb.ansi16(r.hsv.rgb(a), a[2]);
  }, r.rgb.ansi256 = function(a) {
    const s = a[0], i = a[1], o = a[2];
    return s === i && i === o ? s < 8 ? 16 : s > 248 ? 231 : Math.round((s - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(s / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(o / 255 * 5);
  }, r.ansi16.rgb = function(a) {
    let s = a % 10;
    if (s === 0 || s === 7)
      return a > 50 && (s += 3.5), s = s / 10.5 * 255, [s, s, s];
    const i = (~~(a > 50) + 1) * 0.5, o = (s & 1) * i * 255, l = (s >> 1 & 1) * i * 255, u = (s >> 2 & 1) * i * 255;
    return [o, l, u];
  }, r.ansi256.rgb = function(a) {
    if (a >= 232) {
      const u = (a - 232) * 10 + 8;
      return [u, u, u];
    }
    a -= 16;
    let s;
    const i = Math.floor(a / 36) / 5 * 255, o = Math.floor((s = a % 36) / 6) / 5 * 255, l = s % 6 / 5 * 255;
    return [i, o, l];
  }, r.rgb.hex = function(a) {
    const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  }, r.hex.rgb = function(a) {
    const s = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!s)
      return [0, 0, 0];
    let i = s[0];
    s[0].length === 3 && (i = i.split("").map((d) => d + d).join(""));
    const o = parseInt(i, 16), l = o >> 16 & 255, u = o >> 8 & 255, c = o & 255;
    return [l, u, c];
  }, r.rgb.hcg = function(a) {
    const s = a[0] / 255, i = a[1] / 255, o = a[2] / 255, l = Math.max(Math.max(s, i), o), u = Math.min(Math.min(s, i), o), c = l - u;
    let d, p;
    return c < 1 ? d = u / (1 - c) : d = 0, c <= 0 ? p = 0 : l === s ? p = (i - o) / c % 6 : l === i ? p = 2 + (o - s) / c : p = 4 + (s - i) / c, p /= 6, p %= 1, [p * 360, c * 100, d * 100];
  }, r.hsl.hcg = function(a) {
    const s = a[1] / 100, i = a[2] / 100, o = i < 0.5 ? 2 * s * i : 2 * s * (1 - i);
    let l = 0;
    return o < 1 && (l = (i - 0.5 * o) / (1 - o)), [a[0], o * 100, l * 100];
  }, r.hsv.hcg = function(a) {
    const s = a[1] / 100, i = a[2] / 100, o = s * i;
    let l = 0;
    return o < 1 && (l = (i - o) / (1 - o)), [a[0], o * 100, l * 100];
  }, r.hcg.rgb = function(a) {
    const s = a[0] / 360, i = a[1] / 100, o = a[2] / 100;
    if (i === 0)
      return [o * 255, o * 255, o * 255];
    const l = [0, 0, 0], u = s % 1 * 6, c = u % 1, d = 1 - c;
    let p = 0;
    switch (Math.floor(u)) {
      case 0:
        l[0] = 1, l[1] = c, l[2] = 0;
        break;
      case 1:
        l[0] = d, l[1] = 1, l[2] = 0;
        break;
      case 2:
        l[0] = 0, l[1] = 1, l[2] = c;
        break;
      case 3:
        l[0] = 0, l[1] = d, l[2] = 1;
        break;
      case 4:
        l[0] = c, l[1] = 0, l[2] = 1;
        break;
      default:
        l[0] = 1, l[1] = 0, l[2] = d;
    }
    return p = (1 - i) * o, [
      (i * l[0] + p) * 255,
      (i * l[1] + p) * 255,
      (i * l[2] + p) * 255
    ];
  }, r.hcg.hsv = function(a) {
    const s = a[1] / 100, i = a[2] / 100, o = s + i * (1 - s);
    let l = 0;
    return o > 0 && (l = s / o), [a[0], l * 100, o * 100];
  }, r.hcg.hsl = function(a) {
    const s = a[1] / 100, o = a[2] / 100 * (1 - s) + 0.5 * s;
    let l = 0;
    return o > 0 && o < 0.5 ? l = s / (2 * o) : o >= 0.5 && o < 1 && (l = s / (2 * (1 - o))), [a[0], l * 100, o * 100];
  }, r.hcg.hwb = function(a) {
    const s = a[1] / 100, i = a[2] / 100, o = s + i * (1 - s);
    return [a[0], (o - s) * 100, (1 - o) * 100];
  }, r.hwb.hcg = function(a) {
    const s = a[1] / 100, o = 1 - a[2] / 100, l = o - s;
    let u = 0;
    return l < 1 && (u = (o - l) / (1 - l)), [a[0], l * 100, u * 100];
  }, r.apple.rgb = function(a) {
    return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255];
  }, r.rgb.apple = function(a) {
    return [a[0] / 255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535];
  }, r.gray.rgb = function(a) {
    return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255];
  }, r.gray.hsl = function(a) {
    return [0, 0, a[0]];
  }, r.gray.hsv = r.gray.hsl, r.gray.hwb = function(a) {
    return [0, 100, a[0]];
  }, r.gray.cmyk = function(a) {
    return [0, 0, 0, a[0]];
  }, r.gray.lab = function(a) {
    return [a[0], 0, 0];
  }, r.gray.hex = function(a) {
    const s = Math.round(a[0] / 100 * 255) & 255, o = ((s << 16) + (s << 8) + s).toString(16).toUpperCase();
    return "000000".substring(o.length) + o;
  }, r.rgb.gray = function(a) {
    return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];
  }, Zx;
}
var Jx, M5;
function zAe() {
  if (M5) return Jx;
  M5 = 1;
  const e = rW();
  function t() {
    const s = {}, i = Object.keys(e);
    for (let o = i.length, l = 0; l < o; l++)
      s[i[l]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    const i = t(), o = [s];
    for (i[s].distance = 0; o.length; ) {
      const l = o.pop(), u = Object.keys(e[l]);
      for (let c = u.length, d = 0; d < c; d++) {
        const p = u[d], f = i[p];
        f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, o.unshift(p));
      }
    }
    return i;
  }
  function n(s, i) {
    return function(o) {
      return i(s(o));
    };
  }
  function a(s, i) {
    const o = [i[s].parent, s];
    let l = e[i[s].parent][s], u = i[s].parent;
    for (; i[u].parent; )
      o.unshift(i[u].parent), l = n(e[i[u].parent][u], l), u = i[u].parent;
    return l.conversion = o, l;
  }
  return Jx = function(s) {
    const i = r(s), o = {}, l = Object.keys(i);
    for (let u = l.length, c = 0; c < u; c++) {
      const d = l[c];
      i[d].parent !== null && (o[d] = a(d, i));
    }
    return o;
  }, Jx;
}
var Qx, F5;
function qAe() {
  if (F5) return Qx;
  F5 = 1;
  const e = rW(), t = zAe(), r = {}, n = Object.keys(e);
  function a(i) {
    const o = function(...l) {
      const u = l[0];
      return u == null ? u : (u.length > 1 && (l = u), i(l));
    };
    return "conversion" in i && (o.conversion = i.conversion), o;
  }
  function s(i) {
    const o = function(...l) {
      const u = l[0];
      if (u == null)
        return u;
      u.length > 1 && (l = u);
      const c = i(l);
      if (typeof c == "object")
        for (let d = c.length, p = 0; p < d; p++)
          c[p] = Math.round(c[p]);
      return c;
    };
    return "conversion" in i && (o.conversion = i.conversion), o;
  }
  return n.forEach((i) => {
    r[i] = {}, Object.defineProperty(r[i], "channels", { value: e[i].channels }), Object.defineProperty(r[i], "labels", { value: e[i].labels });
    const o = t(i);
    Object.keys(o).forEach((u) => {
      const c = o[u];
      r[i][u] = s(c), r[i][u].raw = a(c);
    });
  }), Qx = r, Qx;
}
var eE, $5;
function jAe() {
  if ($5) return eE;
  $5 = 1;
  const e = UAe(), t = qAe(), r = [
    // To be honest, I don't really feel like keyword belongs in color convert, but eh.
    "keyword",
    // Gray conflicts with some method names, and has its own method defined.
    "gray",
    // Shouldn't really be in color-convert either...
    "hex"
  ], n = {};
  for (const p of Object.keys(t))
    n[[...t[p].labels].sort().join("")] = p;
  const a = {};
  function s(p, f) {
    if (!(this instanceof s))
      return new s(p, f);
    if (f && f in r && (f = null), f && !(f in t))
      throw new Error("Unknown model: " + f);
    let h, m;
    if (p == null)
      this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
    else if (p instanceof s)
      this.model = p.model, this.color = [...p.color], this.valpha = p.valpha;
    else if (typeof p == "string") {
      const y = e.get(p);
      if (y === null)
        throw new Error("Unable to parse color from string: " + p);
      this.model = y.model, m = t[this.model].channels, this.color = y.value.slice(0, m), this.valpha = typeof y.value[m] == "number" ? y.value[m] : 1;
    } else if (p.length > 0) {
      this.model = f || "rgb", m = t[this.model].channels;
      const y = Array.prototype.slice.call(p, 0, m);
      this.color = d(y, m), this.valpha = typeof p[m] == "number" ? p[m] : 1;
    } else if (typeof p == "number")
      this.model = "rgb", this.color = [
        p >> 16 & 255,
        p >> 8 & 255,
        p & 255
      ], this.valpha = 1;
    else {
      this.valpha = 1;
      const y = Object.keys(p);
      "alpha" in p && (y.splice(y.indexOf("alpha"), 1), this.valpha = typeof p.alpha == "number" ? p.alpha : 0);
      const b = y.sort().join("");
      if (!(b in n))
        throw new Error("Unable to parse color from object: " + JSON.stringify(p));
      this.model = n[b];
      const { labels: v } = t[this.model], x = [];
      for (h = 0; h < v.length; h++)
        x.push(p[v[h]]);
      this.color = d(x);
    }
    if (a[this.model])
      for (m = t[this.model].channels, h = 0; h < m; h++) {
        const y = a[this.model][h];
        y && (this.color[h] = y(this.color[h]));
      }
    this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
  }
  s.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(p) {
      let f = this.model in e.to ? this : this.rgb();
      f = f.round(typeof p == "number" ? p : 1);
      const h = f.valpha === 1 ? f.color : [...f.color, this.valpha];
      return e.to[f.model](h);
    },
    percentString(p) {
      const f = this.rgb().round(typeof p == "number" ? p : 1), h = f.valpha === 1 ? f.color : [...f.color, this.valpha];
      return e.to.rgb.percent(h);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const p = {}, { channels: f } = t[this.model], { labels: h } = t[this.model];
      for (let m = 0; m < f; m++)
        p[h[m]] = this.color[m];
      return this.valpha !== 1 && (p.alpha = this.valpha), p;
    },
    unitArray() {
      const p = this.rgb().color;
      return p[0] /= 255, p[1] /= 255, p[2] /= 255, this.valpha !== 1 && p.push(this.valpha), p;
    },
    unitObject() {
      const p = this.rgb().object();
      return p.r /= 255, p.g /= 255, p.b /= 255, this.valpha !== 1 && (p.alpha = this.valpha), p;
    },
    round(p) {
      return p = Math.max(p || 0, 0), new s([...this.color.map(o(p)), this.valpha], this.model);
    },
    alpha(p) {
      return p !== void 0 ? new s([...this.color, Math.max(0, Math.min(1, p))], this.model) : this.valpha;
    },
    // Rgb
    red: l("rgb", 0, u(255)),
    green: l("rgb", 1, u(255)),
    blue: l("rgb", 2, u(255)),
    hue: l(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (p) => (p % 360 + 360) % 360),
    saturationl: l("hsl", 1, u(100)),
    lightness: l("hsl", 2, u(100)),
    saturationv: l("hsv", 1, u(100)),
    value: l("hsv", 2, u(100)),
    chroma: l("hcg", 1, u(100)),
    gray: l("hcg", 2, u(100)),
    white: l("hwb", 1, u(100)),
    wblack: l("hwb", 2, u(100)),
    cyan: l("cmyk", 0, u(100)),
    magenta: l("cmyk", 1, u(100)),
    yellow: l("cmyk", 2, u(100)),
    black: l("cmyk", 3, u(100)),
    x: l("xyz", 0, u(95.047)),
    y: l("xyz", 1, u(100)),
    z: l("xyz", 2, u(108.833)),
    l: l("lab", 0, u(100)),
    a: l("lab", 1),
    b: l("lab", 2),
    keyword(p) {
      return p !== void 0 ? new s(p) : t[this.model].keyword(this.color);
    },
    hex(p) {
      return p !== void 0 ? new s(p) : e.to.hex(this.rgb().round().color);
    },
    hexa(p) {
      if (p !== void 0)
        return new s(p);
      const f = this.rgb().round().color;
      let h = Math.round(this.valpha * 255).toString(16).toUpperCase();
      return h.length === 1 && (h = "0" + h), e.to.hex(f) + h;
    },
    rgbNumber() {
      const p = this.rgb().color;
      return (p[0] & 255) << 16 | (p[1] & 255) << 8 | p[2] & 255;
    },
    luminosity() {
      const p = this.rgb().color, f = [];
      for (const [h, m] of p.entries()) {
        const y = m / 255;
        f[h] = y <= 0.04045 ? y / 12.92 : ((y + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * f[0] + 0.7152 * f[1] + 0.0722 * f[2];
    },
    contrast(p) {
      const f = this.luminosity(), h = p.luminosity();
      return f > h ? (f + 0.05) / (h + 0.05) : (h + 0.05) / (f + 0.05);
    },
    level(p) {
      const f = this.contrast(p);
      return f >= 7 ? "AAA" : f >= 4.5 ? "AA" : "";
    },
    isDark() {
      const p = this.rgb().color;
      return (p[0] * 2126 + p[1] * 7152 + p[2] * 722) / 1e4 < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const p = this.rgb();
      for (let f = 0; f < 3; f++)
        p.color[f] = 255 - p.color[f];
      return p;
    },
    lighten(p) {
      const f = this.hsl();
      return f.color[2] += f.color[2] * p, f;
    },
    darken(p) {
      const f = this.hsl();
      return f.color[2] -= f.color[2] * p, f;
    },
    saturate(p) {
      const f = this.hsl();
      return f.color[1] += f.color[1] * p, f;
    },
    desaturate(p) {
      const f = this.hsl();
      return f.color[1] -= f.color[1] * p, f;
    },
    whiten(p) {
      const f = this.hwb();
      return f.color[1] += f.color[1] * p, f;
    },
    blacken(p) {
      const f = this.hwb();
      return f.color[2] += f.color[2] * p, f;
    },
    grayscale() {
      const p = this.rgb().color, f = p[0] * 0.3 + p[1] * 0.59 + p[2] * 0.11;
      return s.rgb(f, f, f);
    },
    fade(p) {
      return this.alpha(this.valpha - this.valpha * p);
    },
    opaquer(p) {
      return this.alpha(this.valpha + this.valpha * p);
    },
    rotate(p) {
      const f = this.hsl();
      let h = f.color[0];
      return h = (h + p) % 360, h = h < 0 ? 360 + h : h, f.color[0] = h, f;
    },
    mix(p, f) {
      if (!p || !p.rgb)
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof p);
      const h = p.rgb(), m = this.rgb(), y = f === void 0 ? 0.5 : f, b = 2 * y - 1, v = h.alpha() - m.alpha(), x = ((b * v === -1 ? b : (b + v) / (1 + b * v)) + 1) / 2, _ = 1 - x;
      return s.rgb(
        x * h.red() + _ * m.red(),
        x * h.green() + _ * m.green(),
        x * h.blue() + _ * m.blue(),
        h.alpha() * y + m.alpha() * (1 - y)
      );
    }
  };
  for (const p of Object.keys(t)) {
    if (r.includes(p))
      continue;
    const { channels: f } = t[p];
    s.prototype[p] = function(...h) {
      return this.model === p ? new s(this) : h.length > 0 ? new s(h, p) : new s([...c(t[this.model][p].raw(this.color)), this.valpha], p);
    }, s[p] = function(...h) {
      let m = h[0];
      return typeof m == "number" && (m = d(h, f)), new s(m, p);
    };
  }
  function i(p, f) {
    return Number(p.toFixed(f));
  }
  function o(p) {
    return function(f) {
      return i(f, p);
    };
  }
  function l(p, f, h) {
    p = Array.isArray(p) ? p : [p];
    for (const m of p)
      (a[m] || (a[m] = []))[f] = h;
    return p = p[0], function(m) {
      let y;
      return m !== void 0 ? (h && (m = h(m)), y = this[p](), y.color[f] = m, y) : (y = this[p]().color[f], h && (y = h(y)), y);
    };
  }
  function u(p) {
    return function(f) {
      return Math.max(0, Math.min(p, f));
    };
  }
  function c(p) {
    return Array.isArray(p) ? p : [p];
  }
  function d(p, f) {
    for (let h = 0; h < f; h++)
      typeof p[h] != "number" && (p[h] = 0);
    return p;
  }
  return eE = s, eE;
}
var HAe = /* @__PURE__ */ jAe();
const cr = /* @__PURE__ */ da(HAe), VAe = {
  substitutecolormodel: {
    signature: "m m",
    renderInfo: { breakAround: !0 }
  },
  selectcolormodel: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  definecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: !0 }
  },
  providecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: !0 }
  },
  colorlet: {
    signature: "o m o m",
    renderInfo: { breakAround: !0 }
  },
  definecolorset: {
    signature: "o m m m",
    renderInfo: { breakAround: !0 }
  },
  providecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: !0 }
  },
  preparecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: !0 }
  },
  preparecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: !0 }
  },
  DefineNamedColor: {
    signature: "m m m m",
    renderInfo: { breakAround: !0 }
  },
  definecolors: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  providecolors: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  color: { signature: "o m", renderInfo: { breakAround: !0 } },
  textcolor: { signature: "o m m", renderInfo: { inParMode: !0 } },
  pagecolor: { signature: "o m" },
  colorbox: { signature: "o m m" },
  fcolorbox: { signature: "o m o m m" },
  boxframe: { signature: "o m" },
  testcolor: { signature: "o m" },
  blendcolors: { signature: "s m" },
  maskcolors: { signature: "o m" },
  definecolorseries: {
    signature: "m m m o m o m",
    renderInfo: { breakAround: !0 }
  },
  resetcolorseries: {
    signature: "o m",
    renderInfo: { breakAround: !0 }
  },
  rowcolors: { signature: "s o m m m" },
  extractcolorspec: { signature: "m m" },
  extractcolorspecs: { signature: "m m m" },
  convertcolorspec: { signature: "m m m m" }
}, GAe = {
  testcolors: { signature: "o", renderInfo: { pgfkeysArgs: !0 } }
}, se = ([e, t, r]) => cr([e * 255, t * 255, r * 255], "rgb"), WAe = {
  Apricot: cr("#FBB982"),
  Aquamarine: cr("#00B5BE"),
  Bittersweet: cr("#C04F17"),
  Black: cr("#221E1F"),
  Blue: cr("#2D2F92"),
  BlueGreen: cr("#00B3B8"),
  BlueViolet: cr("#473992"),
  BrickRed: cr("#B6321C"),
  Brown: cr("#792500"),
  BurntOrange: cr("#F7921D"),
  CadetBlue: cr("#74729A"),
  CarnationPink: cr("#F282B4"),
  Cerulean: cr("#00A2E3"),
  CornflowerBlue: cr("#41B0E4"),
  Cyan: cr("#00AEEF"),
  Dandelion: cr("#FDBC42"),
  DarkOrchid: cr("#A4538A"),
  Emerald: cr("#00A99D"),
  ForestGreen: cr("#009B55"),
  Fuchsia: cr("#8C368C"),
  Goldenrod: cr("#FFDF42"),
  Gray: cr("#949698"),
  Green: cr("#00A64F"),
  GreenYellow: cr("#DFE674"),
  JungleGreen: cr("#00A99A"),
  Lavender: cr("#F49EC4"),
  LimeGreen: cr("#8DC73E"),
  Magenta: cr("#EC008C"),
  Mahogany: cr("#A9341F"),
  Maroon: cr("#AF3235"),
  Melon: cr("#F89E7B"),
  MidnightBlue: cr("#006795"),
  Mulberry: cr("#A93C93"),
  NavyBlue: cr("#006EB8"),
  OliveGreen: cr("#3C8031"),
  Orange: cr("#F58137"),
  OrangeRed: cr("#ED135A"),
  Orchid: cr("#AF72B0"),
  Peach: cr("#F7965A"),
  Periwinkle: cr("#7977B8"),
  PineGreen: cr("#008B72"),
  Plum: cr("#92268F"),
  ProcessBlue: cr("#00B0F0"),
  Purple: cr("#99479B"),
  RawSienna: cr("#974006"),
  Red: cr("#ED1B23"),
  RedOrange: cr("#F26035"),
  RedViolet: cr("#A1246B"),
  Rhodamine: cr("#EF559F"),
  RoyalBlue: cr("#0071BC"),
  RoyalPurple: cr("#613F99"),
  RubineRed: cr("#ED017D"),
  Salmon: cr("#F69289"),
  SeaGreen: cr("#3FBC9D"),
  Sepia: cr("#671800"),
  SkyBlue: cr("#46C5DD"),
  SpringGreen: cr("#C6DC67"),
  Tan: cr("#DA9D76"),
  TealBlue: cr("#00AEB3"),
  Thistle: cr("#D883B7"),
  Turquoise: cr("#00B4CE"),
  Violet: cr("#58429B"),
  VioletRed: cr("#EF58A0"),
  White: cr("#FFFFFF"),
  WildStrawberry: cr("#EE2967"),
  Yellow: cr("#FFF200"),
  YellowGreen: cr("#98CC70"),
  YellowOrange: cr("#FAA21A")
}, KAe = {
  AliceBlue: se([0.94, 0.972, 1]),
  AntiqueWhite: se([0.98, 0.92, 0.844]),
  Aqua: se([0, 1, 1]),
  Aquamarine: se([0.498, 1, 0.83]),
  Azure: se([0.94, 1, 1]),
  Beige: se([0.96, 0.96, 0.864]),
  Bisque: se([1, 0.894, 0.77]),
  Black: se([0, 0, 0]),
  BlanchedAlmond: se([1, 0.92, 0.804]),
  Blue: se([0, 0, 1]),
  BlueViolet: se([0.54, 0.17, 0.888]),
  Brown: se([0.648, 0.165, 0.165]),
  BurlyWood: se([0.87, 0.72, 0.53]),
  CadetBlue: se([0.372, 0.62, 0.628]),
  Chartreuse: se([0.498, 1, 0]),
  Chocolate: se([0.824, 0.41, 0.116]),
  Coral: se([1, 0.498, 0.312]),
  CornflowerBlue: se([0.392, 0.585, 0.93]),
  Cornsilk: se([1, 0.972, 0.864]),
  Crimson: se([0.864, 0.08, 0.235]),
  Cyan: se([0, 1, 1]),
  DarkBlue: se([0, 0, 0.545]),
  DarkCyan: se([0, 0.545, 0.545]),
  DarkGoldenrod: se([0.72, 0.525, 0.044]),
  DarkGray: se([0.664, 0.664, 0.664]),
  DarkGreen: se([0, 0.392, 0]),
  DarkGrey: se([0.664, 0.664, 0.664]),
  DarkKhaki: se([0.74, 0.716, 0.42]),
  DarkMagenta: se([0.545, 0, 0.545]),
  DarkOliveGreen: se([0.332, 0.42, 0.185]),
  DarkOrange: se([1, 0.55, 0]),
  DarkOrchid: se([0.6, 0.196, 0.8]),
  DarkRed: se([0.545, 0, 0]),
  DarkSalmon: se([0.912, 0.59, 0.48]),
  DarkSeaGreen: se([0.56, 0.736, 0.56]),
  DarkSlateBlue: se([0.284, 0.24, 0.545]),
  DarkSlateGray: se([0.185, 0.31, 0.31]),
  DarkSlateGrey: se([0.185, 0.31, 0.31]),
  DarkTurquoise: se([0, 0.808, 0.82]),
  DarkViolet: se([0.58, 0, 0.828]),
  DeepPink: se([1, 0.08, 0.576]),
  DeepSkyBlue: se([0, 0.75, 1]),
  DimGray: se([0.41, 0.41, 0.41]),
  DimGrey: se([0.41, 0.41, 0.41]),
  DodgerBlue: se([0.116, 0.565, 1]),
  FireBrick: se([0.698, 0.132, 0.132]),
  FloralWhite: se([1, 0.98, 0.94]),
  ForestGreen: se([0.132, 0.545, 0.132]),
  Fuchsia: se([1, 0, 1]),
  Gainsboro: se([0.864, 0.864, 0.864]),
  GhostWhite: se([0.972, 0.972, 1]),
  Gold: se([1, 0.844, 0]),
  Goldenrod: se([0.855, 0.648, 0.125]),
  Gray: se([0.5, 0.5, 0.5]),
  Green: se([0, 0.5, 0]),
  GreenYellow: se([0.68, 1, 0.185]),
  Grey: se([0.5, 0.5, 0.5]),
  Honeydew: se([0.94, 1, 0.94]),
  HotPink: se([1, 0.41, 0.705]),
  IndianRed: se([0.804, 0.36, 0.36]),
  Indigo: se([0.294, 0, 0.51]),
  Ivory: se([1, 1, 0.94]),
  Khaki: se([0.94, 0.9, 0.55]),
  Lavender: se([0.9, 0.9, 0.98]),
  LavenderBlush: se([1, 0.94, 0.96]),
  LawnGreen: se([0.488, 0.99, 0]),
  LemonChiffon: se([1, 0.98, 0.804]),
  LightBlue: se([0.68, 0.848, 0.9]),
  LightCoral: se([0.94, 0.5, 0.5]),
  LightCyan: se([0.88, 1, 1]),
  LightGoldenrod: se([0.933, 0.867, 0.51]),
  LightGoldenrodYellow: se([0.98, 0.98, 0.824]),
  LightGray: se([0.828, 0.828, 0.828]),
  LightGreen: se([0.565, 0.932, 0.565]),
  LightGrey: se([0.828, 0.828, 0.828]),
  LightPink: se([1, 0.712, 0.756]),
  LightSalmon: se([1, 0.628, 0.48]),
  LightSeaGreen: se([0.125, 0.698, 0.668]),
  LightSkyBlue: se([0.53, 0.808, 0.98]),
  LightSlateBlue: se([0.518, 0.44, 1]),
  LightSlateGray: se([0.468, 0.532, 0.6]),
  LightSlateGrey: se([0.468, 0.532, 0.6]),
  LightSteelBlue: se([0.69, 0.77, 0.87]),
  LightYellow: se([1, 1, 0.88]),
  Lime: se([0, 1, 0]),
  LimeGreen: se([0.196, 0.804, 0.196]),
  Linen: se([0.98, 0.94, 0.9]),
  Magenta: se([1, 0, 1]),
  Maroon: se([0.5, 0, 0]),
  MediumAquamarine: se([0.4, 0.804, 0.668]),
  MediumBlue: se([0, 0, 0.804]),
  MediumOrchid: se([0.73, 0.332, 0.828]),
  MediumPurple: se([0.576, 0.44, 0.86]),
  MediumSeaGreen: se([0.235, 0.7, 0.444]),
  MediumSlateBlue: se([0.484, 0.408, 0.932]),
  MediumSpringGreen: se([0, 0.98, 0.604]),
  MediumTurquoise: se([0.284, 0.82, 0.8]),
  MediumVioletRed: se([0.78, 0.084, 0.52]),
  MidnightBlue: se([0.098, 0.098, 0.44]),
  MintCream: se([0.96, 1, 0.98]),
  MistyRose: se([1, 0.894, 0.884]),
  Moccasin: se([1, 0.894, 0.71]),
  NavajoWhite: se([1, 0.87, 0.68]),
  Navy: se([0, 0, 0.5]),
  NavyBlue: se([0, 0, 0.5]),
  OldLace: se([0.992, 0.96, 0.9]),
  Olive: se([0.5, 0.5, 0]),
  OliveDrab: se([0.42, 0.556, 0.136]),
  Orange: se([1, 0.648, 0]),
  OrangeRed: se([1, 0.27, 0]),
  Orchid: se([0.855, 0.44, 0.84]),
  PaleGoldenrod: se([0.932, 0.91, 0.668]),
  PaleGreen: se([0.596, 0.985, 0.596]),
  PaleTurquoise: se([0.688, 0.932, 0.932]),
  PaleVioletRed: se([0.86, 0.44, 0.576]),
  PapayaWhip: se([1, 0.936, 0.835]),
  PeachPuff: se([1, 0.855, 0.725]),
  Peru: se([0.804, 0.52, 0.248]),
  Pink: se([1, 0.752, 0.796]),
  Plum: se([0.868, 0.628, 0.868]),
  PowderBlue: se([0.69, 0.88, 0.9]),
  Purple: se([0.5, 0, 0.5]),
  Red: se([1, 0, 0]),
  RosyBrown: se([0.736, 0.56, 0.56]),
  RoyalBlue: se([0.255, 0.41, 0.884]),
  SaddleBrown: se([0.545, 0.27, 0.075]),
  Salmon: se([0.98, 0.5, 0.448]),
  SandyBrown: se([0.956, 0.644, 0.376]),
  SeaGreen: se([0.18, 0.545, 0.34]),
  Seashell: se([1, 0.96, 0.932]),
  Sienna: se([0.628, 0.32, 0.176]),
  Silver: se([0.752, 0.752, 0.752]),
  SkyBlue: se([0.53, 0.808, 0.92]),
  SlateBlue: se([0.415, 0.352, 0.804]),
  SlateGray: se([0.44, 0.5, 0.565]),
  SlateGrey: se([0.44, 0.5, 0.565]),
  Snow: se([1, 0.98, 0.98]),
  SpringGreen: se([0, 1, 0.498]),
  SteelBlue: se([0.275, 0.51, 0.705]),
  Tan: se([0.824, 0.705, 0.55]),
  Teal: se([0, 0.5, 0.5]),
  Thistle: se([0.848, 0.75, 0.848]),
  Tomato: se([1, 0.39, 0.28]),
  Turquoise: se([0.25, 0.88, 0.815]),
  Violet: se([0.932, 0.51, 0.932]),
  VioletRed: se([0.816, 0.125, 0.565]),
  Wheat: se([0.96, 0.87, 0.7]),
  White: se([1, 1, 1]),
  WhiteSmoke: se([0.96, 0.96, 0.96]),
  Yellow: se([1, 1, 0]),
  YellowGreen: se([0.604, 0.804, 0.196])
}, YAe = {
  AntiqueWhite1: se([1, 0.936, 0.86]),
  AntiqueWhite2: se([0.932, 0.875, 0.8]),
  AntiqueWhite3: se([0.804, 0.752, 0.69]),
  AntiqueWhite4: se([0.545, 0.512, 0.47]),
  Aquamarine1: se([0.498, 1, 0.83]),
  Aquamarine2: se([0.464, 0.932, 0.776]),
  Aquamarine3: se([0.4, 0.804, 0.668]),
  Aquamarine4: se([0.27, 0.545, 0.455]),
  Azure1: se([0.94, 1, 1]),
  Azure2: se([0.88, 0.932, 0.932]),
  Azure3: se([0.756, 0.804, 0.804]),
  Azure4: se([0.512, 0.545, 0.545]),
  Bisque1: se([1, 0.894, 0.77]),
  Bisque2: se([0.932, 0.835, 0.716]),
  Bisque3: se([0.804, 0.716, 0.62]),
  Bisque4: se([0.545, 0.49, 0.42]),
  Blue1: se([0, 0, 1]),
  Blue2: se([0, 0, 0.932]),
  Blue3: se([0, 0, 0.804]),
  Blue4: se([0, 0, 0.545]),
  Brown1: se([1, 0.25, 0.25]),
  Brown2: se([0.932, 0.23, 0.23]),
  Brown3: se([0.804, 0.2, 0.2]),
  Brown4: se([0.545, 0.136, 0.136]),
  Burlywood1: se([1, 0.828, 0.608]),
  Burlywood2: se([0.932, 0.772, 0.57]),
  Burlywood3: se([0.804, 0.668, 0.49]),
  Burlywood4: se([0.545, 0.45, 0.332]),
  CadetBlue1: se([0.596, 0.96, 1]),
  CadetBlue2: se([0.556, 0.898, 0.932]),
  CadetBlue3: se([0.48, 0.772, 0.804]),
  CadetBlue4: se([0.325, 0.525, 0.545]),
  Chartreuse1: se([0.498, 1, 0]),
  Chartreuse2: se([0.464, 0.932, 0]),
  Chartreuse3: se([0.4, 0.804, 0]),
  Chartreuse4: se([0.27, 0.545, 0]),
  Chocolate1: se([1, 0.498, 0.14]),
  Chocolate2: se([0.932, 0.464, 0.13]),
  Chocolate3: se([0.804, 0.4, 0.112]),
  Chocolate4: se([0.545, 0.27, 0.075]),
  Coral1: se([1, 0.448, 0.336]),
  Coral2: se([0.932, 0.415, 0.312]),
  Coral3: se([0.804, 0.356, 0.27]),
  Coral4: se([0.545, 0.244, 0.185]),
  Cornsilk1: se([1, 0.972, 0.864]),
  Cornsilk2: se([0.932, 0.91, 0.804]),
  Cornsilk3: se([0.804, 0.785, 0.694]),
  Cornsilk4: se([0.545, 0.532, 0.47]),
  Cyan1: se([0, 1, 1]),
  Cyan2: se([0, 0.932, 0.932]),
  Cyan3: se([0, 0.804, 0.804]),
  Cyan4: se([0, 0.545, 0.545]),
  DarkGoldenrod1: se([1, 0.725, 0.06]),
  DarkGoldenrod2: se([0.932, 0.68, 0.055]),
  DarkGoldenrod3: se([0.804, 0.585, 0.048]),
  DarkGoldenrod4: se([0.545, 0.396, 0.03]),
  DarkOliveGreen1: se([0.792, 1, 0.44]),
  DarkOliveGreen2: se([0.736, 0.932, 0.408]),
  DarkOliveGreen3: se([0.635, 0.804, 0.352]),
  DarkOliveGreen4: se([0.43, 0.545, 0.24]),
  DarkOrange1: se([1, 0.498, 0]),
  DarkOrange2: se([0.932, 0.464, 0]),
  DarkOrange3: se([0.804, 0.4, 0]),
  DarkOrange4: se([0.545, 0.27, 0]),
  DarkOrchid1: se([0.75, 0.244, 1]),
  DarkOrchid2: se([0.698, 0.228, 0.932]),
  DarkOrchid3: se([0.604, 0.196, 0.804]),
  DarkOrchid4: se([0.408, 0.132, 0.545]),
  DarkSeaGreen1: se([0.756, 1, 0.756]),
  DarkSeaGreen2: se([0.705, 0.932, 0.705]),
  DarkSeaGreen3: se([0.608, 0.804, 0.608]),
  DarkSeaGreen4: se([0.41, 0.545, 0.41]),
  DarkSlateGray1: se([0.592, 1, 1]),
  DarkSlateGray2: se([0.552, 0.932, 0.932]),
  DarkSlateGray3: se([0.475, 0.804, 0.804]),
  DarkSlateGray4: se([0.32, 0.545, 0.545]),
  DeepPink1: se([1, 0.08, 0.576]),
  DeepPink2: se([0.932, 0.07, 0.536]),
  DeepPink3: se([0.804, 0.064, 0.464]),
  DeepPink4: se([0.545, 0.04, 0.312]),
  DeepSkyBlue1: se([0, 0.75, 1]),
  DeepSkyBlue2: se([0, 0.698, 0.932]),
  DeepSkyBlue3: se([0, 0.604, 0.804]),
  DeepSkyBlue4: se([0, 0.408, 0.545]),
  DodgerBlue1: se([0.116, 0.565, 1]),
  DodgerBlue2: se([0.11, 0.525, 0.932]),
  DodgerBlue3: se([0.094, 0.455, 0.804]),
  DodgerBlue4: se([0.064, 0.305, 0.545]),
  Firebrick1: se([1, 0.19, 0.19]),
  Firebrick2: se([0.932, 0.172, 0.172]),
  Firebrick3: se([0.804, 0.15, 0.15]),
  Firebrick4: se([0.545, 0.1, 0.1]),
  Gold1: se([1, 0.844, 0]),
  Gold2: se([0.932, 0.79, 0]),
  Gold3: se([0.804, 0.68, 0]),
  Gold4: se([0.545, 0.46, 0]),
  Goldenrod1: se([1, 0.756, 0.145]),
  Goldenrod2: se([0.932, 0.705, 0.132]),
  Goldenrod3: se([0.804, 0.608, 0.112]),
  Goldenrod4: se([0.545, 0.41, 0.08]),
  Green1: se([0, 1, 0]),
  Green2: se([0, 0.932, 0]),
  Green3: se([0, 0.804, 0]),
  Green4: se([0, 0.545, 0]),
  Honeydew1: se([0.94, 1, 0.94]),
  Honeydew2: se([0.88, 0.932, 0.88]),
  Honeydew3: se([0.756, 0.804, 0.756]),
  Honeydew4: se([0.512, 0.545, 0.512]),
  HotPink1: se([1, 0.43, 0.705]),
  HotPink2: se([0.932, 0.415, 0.655]),
  HotPink3: se([0.804, 0.376, 0.565]),
  HotPink4: se([0.545, 0.228, 0.385]),
  IndianRed1: se([1, 0.415, 0.415]),
  IndianRed2: se([0.932, 0.39, 0.39]),
  IndianRed3: se([0.804, 0.332, 0.332]),
  IndianRed4: se([0.545, 0.228, 0.228]),
  Ivory1: se([1, 1, 0.94]),
  Ivory2: se([0.932, 0.932, 0.88]),
  Ivory3: se([0.804, 0.804, 0.756]),
  Ivory4: se([0.545, 0.545, 0.512]),
  Khaki1: se([1, 0.965, 0.56]),
  Khaki2: se([0.932, 0.9, 0.52]),
  Khaki3: se([0.804, 0.776, 0.45]),
  Khaki4: se([0.545, 0.525, 0.305]),
  LavenderBlush1: se([1, 0.94, 0.96]),
  LavenderBlush2: se([0.932, 0.88, 0.898]),
  LavenderBlush3: se([0.804, 0.756, 0.772]),
  LavenderBlush4: se([0.545, 0.512, 0.525]),
  LemonChiffon1: se([1, 0.98, 0.804]),
  LemonChiffon2: se([0.932, 0.912, 0.75]),
  LemonChiffon3: se([0.804, 0.79, 0.648]),
  LemonChiffon4: se([0.545, 0.536, 0.44]),
  LightBlue1: se([0.75, 0.936, 1]),
  LightBlue2: se([0.698, 0.875, 0.932]),
  LightBlue3: se([0.604, 0.752, 0.804]),
  LightBlue4: se([0.408, 0.512, 0.545]),
  LightCyan1: se([0.88, 1, 1]),
  LightCyan2: se([0.82, 0.932, 0.932]),
  LightCyan3: se([0.705, 0.804, 0.804]),
  LightCyan4: se([0.48, 0.545, 0.545]),
  LightGoldenrod1: se([1, 0.925, 0.545]),
  LightGoldenrod2: se([0.932, 0.864, 0.51]),
  LightGoldenrod3: se([0.804, 0.745, 0.44]),
  LightGoldenrod4: se([0.545, 0.505, 0.298]),
  LightPink1: se([1, 0.684, 0.725]),
  LightPink2: se([0.932, 0.635, 0.68]),
  LightPink3: se([0.804, 0.55, 0.585]),
  LightPink4: se([0.545, 0.372, 0.396]),
  LightSalmon1: se([1, 0.628, 0.48]),
  LightSalmon2: se([0.932, 0.585, 0.448]),
  LightSalmon3: se([0.804, 0.505, 0.385]),
  LightSalmon4: se([0.545, 0.34, 0.26]),
  LightSkyBlue1: se([0.69, 0.888, 1]),
  LightSkyBlue2: se([0.644, 0.828, 0.932]),
  LightSkyBlue3: se([0.552, 0.712, 0.804]),
  LightSkyBlue4: se([0.376, 0.484, 0.545]),
  LightSteelBlue1: se([0.792, 0.884, 1]),
  LightSteelBlue2: se([0.736, 0.824, 0.932]),
  LightSteelBlue3: se([0.635, 0.71, 0.804]),
  LightSteelBlue4: se([0.43, 0.484, 0.545]),
  LightYellow1: se([1, 1, 0.88]),
  LightYellow2: se([0.932, 0.932, 0.82]),
  LightYellow3: se([0.804, 0.804, 0.705]),
  LightYellow4: se([0.545, 0.545, 0.48]),
  Magenta1: se([1, 0, 1]),
  Magenta2: se([0.932, 0, 0.932]),
  Magenta3: se([0.804, 0, 0.804]),
  Magenta4: se([0.545, 0, 0.545]),
  Maroon1: se([1, 0.204, 0.7]),
  Maroon2: se([0.932, 0.19, 0.655]),
  Maroon3: se([0.804, 0.16, 0.565]),
  Maroon4: se([0.545, 0.11, 0.385]),
  MediumOrchid1: se([0.88, 0.4, 1]),
  MediumOrchid2: se([0.82, 0.372, 0.932]),
  MediumOrchid3: se([0.705, 0.32, 0.804]),
  MediumOrchid4: se([0.48, 0.215, 0.545]),
  MediumPurple1: se([0.67, 0.51, 1]),
  MediumPurple2: se([0.624, 0.475, 0.932]),
  MediumPurple3: se([0.536, 0.408, 0.804]),
  MediumPurple4: se([0.365, 0.28, 0.545]),
  MistyRose1: se([1, 0.894, 0.884]),
  MistyRose2: se([0.932, 0.835, 0.824]),
  MistyRose3: se([0.804, 0.716, 0.71]),
  MistyRose4: se([0.545, 0.49, 0.484]),
  NavajoWhite1: se([1, 0.87, 0.68]),
  NavajoWhite2: se([0.932, 0.81, 0.63]),
  NavajoWhite3: se([0.804, 0.7, 0.545]),
  NavajoWhite4: se([0.545, 0.475, 0.37]),
  OliveDrab1: se([0.752, 1, 0.244]),
  OliveDrab2: se([0.7, 0.932, 0.228]),
  OliveDrab3: se([0.604, 0.804, 0.196]),
  OliveDrab4: se([0.41, 0.545, 0.132]),
  Orange1: se([1, 0.648, 0]),
  Orange2: se([0.932, 0.604, 0]),
  Orange3: se([0.804, 0.52, 0]),
  Orange4: se([0.545, 0.352, 0]),
  OrangeRed1: se([1, 0.27, 0]),
  OrangeRed2: se([0.932, 0.25, 0]),
  OrangeRed3: se([0.804, 0.215, 0]),
  OrangeRed4: se([0.545, 0.145, 0]),
  Orchid1: se([1, 0.512, 0.98]),
  Orchid2: se([0.932, 0.48, 0.912]),
  Orchid3: se([0.804, 0.41, 0.79]),
  Orchid4: se([0.545, 0.28, 0.536]),
  PaleGreen1: se([0.604, 1, 0.604]),
  PaleGreen2: se([0.565, 0.932, 0.565]),
  PaleGreen3: se([0.488, 0.804, 0.488]),
  PaleGreen4: se([0.33, 0.545, 0.33]),
  PaleTurquoise1: se([0.732, 1, 1]),
  PaleTurquoise2: se([0.684, 0.932, 0.932]),
  PaleTurquoise3: se([0.59, 0.804, 0.804]),
  PaleTurquoise4: se([0.4, 0.545, 0.545]),
  PaleVioletRed1: se([1, 0.51, 0.67]),
  PaleVioletRed2: se([0.932, 0.475, 0.624]),
  PaleVioletRed3: se([0.804, 0.408, 0.536]),
  PaleVioletRed4: se([0.545, 0.28, 0.365]),
  PeachPuff1: se([1, 0.855, 0.725]),
  PeachPuff2: se([0.932, 0.796, 0.68]),
  PeachPuff3: se([0.804, 0.688, 0.585]),
  PeachPuff4: se([0.545, 0.468, 0.396]),
  Pink1: se([1, 0.71, 0.772]),
  Pink2: se([0.932, 0.664, 0.72]),
  Pink3: se([0.804, 0.57, 0.62]),
  Pink4: se([0.545, 0.39, 0.424]),
  Plum1: se([1, 0.732, 1]),
  Plum2: se([0.932, 0.684, 0.932]),
  Plum3: se([0.804, 0.59, 0.804]),
  Plum4: se([0.545, 0.4, 0.545]),
  Purple1: se([0.608, 0.19, 1]),
  Purple2: se([0.57, 0.172, 0.932]),
  Purple3: se([0.49, 0.15, 0.804]),
  Purple4: se([0.332, 0.1, 0.545]),
  Red1: se([1, 0, 0]),
  Red2: se([0.932, 0, 0]),
  Red3: se([0.804, 0, 0]),
  Red4: se([0.545, 0, 0]),
  RosyBrown1: se([1, 0.756, 0.756]),
  RosyBrown2: se([0.932, 0.705, 0.705]),
  RosyBrown3: se([0.804, 0.608, 0.608]),
  RosyBrown4: se([0.545, 0.41, 0.41]),
  RoyalBlue1: se([0.284, 0.464, 1]),
  RoyalBlue2: se([0.264, 0.43, 0.932]),
  RoyalBlue3: se([0.228, 0.372, 0.804]),
  RoyalBlue4: se([0.152, 0.25, 0.545]),
  Salmon1: se([1, 0.55, 0.41]),
  Salmon2: se([0.932, 0.51, 0.385]),
  Salmon3: se([0.804, 0.44, 0.33]),
  Salmon4: se([0.545, 0.298, 0.224]),
  SeaGreen1: se([0.33, 1, 0.624]),
  SeaGreen2: se([0.305, 0.932, 0.58]),
  SeaGreen3: se([0.264, 0.804, 0.5]),
  SeaGreen4: se([0.18, 0.545, 0.34]),
  Seashell1: se([1, 0.96, 0.932]),
  Seashell2: se([0.932, 0.898, 0.87]),
  Seashell3: se([0.804, 0.772, 0.75]),
  Seashell4: se([0.545, 0.525, 0.51]),
  Sienna1: se([1, 0.51, 0.28]),
  Sienna2: se([0.932, 0.475, 0.26]),
  Sienna3: se([0.804, 0.408, 0.224]),
  Sienna4: se([0.545, 0.28, 0.15]),
  SkyBlue1: se([0.53, 0.808, 1]),
  SkyBlue2: se([0.494, 0.752, 0.932]),
  SkyBlue3: se([0.424, 0.65, 0.804]),
  SkyBlue4: se([0.29, 0.44, 0.545]),
  SlateBlue1: se([0.512, 0.435, 1]),
  SlateBlue2: se([0.48, 0.404, 0.932]),
  SlateBlue3: se([0.41, 0.35, 0.804]),
  SlateBlue4: se([0.28, 0.235, 0.545]),
  SlateGray1: se([0.776, 0.888, 1]),
  SlateGray2: se([0.725, 0.828, 0.932]),
  SlateGray3: se([0.624, 0.712, 0.804]),
  SlateGray4: se([0.424, 0.484, 0.545]),
  Snow1: se([1, 0.98, 0.98]),
  Snow2: se([0.932, 0.912, 0.912]),
  Snow3: se([0.804, 0.79, 0.79]),
  Snow4: se([0.545, 0.536, 0.536]),
  SpringGreen1: se([0, 1, 0.498]),
  SpringGreen2: se([0, 0.932, 0.464]),
  SpringGreen3: se([0, 0.804, 0.4]),
  SpringGreen4: se([0, 0.545, 0.27]),
  SteelBlue1: se([0.39, 0.72, 1]),
  SteelBlue2: se([0.36, 0.675, 0.932]),
  SteelBlue3: se([0.31, 0.58, 0.804]),
  SteelBlue4: se([0.21, 0.392, 0.545]),
  Tan1: se([1, 0.648, 0.31]),
  Tan2: se([0.932, 0.604, 0.288]),
  Tan3: se([0.804, 0.52, 0.248]),
  Tan4: se([0.545, 0.352, 0.17]),
  Thistle1: se([1, 0.884, 1]),
  Thistle2: se([0.932, 0.824, 0.932]),
  Thistle3: se([0.804, 0.71, 0.804]),
  Thistle4: se([0.545, 0.484, 0.545]),
  Tomato1: se([1, 0.39, 0.28]),
  Tomato2: se([0.932, 0.36, 0.26]),
  Tomato3: se([0.804, 0.31, 0.224]),
  Tomato4: se([0.545, 0.21, 0.15]),
  Turquoise1: se([0, 0.96, 1]),
  Turquoise2: se([0, 0.898, 0.932]),
  Turquoise3: se([0, 0.772, 0.804]),
  Turquoise4: se([0, 0.525, 0.545]),
  VioletRed1: se([1, 0.244, 0.59]),
  VioletRed2: se([0.932, 0.228, 0.55]),
  VioletRed3: se([0.804, 0.196, 0.47]),
  VioletRed4: se([0.545, 0.132, 0.32]),
  Wheat1: se([1, 0.905, 0.73]),
  Wheat2: se([0.932, 0.848, 0.684]),
  Wheat3: se([0.804, 0.73, 0.59]),
  Wheat4: se([0.545, 0.494, 0.4]),
  Yellow1: se([1, 1, 0]),
  Yellow2: se([0.932, 0.932, 0]),
  Yellow3: se([0.804, 0.804, 0]),
  Yellow4: se([0.545, 0.545, 0]),
  Gray0: se([0.745, 0.745, 0.745]),
  Green0: se([0, 1, 0]),
  Grey0: se([0.745, 0.745, 0.745]),
  Maroon0: se([0.69, 0.19, 0.376]),
  Purple0: se([0.628, 0.125, 0.94])
}, mi = {
  rgb: ([e, t, r]) => cr([e * 255, t * 255, r * 255], "rgb"),
  cmy: ([e, t, r]) => mi.rgb([1 - e, 1 - t, 1 - r]),
  cmyk: ([e, t, r, n]) => cr([e * 255, t * 255, r * 255, n * 100], "cmyk"),
  hsb: ([e, t, r]) => cr([e * 360, t * 100, r * 100], "hsv"),
  gray: ([e]) => cr([e * 255, e * 255, e * 255], "rgb")
};
({
  // Core colors
  red: mi.rgb([1, 0, 0]),
  green: mi.rgb([0, 1, 0]),
  blue: mi.rgb([0, 0, 1]),
  brown: mi.rgb([0.75, 0.5, 0.25]),
  lime: mi.rgb([0.75, 1, 0]),
  orange: mi.rgb([1, 0.5, 0]),
  pink: mi.rgb([1, 0.75, 0.75]),
  purple: mi.rgb([0.75, 0, 0.25]),
  teal: mi.rgb([0, 0.5, 0.5]),
  violet: mi.rgb([0.5, 0, 0.5]),
  cyan: mi.rgb([0, 1, 1]),
  magenta: mi.rgb([1, 0, 1]),
  yellow: mi.rgb([1, 1, 0]),
  olive: mi.rgb([0.5, 0.5, 0]),
  black: mi.rgb([0, 0, 0]),
  darkgray: mi.rgb([0.25, 0.25, 0.25]),
  gray: mi.rgb([0.5, 0.5, 0.5]),
  lightgray: mi.rgb([0.75, 0.75, 0.75]),
  white: mi.rgb([1, 1, 1]),
  ...WAe,
  ...KAe,
  ...YAe
});
const XAe = {
  NewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  RenewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  ProvideDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  DeclareDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  NewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: !0 }
  },
  RenewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: !0 }
  },
  ProvideDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: !0 }
  },
  DeclareDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: !0 }
  },
  NewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  RenewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  ProvideExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  DeclareExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  RequirePackage: {
    signature: "o m",
    renderInfo: { pgfkeysArgs: !0, breakAround: !0 }
  },
  DeclareOption: { signature: "m m", renderInfo: { breakAround: !0 } }
}, ZAe = {}, JAe = {
  mode: { signature: "s d<> d{}", renderInfo: { breakAround: !0 } },
  insertnavigation: { signature: "m", renderInfo: { breakAround: !0 } },
  insertsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  insertsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  insertauthor: { signature: "o", renderInfo: { breakAround: !0 } },
  insertshortauthor: { signature: "o", renderInfo: { breakAround: !0 } },
  insertshortdate: { signature: "o", renderInfo: { breakAround: !0 } },
  insertshortinstitute: { signature: "o", renderInfo: { breakAround: !0 } },
  insertshortpart: { signature: "o", renderInfo: { breakAround: !0 } },
  insertshorttitle: { signature: "o", renderInfo: { breakAround: !0 } },
  insertsubsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  insertsubsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: !0 }
  },
  insertverticalnavigation: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  usebeamercolor: { signature: "s m", renderInfo: { breakAround: !0 } },
  usebeamertemplate: { signature: "s m", renderInfo: { breakAround: !0 } },
  setbeamercolor: {
    signature: "m m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  setbeamersize: {
    signature: "m o o",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  setbeamertemplate: {
    signature: "m o o d{}",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  newcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: !0,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  renewcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: !0,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  newenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: !0 }
  },
  renewenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: !0 }
  },
  resetcounteronoverlays: {
    signature: "m",
    renderInfo: { breakAround: !0 }
  },
  resetcountonoverlays: { signature: "m", renderInfo: { breakAround: !0 } },
  logo: { signature: "m", renderInfo: { breakAround: !0 } },
  frametitle: { signature: "d<> o m", renderInfo: { breakAround: !0 } },
  framesubtitle: { signature: "d<> m", renderInfo: { breakAround: !0 } },
  pause: { signature: "o" },
  onslide: { signature: "t+ t* d<> d{}" },
  only: { signature: "d<> m d<>" },
  uncover: { signature: "d<> m" },
  visible: { signature: "d<> m" },
  invisible: { signature: "d<> m" },
  alt: { signature: "d<> m m d<>" },
  temporal: { signature: "r<> m m m" },
  item: {
    signature: "d<> o d<>",
    renderInfo: {
      hangingIndent: !0,
      namedArguments: [null, "label", null]
    }
  },
  label: { signature: "d<> o m" },
  // cleveref adds an optional argument to label; this gives maximum compatibility.
  action: { signature: "d<> m" },
  beamerdefaultoverlayspecification: { signature: "m" },
  titlegraphic: { signature: "m", renderInfo: { breakAround: !0 } },
  subject: { signature: "m", renderInfo: { breakAround: !0 } },
  keywords: { signature: "m", renderInfo: { breakAround: !0 } },
  lecture: { signature: "o m m", renderInfo: { breakAround: !0 } },
  partpage: { renderInfo: { breakAround: !0 } },
  sectionpage: { renderInfo: { breakAround: !0 } },
  subsectionpage: { renderInfo: { breakAround: !0 } },
  AtBeginLecture: { signature: "m", renderInfo: { breakAround: !0 } },
  AtBeginPart: { signature: "m", renderInfo: { breakAround: !0 } },
  tableofcontents: {
    signature: "o",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  againframe: { signature: "d<> o o m", renderInfo: { breakAround: !0 } },
  framezoom: {
    signature: "r<> r<> o r() r()",
    renderInfo: { breakAround: !0 }
  },
  column: { signature: "d<> o m", renderInfo: { breakAround: !0 } },
  animate: { signature: "r<>", renderInfo: { breakAround: !0 } },
  animatevalue: { signature: "r<> m m m", renderInfo: { breakAround: !0 } },
  sound: {
    signature: "o m m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  hyperlinksound: {
    signature: "o m m",
    renderInfo: { breakAround: !0, pgfkeysArgs: !0 }
  },
  hyperlinkmute: { signature: "m", renderInfo: { breakAround: !0 } },
  // These signatures conflict with the default signatures.
  // Care must be taken when processing an AST.
  section: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  part: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: !0,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  bibitem: {
    signature: "s d<> o m",
    renderInfo: {
      hangingIndent: !0,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  }
}, QAe = {
  frame: {
    signature: "!d<> !o !o !d{} !d{}"
  },
  block: {
    signature: "!d<> !d{} !d<>"
  },
  alertblock: {
    signature: "!d<> !d{} !d<>"
  },
  exampleblock: {
    signature: "!d<> !d{} !d<>"
  },
  onlyenv: {
    signature: "!d<>"
  },
  altenv: {
    signature: "!d<> m m m m !d<>"
  },
  overlayarea: { signature: "m m" },
  overprint: { signature: "o" },
  actionenv: { signature: "!d<>" },
  columns: { signature: "d<> o" },
  column: { signature: "d<> o m" }
}, eTe = {
  columnbreak: { renderInfo: { breakAround: !0 } }
}, tTe = {
  multicols: {
    signature: "m o o"
  },
  "multicols*": {
    signature: "m o o"
  }
}, rTe = {
  amsart: FCe,
  cleveref: BCe,
  exam: eAe,
  geometry: rAe,
  hyperref: iAe,
  latex2e: sAe,
  listings: wAe,
  makeidx: EAe,
  mathtools: _Ae,
  minted: AAe,
  nicematrix: RAe,
  systeme: NAe,
  tikz: LAe,
  xcolor: VAe,
  xparse: XAe,
  beamer: JAe,
  multicol: eTe
}, nTe = {
  amsart: $Ce,
  cleveref: UCe,
  exam: tAe,
  geometry: nAe,
  hyperref: aAe,
  latex2e: oAe,
  listings: xAe,
  makeidx: SAe,
  mathtools: kAe,
  minted: TAe,
  nicematrix: IAe,
  systeme: DAe,
  tikz: MAe,
  xcolor: GAe,
  xparse: ZAe,
  beamer: QAe,
  multicol: tTe
};
function B5(e, t) {
  if (t.signature && e.args == null) {
    const { args: r } = QG(e.content, t.signature);
    e.args = r;
  }
  gy(e, t.renderInfo), typeof t.processContent == "function" && (e.content = t.processContent(e.content));
}
function U5(e, t, r) {
  const n = [];
  let a = { start: void 0, end: e.length };
  for (let s = 0; s < e.length; s++) {
    const i = e[s];
    t(i) && (a.start = s), r(i) && (a.end = s + 1, n.push(a), a = { start: void 0, end: e.length });
  }
  return a.start != null && n.push(a), n;
}
function iTe(e) {
  const t = [...e];
  t.sort((o, l) => o.start - l.start);
  const r = new Set(t.flatMap((o) => [o.start, o.end])), n = Array.from(r);
  n.sort((o, l) => o - l);
  const a = [], s = [];
  let i = 0;
  for (let o = 0; o < n.length - 1; o++) {
    const l = n[o], u = n[o + 1], c = { start: l, end: u }, d = /* @__PURE__ */ new Set();
    let p = !1;
    for (let f = i; f < t.length; f++) {
      const h = t[f];
      if (h.end >= c.start && (p = !0), !p && h.end < c.start) {
        i = f + 1;
        continue;
      }
      if (h.start > u)
        break;
      h.start <= c.start && h.end >= c.end && (p = !0, d.add(h));
    }
    d.size > 0 && (a.push(c), s.push(d));
  }
  return { regions: a, regionsContainedIn: s };
}
function aTe(e, t) {
  const r = [], n = [0, e.length], a = {};
  for (const [s, i] of Object.entries(t))
    n.push(
      ...i.flatMap((o) => (a["" + [o.start, o.end]] = s, [o.start, o.end]))
    );
  n.sort((s, i) => s - i);
  for (let s = 0; s < n.length - 1; s++) {
    const i = n[s], o = n[s + 1];
    if (i === o)
      continue;
    const l = a["" + [i, o]];
    r.push([l || null, e.slice(i, o)]);
  }
  return r;
}
function sTe(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function oTe(e) {
  const t = `^(${["\\p{L}"].concat(Array.from(e).map(sTe)).join("|")})*`;
  return new RegExp(t, "u");
}
function lTe(e, t) {
  for (let r = 0; r < e.length; r++) {
    const n = e[r], a = e[r + 1];
    if (vr.anyMacro(n) && vr.anyString(a) && (t.has(
      n.content.charAt(n.content.length - 1)
    ) || t.has(a.content.charAt(0))))
      return !0;
  }
  return !1;
}
function z5(e, t) {
  typeof t == "string" && (t = new Set(t.split("")));
  const r = t;
  for (const a of r)
    if (a.length > 1)
      throw new Error(
        `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${a}\`.`
      );
  let n = !1;
  return Tu(
    e,
    (a) => {
      if (lTe(a, r))
        return n = !0, pg;
    },
    { includeArrays: !0, test: Array.isArray }
  ), n;
}
function uTe(e, t) {
  var r, n, a;
  const s = oTe(t);
  let i = 0;
  for (; i < e.length; ) {
    const o = e[i], l = e[i + 1];
    if (vr.anyMacro(o) && // The _^ macros in math mode should not be extended no-matter what;
    // So we check to make sure that the macro we're dealing with has the default escape token.
    (o.escapeToken == null || o.escapeToken === "\\") && vr.anyString(l) && // There are two options. Either the macro ends with the special character,
    // e.g. `\@foo` or the special character starts the next string, e.g. `\foo@`.
    (t.has(
      o.content.charAt(o.content.length - 1)
    ) || t.has(l.content.charAt(0)))) {
      const u = l.content.match(s), c = u ? u[0] : "";
      c.length > 0 ? c.length === l.content.length ? (o.content += l.content, e.splice(i + 1, 1), o.position && ((r = l.position) != null && r.end) && (o.position.end = l.position.end)) : (o.content += c, l.content = l.content.slice(c.length), (n = o.position) != null && n.end && (o.position.end.offset += c.length, o.position.end.column += c.length), (a = l.position) != null && a.start && (l.position.start.offset += c.length, l.position.start.column += c.length)) : i++;
    } else
      ++i;
  }
}
function hg(e, t) {
  typeof t == "string" && (t = new Set(t.split("")));
  const r = t;
  for (const n of r)
    if (n.length > 1)
      throw new Error(
        `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${n}\`.`
      );
  Tu(
    e,
    (n) => {
      uTe(n, r);
    },
    { includeArrays: !0, test: Array.isArray }
  );
}
const q5 = {
  start: vr.createMacroMatcher(["ExplSyntaxOn"]),
  end: vr.createMacroMatcher(["ExplSyntaxOff"])
}, j5 = {
  start: vr.createMacroMatcher(["makeatletter"]),
  end: vr.createMacroMatcher(["makeatother"])
};
function cTe(e) {
  const t = U5(e, q5.start, q5.end), r = U5(
    e,
    j5.start,
    j5.end
  ), n = new Map([
    ...t.map((i) => [i, "expl"]),
    ...r.map((i) => [i, "atLetter"])
  ]), a = iTe([...t, ...r]), s = {
    explOnly: [],
    atLetterOnly: [],
    both: []
  };
  for (let i = 0; i < a.regions.length; i++) {
    const o = a.regions[i], l = a.regionsContainedIn[i];
    if (l.size === 2) {
      s.both.push(o);
      continue;
    }
    for (const u of l.values())
      n.get(u) === "expl" && s.explOnly.push(o), n.get(u) === "atLetter" && s.atLetterOnly.push(o);
  }
  return s.explOnly = s.explOnly.filter((i) => i.end - i.start > 1), s.atLetterOnly = s.atLetterOnly.filter((i) => i.end - i.start > 1), s.both = s.both.filter((i) => i.end - i.start > 1), s;
}
const dTe = /* @__PURE__ */ new Set(["@"]), fTe = /* @__PURE__ */ new Set(["_", ":"]), pTe = /* @__PURE__ */ new Set(["_", ":", "@"]);
function hTe(e) {
  Tu(
    e,
    {
      leave: (t) => {
        const r = cTe(t);
        if (r.both.length + r.atLetterOnly.length + r.explOnly.length === 0)
          return;
        const a = aTe(t, r), s = [];
        for (const [i, o] of a)
          switch (i) {
            case null:
              s.push(...o);
              continue;
            case "atLetterOnly":
              hg(o, dTe), s.push(...o);
              continue;
            case "explOnly":
              hg(o, fTe), s.push(...o);
              continue;
            case "both":
              hg(o, pTe), s.push(...o);
              continue;
            default:
              throw new Error(
                `Unexpected case when splitting ${i}`
              );
          }
        return t.length = 0, t.push(...s), WG;
      }
    },
    { includeArrays: !0, test: Array.isArray }
  );
}
var nW = function() {
  Object.assign(this, { Compiler: (t) => t });
};
function mTe(e) {
  return XG.parse(e);
}
function $R(e) {
  return XG.parse(e, { startRule: "math" });
}
var gTe = function(t) {
  Object.assign(this, { Parser: (n) => t?.mode === "math" ? {
    type: "root",
    content: $R(n),
    _renderInfo: { inMathMode: !0 }
  } : mTe(n) });
};
function bTe({
  mathEnvs: e,
  mathMacros: t
}) {
  const r = vr.createEnvironmentMatcher(e), n = vr.createMacroMatcher(t);
  return (a) => {
    Tu(
      a,
      (s) => {
        if (vr.anyMacro(s))
          for (const i of s.args || [])
            i.content.length > 0 && !H5(i.content) && (i.content = $R(
              Ho(i.content)
            ));
        vr.anyEnvironment(s) && (H5(s.content) || (s.content = $R(Ho(s.content))));
      },
      {
        test: (s) => r(s) || n(s)
      }
    );
  };
}
function H5(e) {
  return !e.some(
    (t) => (
      // If there are multi-char strings or ^ and _ have been parsed as strings, we know
      // that we were not parsed in math mode.
      vr.anyString(t) && t.content.length > 1 || vr.string(t, "^") || vr.string(t, "_")
    )
  );
}
var yTe = function(t) {
  const { environments: r = {}, macros: n = {} } = t || {}, a = Object.fromEntries(
    Object.entries(n).filter(
      ([u, c]) => {
        var d;
        return ((d = c.renderInfo) == null ? void 0 : d.inMathMode) === !0;
      }
    )
  ), s = Object.fromEntries(
    Object.entries(r).filter(
      ([u, c]) => {
        var d;
        return ((d = c.renderInfo) == null ? void 0 : d.inMathMode) === !0;
      }
    )
  ), i = bTe({
    mathEnvs: Object.keys(s),
    mathMacros: Object.keys(a)
  }), o = vr.createEnvironmentMatcher(r), l = vr.createEnvironmentMatcher(s);
  return (u) => {
    Tu(
      u,
      {
        enter: (c) => {
          Array.isArray(c) && FR(c, a);
        },
        leave: (c) => {
          if (!l(c))
            return;
          const d = Ho(c.env), p = r[d];
          if (!p)
            throw new Error(
              `Could not find environment info for environment "${d}"`
            );
          B5(c, p);
        }
      },
      { includeArrays: !0 }
    ), i(u), Tu(
      u,
      {
        enter: (c) => {
          Array.isArray(c) && FR(c, n);
        },
        leave: (c) => {
          if (!o(c))
            return;
          const d = Ho(c.env), p = r[d];
          if (!p)
            throw new Error(
              `Could not find environment info for environment "${d}"`
            );
          B5(c, p);
        }
      },
      { includeArrays: !0 }
    );
  };
}, vTe = function(t) {
  let {
    atLetter: r = !1,
    expl3: n = !1,
    autodetectExpl3AndAtLetter: a = !1
  } = t || {};
  return (s) => {
    hTe(s), (r || n) && (a = !1), a && (r = z5(s, "@"), n = z5(s, "_"));
    const i = /* @__PURE__ */ new Set();
    r && i.add("@"), n && (i.add(":"), i.add("_")), i.size > 0 && hg(s, i);
  };
}, iW = function(t) {
  const {
    mode: r = "regular",
    macros: n = {},
    environments: a = {},
    flags: {
      atLetter: s = !1,
      expl3: i = !1,
      autodetectExpl3AndAtLetter: o = !1
    } = {}
  } = t || {}, l = Object.assign(
    {},
    ...Object.values(rTe),
    n
  ), u = Object.assign(
    {},
    ...Object.values(nTe),
    a
  ), c = eD().use(gTe, { mode: r }).use(vTe, {
    atLetter: s,
    expl3: i,
    autodetectExpl3AndAtLetter: o
  }).use(yTe, {
    macros: l,
    environments: u
  }).use(KCe).use(YCe).use(nW);
  Object.assign(this, { Parser: (p) => c.processSync({ value: p }).result });
};
eD().use(iW).freeze();
function wTe(e) {
  return typeof e != "string" && (e = Ho(e)), eD().use(iW, { mode: "math" }).use(nW).processSync({ value: e }).result.content;
}
const aW = (e) => {
  throw new Error("unreachable");
};
function tp(e, t) {
  if (!e)
    throw new Error(t);
}
const xTe = (e) => !!e && e.openMark === "[" && e.closeMark === "]", Bm = (e) => !!e && e.openMark === "{" && e.closeMark === "}", Ot = (e) => new FSe(e), ETe = (e, t) => {
  var r, n, a, s, i, o, l, u;
  switch (e.content) {
    case "#":
      return Ot("#");
    case "$":
      return Ot("$");
    case "%":
      return Ot("%");
    case "&":
      return Ot("&");
    case "textasciitilde":
      return Ot("~");
    case "textasciicircum":
      return Ot("^");
    case "textbackslash":
      return Ot("∖");
    case "{":
      return Ot("{");
    case "}":
      return Ot("}");
    case "textbar":
      return Ot("|");
    case "textless":
      return Ot("<");
    case "textgreater":
      return Ot(">");
    case "neq":
      return Ot("≠");
    case "sim":
      return Ot("∼");
    case "simeq":
      return Ot("≃");
    case "approx":
      return Ot("≈");
    case "fallingdotseq":
      return Ot("≒");
    case "risingdotseq":
      return Ot("≓");
    case "equiv":
      return Ot("≡");
    case "geq":
      return Ot("≥");
    case "geqq":
      return Ot("≧");
    case "leq":
      return Ot("≤");
    case "leqq":
      return Ot("≦");
    case "gg":
      return Ot("≫");
    case "ll":
      return Ot("≪");
    case "times":
      return Ot("×");
    case "div":
      return Ot("÷");
    case "pm":
      return Ot("±");
    case "mp":
      return Ot("∓");
    case "oplus":
      return Ot("⊕");
    case "ominus":
      return Ot("⊖");
    case "otimes":
      return Ot("⊗");
    case "oslash":
      return Ot("⊘");
    case "circ":
      return Ot("∘");
    case "cdot":
      return Ot("⋅");
    case "bullet":
      return Ot("∙");
    case "ltimes":
      return Ot("⋉");
    case "rtimes":
      return Ot("⋊");
    case "in":
      return Ot("∈");
    case "ni":
      return Ot("∋");
    case "notin":
      return Ot("∉");
    case "subset":
      return Ot("⊂");
    case "supset":
      return Ot("⊃");
    case "subseteq":
      return Ot("⊆");
    case "supseteq":
      return Ot("⊇");
    case "nsubseteq":
      return Ot("⊈");
    case "nsupseteq":
      return Ot("⊉");
    case "subsetneq":
      return Ot("⊊");
    case "supsetneq":
      return Ot("⊋");
    case "cap":
      return Ot("∩");
    case "cup":
      return Ot("∪");
    case "emptyset":
      return Ot("∅");
    case "infty":
      return Ot("∞");
    case "partial":
      return Ot("∂");
    case "aleph":
      return Ot("ℵ");
    case "hbar":
      return Ot("ℏ");
    case "wp":
      return Ot("℘");
    case "Re":
      return Ot("ℜ");
    case "Im":
      return Ot("ℑ");
    case "alpha":
      return Ot("α");
    case "beta":
      return Ot("β");
    case "gamma":
      return Ot("γ");
    case "delta":
      return Ot("δ");
    case "epsilon":
      return Ot("ϵ");
    case "zeta":
      return Ot("ζ");
    case "eta":
      return Ot("η");
    case "theta":
      return Ot("θ");
    case "iota":
      return Ot("ι");
    case "kappa":
      return Ot("κ");
    case "lambda":
      return Ot("λ");
    case "eta":
      return Ot("η");
    case "mu":
      return Ot("μ");
    case "nu":
      return Ot("ν");
    case "xi":
      return Ot("ξ");
    case "pi":
      return Ot("π");
    case "rho":
      return Ot("ρ");
    case "sigma":
      return Ot("σ");
    case "tau":
      return Ot("τ");
    case "upsilon":
      return Ot("υ");
    case "phi":
      return Ot("ϕ");
    case "chi":
      return Ot("χ");
    case "psi":
      return Ot("ψ");
    case "omega":
      return Ot("ω");
    case "varepsilon":
      return Ot("ε");
    case "vartheta":
      return Ot("ϑ");
    case "varrho":
      return Ot("ϱ");
    case "varsigma":
      return Ot("ς");
    case "varphi":
      return Ot("φ");
    case "Gamma":
      return Ot("Γ");
    case "Delta":
      return Ot("Δ");
    case "Theta":
      return Ot("Θ");
    case "Lambda":
      return Ot("Λ");
    case "Xi":
      return Ot("Ξ");
    case "Pi":
      return Ot("Π");
    case "Sigma":
      return Ot("Σ");
    case "Upsilon":
      return Ot("Υ");
    case "Phi":
      return Ot("Φ");
    case "Psi":
      return Ot("Ψ");
    case "Omega":
      return Ot("Ω");
    case "newline":
    case "\\":
      return !1;
    case "^": {
      const c = t.pop();
      if (!c)
        break;
      return new JSe({
        children: [c],
        superScript: _l((a = (n = (r = e.args) === null || r === void 0 ? void 0 : r[0]) === null || n === void 0 ? void 0 : n.content) !== null && a !== void 0 ? a : [])
      });
    }
    case "_": {
      const c = t.pop();
      if (!c)
        break;
      return new e_e({
        children: [c],
        subScript: _l((o = (i = (s = e.args) === null || s === void 0 ? void 0 : s[0]) === null || i === void 0 ? void 0 : i.content) !== null && o !== void 0 ? o : [])
      });
    }
    case "hat":
      break;
    case "widehat":
      break;
    case "sum":
      return new XSe({
        children: []
      });
    case "int":
      return Ot("∫");
    case "frac":
    case "tfrac":
    case "dfrac": {
      const c = (l = e.args) !== null && l !== void 0 ? l : [];
      if (c.length === 2 && Bm(c[0]) && Bm(c[1]))
        return new USe({
          numerator: _l(c[0].content),
          denominator: _l(c[1].content)
        });
      break;
    }
    case "sqrt": {
      const c = (u = e.args) !== null && u !== void 0 ? u : [];
      if (c.length === 1 && Bm(c[0]))
        return new e5({
          children: _l(c[0].content)
        });
      if (c.length === 2 && xTe(c[0]) && Bm(c[1]))
        return new e5({
          children: _l(c[1].content),
          degree: _l(c[0].content)
        });
      break;
    }
  }
  return Ot(e.content);
}, _l = (e) => {
  const t = [];
  for (const r of e)
    t.push(...sW(r, t) || []);
  return t;
}, sW = (e, t) => {
  switch (e.type) {
    case "root":
      break;
    case "string":
      return [Ot(e.content)];
    case "whitespace":
      break;
    case "parbreak":
      break;
    case "comment":
      break;
    case "macro":
      const r = ETe(e, t);
      return r ? [r] : !1;
    case "environment":
    case "mathenv":
      break;
    case "verbatim":
      break;
    case "inlinemath":
      break;
    case "displaymath":
      break;
    case "group":
      return _l(e.content);
    case "verb":
      break;
    default:
      aW();
  }
  return [];
}, oW = (e) => {
  const t = wTe(e), r = [[]];
  let n = r[0];
  for (const a of t) {
    const s = sW(a, n);
    s ? n.push(...s) : r.push(n = []);
  }
  return r;
}, lW = "ordered", Rc = 0.5, STe = [
  {
    level: 0,
    format: na.DECIMAL,
    text: "%1.",
    alignment: bi.START
  },
  {
    level: 1,
    format: na.DECIMAL,
    text: "%2.",
    alignment: bi.START,
    style: {
      paragraph: {
        indent: { start: Pi(Rc * 1) }
      }
    }
  },
  {
    level: 2,
    format: na.DECIMAL,
    text: "%3.",
    alignment: bi.START,
    style: {
      paragraph: {
        indent: { start: Pi(Rc * 2) }
      }
    }
  },
  {
    level: 3,
    format: na.DECIMAL,
    text: "%4.",
    alignment: bi.START,
    style: {
      paragraph: {
        indent: { start: Pi(Rc * 3) }
      }
    }
  },
  {
    level: 4,
    format: na.DECIMAL,
    text: "%5.",
    alignment: bi.START,
    style: {
      paragraph: {
        indent: { start: Pi(Rc * 4) }
      }
    }
  },
  {
    level: 5,
    format: na.DECIMAL,
    text: "%6.",
    alignment: bi.START,
    style: {
      paragraph: {
        indent: { start: Pi(Rc * 5) }
      }
    }
  }
], _Te = async (e, { output: t = "buffer", title: r, subject: n, creator: a, keywords: s, description: i, lastModifiedBy: o, revision: l, styles: u, background: c }, d) => {
  const { nodes: p, footnotes: f } = bo(e.children, {
    deco: {},
    images: d,
    indent: 0
  }), h = new Hke({
    title: r,
    subject: n,
    creator: a,
    keywords: s,
    description: i,
    lastModifiedBy: o,
    revision: l,
    styles: u,
    background: c,
    footnotes: f,
    sections: [{ children: p }],
    numbering: {
      config: [
        {
          reference: lW,
          levels: STe
        }
      ]
    }
  });
  switch (t) {
    case "buffer":
      const m = await OR.toBuffer(h);
      return typeof Buffer == "function" ? Buffer.from(m) : m;
    case "blob":
      return OR.toBlob(h);
  }
}, bo = (e, t) => {
  const r = [];
  let n = {};
  for (const a of e)
    switch (a.type) {
      case "paragraph":
        r.push(kTe(a, t));
        break;
      case "heading":
        r.push(CTe(a, t));
        break;
      case "thematicBreak":
        r.push(ATe());
        break;
      case "blockquote":
        r.push(...TTe(a, t));
        break;
      case "list":
        r.push(...RTe(a, t));
        break;
      case "listItem":
        tp(!1, "unreachable");
      case "table":
        r.push(NTe(a, t));
        break;
      case "tableRow":
        tp(!1, "unreachable");
      case "tableCell":
        tp(!1, "unreachable");
      case "html":
        r.push(PTe(a));
        break;
      case "code":
        r.push(LTe(a));
        break;
      case "yaml":
        break;
      case "toml":
        break;
      case "definition":
        break;
      case "footnoteDefinition":
        n[a.identifier] = qTe(a, t);
        break;
      case "text":
        r.push(Qg(a.value, t.deco));
        break;
      case "emphasis":
      case "strong":
      case "delete": {
        const { type: s, children: i } = a, { nodes: o } = bo(i, {
          ...t,
          deco: { ...t.deco, [s]: !0 }
        });
        r.push(...o);
        break;
      }
      case "inlineCode":
        r.push(Qg(a.value, t.deco));
        break;
      case "break":
        r.push($Te());
        break;
      case "link":
        r.push(BTe(a, t));
        break;
      case "image":
        r.push(UTe(a, t.images));
        break;
      case "linkReference":
        break;
      case "imageReference":
        break;
      case "footnote":
        r.push(zTe(a, t));
        break;
      case "footnoteReference":
        r.push(jTe(a));
        break;
      case "math":
        r.push(...MTe(a));
        break;
      case "inlineMath":
        r.push(FTe(a));
        break;
      default:
        aW();
        break;
    }
  return {
    nodes: r,
    footnotes: n
  };
}, kTe = ({ children: e }, t) => {
  const r = t.list, { nodes: n } = bo(e, t);
  return r && r.checked != null && n.unshift(new Zke({
    checked: r.checked,
    checkedState: { value: "2611" },
    uncheckedState: { value: "2610" }
  })), new Ha({
    children: n,
    indent: t.indent > 0 ? {
      start: Pi(Rc * t.indent)
    } : void 0,
    ...r && (r.ordered ? {
      numbering: {
        reference: lW,
        level: r.level
      }
    } : {
      bullet: {
        level: r.level
      }
    })
  });
}, CTe = ({ children: e, depth: t }, r) => {
  let n;
  switch (t) {
    case 1:
      n = pc.TITLE;
      break;
    case 2:
      n = pc.HEADING_1;
      break;
    case 3:
      n = pc.HEADING_2;
      break;
    case 4:
      n = pc.HEADING_3;
      break;
    case 5:
      n = pc.HEADING_4;
      break;
    case 6:
      n = pc.HEADING_5;
      break;
  }
  const { nodes: a } = bo(e, r);
  return new Ha({
    heading: n,
    children: a
  });
}, ATe = (e) => new Ha({
  thematicBreak: !0
}), TTe = ({ children: e }, t) => {
  const { nodes: r } = bo(e, { ...t, indent: t.indent + 1 });
  return r;
}, RTe = ({ children: e, ordered: t, start: r, spread: n }, a) => {
  const s = {
    level: a.list ? a.list.level + 1 : 0,
    ordered: !!t
  };
  return e.flatMap((i) => ITe(i, {
    ...a,
    list: s
  }));
}, ITe = ({ children: e, checked: t, spread: r }, n) => {
  const { nodes: a } = bo(e, {
    ...n,
    ...n.list && { list: { ...n.list, checked: t ?? void 0 } }
  });
  return a;
}, NTe = ({ children: e, align: t }, r) => {
  const n = t?.map((a) => {
    switch (a) {
      case "left":
        return bi.LEFT;
      case "right":
        return bi.RIGHT;
      case "center":
        return bi.CENTER;
      default:
        return bi.LEFT;
    }
  });
  return new y_e({
    rows: e.map((a) => DTe(a, r, n))
  });
}, DTe = ({ children: e }, t, r) => new E_e({
  children: e.map((n, a) => OTe(n, t, r?.[a]))
}), OTe = ({ children: e }, t, r) => {
  const { nodes: n } = bo(e, t);
  return new JN({
    children: [
      new Ha({
        alignment: r,
        children: n
      })
    ]
  });
}, PTe = ({ value: e }) => new Ha({
  children: [Qg(e, {})]
}), LTe = ({ value: e, lang: t, meta: r }) => new Ha({
  children: [Qg(e, {})]
}), MTe = ({ value: e }) => oW(e).map((t) => new Ha({
  children: [
    new DG({
      children: t
    })
  ]
})), FTe = ({ value: e }) => new DG({
  children: oW(e).flatMap((t) => t)
}), Qg = (e, t) => new Kg({
  text: e,
  bold: t.strong,
  italics: t.emphasis,
  strike: t.delete
}), $Te = (e) => new Kg({ text: "", break: 1 }), BTe = ({ children: e, url: t, title: r }, n) => {
  const { nodes: a } = bo(e, n);
  return new TG({
    link: t,
    children: a
  });
}, UTe = ({ url: e, title: t, alt: r }, n) => {
  const a = n[e];
  tp(a, `Fetch image was failed: ${e}`);
  const { image: s, width: i, height: o } = a;
  return new jEe({
    data: s,
    transformation: {
      width: i,
      height: o
    }
  });
}, zTe = ({ children: e }, t) => {
  const { nodes: r } = bo(e, t);
  return new Ha({
    children: r
  });
}, qTe = ({ children: e }, t) => ({
  children: e.map((r) => {
    const { nodes: n } = bo([r], t);
    return n[0];
  })
}), jTe = ({ identifier: e }) => new Yke(parseInt(e)), HTe = function(e = {}) {
  let t = {};
  return this.Compiler = (r) => _Te(r, e, t), async (r) => {
    const n = [];
    if (zwe(r, "image", (i) => {
      n.push(i);
    }), n.length === 0)
      return r;
    const a = e.imageResolver;
    tp(a, "options.imageResolver is not defined.");
    const s = await Promise.all(n.map(({ url: i }) => a(i)));
    return t = n.reduce((i, o, l) => (i[o.url] = s[l], i), {}), r;
  };
};
function VTe(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function GTe(e, t) {
  const r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function WTe(e, t) {
  const r = t.value ? t.value + `
` : "", n = {};
  t.lang && (n.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: n,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function KTe(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function YTe(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function XTe(e, t) {
  const r = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = String(t.identifier).toUpperCase(), a = Rd(n.toLowerCase()), s = e.footnoteOrder.indexOf(n);
  let i, o = e.footnoteCounts.get(n);
  o === void 0 ? (o = 0, e.footnoteOrder.push(n), i = e.footnoteOrder.length) : i = s + 1, o += 1, e.footnoteCounts.set(n, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + r + "fn-" + a,
      id: r + "fnref-" + a + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, l);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function ZTe(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function JTe(e, t) {
  if (e.options.allowDangerousHtml) {
    const r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
}
function uW(e, t) {
  const r = t.referenceType;
  let n = "]";
  if (r === "collapsed" ? n += "[]" : r === "full" && (n += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + n }];
  const a = e.all(t), s = a[0];
  s && s.type === "text" ? s.value = "[" + s.value : a.unshift({ type: "text", value: "[" });
  const i = a[a.length - 1];
  return i && i.type === "text" ? i.value += n : a.push({ type: "text", value: n }), a;
}
function QTe(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return uW(e, t);
  const a = { src: Rd(n.url || ""), alt: t.alt };
  n.title !== null && n.title !== void 0 && (a.title = n.title);
  const s = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function eRe(e, t) {
  const r = { src: Rd(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, n), e.applyData(t, n);
}
function tRe(e, t) {
  const r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  const n = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, n), e.applyData(t, n);
}
function rRe(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return uW(e, t);
  const a = { href: Rd(n.url || "") };
  n.title !== null && n.title !== void 0 && (a.title = n.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function nRe(e, t) {
  const r = { href: Rd(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function iRe(e, t, r) {
  const n = e.all(t), a = r ? aRe(r) : cW(t), s = {}, i = [];
  if (typeof t.checked == "boolean") {
    const c = n[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, n.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < n.length; ) {
    const c = n[o];
    (a || o !== 0 || c.type !== "element" || c.tagName !== "p") && i.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !a ? i.push(...c.children) : i.push(c);
  }
  const l = n[n.length - 1];
  l && (a || l.type !== "element" || l.tagName !== "p") && i.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: s, children: i };
  return e.patch(t, u), e.applyData(t, u);
}
function aRe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const r = e.children;
    let n = -1;
    for (; !t && ++n < r.length; )
      t = cW(r[n]);
  }
  return t;
}
function cW(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function sRe(e, t) {
  const r = {}, n = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++a < n.length; ) {
    const i = n[a];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(n, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function oRe(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function lRe(e, t) {
  const r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function uRe(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const dW = pW("end"), fW = pW("start");
function pW(e) {
  return t;
  function t(r) {
    const n = r && r.position && r.position[e] || {};
    if (typeof n.line == "number" && n.line > 0 && typeof n.column == "number" && n.column > 0)
      return {
        line: n.line,
        column: n.column,
        offset: typeof n.offset == "number" && n.offset > -1 ? n.offset : void 0
      };
  }
}
function hW(e) {
  const t = fW(e), r = dW(e);
  if (t && r)
    return { start: t, end: r };
}
function cRe(e, t) {
  const r = e.all(t), n = r.shift(), a = [];
  if (n) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([n], !0)
    };
    e.patch(t.children[0], i), a.push(i);
  }
  if (r.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, o = fW(t.children[1]), l = dW(t.children[t.children.length - 1]);
    o && l && (i.position = { start: o, end: l }), a.push(i);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function dRe(e, t, r) {
  const n = r ? r.children : void 0, s = (n ? n.indexOf(t) : 1) === 0 ? "th" : "td", i = r && r.type === "table" ? r.align : void 0, o = i ? i.length : t.children.length;
  let l = -1;
  const u = [];
  for (; ++l < o; ) {
    const d = t.children[l], p = {}, f = i ? i[l] : void 0;
    f && (p.align = f);
    let h = { type: "element", tagName: s, properties: p, children: [] };
    d && (h.children = e.all(d), e.patch(d, h), h = e.applyData(d, h)), u.push(h);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function fRe(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const V5 = 9, G5 = 32;
function pRe(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let n = r.exec(t), a = 0;
  const s = [];
  for (; n; )
    s.push(
      W5(t.slice(a, n.index), a > 0, !0),
      n[0]
    ), a = n.index + n[0].length, n = r.exec(t);
  return s.push(W5(t.slice(a), a > 0, !1)), s.join("");
}
function W5(e, t, r) {
  let n = 0, a = e.length;
  if (t) {
    let s = e.codePointAt(n);
    for (; s === V5 || s === G5; )
      n++, s = e.codePointAt(n);
  }
  if (r) {
    let s = e.codePointAt(a - 1);
    for (; s === V5 || s === G5; )
      a--, s = e.codePointAt(a - 1);
  }
  return a > n ? e.slice(n, a) : "";
}
function hRe(e, t) {
  const r = { type: "text", value: pRe(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function mRe(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
const gRe = {
  blockquote: VTe,
  break: GTe,
  code: WTe,
  delete: KTe,
  emphasis: YTe,
  footnoteReference: XTe,
  heading: ZTe,
  html: JTe,
  imageReference: QTe,
  image: eRe,
  inlineCode: tRe,
  linkReference: rRe,
  link: nRe,
  listItem: iRe,
  list: sRe,
  paragraph: oRe,
  // @ts-expect-error: root is different, but hard to type.
  root: lRe,
  strong: uRe,
  table: cRe,
  tableCell: fRe,
  tableRow: dRe,
  text: hRe,
  thematicBreak: mRe,
  toml: Um,
  yaml: Um,
  definition: Um,
  footnoteDefinition: Um
};
function Um() {
}
const mW = -1, by = 0, eb = 1, tb = 2, rD = 3, nD = 4, iD = 5, aD = 6, gW = 7, bW = 8, K5 = typeof self == "object" ? self : globalThis, bRe = (e, t) => {
  const r = (a, s) => (e.set(s, a), a), n = (a) => {
    if (e.has(a))
      return e.get(a);
    const [s, i] = t[a];
    switch (s) {
      case by:
      case mW:
        return r(i, a);
      case eb: {
        const o = r([], a);
        for (const l of i)
          o.push(n(l));
        return o;
      }
      case tb: {
        const o = r({}, a);
        for (const [l, u] of i)
          o[n(l)] = n(u);
        return o;
      }
      case rD:
        return r(new Date(i), a);
      case nD: {
        const { source: o, flags: l } = i;
        return r(new RegExp(o, l), a);
      }
      case iD: {
        const o = r(/* @__PURE__ */ new Map(), a);
        for (const [l, u] of i)
          o.set(n(l), n(u));
        return o;
      }
      case aD: {
        const o = r(/* @__PURE__ */ new Set(), a);
        for (const l of i)
          o.add(n(l));
        return o;
      }
      case gW: {
        const { name: o, message: l } = i;
        return r(new K5[o](l), a);
      }
      case bW:
        return r(BigInt(i), a);
      case "BigInt":
        return r(Object(BigInt(i)), a);
    }
    return r(new K5[s](i), a);
  };
  return n;
}, Y5 = (e) => bRe(/* @__PURE__ */ new Map(), e)(0), bc = "", { toString: yRe } = {}, { keys: vRe } = Object, xf = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [by, t];
  const r = yRe.call(e).slice(8, -1);
  switch (r) {
    case "Array":
      return [eb, bc];
    case "Object":
      return [tb, bc];
    case "Date":
      return [rD, bc];
    case "RegExp":
      return [nD, bc];
    case "Map":
      return [iD, bc];
    case "Set":
      return [aD, bc];
  }
  return r.includes("Array") ? [eb, r] : r.includes("Error") ? [gW, r] : [tb, r];
}, zm = ([e, t]) => e === by && (t === "function" || t === "symbol"), wRe = (e, t, r, n) => {
  const a = (i, o) => {
    const l = n.push(i) - 1;
    return r.set(o, l), l;
  }, s = (i) => {
    if (r.has(i))
      return r.get(i);
    let [o, l] = xf(i);
    switch (o) {
      case by: {
        let c = i;
        switch (l) {
          case "bigint":
            o = bW, c = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            c = null;
            break;
          case "undefined":
            return a([mW], i);
        }
        return a([o, c], i);
      }
      case eb: {
        if (l)
          return a([l, [...i]], i);
        const c = [], d = a([o, c], i);
        for (const p of i)
          c.push(s(p));
        return d;
      }
      case tb: {
        if (l)
          switch (l) {
            case "BigInt":
              return a([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return a([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return s(i.toJSON());
        const c = [], d = a([o, c], i);
        for (const p of vRe(i))
          (e || !zm(xf(i[p]))) && c.push([s(p), s(i[p])]);
        return d;
      }
      case rD:
        return a([o, i.toISOString()], i);
      case nD: {
        const { source: c, flags: d } = i;
        return a([o, { source: c, flags: d }], i);
      }
      case iD: {
        const c = [], d = a([o, c], i);
        for (const [p, f] of i)
          (e || !(zm(xf(p)) || zm(xf(f)))) && c.push([s(p), s(f)]);
        return d;
      }
      case aD: {
        const c = [], d = a([o, c], i);
        for (const p of i)
          (e || !zm(xf(p))) && c.push(s(p));
        return d;
      }
    }
    const { message: u } = i;
    return a([o, { name: l, message: u }], i);
  };
  return s;
}, X5 = (e, { json: t, lossy: r } = {}) => {
  const n = [];
  return wRe(!(t || r), !!t, /* @__PURE__ */ new Map(), n)(e), n;
}, rb = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Y5(X5(e, t)) : structuredClone(e)
) : (e, t) => Y5(X5(e, t));
function xRe(e, t) {
  const r = [{ type: "text", value: "↩" }];
  return t > 1 && r.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), r;
}
function ERe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function SRe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = e.options.footnoteBackContent || xRe, n = e.options.footnoteBackLabel || ERe, a = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!u)
      continue;
    const c = e.all(u), d = String(u.identifier).toUpperCase(), p = Rd(d.toLowerCase());
    let f = 0;
    const h = [], m = e.footnoteCounts.get(d);
    for (; m !== void 0 && ++f <= m; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let v = typeof r == "string" ? r : r(l, f);
      typeof v == "string" && (v = { type: "text", value: v }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof n == "string" ? n : n(l, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(v) ? v : [v]
      });
    }
    const y = c[c.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const v = y.children[y.children.length - 1];
      v && v.type === "text" ? v.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...h);
    } else
      c.push(...h);
    const b = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(c, !0)
    };
    e.patch(u, b), o.push(b);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...rb(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const BR = {}.hasOwnProperty, _Re = {};
function kRe(e, t) {
  const r = t || _Re, n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = { ...gRe, ...r.handlers }, o = {
    all: u,
    applyData: ARe,
    definitionById: n,
    footnoteById: a,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: i,
    one: l,
    options: r,
    patch: CRe,
    wrap: RRe
  };
  return ay(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? n : a, p = String(c.identifier).toUpperCase();
      d.has(p) || d.set(p, c);
    }
  }), o;
  function l(c, d) {
    const p = c.type, f = o.handlers[p];
    if (BR.call(o.handlers, p) && f)
      return f(o, c, d);
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ("children" in c) {
        const { children: m, ...y } = c, b = rb(y);
        return b.children = o.all(c), b;
      }
      return rb(c);
    }
    return (o.options.unknownHandler || TRe)(o, c, d);
  }
  function u(c) {
    const d = [];
    if ("children" in c) {
      const p = c.children;
      let f = -1;
      for (; ++f < p.length; ) {
        const h = o.one(p[f], c);
        if (h) {
          if (f && p[f - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = Z5(h.value)), !Array.isArray(h) && h.type === "element")) {
            const m = h.children[0];
            m && m.type === "text" && (m.value = Z5(m.value));
          }
          Array.isArray(h) ? d.push(...h) : d.push(h);
        }
      }
    }
    return d;
  }
}
function CRe(e, t) {
  e.position && (t.position = hW(e));
}
function ARe(e, t) {
  let r = t;
  if (e && e.data) {
    const n = e.data.hName, a = e.data.hChildren, s = e.data.hProperties;
    if (typeof n == "string")
      if (r.type === "element")
        r.tagName = n;
      else {
        const i = "children" in r ? r.children : [r];
        r = { type: "element", tagName: n, properties: {}, children: i };
      }
    r.type === "element" && s && Object.assign(r.properties, rb(s)), "children" in r && r.children && a !== null && a !== void 0 && (r.children = a);
  }
  return r;
}
function TRe(e, t) {
  const r = t.data || {}, n = "value" in t && !(BR.call(r, "hProperties") || BR.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function RRe(e, t) {
  const r = [];
  let n = -1;
  for (t && r.push({ type: "text", value: `
` }); ++n < e.length; )
    n && r.push({ type: "text", value: `
` }), r.push(e[n]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
function Z5(e) {
  let t = 0, r = e.charCodeAt(t);
  for (; r === 9 || r === 32; )
    t++, r = e.charCodeAt(t);
  return e.slice(t);
}
function J5(e, t) {
  const r = kRe(e, t), n = r.one(e, void 0), a = SRe(r), s = Array.isArray(n) ? { type: "root", children: n } : n || { type: "root", children: [] };
  return a && s.children.push({ type: "text", value: `
` }, a), s;
}
function yW(e, t) {
  return e && "run" in e ? async function(r, n) {
    const a = (
      /** @type {HastRoot} */
      J5(r, { file: n, ...t })
    );
    await e.run(a, n);
  } : function(r, n) {
    return (
      /** @type {HastRoot} */
      J5(r, { file: n, ...e || t })
    );
  };
}
class Rn extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, r, n) {
    super(), typeof r == "string" && (n = r, r = void 0);
    let a = "", s = {}, i = !1;
    if (r && ("line" in r && "column" in r ? s = { place: r } : "start" in r && "end" in r ? s = { place: r } : "type" in r ? s = {
      ancestors: [r],
      place: r.position
    } : s = { ...r }), typeof t == "string" ? a = t : !s.cause && t && (i = !0, a = t.message, s.cause = t), !s.ruleId && !s.source && typeof n == "string") {
      const l = n.indexOf(":");
      l === -1 ? s.ruleId = n : (s.source = n.slice(0, l), s.ruleId = n.slice(l + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const l = s.ancestors[s.ancestors.length - 1];
      l && (s.place = l.position);
    }
    const o = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = o ? o.line : void 0, this.name = ss(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = i && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Rn.prototype.file = "";
Rn.prototype.name = "";
Rn.prototype.reason = "";
Rn.prototype.message = "";
Rn.prototype.stack = "";
Rn.prototype.column = void 0;
Rn.prototype.line = void 0;
Rn.prototype.ancestors = void 0;
Rn.prototype.cause = void 0;
Rn.prototype.fatal = void 0;
Rn.prototype.place = void 0;
Rn.prototype.ruleId = void 0;
Rn.prototype.source = void 0;
const Zs = { basename: IRe, dirname: NRe, extname: DRe, join: ORe, sep: "/" };
function IRe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Ah(e);
  let r = 0, n = -1, a = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (s) {
          r = a + 1;
          break;
        }
      } else n < 0 && (s = !0, n = a + 1);
    return n < 0 ? "" : e.slice(r, n);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (s) {
        r = a + 1;
        break;
      }
    } else
      i < 0 && (s = !0, i = a + 1), o > -1 && (e.codePointAt(a) === t.codePointAt(o--) ? o < 0 && (n = a) : (o = -1, n = i));
  return r === n ? n = i : n < 0 && (n = e.length), e.slice(r, n);
}
function NRe(e) {
  if (Ah(e), e.length === 0)
    return ".";
  let t = -1, r = e.length, n;
  for (; --r; )
    if (e.codePointAt(r) === 47) {
      if (n) {
        t = r;
        break;
      }
    } else n || (n = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function DRe(e) {
  Ah(e);
  let t = e.length, r = -1, n = 0, a = -1, s = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        n = t + 1;
        break;
      }
      continue;
    }
    r < 0 && (i = !0, r = t + 1), o === 46 ? a < 0 ? a = t : s !== 1 && (s = 1) : a > -1 && (s = -1);
  }
  return a < 0 || r < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && a === r - 1 && a === n + 1 ? "" : e.slice(a, r);
}
function ORe(...e) {
  let t = -1, r;
  for (; ++t < e.length; )
    Ah(e[t]), e[t] && (r = r === void 0 ? e[t] : r + "/" + e[t]);
  return r === void 0 ? "." : PRe(r);
}
function PRe(e) {
  Ah(e);
  const t = e.codePointAt(0) === 47;
  let r = LRe(e, !t);
  return r.length === 0 && !t && (r = "."), r.length > 0 && e.codePointAt(e.length - 1) === 47 && (r += "/"), t ? "/" + r : r;
}
function LRe(e, t) {
  let r = "", n = 0, a = -1, s = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(a === i - 1 || s === 1)) if (a !== i - 1 && s === 2) {
        if (r.length < 2 || n !== 2 || r.codePointAt(r.length - 1) !== 46 || r.codePointAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            if (l = r.lastIndexOf("/"), l !== r.length - 1) {
              l < 0 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), a = i, s = 0;
              continue;
            }
          } else if (r.length > 0) {
            r = "", n = 0, a = i, s = 0;
            continue;
          }
        }
        t && (r = r.length > 0 ? r + "/.." : "..", n = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(a + 1, i) : r = e.slice(a + 1, i), n = i - a - 1;
      a = i, s = 0;
    } else o === 46 && s > -1 ? s++ : s = -1;
  }
  return r;
}
function Ah(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const MRe = { cwd: FRe };
function FRe() {
  return "/";
}
function UR(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function $Re(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!UR(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return BRe(e);
}
function BRe(e) {
  if (e.hostname !== "") {
    const n = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw n.code = "ERR_INVALID_FILE_URL_HOST", n;
  }
  const t = e.pathname;
  let r = -1;
  for (; ++r < t.length; )
    if (t.codePointAt(r) === 37 && t.codePointAt(r + 1) === 50) {
      const n = t.codePointAt(r + 2);
      if (n === 70 || n === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const tE = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class vW {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let r;
    t ? UR(t) ? r = { path: t } : typeof t == "string" || URe(t) ? r = { value: t } : r = t : r = {}, this.cwd = "cwd" in r ? "" : MRe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let n = -1;
    for (; ++n < tE.length; ) {
      const s = tE[n];
      s in r && r[s] !== void 0 && r[s] !== null && (this[s] = s === "history" ? [...r[s]] : r[s]);
    }
    let a;
    for (a in r)
      tE.includes(a) || (this[a] = r[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Zs.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    nE(t, "basename"), rE(t, "basename"), this.path = Zs.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Zs.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Q5(this.basename, "dirname"), this.path = Zs.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Zs.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (rE(t, "extname"), Q5(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Zs.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    UR(t) && (t = $Re(t)), nE(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Zs.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    nE(t, "stem"), rE(t, "stem"), this.path = Zs.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, r, n) {
    const a = this.message(t, r, n);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, r, n) {
    const a = this.message(t, r, n);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, r, n) {
    const a = new Rn(
      // @ts-expect-error: the overloads are fine.
      t,
      r,
      n
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function rE(e, t) {
  if (e && e.includes(Zs.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Zs.sep + "`"
    );
}
function nE(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Q5(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function URe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const zRe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const n = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), a = n[e], s = function() {
      return a.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, n), s;
  }
), qRe = {}.hasOwnProperty;
class sD extends zRe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = jG();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new sD()
    );
    let r = -1;
    for (; ++r < this.attachers.length; ) {
      const n = this.attachers[r];
      t.use(...n);
    }
    return t.data(ep(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, r) {
    return typeof t == "string" ? arguments.length === 2 ? (sE("data", this.frozen), this.namespace[t] = r, this) : qRe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (sE("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [r, ...n] = this.attachers[this.freezeIndex];
      if (n[0] === !1)
        continue;
      n[0] === !0 && (n[0] = void 0);
      const a = r.call(t, ...n);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const r = qm(t), n = this.parser || this.Parser;
    return iE("parse", n), n(String(r), r);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, r) {
    const n = this;
    return this.freeze(), iE("process", this.parser || this.Parser), aE("process", this.compiler || this.Compiler), r ? a(void 0, r) : new Promise(a);
    function a(s, i) {
      const o = qm(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        n.parse(o)
      );
      n.run(l, o, function(c, d, p) {
        if (c || !d || !p)
          return u(c);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), h = n.stringify(f, p);
        HRe(h) ? p.value = h : p.result = h, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function u(c, d) {
        c || !d ? i(c) : s ? s(d) : r(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let r = !1, n;
    return this.freeze(), iE("processSync", this.parser || this.Parser), aE("processSync", this.compiler || this.Compiler), this.process(t, a), tF("processSync", "process", r), n;
    function a(s, i) {
      r = !0, Zg(s), n = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, r, n) {
    eF(t), this.freeze();
    const a = this.transformers;
    return !n && typeof r == "function" && (n = r, r = void 0), n ? s(void 0, n) : new Promise(s);
    function s(i, o) {
      const l = qm(r);
      a.run(t, l, u);
      function u(c, d, p) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        c ? o(c) : i ? i(f) : n(void 0, f, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, r) {
    let n = !1, a;
    return this.run(t, r, s), tF("runSync", "run", n), a;
    function s(i, o) {
      Zg(i), a = o, n = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, r) {
    this.freeze();
    const n = qm(r), a = this.compiler || this.Compiler;
    return aE("stringify", a), eF(t), a(t, n);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...r) {
    const n = this.attachers, a = this.namespace;
    if (sE("use", this.frozen), t != null) if (typeof t == "function")
      l(t, r);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(u) {
      if (typeof u == "function")
        l(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          l(c, d);
        } else
          i(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function i(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(u.plugins), u.settings && (a.settings = ep(!0, a.settings, u.settings));
    }
    function o(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const d = u[c];
          s(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function l(u, c) {
      let d = -1, p = -1;
      for (; ++d < n.length; )
        if (n[d][0] === u) {
          p = d;
          break;
        }
      if (p === -1)
        n.push([u, ...c]);
      else if (c.length > 0) {
        let [f, ...h] = c;
        const m = n[p][1];
        md(m) && md(f) && (f = ep(!0, m, f)), n[p] = [u, f, ...h];
      }
    }
  }
}
const oD = new sD().freeze();
function iE(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function aE(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function sE(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function eF(e) {
  if (!md(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function tF(e, t, r) {
  if (!r)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function qm(e) {
  return jRe(e) ? e : new vW(e);
}
function jRe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function HRe(e) {
  return typeof e == "string" || VRe(e);
}
function VRe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
var mg = { exports: {} }, GRe = mg.exports, rF;
function WRe() {
  return rF || (rF = 1, function(e, t) {
    (function(r, n) {
      n();
    })(GRe, function() {
      function r(u, c) {
        return typeof c > "u" ? c = { autoBom: !1 } : typeof c != "object" && (console.warn("Deprecated: Expected third argument to be a object"), c = { autoBom: !c }), c.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["\uFEFF", u], { type: u.type }) : u;
      }
      function n(u, c, d) {
        var p = new XMLHttpRequest();
        p.open("GET", u), p.responseType = "blob", p.onload = function() {
          l(p.response, c, d);
        }, p.onerror = function() {
          console.error("could not download file");
        }, p.send();
      }
      function a(u) {
        var c = new XMLHttpRequest();
        c.open("HEAD", u, !1);
        try {
          c.send();
        } catch {
        }
        return 200 <= c.status && 299 >= c.status;
      }
      function s(u) {
        try {
          u.dispatchEvent(new MouseEvent("click"));
        } catch {
          var c = document.createEvent("MouseEvents");
          c.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), u.dispatchEvent(c);
        }
      }
      var i = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof is == "object" && is.global === is ? is : void 0, o = i.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), l = i.saveAs || (typeof window != "object" || window !== i ? function() {
      } : "download" in HTMLAnchorElement.prototype && !o ? function(u, c, d) {
        var p = i.URL || i.webkitURL, f = document.createElement("a");
        c = c || u.name || "download", f.download = c, f.rel = "noopener", typeof u == "string" ? (f.href = u, f.origin === location.origin ? s(f) : a(f.href) ? n(u, c, d) : s(f, f.target = "_blank")) : (f.href = p.createObjectURL(u), setTimeout(function() {
          p.revokeObjectURL(f.href);
        }, 4e4), setTimeout(function() {
          s(f);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(u, c, d) {
        if (c = c || u.name || "download", typeof u != "string") navigator.msSaveOrOpenBlob(r(u, d), c);
        else if (a(u)) n(u, c, d);
        else {
          var p = document.createElement("a");
          p.href = u, p.target = "_blank", setTimeout(function() {
            s(p);
          });
        }
      } : function(u, c, d, p) {
        if (p = p || open("", "_blank"), p && (p.document.title = p.document.body.innerText = "downloading..."), typeof u == "string") return n(u, c, d);
        var f = u.type === "application/octet-stream", h = /constructor/i.test(i.HTMLElement) || i.safari, m = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((m || f && h || o) && typeof FileReader < "u") {
          var y = new FileReader();
          y.onloadend = function() {
            var x = y.result;
            x = m ? x : x.replace(/^data:[^;]*;/, "data:attachment/file;"), p ? p.location.href = x : location = x, p = null;
          }, y.readAsDataURL(u);
        } else {
          var b = i.URL || i.webkitURL, v = b.createObjectURL(u);
          p ? p.location = v : location.href = v, p = null, setTimeout(function() {
            b.revokeObjectURL(v);
          }, 4e4);
        }
      });
      i.saveAs = l.saveAs = l, e.exports = l;
    });
  }(mg)), mg.exports;
}
var KRe = WRe();
const YRe = async (e) => {
  const t = new Image(), n = await (await fetch(e)).arrayBuffer();
  return new Promise((a, s) => {
    t.onload = () => {
      a({
        image: n,
        width: t.naturalWidth,
        height: t.naturalHeight
      });
    }, t.onerror = s, t.src = URL.createObjectURL(new Blob([n], { type: "image/png" }));
  });
}, XRe = () => oD().use(DN).use(NN).use(yW), nF = () => XRe().use(mbe), wW = (e) => {
  const { api: t = "/api/llm-util" } = e, r = D.useCallback(async () => {
    const o = await fetch(`${t}`);
    return o.ok ? !0 : (console.error("Error:", await o.json()), !1);
  }, [t]), n = D.useCallback(
    async (o) => {
      const l = await nF().process(o), u = String(l), c = await fetch(`${t}/html-to-pdf`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ html: u })
      });
      if (c.ok) {
        const d = await c.blob(), p = window.URL.createObjectURL(d), f = document.createElement("a");
        f.href = p, f.download = "generated.pdf", f.click(), window.URL.revokeObjectURL(p);
      } else
        console.error("Error:", await c.json());
    },
    [t]
  ), a = D.useCallback(
    async (o) => {
      const u = await (await oD().use(DN).use(NN).use(HTe, {
        output: "blob",
        imageResolver: YRe
      }).process(o)).result;
      KRe.saveAs(u, "generated.docx");
    },
    [t]
  ), s = D.useCallback(async (o) => {
    const l = new Blob([o], { type: "text/plain" }), u = window.URL.createObjectURL(l), c = document.createElement("a");
    c.href = u, c.download = "generated.md", c.click(), window.URL.revokeObjectURL(u);
  }, []), i = D.useCallback(async (o) => {
    const l = await nF().process(o), u = new Blob([String(l)], { type: "text/html" }), c = window.URL.createObjectURL(u), d = document.createElement("a");
    d.href = c, d.download = "generated.html", d.click(), window.URL.revokeObjectURL(c);
  }, []);
  return {
    downloadPdfFromMd: n,
    downloadWordFromMd: a,
    downloadMd: s,
    downloadHtml: i,
    checkUtilEndpoint: r
  };
};
function ZRe(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
function JRe(e, t) {
  if (e == null) return {};
  var r, n, a = ZRe(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (n = 0; n < s.length; n++) r = s[n], t.includes(r) || {}.propertyIsEnumerable.call(e, r) && (a[r] = e[r]);
  }
  return a;
}
function zR(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function QRe(e) {
  if (Array.isArray(e)) return zR(e);
}
function eIe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function tIe(e, t) {
  if (e) {
    if (typeof e == "string") return zR(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? zR(e, t) : void 0;
  }
}
function rIe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function qR(e) {
  return QRe(e) || eIe(e) || tIe(e) || rIe();
}
function Vp(e) {
  "@babel/helpers - typeof";
  return Vp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vp(e);
}
function nIe(e, t) {
  if (Vp(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Vp(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function iIe(e) {
  var t = nIe(e, "string");
  return Vp(t) == "symbol" ? t : t + "";
}
function xW(e, t, r) {
  return (t = iIe(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function jR() {
  return jR = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, jR.apply(null, arguments);
}
function iF(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Mc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iF(Object(r), !0).forEach(function(n) {
      xW(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : iF(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function aIe(e) {
  var t = e.length;
  if (t === 0 || t === 1) return e;
  if (t === 2)
    return [e[0], e[1], "".concat(e[0], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0])];
  if (t === 3)
    return [e[0], e[1], e[2], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0])];
  if (t >= 4)
    return [e[0], e[1], e[2], e[3], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3]), "".concat(e[3], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1], ".").concat(e[0])];
}
var oE = {};
function sIe(e) {
  if (e.length === 0 || e.length === 1) return e;
  var t = e.join(".");
  return oE[t] || (oE[t] = aIe(e)), oE[t];
}
function oIe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, n = e.filter(function(s) {
    return s !== "token";
  }), a = sIe(n);
  return a.reduce(function(s, i) {
    return Mc(Mc({}, s), r[i]);
  }, t);
}
function aF(e) {
  return e.join(" ");
}
function lIe(e, t) {
  var r = 0;
  return function(n) {
    return r += 1, n.map(function(a, s) {
      return EW({
        node: a,
        stylesheet: e,
        useInlineStyles: t,
        key: "code-segment-".concat(r, "-").concat(s)
      });
    });
  };
}
function EW(e) {
  var t = e.node, r = e.stylesheet, n = e.style, a = n === void 0 ? {} : n, s = e.useInlineStyles, i = e.key, o = t.properties, l = t.type, u = t.tagName, c = t.value;
  if (l === "text")
    return c;
  if (u) {
    var d = lIe(r, s), p;
    if (!s)
      p = Mc(Mc({}, o), {}, {
        className: aF(o.className)
      });
    else {
      var f = Object.keys(r).reduce(function(b, v) {
        return v.split(".").forEach(function(x) {
          b.includes(x) || b.push(x);
        }), b;
      }, []), h = o.className && o.className.includes("token") ? ["token"] : [], m = o.className && h.concat(o.className.filter(function(b) {
        return !f.includes(b);
      }));
      p = Mc(Mc({}, o), {}, {
        className: aF(m) || void 0,
        style: oIe(o.className, Object.assign({}, o.style, a), r)
      });
    }
    var y = d(t.children);
    return /* @__PURE__ */ kt.createElement(u, jR({
      key: i
    }, p), y);
  }
}
const uIe = function(e, t) {
  var r = e.listLanguages();
  return r.indexOf(t) !== -1;
};
var cIe = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function sF(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Il(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sF(Object(r), !0).forEach(function(n) {
      xW(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : sF(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
var dIe = /\n/g;
function fIe(e) {
  return e.match(dIe);
}
function pIe(e) {
  var t = e.lines, r = e.startingLineNumber, n = e.style;
  return t.map(function(a, s) {
    var i = s + r;
    return /* @__PURE__ */ kt.createElement("span", {
      key: "line-".concat(s),
      className: "react-syntax-highlighter-line-number",
      style: typeof n == "function" ? n(i) : n
    }, "".concat(i, `
`));
  });
}
function hIe(e) {
  var t = e.codeString, r = e.codeStyle, n = e.containerStyle, a = n === void 0 ? {
    float: "left",
    paddingRight: "10px"
  } : n, s = e.numberStyle, i = s === void 0 ? {} : s, o = e.startingLineNumber;
  return /* @__PURE__ */ kt.createElement("code", {
    style: Object.assign({}, r, a)
  }, pIe({
    lines: t.replace(/\n$/, "").split(`
`),
    style: i,
    startingLineNumber: o
  }));
}
function mIe(e) {
  return "".concat(e.toString().length, ".25em");
}
function SW(e, t) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(e),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: t
    },
    children: [{
      type: "text",
      value: e
    }]
  };
}
function _W(e, t, r) {
  var n = {
    display: "inline-block",
    minWidth: mIe(r),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  }, a = typeof e == "function" ? e(t) : e, s = Il(Il({}, n), a);
  return s;
}
function gg(e) {
  var t = e.children, r = e.lineNumber, n = e.lineNumberStyle, a = e.largestLineNumber, s = e.showInlineLineNumbers, i = e.lineProps, o = i === void 0 ? {} : i, l = e.className, u = l === void 0 ? [] : l, c = e.showLineNumbers, d = e.wrapLongLines, p = e.wrapLines, f = p === void 0 ? !1 : p, h = f ? Il({}, typeof o == "function" ? o(r) : o) : {};
  if (h.className = h.className ? [].concat(qR(h.className.trim().split(/\s+/)), qR(u)) : u, r && s) {
    var m = _W(n, r, a);
    t.unshift(SW(r, m));
  }
  return d & c && (h.style = Il({
    display: "flex"
  }, h.style)), {
    type: "element",
    tagName: "span",
    properties: h,
    children: t
  };
}
function kW(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], n = 0; n < e.length; n++) {
    var a = e[n];
    if (a.type === "text")
      r.push(gg({
        children: [a],
        className: qR(new Set(t))
      }));
    else if (a.children) {
      var s = t.concat(a.properties.className);
      kW(a.children, s).forEach(function(i) {
        return r.push(i);
      });
    }
  }
  return r;
}
function gIe(e, t, r, n, a, s, i, o, l) {
  var u, c = kW(e.value), d = [], p = -1, f = 0;
  function h(E, w) {
    var C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return gg({
      children: E,
      lineNumber: w,
      lineNumberStyle: o,
      largestLineNumber: i,
      showInlineLineNumbers: a,
      lineProps: r,
      className: C,
      showLineNumbers: n,
      wrapLongLines: l,
      wrapLines: t
    });
  }
  function m(E, w) {
    if (n && w && a) {
      var C = _W(o, w, i);
      E.unshift(SW(w, C));
    }
    return E;
  }
  function y(E, w) {
    var C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return t || C.length > 0 ? h(E, w, C) : m(E, w);
  }
  for (var b = function() {
    var w = c[f], C = w.children[0].value, k = fIe(C);
    if (k) {
      var S = C.split(`
`);
      S.forEach(function(B, U) {
        var N = n && d.length + s, O = {
          type: "text",
          value: "".concat(B, `
`)
        };
        if (U === 0) {
          var I = c.slice(p + 1, f).concat(gg({
            children: [O],
            className: w.properties.className
          })), q = y(I, N);
          d.push(q);
        } else if (U === S.length - 1) {
          var ae = c[f + 1] && c[f + 1].children && c[f + 1].children[0], Q = {
            type: "text",
            value: "".concat(B)
          };
          if (ae) {
            var ne = gg({
              children: [Q],
              className: w.properties.className
            });
            c.splice(f + 1, 0, ne);
          } else {
            var le = [Q], W = y(le, N, w.properties.className);
            d.push(W);
          }
        } else {
          var X = [O], G = y(X, N, w.properties.className);
          d.push(G);
        }
      }), p = f;
    }
    f++;
  }; f < c.length; )
    b();
  if (p !== c.length - 1) {
    var v = c.slice(p + 1, c.length);
    if (v && v.length) {
      var x = n && d.length + s, _ = y(v, x);
      d.push(_);
    }
  }
  return t ? d : (u = []).concat.apply(u, d);
}
function bIe(e) {
  var t = e.rows, r = e.stylesheet, n = e.useInlineStyles;
  return t.map(function(a, s) {
    return EW({
      node: a,
      stylesheet: r,
      useInlineStyles: n,
      key: "code-segement".concat(s)
    });
  });
}
function CW(e) {
  return e && typeof e.highlightAuto < "u";
}
function yIe(e) {
  var t = e.astGenerator, r = e.language, n = e.code, a = e.defaultCodeValue;
  if (CW(t)) {
    var s = uIe(t, r);
    return r === "text" ? {
      value: a,
      language: "text"
    } : s ? t.highlight(r, n) : t.highlightAuto(n);
  }
  try {
    return r && r !== "text" ? {
      value: t.highlight(n, r)
    } : {
      value: a
    };
  } catch {
    return {
      value: a
    };
  }
}
function vIe(e, t) {
  return function(n) {
    var a = n.language, s = n.children, i = n.style, o = i === void 0 ? t : i, l = n.customStyle, u = l === void 0 ? {} : l, c = n.codeTagProps, d = c === void 0 ? {
      className: a ? "language-".concat(a) : void 0,
      style: Il(Il({}, o['code[class*="language-"]']), o['code[class*="language-'.concat(a, '"]')])
    } : c, p = n.useInlineStyles, f = p === void 0 ? !0 : p, h = n.showLineNumbers, m = h === void 0 ? !1 : h, y = n.showInlineLineNumbers, b = y === void 0 ? !0 : y, v = n.startingLineNumber, x = v === void 0 ? 1 : v, _ = n.lineNumberContainerStyle, E = n.lineNumberStyle, w = E === void 0 ? {} : E, C = n.wrapLines, k = n.wrapLongLines, S = k === void 0 ? !1 : k, B = n.lineProps, U = B === void 0 ? {} : B, N = n.renderer, O = n.PreTag, I = O === void 0 ? "pre" : O, q = n.CodeTag, ae = q === void 0 ? "code" : q, Q = n.code, ne = Q === void 0 ? (Array.isArray(s) ? s[0] : s) || "" : Q, le = n.astGenerator, W = JRe(n, cIe);
    le = le || e;
    var X = m ? /* @__PURE__ */ kt.createElement(hIe, {
      containerStyle: _,
      codeStyle: d.style || {},
      numberStyle: w,
      startingLineNumber: x,
      codeString: ne
    }) : null, G = o.hljs || o['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    }, P = CW(le) ? "hljs" : "prismjs", he = f ? Object.assign({}, W, {
      style: Object.assign({}, G, u)
    }) : Object.assign({}, W, {
      className: W.className ? "".concat(P, " ").concat(W.className) : P,
      style: Object.assign({}, u)
    });
    if (S ? d.style = Il({
      whiteSpace: "pre-wrap"
    }, d.style) : d.style = Il({
      whiteSpace: "pre"
    }, d.style), !le)
      return /* @__PURE__ */ kt.createElement(I, he, X, /* @__PURE__ */ kt.createElement(ae, d, ne));
    (C === void 0 && N || S) && (C = !0), N = N || bIe;
    var ye = [{
      type: "text",
      value: ne
    }], pe = yIe({
      astGenerator: le,
      language: a,
      code: ne,
      defaultCodeValue: ye
    });
    pe.language === null && (pe.value = ye);
    var $ = pe.value.length;
    $ === 1 && pe.value[0].type === "text" && ($ = pe.value[0].value.split(`
`).length);
    var F = $ + x, ge = gIe(pe, C, U, m, b, x, F, w, S);
    return /* @__PURE__ */ kt.createElement(I, he, /* @__PURE__ */ kt.createElement(ae, d, !b && X, N({
      rows: ge,
      stylesheet: o,
      useInlineStyles: f
    })));
  };
}
const wIe = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
var lE, oF;
function xIe() {
  if (oF) return lE;
  oF = 1, lE = t;
  var e = Object.prototype.hasOwnProperty;
  function t() {
    for (var r = {}, n = 0; n < arguments.length; n++) {
      var a = arguments[n];
      for (var s in a)
        e.call(a, s) && (r[s] = a[s]);
    }
    return r;
  }
  return lE;
}
var uE, lF;
function AW() {
  if (lF) return uE;
  lF = 1, uE = t;
  var e = t.prototype;
  e.space = null, e.normal = {}, e.property = {};
  function t(r, n, a) {
    this.property = r, this.normal = n, a && (this.space = a);
  }
  return uE;
}
var cE, uF;
function EIe() {
  if (uF) return cE;
  uF = 1;
  var e = xIe(), t = AW();
  cE = r;
  function r(n) {
    for (var a = n.length, s = [], i = [], o = -1, l, u; ++o < a; )
      l = n[o], s.push(l.property), i.push(l.normal), u = l.space;
    return new t(
      e.apply(null, s),
      e.apply(null, i),
      u
    );
  }
  return cE;
}
var dE, cF;
function lD() {
  if (cF) return dE;
  cF = 1, dE = e;
  function e(t) {
    return t.toLowerCase();
  }
  return dE;
}
var fE, dF;
function TW() {
  if (dF) return fE;
  dF = 1, fE = t;
  var e = t.prototype;
  e.space = null, e.attribute = null, e.property = null, e.boolean = !1, e.booleanish = !1, e.overloadedBoolean = !1, e.number = !1, e.commaSeparated = !1, e.spaceSeparated = !1, e.commaOrSpaceSeparated = !1, e.mustUseProperty = !1, e.defined = !1;
  function t(r, n) {
    this.property = r, this.attribute = n;
  }
  return fE;
}
var ko = {}, fF;
function uD() {
  if (fF) return ko;
  fF = 1;
  var e = 0;
  ko.boolean = t(), ko.booleanish = t(), ko.overloadedBoolean = t(), ko.number = t(), ko.spaceSeparated = t(), ko.commaSeparated = t(), ko.commaOrSpaceSeparated = t();
  function t() {
    return Math.pow(2, ++e);
  }
  return ko;
}
var pE, pF;
function RW() {
  if (pF) return pE;
  pF = 1;
  var e = TW(), t = uD();
  pE = a, a.prototype = new e(), a.prototype.defined = !0;
  var r = [
    "boolean",
    "booleanish",
    "overloadedBoolean",
    "number",
    "commaSeparated",
    "spaceSeparated",
    "commaOrSpaceSeparated"
  ], n = r.length;
  function a(i, o, l, u) {
    var c = -1, d;
    for (s(this, "space", u), e.call(this, i, o); ++c < n; )
      d = r[c], s(this, d, (l & t[d]) === t[d]);
  }
  function s(i, o, l) {
    l && (i[o] = l);
  }
  return pE;
}
var hE, hF;
function Th() {
  if (hF) return hE;
  hF = 1;
  var e = lD(), t = AW(), r = RW();
  hE = n;
  function n(a) {
    var s = a.space, i = a.mustUseProperty || [], o = a.attributes || {}, l = a.properties, u = a.transform, c = {}, d = {}, p, f;
    for (p in l)
      f = new r(
        p,
        u(o, p),
        l[p],
        s
      ), i.indexOf(p) !== -1 && (f.mustUseProperty = !0), c[p] = f, d[e(p)] = p, d[e(f.attribute)] = p;
    return new t(c, d, s);
  }
  return hE;
}
var mE, mF;
function SIe() {
  if (mF) return mE;
  mF = 1;
  var e = Th();
  mE = e({
    space: "xlink",
    transform: t,
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  });
  function t(r, n) {
    return "xlink:" + n.slice(5).toLowerCase();
  }
  return mE;
}
var gE, gF;
function _Ie() {
  if (gF) return gE;
  gF = 1;
  var e = Th();
  gE = e({
    space: "xml",
    transform: t,
    properties: {
      xmlLang: null,
      xmlBase: null,
      xmlSpace: null
    }
  });
  function t(r, n) {
    return "xml:" + n.slice(3).toLowerCase();
  }
  return gE;
}
var bE, bF;
function kIe() {
  if (bF) return bE;
  bF = 1, bE = e;
  function e(t, r) {
    return r in t ? t[r] : r;
  }
  return bE;
}
var yE, yF;
function IW() {
  if (yF) return yE;
  yF = 1;
  var e = kIe();
  yE = t;
  function t(r, n) {
    return e(r, n.toLowerCase());
  }
  return yE;
}
var vE, vF;
function CIe() {
  if (vF) return vE;
  vF = 1;
  var e = Th(), t = IW();
  return vE = e({
    space: "xmlns",
    attributes: {
      xmlnsxlink: "xmlns:xlink"
    },
    transform: t,
    properties: {
      xmlns: null,
      xmlnsXLink: null
    }
  }), vE;
}
var wE, wF;
function AIe() {
  if (wF) return wE;
  wF = 1;
  var e = uD(), t = Th(), r = e.booleanish, n = e.number, a = e.spaceSeparated;
  wE = t({
    transform: s,
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: r,
      ariaAutoComplete: null,
      ariaBusy: r,
      ariaChecked: r,
      ariaColCount: n,
      ariaColIndex: n,
      ariaColSpan: n,
      ariaControls: a,
      ariaCurrent: null,
      ariaDescribedBy: a,
      ariaDetails: null,
      ariaDisabled: r,
      ariaDropEffect: a,
      ariaErrorMessage: null,
      ariaExpanded: r,
      ariaFlowTo: a,
      ariaGrabbed: r,
      ariaHasPopup: null,
      ariaHidden: r,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: a,
      ariaLevel: n,
      ariaLive: null,
      ariaModal: r,
      ariaMultiLine: r,
      ariaMultiSelectable: r,
      ariaOrientation: null,
      ariaOwns: a,
      ariaPlaceholder: null,
      ariaPosInSet: n,
      ariaPressed: r,
      ariaReadOnly: r,
      ariaRelevant: null,
      ariaRequired: r,
      ariaRoleDescription: a,
      ariaRowCount: n,
      ariaRowIndex: n,
      ariaRowSpan: n,
      ariaSelected: r,
      ariaSetSize: n,
      ariaSort: null,
      ariaValueMax: n,
      ariaValueMin: n,
      ariaValueNow: n,
      ariaValueText: null,
      role: null
    }
  });
  function s(i, o) {
    return o === "role" ? o : "aria-" + o.slice(4).toLowerCase();
  }
  return wE;
}
var xE, xF;
function TIe() {
  if (xF) return xE;
  xF = 1;
  var e = uD(), t = Th(), r = IW(), n = e.boolean, a = e.overloadedBoolean, s = e.booleanish, i = e.number, o = e.spaceSeparated, l = e.commaSeparated;
  return xE = t({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: r,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: l,
      acceptCharset: o,
      accessKey: o,
      action: null,
      allow: null,
      allowFullScreen: n,
      allowPaymentRequest: n,
      allowUserMedia: n,
      alt: null,
      as: null,
      async: n,
      autoCapitalize: null,
      autoComplete: o,
      autoFocus: n,
      autoPlay: n,
      capture: n,
      charSet: null,
      checked: n,
      cite: null,
      className: o,
      cols: i,
      colSpan: null,
      content: null,
      contentEditable: s,
      controls: n,
      controlsList: o,
      coords: i | l,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: n,
      defer: n,
      dir: null,
      dirName: null,
      disabled: n,
      download: a,
      draggable: s,
      encType: null,
      enterKeyHint: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: n,
      formTarget: null,
      headers: o,
      height: i,
      hidden: n,
      high: i,
      href: null,
      hrefLang: null,
      htmlFor: o,
      httpEquiv: o,
      id: null,
      imageSizes: null,
      imageSrcSet: l,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: n,
      itemId: null,
      itemProp: o,
      itemRef: o,
      itemScope: n,
      itemType: o,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: n,
      low: i,
      manifest: null,
      max: null,
      maxLength: i,
      media: null,
      method: null,
      min: null,
      minLength: i,
      multiple: n,
      muted: n,
      name: null,
      nonce: null,
      noModule: n,
      noValidate: n,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforePrint: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextMenu: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: n,
      optimum: i,
      pattern: null,
      ping: o,
      placeholder: null,
      playsInline: n,
      poster: null,
      preload: null,
      readOnly: n,
      referrerPolicy: null,
      rel: o,
      required: n,
      reversed: n,
      rows: i,
      rowSpan: i,
      sandbox: o,
      scope: null,
      scoped: n,
      seamless: n,
      selected: n,
      shape: null,
      size: i,
      sizes: null,
      slot: null,
      span: i,
      spellCheck: s,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: l,
      start: i,
      step: null,
      style: null,
      tabIndex: i,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: n,
      useMap: null,
      value: s,
      width: i,
      wrap: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: o,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: i,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: i,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: n,
      // Lists. Use CSS to reduce space between items instead
      declare: n,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: i,
      // `<img>` and `<object>`
      leftMargin: i,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: i,
      // `<body>`
      marginWidth: i,
      // `<body>`
      noResize: n,
      // `<frame>`
      noHref: n,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: n,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: n,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: i,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: s,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: i,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: i,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: n,
      disableRemotePlayback: n,
      prefix: null,
      property: null,
      results: i,
      security: null,
      unselectable: null
    }
  }), xE;
}
var EE, EF;
function RIe() {
  if (EF) return EE;
  EF = 1;
  var e = EIe(), t = SIe(), r = _Ie(), n = CIe(), a = AIe(), s = TIe();
  return EE = e([r, t, n, a, s]), EE;
}
var SE, SF;
function IIe() {
  if (SF) return SE;
  SF = 1;
  var e = lD(), t = RW(), r = TW(), n = "data";
  SE = o;
  var a = /^data[-\w.:]+$/i, s = /-[a-z]/g, i = /[A-Z]/g;
  function o(p, f) {
    var h = e(f), m = f, y = r;
    return h in p.normal ? p.property[p.normal[h]] : (h.length > 4 && h.slice(0, 4) === n && a.test(f) && (f.charAt(4) === "-" ? m = l(f) : f = u(f), y = t), new y(m, f));
  }
  function l(p) {
    var f = p.slice(5).replace(s, d);
    return n + f.charAt(0).toUpperCase() + f.slice(1);
  }
  function u(p) {
    var f = p.slice(4);
    return s.test(f) ? p : (f = f.replace(i, c), f.charAt(0) !== "-" && (f = "-" + f), n + f);
  }
  function c(p) {
    return "-" + p.toLowerCase();
  }
  function d(p) {
    return p.charAt(1).toUpperCase();
  }
  return SE;
}
var _E, _F;
function NIe() {
  if (_F) return _E;
  _F = 1, _E = t;
  var e = /[#.]/g;
  function t(r, n) {
    for (var a = r || "", s = n || "div", i = {}, o = 0, l, u, c; o < a.length; )
      e.lastIndex = o, c = e.exec(a), l = a.slice(o, c ? c.index : a.length), l && (u ? u === "#" ? i.id = l : i.className ? i.className.push(l) : i.className = [l] : s = l, o += l.length), c && (u = c[0], o++);
    return { type: "element", tagName: s, properties: i, children: [] };
  }
  return _E;
}
var jm = {}, kF;
function DIe() {
  if (kF) return jm;
  kF = 1, jm.parse = n, jm.stringify = a;
  var e = "", t = " ", r = /[ \t\n\r\f]+/g;
  function n(s) {
    var i = String(s || e).trim();
    return i === e ? [] : i.split(r);
  }
  function a(s) {
    return s.join(t).trim();
  }
  return jm;
}
var Hm = {}, CF;
function OIe() {
  if (CF) return Hm;
  CF = 1, Hm.parse = n, Hm.stringify = a;
  var e = ",", t = " ", r = "";
  function n(s) {
    for (var i = [], o = String(s || r), l = o.indexOf(e), u = 0, c = !1, d; !c; )
      l === -1 && (l = o.length, c = !0), d = o.slice(u, l).trim(), (d || !c) && i.push(d), u = l + 1, l = o.indexOf(e, u);
    return i;
  }
  function a(s, i) {
    var o = i || {}, l = o.padLeft === !1 ? r : t, u = o.padRight ? t : r;
    return s[s.length - 1] === r && (s = s.concat(r)), s.join(u + e + l).trim();
  }
  return Hm;
}
var kE, AF;
function PIe() {
  if (AF) return kE;
  AF = 1;
  var e = IIe(), t = lD(), r = NIe(), n = DIe().parse, a = OIe().parse;
  kE = i;
  var s = {}.hasOwnProperty;
  function i(h, m, y) {
    var b = y ? f(y) : null;
    return v;
    function v(_, E) {
      var w = r(_, m), C = Array.prototype.slice.call(arguments, 2), k = w.tagName.toLowerCase(), S;
      if (w.tagName = b && s.call(b, k) ? b[k] : k, E && o(E, w) && (C.unshift(E), E = null), E)
        for (S in E)
          x(w.properties, S, E[S]);
      return u(w.children, C), w.tagName === "template" && (w.content = { type: "root", children: w.children }, w.children = []), w;
    }
    function x(_, E, w) {
      var C, k, S;
      w == null || w !== w || (C = e(h, E), k = C.property, S = w, typeof S == "string" && (C.spaceSeparated ? S = n(S) : C.commaSeparated ? S = a(S) : C.commaOrSpaceSeparated && (S = n(a(S).join(" ")))), k === "style" && typeof w != "string" && (S = p(S)), k === "className" && _.className && (S = _.className.concat(S)), _[k] = c(C, k, S));
    }
  }
  function o(h, m) {
    return typeof h == "string" || "length" in h || l(m.tagName, h);
  }
  function l(h, m) {
    var y = m.type;
    return h === "input" || !y || typeof y != "string" ? !1 : typeof m.children == "object" && "length" in m.children ? !0 : (y = y.toLowerCase(), h === "button" ? y !== "menu" && y !== "submit" && y !== "reset" && y !== "button" : "value" in m);
  }
  function u(h, m) {
    var y, b;
    if (typeof m == "string" || typeof m == "number") {
      h.push({ type: "text", value: String(m) });
      return;
    }
    if (typeof m == "object" && "length" in m) {
      for (y = -1, b = m.length; ++y < b; )
        u(h, m[y]);
      return;
    }
    if (typeof m != "object" || !("type" in m))
      throw new Error("Expected node, nodes, or string, got `" + m + "`");
    h.push(m);
  }
  function c(h, m, y) {
    var b, v, x;
    if (typeof y != "object" || !("length" in y))
      return d(h, m, y);
    for (v = y.length, b = -1, x = []; ++b < v; )
      x[b] = d(h, m, y[b]);
    return x;
  }
  function d(h, m, y) {
    var b = y;
    return h.number || h.positiveNumber ? !isNaN(b) && b !== "" && (b = Number(b)) : (h.boolean || h.overloadedBoolean) && typeof b == "string" && (b === "" || t(y) === t(m)) && (b = !0), b;
  }
  function p(h) {
    var m = [], y;
    for (y in h)
      m.push([y, h[y]].join(": "));
    return m.join("; ");
  }
  function f(h) {
    for (var m = h.length, y = -1, b = {}, v; ++y < m; )
      v = h[y], b[v.toLowerCase()] = v;
    return b;
  }
  return kE;
}
var CE, TF;
function LIe() {
  if (TF) return CE;
  TF = 1;
  var e = RIe(), t = PIe(), r = t(e, "div");
  return r.displayName = "html", CE = r, CE;
}
var AE, RF;
function MIe() {
  return RF || (RF = 1, AE = LIe()), AE;
}
const FIe = "Æ", $Ie = "&", BIe = "Á", UIe = "Â", zIe = "À", qIe = "Å", jIe = "Ã", HIe = "Ä", VIe = "©", GIe = "Ç", WIe = "Ð", KIe = "É", YIe = "Ê", XIe = "È", ZIe = "Ë", JIe = ">", QIe = "Í", eNe = "Î", tNe = "Ì", rNe = "Ï", nNe = "<", iNe = "Ñ", aNe = "Ó", sNe = "Ô", oNe = "Ò", lNe = "Ø", uNe = "Õ", cNe = "Ö", dNe = '"', fNe = "®", pNe = "Þ", hNe = "Ú", mNe = "Û", gNe = "Ù", bNe = "Ü", yNe = "Ý", vNe = "á", wNe = "â", xNe = "´", ENe = "æ", SNe = "à", _Ne = "&", kNe = "å", CNe = "ã", ANe = "ä", TNe = "¦", RNe = "ç", INe = "¸", NNe = "¢", DNe = "©", ONe = "¤", PNe = "°", LNe = "÷", MNe = "é", FNe = "ê", $Ne = "è", BNe = "ð", UNe = "ë", zNe = "½", qNe = "¼", jNe = "¾", HNe = ">", VNe = "í", GNe = "î", WNe = "¡", KNe = "ì", YNe = "¿", XNe = "ï", ZNe = "«", JNe = "<", QNe = "¯", eDe = "µ", tDe = "·", rDe = " ", nDe = "¬", iDe = "ñ", aDe = "ó", sDe = "ô", oDe = "ò", lDe = "ª", uDe = "º", cDe = "ø", dDe = "õ", fDe = "ö", pDe = "¶", hDe = "±", mDe = "£", gDe = '"', bDe = "»", yDe = "®", vDe = "§", wDe = "­", xDe = "¹", EDe = "²", SDe = "³", _De = "ß", kDe = "þ", CDe = "×", ADe = "ú", TDe = "û", RDe = "ù", IDe = "¨", NDe = "ü", DDe = "ý", ODe = "¥", PDe = "ÿ", LDe = {
  AElig: FIe,
  AMP: $Ie,
  Aacute: BIe,
  Acirc: UIe,
  Agrave: zIe,
  Aring: qIe,
  Atilde: jIe,
  Auml: HIe,
  COPY: VIe,
  Ccedil: GIe,
  ETH: WIe,
  Eacute: KIe,
  Ecirc: YIe,
  Egrave: XIe,
  Euml: ZIe,
  GT: JIe,
  Iacute: QIe,
  Icirc: eNe,
  Igrave: tNe,
  Iuml: rNe,
  LT: nNe,
  Ntilde: iNe,
  Oacute: aNe,
  Ocirc: sNe,
  Ograve: oNe,
  Oslash: lNe,
  Otilde: uNe,
  Ouml: cNe,
  QUOT: dNe,
  REG: fNe,
  THORN: pNe,
  Uacute: hNe,
  Ucirc: mNe,
  Ugrave: gNe,
  Uuml: bNe,
  Yacute: yNe,
  aacute: vNe,
  acirc: wNe,
  acute: xNe,
  aelig: ENe,
  agrave: SNe,
  amp: _Ne,
  aring: kNe,
  atilde: CNe,
  auml: ANe,
  brvbar: TNe,
  ccedil: RNe,
  cedil: INe,
  cent: NNe,
  copy: DNe,
  curren: ONe,
  deg: PNe,
  divide: LNe,
  eacute: MNe,
  ecirc: FNe,
  egrave: $Ne,
  eth: BNe,
  euml: UNe,
  frac12: zNe,
  frac14: qNe,
  frac34: jNe,
  gt: HNe,
  iacute: VNe,
  icirc: GNe,
  iexcl: WNe,
  igrave: KNe,
  iquest: YNe,
  iuml: XNe,
  laquo: ZNe,
  lt: JNe,
  macr: QNe,
  micro: eDe,
  middot: tDe,
  nbsp: rDe,
  not: nDe,
  ntilde: iDe,
  oacute: aDe,
  ocirc: sDe,
  ograve: oDe,
  ordf: lDe,
  ordm: uDe,
  oslash: cDe,
  otilde: dDe,
  ouml: fDe,
  para: pDe,
  plusmn: hDe,
  pound: mDe,
  quot: gDe,
  raquo: bDe,
  reg: yDe,
  sect: vDe,
  shy: wDe,
  sup1: xDe,
  sup2: EDe,
  sup3: SDe,
  szlig: _De,
  thorn: kDe,
  times: CDe,
  uacute: ADe,
  ucirc: TDe,
  ugrave: RDe,
  uml: IDe,
  uuml: NDe,
  yacute: DDe,
  yen: ODe,
  yuml: PDe
}, MDe = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
var TE, IF;
function NW() {
  if (IF) return TE;
  IF = 1, TE = e;
  function e(t) {
    var r = typeof t == "string" ? t.charCodeAt(0) : t;
    return r >= 48 && r <= 57;
  }
  return TE;
}
var RE, NF;
function FDe() {
  if (NF) return RE;
  NF = 1, RE = e;
  function e(t) {
    var r = typeof t == "string" ? t.charCodeAt(0) : t;
    return r >= 97 && r <= 102 || r >= 65 && r <= 70 || r >= 48 && r <= 57;
  }
  return RE;
}
var IE, DF;
function $De() {
  if (DF) return IE;
  DF = 1, IE = e;
  function e(t) {
    var r = typeof t == "string" ? t.charCodeAt(0) : t;
    return r >= 97 && r <= 122 || r >= 65 && r <= 90;
  }
  return IE;
}
var NE, OF;
function BDe() {
  if (OF) return NE;
  OF = 1;
  var e = $De(), t = NW();
  NE = r;
  function r(n) {
    return e(n) || t(n);
  }
  return NE;
}
var DE, PF;
function UDe() {
  if (PF) return DE;
  PF = 1;
  var e, t = 59;
  DE = r;
  function r(n) {
    var a = "&" + n + ";", s;
    return e = e || document.createElement("i"), e.innerHTML = a, s = e.textContent, s.charCodeAt(s.length - 1) === t && n !== "semi" || s === a ? !1 : s;
  }
  return DE;
}
var OE, LF;
function zDe() {
  if (LF) return OE;
  LF = 1;
  var e = LDe, t = MDe, r = NW(), n = FDe(), a = BDe(), s = UDe();
  OE = le;
  var i = {}.hasOwnProperty, o = String.fromCharCode, l = Function.prototype, u = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: !1,
    nonTerminated: !0
  }, c = 9, d = 10, p = 12, f = 32, h = 38, m = 59, y = 60, b = 61, v = 35, x = 88, _ = 120, E = 65533, w = "named", C = "hexadecimal", k = "decimal", S = {};
  S[C] = 16, S[k] = 10;
  var B = {};
  B[w] = a, B[k] = r, B[C] = n;
  var U = 1, N = 2, O = 3, I = 4, q = 5, ae = 6, Q = 7, ne = {};
  ne[U] = "Named character references must be terminated by a semicolon", ne[N] = "Numeric character references must be terminated by a semicolon", ne[O] = "Named character references cannot be empty", ne[I] = "Numeric character references cannot be empty", ne[q] = "Named character references must be known", ne[ae] = "Numeric character references cannot be disallowed", ne[Q] = "Numeric character references cannot be outside the permissible Unicode range";
  function le(P, he) {
    var ye = {}, pe, $;
    he || (he = {});
    for ($ in u)
      pe = he[$], ye[$] = pe ?? u[$];
    return (ye.position.indent || ye.position.start) && (ye.indent = ye.position.indent || [], ye.position = ye.position.start), W(P, ye);
  }
  function W(P, he) {
    var ye = he.additional, pe = he.nonTerminated, $ = he.text, F = he.reference, ge = he.warning, ce = he.textContext, ie = he.referenceContext, re = he.warningContext, Te = he.position, V = he.indent || [], Pe = P.length, z = 0, A = -1, R = Te.column || 1, H = Te.line || 1, be = "", me = [], Ce, We, xe, we, te, Fe, Y, Je, xt, Ze, rt, Mt, Qt, kr, tr, Oe, Ie, Me, je;
    for (typeof ye == "string" && (ye = ye.charCodeAt(0)), Oe = tt(), Je = ge ? Ct : l, z--, Pe++; ++z < Pe; )
      if (te === d && (R = V[A] || 1), te = P.charCodeAt(z), te === h) {
        if (Y = P.charCodeAt(z + 1), Y === c || Y === d || Y === p || Y === f || Y === h || Y === y || Y !== Y || ye && Y === ye) {
          be += o(te), R++;
          continue;
        }
        for (Qt = z + 1, Mt = Qt, je = Qt, Y === v ? (je = ++Mt, Y = P.charCodeAt(je), Y === x || Y === _ ? (kr = C, je = ++Mt) : kr = k) : kr = w, Ce = "", rt = "", we = "", tr = B[kr], je--; ++je < Pe && (Y = P.charCodeAt(je), !!tr(Y)); )
          we += o(Y), kr === w && i.call(e, we) && (Ce = we, rt = e[we]);
        xe = P.charCodeAt(je) === m, xe && (je++, We = kr === w ? s(we) : !1, We && (Ce = we, rt = We)), Me = 1 + je - Qt, !xe && !pe || (we ? kr === w ? (xe && !rt ? Je(q, 1) : (Ce !== we && (je = Mt + Ce.length, Me = 1 + je - Mt, xe = !1), xe || (xt = Ce ? U : O, he.attribute ? (Y = P.charCodeAt(je), Y === b ? (Je(xt, Me), rt = null) : a(Y) ? rt = null : Je(xt, Me)) : Je(xt, Me))), Fe = rt) : (xe || Je(N, Me), Fe = parseInt(we, S[kr]), X(Fe) ? (Je(Q, Me), Fe = o(E)) : Fe in t ? (Je(ae, Me), Fe = t[Fe]) : (Ze = "", G(Fe) && Je(ae, Me), Fe > 65535 && (Fe -= 65536, Ze += o(Fe >>> 10 | 55296), Fe = 56320 | Fe & 1023), Fe = Ze + o(Fe))) : kr !== w && Je(I, Me)), Fe ? (Kt(), Oe = tt(), z = je - 1, R += je - Qt + 1, me.push(Fe), Ie = tt(), Ie.offset++, F && F.call(
          ie,
          Fe,
          { start: Oe, end: Ie },
          P.slice(Qt - 1, je)
        ), Oe = Ie) : (we = P.slice(Qt - 1, je), be += we, R += we.length, z = je - 1);
      } else
        te === 10 && (H++, A++, R = 0), te === te ? (be += o(te), R++) : Kt();
    return me.join("");
    function tt() {
      return {
        line: H,
        column: R,
        offset: z + (Te.offset || 0)
      };
    }
    function Ct(ct, ir) {
      var xr = tt();
      xr.column += ir, xr.offset += ir, ge.call(re, ne[ct], xr, ct);
    }
    function Kt() {
      be && (me.push(be), $ && $.call(ce, be, { start: Oe, end: tt() }), be = "");
    }
  }
  function X(P) {
    return P >= 55296 && P <= 57343 || P > 1114111;
  }
  function G(P) {
    return P >= 1 && P <= 8 || P === 11 || P >= 13 && P <= 31 || P >= 127 && P <= 159 || P >= 64976 && P <= 65007 || (P & 65535) === 65535 || (P & 65535) === 65534;
  }
  return OE;
}
var PE = { exports: {} }, MF;
function qDe() {
  return MF || (MF = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var r = function(n) {
      var a = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, i = {}, o = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: n.Prism && n.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function v(x) {
            return x instanceof l ? new l(x.type, v(x.content), x.alias) : Array.isArray(x) ? x.map(v) : x.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(v) {
            return Object.prototype.toString.call(v).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(v) {
            return v.__id || Object.defineProperty(v, "__id", { value: ++s }), v.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function v(x, _) {
            _ = _ || {};
            var E, w;
            switch (o.util.type(x)) {
              case "Object":
                if (w = o.util.objId(x), _[w])
                  return _[w];
                E = /** @type {Record<string, any>} */
                {}, _[w] = E;
                for (var C in x)
                  x.hasOwnProperty(C) && (E[C] = v(x[C], _));
                return (
                  /** @type {any} */
                  E
                );
              case "Array":
                return w = o.util.objId(x), _[w] ? _[w] : (E = [], _[w] = E, /** @type {Array} */
                /** @type {any} */
                x.forEach(function(k, S) {
                  E[S] = v(k, _);
                }), /** @type {any} */
                E);
              default:
                return x;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(v) {
            for (; v; ) {
              var x = a.exec(v.className);
              if (x)
                return x[1].toLowerCase();
              v = v.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(v, x) {
            v.className = v.className.replace(RegExp(a, "gi"), ""), v.classList.add("language-" + x);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (E) {
              var v = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(E.stack) || [])[1];
              if (v) {
                var x = document.getElementsByTagName("script");
                for (var _ in x)
                  if (x[_].src == v)
                    return x[_];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(v, x, _) {
            for (var E = "no-" + x; v; ) {
              var w = v.classList;
              if (w.contains(x))
                return !0;
              if (w.contains(E))
                return !1;
              v = v.parentElement;
            }
            return !!_;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: i,
          plaintext: i,
          text: i,
          txt: i,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(v, x) {
            var _ = o.util.clone(o.languages[v]);
            for (var E in x)
              _[E] = x[E];
            return _;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(v, x, _, E) {
            E = E || /** @type {any} */
            o.languages;
            var w = E[v], C = {};
            for (var k in w)
              if (w.hasOwnProperty(k)) {
                if (k == x)
                  for (var S in _)
                    _.hasOwnProperty(S) && (C[S] = _[S]);
                _.hasOwnProperty(k) || (C[k] = w[k]);
              }
            var B = E[v];
            return E[v] = C, o.languages.DFS(o.languages, function(U, N) {
              N === B && U != v && (this[U] = C);
            }), C;
          },
          // Traverse a language definition with Depth First Search
          DFS: function v(x, _, E, w) {
            w = w || {};
            var C = o.util.objId;
            for (var k in x)
              if (x.hasOwnProperty(k)) {
                _.call(x, k, x[k], E || k);
                var S = x[k], B = o.util.type(S);
                B === "Object" && !w[C(S)] ? (w[C(S)] = !0, v(S, _, null, w)) : B === "Array" && !w[C(S)] && (w[C(S)] = !0, v(S, _, k, w));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(v, x) {
          o.highlightAllUnder(document, v, x);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(v, x, _) {
          var E = {
            callback: _,
            container: v,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          o.hooks.run("before-highlightall", E), E.elements = Array.prototype.slice.apply(E.container.querySelectorAll(E.selector)), o.hooks.run("before-all-elements-highlight", E);
          for (var w = 0, C; C = E.elements[w++]; )
            o.highlightElement(C, x === !0, E.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(v, x, _) {
          var E = o.util.getLanguage(v), w = o.languages[E];
          o.util.setLanguage(v, E);
          var C = v.parentElement;
          C && C.nodeName.toLowerCase() === "pre" && o.util.setLanguage(C, E);
          var k = v.textContent, S = {
            element: v,
            language: E,
            grammar: w,
            code: k
          };
          function B(N) {
            S.highlightedCode = N, o.hooks.run("before-insert", S), S.element.innerHTML = S.highlightedCode, o.hooks.run("after-highlight", S), o.hooks.run("complete", S), _ && _.call(S.element);
          }
          if (o.hooks.run("before-sanity-check", S), C = S.element.parentElement, C && C.nodeName.toLowerCase() === "pre" && !C.hasAttribute("tabindex") && C.setAttribute("tabindex", "0"), !S.code) {
            o.hooks.run("complete", S), _ && _.call(S.element);
            return;
          }
          if (o.hooks.run("before-highlight", S), !S.grammar) {
            B(o.util.encode(S.code));
            return;
          }
          if (x && n.Worker) {
            var U = new Worker(o.filename);
            U.onmessage = function(N) {
              B(N.data);
            }, U.postMessage(JSON.stringify({
              language: S.language,
              code: S.code,
              immediateClose: !0
            }));
          } else
            B(o.highlight(S.code, S.grammar, S.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(v, x, _) {
          var E = {
            code: v,
            grammar: x,
            language: _
          };
          if (o.hooks.run("before-tokenize", E), !E.grammar)
            throw new Error('The language "' + E.language + '" has no grammar.');
          return E.tokens = o.tokenize(E.code, E.grammar), o.hooks.run("after-tokenize", E), l.stringify(o.util.encode(E.tokens), E.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(v, x) {
          var _ = x.rest;
          if (_) {
            for (var E in _)
              x[E] = _[E];
            delete x.rest;
          }
          var w = new d();
          return p(w, w.head, v), c(v, w, x, w.head, 0), h(w);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(v, x) {
            var _ = o.hooks.all;
            _[v] = _[v] || [], _[v].push(x);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(v, x) {
            var _ = o.hooks.all[v];
            if (!(!_ || !_.length))
              for (var E = 0, w; w = _[E++]; )
                w(x);
          }
        },
        Token: l
      };
      n.Prism = o;
      function l(v, x, _, E) {
        this.type = v, this.content = x, this.alias = _, this.length = (E || "").length | 0;
      }
      l.stringify = function v(x, _) {
        if (typeof x == "string")
          return x;
        if (Array.isArray(x)) {
          var E = "";
          return x.forEach(function(B) {
            E += v(B, _);
          }), E;
        }
        var w = {
          type: x.type,
          content: v(x.content, _),
          tag: "span",
          classes: ["token", x.type],
          attributes: {},
          language: _
        }, C = x.alias;
        C && (Array.isArray(C) ? Array.prototype.push.apply(w.classes, C) : w.classes.push(C)), o.hooks.run("wrap", w);
        var k = "";
        for (var S in w.attributes)
          k += " " + S + '="' + (w.attributes[S] || "").replace(/"/g, "&quot;") + '"';
        return "<" + w.tag + ' class="' + w.classes.join(" ") + '"' + k + ">" + w.content + "</" + w.tag + ">";
      };
      function u(v, x, _, E) {
        v.lastIndex = x;
        var w = v.exec(_);
        if (w && E && w[1]) {
          var C = w[1].length;
          w.index += C, w[0] = w[0].slice(C);
        }
        return w;
      }
      function c(v, x, _, E, w, C) {
        for (var k in _)
          if (!(!_.hasOwnProperty(k) || !_[k])) {
            var S = _[k];
            S = Array.isArray(S) ? S : [S];
            for (var B = 0; B < S.length; ++B) {
              if (C && C.cause == k + "," + B)
                return;
              var U = S[B], N = U.inside, O = !!U.lookbehind, I = !!U.greedy, q = U.alias;
              if (I && !U.pattern.global) {
                var ae = U.pattern.toString().match(/[imsuy]*$/)[0];
                U.pattern = RegExp(U.pattern.source, ae + "g");
              }
              for (var Q = U.pattern || U, ne = E.next, le = w; ne !== x.tail && !(C && le >= C.reach); le += ne.value.length, ne = ne.next) {
                var W = ne.value;
                if (x.length > v.length)
                  return;
                if (!(W instanceof l)) {
                  var X = 1, G;
                  if (I) {
                    if (G = u(Q, le, v, O), !G || G.index >= v.length)
                      break;
                    var pe = G.index, P = G.index + G[0].length, he = le;
                    for (he += ne.value.length; pe >= he; )
                      ne = ne.next, he += ne.value.length;
                    if (he -= ne.value.length, le = he, ne.value instanceof l)
                      continue;
                    for (var ye = ne; ye !== x.tail && (he < P || typeof ye.value == "string"); ye = ye.next)
                      X++, he += ye.value.length;
                    X--, W = v.slice(le, he), G.index -= le;
                  } else if (G = u(Q, 0, W, O), !G)
                    continue;
                  var pe = G.index, $ = G[0], F = W.slice(0, pe), ge = W.slice(pe + $.length), ce = le + W.length;
                  C && ce > C.reach && (C.reach = ce);
                  var ie = ne.prev;
                  F && (ie = p(x, ie, F), le += F.length), f(x, ie, X);
                  var re = new l(k, N ? o.tokenize($, N) : $, q, $);
                  if (ne = p(x, ie, re), ge && p(x, ne, ge), X > 1) {
                    var Te = {
                      cause: k + "," + B,
                      reach: ce
                    };
                    c(v, x, _, ne.prev, le, Te), C && Te.reach > C.reach && (C.reach = Te.reach);
                  }
                }
              }
            }
          }
      }
      function d() {
        var v = { value: null, prev: null, next: null }, x = { value: null, prev: v, next: null };
        v.next = x, this.head = v, this.tail = x, this.length = 0;
      }
      function p(v, x, _) {
        var E = x.next, w = { value: _, prev: x, next: E };
        return x.next = w, E.prev = w, v.length++, w;
      }
      function f(v, x, _) {
        for (var E = x.next, w = 0; w < _ && E !== v.tail; w++)
          E = E.next;
        x.next = E, E.prev = x, v.length -= w;
      }
      function h(v) {
        for (var x = [], _ = v.head.next; _ !== v.tail; )
          x.push(_.value), _ = _.next;
        return x;
      }
      if (!n.document)
        return n.addEventListener && (o.disableWorkerMessageHandler || n.addEventListener("message", function(v) {
          var x = JSON.parse(v.data), _ = x.language, E = x.code, w = x.immediateClose;
          n.postMessage(o.highlight(E, o.languages[_], _)), w && n.close();
        }, !1)), o;
      var m = o.util.currentScript();
      m && (o.filename = m.src, m.hasAttribute("data-manual") && (o.manual = !0));
      function y() {
        o.manual || o.highlightAll();
      }
      if (!o.manual) {
        var b = document.readyState;
        b === "loading" || b === "interactive" && m && m.defer ? document.addEventListener("DOMContentLoaded", y) : window.requestAnimationFrame ? window.requestAnimationFrame(y) : window.setTimeout(y, 16);
      }
      return o;
    }(t);
    e.exports && (e.exports = r), typeof is < "u" && (is.Prism = r);
  }(PE)), PE.exports;
}
var LE, FF;
function jDe() {
  if (FF) return LE;
  FF = 1, LE = e, e.displayName = "markup", e.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
  function e(t) {
    t.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity, t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup, t.hooks.add("wrap", function(r) {
      r.type === "entity" && (r.attributes.title = r.content.value.replace(/&amp;/, "&"));
    }), Object.defineProperty(t.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(n, a) {
        var s = {};
        s["language-" + a] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: t.languages[a]
        }, s.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var i = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: s
          }
        };
        i["language-" + a] = {
          pattern: /[\s\S]+/,
          inside: t.languages[a]
        };
        var o = {};
        o[n] = {
          pattern: RegExp(
            /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
              /__/g,
              function() {
                return n;
              }
            ),
            "i"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: i
        }, t.languages.insertBefore("markup", "cdata", o);
      }
    }), Object.defineProperty(t.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(r, n) {
        t.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [n, "language-" + n],
                  inside: t.languages[n]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), t.languages.html = t.languages.markup, t.languages.mathml = t.languages.markup, t.languages.svg = t.languages.markup, t.languages.xml = t.languages.extend("markup", {}), t.languages.ssml = t.languages.xml, t.languages.atom = t.languages.xml, t.languages.rss = t.languages.xml;
  }
  return LE;
}
var ME, $F;
function HDe() {
  if ($F) return ME;
  $F = 1, ME = e, e.displayName = "css", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      r.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp(
            "\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
            "i"
          ),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + n.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(
            `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"
          ),
          lookbehind: !0
        },
        string: {
          pattern: n,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, r.languages.css.atrule.inside.rest = r.languages.css;
      var a = r.languages.markup;
      a && (a.tag.addInlined("style", "css"), a.tag.addAttribute("style", "css"));
    })(t);
  }
  return ME;
}
var FE, BF;
function VDe() {
  if (BF) return FE;
  BF = 1, FE = e, e.displayName = "clike", e.aliases = [];
  function e(t) {
    t.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return FE;
}
var $E, UF;
function GDe() {
  if (UF) return $E;
  UF = 1, $E = e, e.displayName = "javascript", e.aliases = ["js"];
  function e(t) {
    t.languages.javascript = t.languages.extend("clike", {
      "class-name": [
        t.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), t.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, t.languages.insertBefore("javascript", "keyword", {
      regex: {
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: t.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), t.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: t.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), t.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"), t.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), t.languages.js = t.languages.javascript;
  }
  return $E;
}
var BE, zF;
function WDe() {
  if (zF) return BE;
  zF = 1;
  var e = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof is == "object" ? is : {}, t = E();
  e.Prism = { manual: !0, disableWorkerMessageHandler: !0 };
  var r = MIe(), n = zDe(), a = qDe(), s = jDe(), i = HDe(), o = VDe(), l = GDe();
  t();
  var u = {}.hasOwnProperty;
  function c() {
  }
  c.prototype = a;
  var d = new c();
  BE = d, d.highlight = h, d.register = p, d.alias = f, d.registered = m, d.listLanguages = y, p(s), p(i), p(o), p(l), d.util.encode = x, d.Token.stringify = b;
  function p(w) {
    if (typeof w != "function" || !w.displayName)
      throw new Error("Expected `function` for `grammar`, got `" + w + "`");
    d.languages[w.displayName] === void 0 && w(d);
  }
  function f(w, C) {
    var k = d.languages, S = w, B, U, N, O;
    C && (S = {}, S[w] = C);
    for (B in S)
      for (U = S[B], U = typeof U == "string" ? [U] : U, N = U.length, O = -1; ++O < N; )
        k[U[O]] = k[B];
  }
  function h(w, C) {
    var k = a.highlight, S;
    if (typeof w != "string")
      throw new Error("Expected `string` for `value`, got `" + w + "`");
    if (d.util.type(C) === "Object")
      S = C, C = null;
    else {
      if (typeof C != "string")
        throw new Error("Expected `string` for `name`, got `" + C + "`");
      if (u.call(d.languages, C))
        S = d.languages[C];
      else
        throw new Error("Unknown language: `" + C + "` is not registered");
    }
    return k.call(this, w, S, C);
  }
  function m(w) {
    if (typeof w != "string")
      throw new Error("Expected `string` for `language`, got `" + w + "`");
    return u.call(d.languages, w);
  }
  function y() {
    var w = d.languages, C = [], k;
    for (k in w)
      u.call(w, k) && typeof w[k] == "object" && C.push(k);
    return C;
  }
  function b(w, C, k) {
    var S;
    return typeof w == "string" ? { type: "text", value: w } : d.util.type(w) === "Array" ? v(w, C) : (S = {
      type: w.type,
      content: d.Token.stringify(w.content, C, k),
      tag: "span",
      classes: ["token", w.type],
      attributes: {},
      language: C,
      parent: k
    }, w.alias && (S.classes = S.classes.concat(w.alias)), d.hooks.run("wrap", S), r(
      S.tag + "." + S.classes.join("."),
      _(S.attributes),
      S.content
    ));
  }
  function v(w, C) {
    for (var k = [], S = w.length, B = -1, U; ++B < S; )
      U = w[B], U !== "" && U !== null && U !== void 0 && k.push(U);
    for (B = -1, S = k.length; ++B < S; )
      U = k[B], k[B] = d.Token.stringify(U, C, k);
    return k;
  }
  function x(w) {
    return w;
  }
  function _(w) {
    var C;
    for (C in w)
      w[C] = n(w[C]);
    return w;
  }
  function E() {
    var w = "Prism" in e, C = w ? e.Prism : void 0;
    return k;
    function k() {
      w ? e.Prism = C : delete e.Prism, w = void 0, C = void 0;
    }
  }
  return BE;
}
const KDe = {
  'code[class*="language-"]': {
    color: "black",
    background: "none",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    color: "black",
    background: "#f5f2f0",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    background: "#f5f2f0",
    padding: ".1em",
    borderRadius: ".3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "slategray"
  },
  prolog: {
    color: "slategray"
  },
  doctype: {
    color: "slategray"
  },
  cdata: {
    color: "slategray"
  },
  punctuation: {
    color: "#999"
  },
  namespace: {
    Opacity: ".7"
  },
  property: {
    color: "#905"
  },
  tag: {
    color: "#905"
  },
  boolean: {
    color: "#905"
  },
  number: {
    color: "#905"
  },
  constant: {
    color: "#905"
  },
  symbol: {
    color: "#905"
  },
  deleted: {
    color: "#905"
  },
  selector: {
    color: "#690"
  },
  "attr-name": {
    color: "#690"
  },
  string: {
    color: "#690"
  },
  char: {
    color: "#690"
  },
  builtin: {
    color: "#690"
  },
  inserted: {
    color: "#690"
  },
  operator: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  entity: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)",
    cursor: "help"
  },
  url: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  atrule: {
    color: "#07a"
  },
  "attr-value": {
    color: "#07a"
  },
  keyword: {
    color: "#07a"
  },
  function: {
    color: "#DD4A68"
  },
  "class-name": {
    color: "#DD4A68"
  },
  regex: {
    color: "#e90"
  },
  important: {
    color: "#e90",
    fontWeight: "bold"
  },
  variable: {
    color: "#e90"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var UE, qF;
function YDe() {
  if (qF) return UE;
  qF = 1, UE = e, e.displayName = "abap", e.aliases = [];
  function e(t) {
    t.languages.abap = {
      comment: /^\*.*/m,
      string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "string-template": {
        pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
        lookbehind: !0,
        alias: "string"
      },
      /* End Of Line comments should not interfere with strings when the
      quote character occurs within them. We assume a string being highlighted
      inside an EOL comment is more acceptable than the opposite.
      */
      "eol-comment": {
        pattern: /(^|\s)".*/m,
        lookbehind: !0,
        alias: "comment"
      },
      keyword: {
        pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
        lookbehind: !0
      },
      /* Numbers can be only integers. Decimal or Hex appear only as strings */
      number: /\b\d+\b/,
      /* Operators must always be surrounded by whitespace, they cannot be put
      adjacent to operands.
      */
      operator: {
        pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
        lookbehind: !0
      },
      "string-operator": {
        pattern: /(\s)&&?(?=\s)/,
        lookbehind: !0,
        /* The official editor highlights */
        alias: "keyword"
      },
      "token-operator": [
        {
          /* Special operators used to access structure components, class methods/attributes, etc. */
          pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
          lookbehind: !0,
          alias: "punctuation"
        },
        {
          /* Special tokens used do delimit string templates */
          pattern: /[|{}]/,
          alias: "punctuation"
        }
      ],
      punctuation: /[,.:()]/
    };
  }
  return UE;
}
var zE, jF;
function XDe() {
  if (jF) return zE;
  jF = 1, zE = e, e.displayName = "abnf", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
      r.languages.abnf = {
        comment: /;.*/,
        string: {
          pattern: /(?:%[is])?"[^"\n\r]*"/,
          greedy: !0,
          inside: {
            punctuation: /^%[is]/
          }
        },
        range: {
          pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
          alias: "number"
        },
        terminal: {
          pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
          alias: "number"
        },
        repetition: {
          pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
          lookbehind: !0,
          alias: "operator"
        },
        definition: {
          pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
          lookbehind: !0,
          alias: "keyword",
          inside: {
            punctuation: /<|>/
          }
        },
        "core-rule": {
          pattern: RegExp(
            "(?:(^|[^<\\w-])" + n + "|<" + n + ">)(?![\\w-])",
            "i"
          ),
          lookbehind: !0,
          alias: ["rule", "constant"],
          inside: {
            punctuation: /<|>/
          }
        },
        rule: {
          pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
          lookbehind: !0,
          inside: {
            punctuation: /<|>/
          }
        },
        operator: /=\/?|\//,
        punctuation: /[()\[\]]/
      };
    })(t);
  }
  return zE;
}
var qE, HF;
function ZDe() {
  if (HF) return qE;
  HF = 1, qE = e, e.displayName = "actionscript", e.aliases = [];
  function e(t) {
    t.languages.actionscript = t.languages.extend("javascript", {
      keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
      operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
    }), t.languages.actionscript["class-name"].alias = "function", delete t.languages.actionscript.parameter, delete t.languages.actionscript["literal-property"], t.languages.markup && t.languages.insertBefore("actionscript", "string", {
      xml: {
        pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
        lookbehind: !0,
        inside: t.languages.markup
      }
    });
  }
  return qE;
}
var jE, VF;
function JDe() {
  if (VF) return jE;
  VF = 1, jE = e, e.displayName = "ada", e.aliases = [];
  function e(t) {
    t.languages.ada = {
      comment: /--.*/,
      string: /"(?:""|[^"\r\f\n])*"/,
      number: [
        {
          pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
        },
        {
          pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
        }
      ],
      "attr-name": /\b'\w+/,
      keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
      boolean: /\b(?:false|true)\b/i,
      operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
      punctuation: /\.\.?|[,;():]/,
      char: /'.'/,
      variable: /\b[a-z](?:\w)*\b/i
    };
  }
  return jE;
}
var HE, GF;
function QDe() {
  if (GF) return HE;
  GF = 1, HE = e, e.displayName = "agda", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.agda = {
        comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
        string: {
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
          greedy: !0
        },
        punctuation: /[(){}⦃⦄.;@]/,
        "class-name": {
          pattern: /((?:data|record) +)\S+/,
          lookbehind: !0
        },
        function: {
          pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
          lookbehind: !0
        },
        operator: {
          pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
          lookbehind: !0
        },
        keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
      };
    })(t);
  }
  return HE;
}
var VE, WF;
function e2e() {
  if (WF) return VE;
  WF = 1, VE = e, e.displayName = "al", e.aliases = [];
  function e(t) {
    t.languages.al = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: !0
      },
      function: {
        pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0
      },
      keyword: [
        // keywords
        /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
        // objects and metadata that are used like keywords
        /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
      ],
      number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
      boolean: /\b(?:false|true)\b/i,
      variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
      "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
      operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
      punctuation: /[()\[\]{}:.;,]/
    };
  }
  return VE;
}
var GE, KF;
function t2e() {
  if (KF) return GE;
  KF = 1, GE = e, e.displayName = "antlr4", e.aliases = ["g4"];
  function e(t) {
    t.languages.antlr4 = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      string: {
        pattern: /'(?:\\.|[^\\'\r\n])*'/,
        greedy: !0
      },
      "character-class": {
        pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
        greedy: !0,
        alias: "regex",
        inside: {
          range: {
            pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
            lookbehind: !0,
            alias: "punctuation"
          },
          escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
          punctuation: /[\[\]]/
        }
      },
      action: {
        pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
        greedy: !0,
        inside: {
          content: {
            // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
            pattern: /(\{)[\s\S]+(?=\})/,
            lookbehind: !0
          },
          punctuation: /[{}]/
        }
      },
      command: {
        pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
        lookbehind: !0,
        inside: {
          function: /\b\w+(?=\s*(?:[,(]|$))/,
          punctuation: /[,()]/
        }
      },
      annotation: {
        pattern: /@\w+(?:::\w+)*/,
        alias: "keyword"
      },
      label: {
        pattern: /#[ \t]*\w+/,
        alias: "punctuation"
      },
      keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
      definition: [
        {
          pattern: /\b[a-z]\w*(?=\s*:)/,
          alias: ["rule", "class-name"]
        },
        {
          pattern: /\b[A-Z]\w*(?=\s*:)/,
          alias: ["token", "constant"]
        }
      ],
      constant: /\b[A-Z][A-Z_]*\b/,
      operator: /\.\.|->|[|~]|[*+?]\??/,
      punctuation: /[;:()=]/
    }, t.languages.g4 = t.languages.antlr4;
  }
  return GE;
}
var WE, YF;
function r2e() {
  if (YF) return WE;
  YF = 1, WE = e, e.displayName = "apacheconf", e.aliases = [];
  function e(t) {
    t.languages.apacheconf = {
      comment: /#.*/,
      "directive-inline": {
        pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
        lookbehind: !0,
        alias: "property"
      },
      "directive-block": {
        pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
        inside: {
          "directive-block": {
            pattern: /^<\/?\w+/,
            inside: {
              punctuation: /^<\/?/
            },
            alias: "tag"
          },
          "directive-block-parameter": {
            pattern: /.*[^>]/,
            inside: {
              punctuation: /:/,
              string: {
                pattern: /("|').*\1/,
                inside: {
                  variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
                }
              }
            },
            alias: "attr-value"
          },
          punctuation: />/
        },
        alias: "tag"
      },
      "directive-flags": {
        pattern: /\[(?:[\w=],?)+\]/,
        alias: "keyword"
      },
      string: {
        pattern: /("|').*\1/,
        inside: {
          variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
        }
      },
      variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
      regex: /\^?.*\$|\^.*\$?/
    };
  }
  return WE;
}
var KE, XF;
function cD() {
  if (XF) return KE;
  XF = 1, KE = e, e.displayName = "sql", e.aliases = [];
  function e(t) {
    t.languages.sql = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: !0
      },
      variable: [
        {
          pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
          greedy: !0
        },
        /@[\w.$]+/
      ],
      string: {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: !0,
        lookbehind: !0
      },
      identifier: {
        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /^`|`$/
        }
      },
      function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
      // Should we highlight user defined functions too?
      keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
      punctuation: /[;[\]()`,.]/
    };
  }
  return KE;
}
var YE, ZF;
function n2e() {
  if (ZF) return YE;
  ZF = 1;
  var e = cD();
  YE = t, t.displayName = "apex", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i, s = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
        /<keyword>/g,
        function() {
          return a.source;
        }
      );
      function i(l) {
        return RegExp(
          l.replace(/<CLASS-NAME>/g, function() {
            return s;
          }),
          "i"
        );
      }
      var o = {
        keyword: a,
        punctuation: /[()\[\]{};,:.<>]/
      };
      n.languages.apex = {
        comment: n.languages.clike.comment,
        string: n.languages.clike.string,
        sql: {
          pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
          lookbehind: !0,
          greedy: !0,
          alias: "language-sql",
          inside: n.languages.sql
        },
        annotation: {
          pattern: /@\w+\b/,
          alias: "punctuation"
        },
        "class-name": [
          {
            pattern: i(
              /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
            ),
            lookbehind: !0,
            inside: o
          },
          {
            // cast
            pattern: i(
              /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
            ),
            lookbehind: !0,
            inside: o
          },
          {
            // variable/parameter declaration and return types
            pattern: i(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
            inside: o
          }
        ],
        trigger: {
          pattern: /(\btrigger\s+)\w+\b/i,
          lookbehind: !0,
          alias: "class-name"
        },
        keyword: a,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        boolean: /\b(?:false|true)\b/i,
        number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
        operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
        punctuation: /[()\[\]{};,.]/
      };
    }(r);
  }
  return YE;
}
var XE, JF;
function i2e() {
  if (JF) return XE;
  JF = 1, XE = e, e.displayName = "apl", e.aliases = [];
  function e(t) {
    t.languages.apl = {
      comment: /(?:⍝|#[! ]).*$/m,
      string: {
        pattern: /'(?:[^'\r\n]|'')*'/,
        greedy: !0
      },
      number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
      statement: /:[A-Z][a-z][A-Za-z]*\b/,
      "system-function": {
        pattern: /⎕[A-Z]+/i,
        alias: "function"
      },
      constant: /[⍬⌾#⎕⍞]/,
      function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
      "monadic-operator": {
        pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
        alias: "operator"
      },
      "dyadic-operator": {
        pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
        alias: "operator"
      },
      assignment: {
        pattern: /←/,
        alias: "keyword"
      },
      punctuation: /[\[;\]()◇⋄]/,
      dfn: {
        pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
        alias: "builtin"
      }
    };
  }
  return XE;
}
var ZE, QF;
function a2e() {
  if (QF) return ZE;
  QF = 1, ZE = e, e.displayName = "applescript", e.aliases = [];
  function e(t) {
    t.languages.applescript = {
      comment: [
        // Allow one level of nesting
        /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
        /--.+/,
        /#.+/
      ],
      string: /"(?:\\.|[^"\\\r\n])*"/,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
      operator: [
        /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
        /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
      ],
      keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
      "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
      punctuation: /[{}():,¬«»《》]/
    };
  }
  return ZE;
}
var JE, e6;
function s2e() {
  if (e6) return JE;
  e6 = 1, JE = e, e.displayName = "aql", e.aliases = [];
  function e(t) {
    t.languages.aql = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      property: {
        pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: !0
      },
      identifier: {
        pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: !0
      },
      variable: /@@?\w+/,
      keyword: [
        {
          pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
          lookbehind: !0
        },
        /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
        // pseudo keywords get a lookbehind to avoid false positives
        {
          pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
          lookbehind: !0
        },
        {
          pattern: /\bOPTIONS(?=\s*\{)/i
        }
      ],
      function: /\b(?!\d)\w+(?=\s*\()/,
      boolean: /\b(?:false|true)\b/i,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      number: [
        /\b0b[01]+/i,
        /\b0x[0-9a-f]+/i,
        /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
      ],
      operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
      punctuation: /::|[?.:,;()[\]{}]/
    };
  }
  return JE;
}
var QE, t6;
function Wu() {
  if (t6) return QE;
  t6 = 1, QE = e, e.displayName = "c", e.aliases = [];
  function e(t) {
    t.languages.c = t.languages.extend("clike", {
      comment: {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: !0
      },
      string: {
        // https://en.cppreference.com/w/c/language/string_literal
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: !0
      },
      keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
      operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    }), t.languages.insertBefore("c", "string", {
      char: {
        // https://en.cppreference.com/w/c/language/character_constant
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: !0
      }
    }), t.languages.insertBefore("c", "string", {
      macro: {
        // allow for multiline macro definitions
        // spaces after the # character compile fine with gcc
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          string: [
            {
              // highlight the path of the include statement as a string
              pattern: /^(#\s*include\s*)<[^>]+>/,
              lookbehind: !0
            },
            t.languages.c.string
          ],
          char: t.languages.c.char,
          comment: t.languages.c.comment,
          "macro-name": [
            {
              pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
              lookbehind: !0
            },
            {
              pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
              lookbehind: !0,
              alias: "function"
            }
          ],
          // highlight macro directives as keywords
          directive: {
            pattern: /^(#\s*)[a-z]+/,
            lookbehind: !0,
            alias: "keyword"
          },
          "directive-hash": /^#/,
          punctuation: /##|\\(?=[\r\n])/,
          expression: {
            pattern: /\S[\s\S]*/,
            inside: t.languages.c
          }
        }
      }
    }), t.languages.insertBefore("c", "function", {
      // highlight predefined macros as constants
      constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    }), delete t.languages.c.boolean;
  }
  return QE;
}
var eS, r6;
function dD() {
  if (r6) return eS;
  r6 = 1;
  var e = Wu();
  eS = t, t.displayName = "cpp", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, s = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
        /<keyword>/g,
        function() {
          return a.source;
        }
      );
      n.languages.cpp = n.languages.extend("c", {
        "class-name": [
          {
            pattern: RegExp(
              /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
                /<keyword>/g,
                function() {
                  return a.source;
                }
              )
            ),
            lookbehind: !0
          },
          // This is intended to capture the class name of method implementations like:
          //   void foo::bar() const {}
          // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
          // it starts with an uppercase letter. This approximation should give decent results.
          /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
          // This will capture the class name before destructors like:
          //   Foo::~Foo() {}
          /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
          // This also intends to capture the class name of method implementations but here the class has template
          // parameters, so it can't be a namespace (until C++ adds generic namespaces).
          /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        keyword: a,
        number: {
          pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
          greedy: !0
        },
        operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        boolean: /\b(?:false|true)\b/
      }), n.languages.insertBefore("cpp", "string", {
        module: {
          // https://en.cppreference.com/w/cpp/language/modules
          pattern: RegExp(
            /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
              /<mod-name>/g,
              function() {
                return s;
              }
            ) + ")"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: /^[<"][\s\S]+/,
            operator: /:/,
            punctuation: /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: !0
        }
      }), n.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: n.languages.cpp
            }
          }
        }
      }), n.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      }), n.languages.insertBefore("cpp", "class-name", {
        // the base clause is an optional list of parent classes
        // https://en.cppreference.com/w/cpp/language/class
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: n.languages.extend("cpp", {})
        }
      }), n.languages.insertBefore(
        "inside",
        "double-colon",
        {
          // All untokenized words that are not namespaces should be class names
          "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
        },
        n.languages.cpp["base-clause"]
      );
    }(r);
  }
  return eS;
}
var tS, n6;
function o2e() {
  if (n6) return tS;
  n6 = 1;
  var e = dD();
  tS = t, t.displayName = "arduino", t.aliases = ["ino"];
  function t(r) {
    r.register(e), r.languages.arduino = r.languages.extend("cpp", {
      keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
      constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
      builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
    }), r.languages.ino = r.languages.arduino;
  }
  return tS;
}
var rS, i6;
function l2e() {
  if (i6) return rS;
  i6 = 1, rS = e, e.displayName = "arff", e.aliases = [];
  function e(t) {
    t.languages.arff = {
      comment: /%.*/,
      string: {
        pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: /@(?:attribute|data|end|relation)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      punctuation: /[{},]/
    };
  }
  return rS;
}
var nS, a6;
function u2e() {
  if (a6) return nS;
  a6 = 1, nS = e, e.displayName = "asciidoc", e.aliases = ["adoc"];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
        lookbehind: !0,
        inside: {
          quoted: {
            pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
            inside: {
              punctuation: /^[$`]|[$`]$/
            }
          },
          interpreted: {
            pattern: /'(?:[^'\\]|\\.)*'/,
            inside: {
              punctuation: /^'|'$/
              // See rest below
            }
          },
          string: /"(?:[^"\\]|\\.)*"/,
          variable: /\w+(?==)/,
          punctuation: /^\[|\]$|,/,
          operator: /=/,
          // The negative look-ahead prevents blank matches
          "attr-value": /(?!^\s+$).+/
        }
      }, a = r.languages.asciidoc = {
        "comment-block": {
          pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
          alias: "comment"
        },
        table: {
          pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
          inside: {
            specifiers: {
              pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
              alias: "attr-value"
            },
            punctuation: {
              pattern: /(^|[^\\])[|!]=*/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        "passthrough-block": {
          pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^\++|\++$/
            // See rest below
          }
        },
        // Literal blocks and listing blocks
        "literal-block": {
          pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
            // See rest below
          }
        },
        // Sidebar blocks, quote blocks, example blocks and open blocks
        "other-block": {
          pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
            // See rest below
          }
        },
        // list-punctuation and list-label must appear before indented-block
        "list-punctuation": {
          pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
          lookbehind: !0,
          alias: "punctuation"
        },
        "list-label": {
          pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
          lookbehind: !0,
          alias: "symbol"
        },
        "indented-block": {
          pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
          lookbehind: !0
        },
        comment: /^\/\/.*/m,
        title: {
          pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
          alias: "important",
          inside: {
            punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
            // See rest below
          }
        },
        "attribute-entry": {
          pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
          alias: "tag"
        },
        attributes: n,
        hr: {
          pattern: /^'{3,}$/m,
          alias: "punctuation"
        },
        "page-break": {
          pattern: /^<{3,}$/m,
          alias: "punctuation"
        },
        admonition: {
          pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
          alias: "keyword"
        },
        callout: [
          {
            pattern: /(^[ \t]*)<?\d*>/m,
            lookbehind: !0,
            alias: "symbol"
          },
          {
            pattern: /<\d+>/,
            alias: "symbol"
          }
        ],
        macro: {
          pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
          inside: {
            function: /^[a-z\d-]+(?=:)/,
            punctuation: /^::?/,
            attributes: {
              pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
              inside: n.inside
            }
          }
        },
        inline: {
          /*
          The initial look-behind prevents the highlighting of escaped quoted text.
          Quoted text can be multi-line but cannot span an empty line.
          All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
          First, we handle the constrained quotes.
          Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
          They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
          Then we handle the unconstrained quotes.
          Those do not have the restrictions of the constrained quotes.
          They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
          */
          pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
          lookbehind: !0,
          inside: {
            attributes: n,
            url: {
              pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
              inside: {
                punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
              }
            },
            "attribute-ref": {
              pattern: /^\{.+\}$/,
              inside: {
                variable: {
                  pattern: /(^\{)[a-z\d,+_-]+/,
                  lookbehind: !0
                },
                operator: /^[=?!#%@$]|!(?=[:}])/,
                punctuation: /^\{|\}$|::?/
              }
            },
            italic: {
              pattern: /^(['_])[\s\S]+\1$/,
              inside: {
                punctuation: /^(?:''?|__?)|(?:''?|__?)$/
              }
            },
            bold: {
              pattern: /^\*[\s\S]+\*$/,
              inside: {
                punctuation: /^\*\*?|\*\*?$/
              }
            },
            punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
          }
        },
        replacement: {
          pattern: /\((?:C|R|TM)\)/,
          alias: "builtin"
        },
        entity: /&#?[\da-z]{1,8};/i,
        "line-continuation": {
          pattern: /(^| )\+$/m,
          lookbehind: !0,
          alias: "punctuation"
        }
      };
      function s(i) {
        i = i.split(" ");
        for (var o = {}, l = 0, u = i.length; l < u; l++)
          o[i[l]] = a[i[l]];
        return o;
      }
      n.inside.interpreted.inside.rest = s(
        "macro inline replacement entity"
      ), a["passthrough-block"].inside.rest = s("macro"), a["literal-block"].inside.rest = s("callout"), a.table.inside.rest = s(
        "comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"
      ), a["other-block"].inside.rest = s(
        "table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"
      ), a.title.inside.rest = s(
        "macro inline replacement entity"
      ), r.hooks.add("wrap", function(i) {
        i.type === "entity" && (i.attributes.title = i.content.value.replace(/&amp;/, "&"));
      }), r.languages.adoc = r.languages.asciidoc;
    })(t);
  }
  return nS;
}
var iS, s6;
function c2e() {
  if (s6) return iS;
  s6 = 1, iS = e, e.displayName = "asm6502", e.aliases = [];
  function e(t) {
    t.languages.asm6502 = {
      comment: /;.*/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "op-code": {
        pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{1,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[xya]\b/i,
        alias: "variable"
      },
      punctuation: /[(),:]/
    };
  }
  return iS;
}
var aS, o6;
function d2e() {
  if (o6) return aS;
  o6 = 1, aS = e, e.displayName = "asmatmel", e.aliases = [];
  function e(t) {
    t.languages.asmatmel = {
      comment: {
        pattern: /;.*/,
        greedy: !0
      },
      string: {
        pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      "r-register": {
        pattern: /\br(?:\d|[12]\d|3[01])\b/,
        alias: "variable"
      },
      "op-code": {
        pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{2,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[acznvshtixy]\b/i,
        alias: "variable"
      },
      operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
      punctuation: /[(),:]/
    };
  }
  return aS;
}
var sS, l6;
function yy() {
  if (l6) return sS;
  l6 = 1, sS = e, e.displayName = "csharp", e.aliases = ["dotnet", "cs"];
  function e(t) {
    (function(r) {
      function n(X, G) {
        return X.replace(/<<(\d+)>>/g, function(P, he) {
          return "(?:" + G[+he] + ")";
        });
      }
      function a(X, G, P) {
        return RegExp(n(X, G), "");
      }
      function s(X, G) {
        for (var P = 0; P < G; P++)
          X = X.replace(/<<self>>/g, function() {
            return "(?:" + X + ")";
          });
        return X.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var i = {
        // keywords which represent a return or variable type
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        // keywords which are used to declare a type
        typeDeclaration: "class enum interface record struct",
        // contextual keywords
        // ("var" and "dynamic" are missing because they are used like types)
        contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
        // all other keywords
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
      };
      function o(X) {
        return "\\b(?:" + X.trim().replace(/ /g, "|") + ")\\b";
      }
      var l = o(
        i.typeDeclaration
      ), u = RegExp(
        o(
          i.type + " " + i.typeDeclaration + " " + i.contextual + " " + i.other
        )
      ), c = o(
        i.typeDeclaration + " " + i.contextual + " " + i.other
      ), d = o(
        i.type + " " + i.typeDeclaration + " " + i.other
      ), p = s(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), f = s(/\((?:[^()]|<<self>>)*\)/.source, 2), h = /@?\b[A-Za-z_]\w*\b/.source, m = n(/<<0>>(?:\s*<<1>>)?/.source, [h, p]), y = n(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
        c,
        m
      ]), b = /\[\s*(?:,\s*)*\]/.source, v = n(
        /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
        [y, b]
      ), x = n(
        /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
        [p, f, b]
      ), _ = n(/\(<<0>>+(?:,<<0>>+)+\)/.source, [x]), E = n(
        /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
        [_, y, b]
      ), w = {
        keyword: u,
        punctuation: /[<>()?,.:[\]]/
      }, C = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, k = /"(?:\\.|[^\\"\r\n])*"/.source, S = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
      r.languages.csharp = r.languages.extend("clike", {
        string: [
          {
            pattern: a(/(^|[^$\\])<<0>>/.source, [S]),
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: a(/(^|[^@$\\])<<0>>/.source, [k]),
            lookbehind: !0,
            greedy: !0
          }
        ],
        "class-name": [
          {
            // Using static
            // using static System.Math;
            pattern: a(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
              y
            ]),
            lookbehind: !0,
            inside: w
          },
          {
            // Using alias (type)
            // using Project = PC.MyCompany.Project;
            pattern: a(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
              h,
              E
            ]),
            lookbehind: !0,
            inside: w
          },
          {
            // Using alias (alias)
            // using Project = PC.MyCompany.Project;
            pattern: a(/(\busing\s+)<<0>>(?=\s*=)/.source, [h]),
            lookbehind: !0
          },
          {
            // Type declarations
            // class Foo<A, B>
            // interface Foo<out A, B>
            pattern: a(/(\b<<0>>\s+)<<1>>/.source, [
              l,
              m
            ]),
            lookbehind: !0,
            inside: w
          },
          {
            // Single catch exception declaration
            // catch(Foo)
            // (things like catch(Foo e) is covered by variable declaration)
            pattern: a(/(\bcatch\s*\(\s*)<<0>>/.source, [y]),
            lookbehind: !0,
            inside: w
          },
          {
            // Name of the type parameter of generic constraints
            // where Foo : class
            pattern: a(/(\bwhere\s+)<<0>>/.source, [h]),
            lookbehind: !0
          },
          {
            // Casts and checks via as and is.
            // as Foo<A>, is Bar<B>
            // (things like if(a is Foo b) is covered by variable declaration)
            pattern: a(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
              v
            ]),
            lookbehind: !0,
            inside: w
          },
          {
            // Variable, field and parameter declaration
            // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
            pattern: a(
              /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
              [E, d, h]
            ),
            inside: w
          }
        ],
        keyword: u,
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
        number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
        operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        punctuation: /\?\.?|::|[{}[\];(),.:]/
      }), r.languages.insertBefore("csharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      }), r.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
          pattern: a(/([(,]\s*)<<0>>(?=\s*:)/.source, [h]),
          lookbehind: !0,
          alias: "punctuation"
        }
      }), r.languages.insertBefore("csharp", "class-name", {
        namespace: {
          // namespace Foo.Bar {}
          // using Foo.Bar;
          pattern: a(
            /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
            [h]
          ),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        "type-expression": {
          // default(Foo), typeof(Foo<Bar>), sizeof(int)
          pattern: a(
            /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
            [f]
          ),
          lookbehind: !0,
          alias: "class-name",
          inside: w
        },
        "return-type": {
          // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
          // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
          // int Foo => 0; int Foo { get; set } = 0;
          pattern: a(
            /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
            [E, y]
          ),
          inside: w,
          alias: "class-name"
        },
        "constructor-invocation": {
          // new List<Foo<Bar[]>> { }
          pattern: a(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [E]),
          lookbehind: !0,
          inside: w,
          alias: "class-name"
        },
        /*'explicit-implementation': {
        // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
        pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
        inside: classNameInside,
        alias: 'class-name'
        },*/
        "generic-method": {
          // foo<Bar>()
          pattern: a(/<<0>>\s*<<1>>(?=\s*\()/.source, [h, p]),
          inside: {
            function: a(/^<<0>>/.source, [h]),
            generic: {
              pattern: RegExp(p),
              alias: "class-name",
              inside: w
            }
          }
        },
        "type-list": {
          // The list of types inherited or of generic constraints
          // class Foo<F> : Bar, IList<FooBar>
          // where F : Bar, IList<int>
          pattern: a(
            /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
            [
              l,
              m,
              h,
              E,
              u.source,
              f,
              /\bnew\s*\(\s*\)/.source
            ]
          ),
          lookbehind: !0,
          inside: {
            "record-arguments": {
              pattern: a(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                m,
                f
              ]),
              lookbehind: !0,
              greedy: !0,
              inside: r.languages.csharp
            },
            keyword: u,
            "class-name": {
              pattern: RegExp(E),
              greedy: !0,
              inside: w
            },
            punctuation: /[,()]/
          }
        },
        preprocessor: {
          pattern: /(^[\t ]*)#.*/m,
          lookbehind: !0,
          alias: "property",
          inside: {
            // highlight preprocessor directives as keywords
            directive: {
              pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
              lookbehind: !0,
              alias: "keyword"
            }
          }
        }
      });
      var B = k + "|" + C, U = n(
        /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
        [B]
      ), N = s(
        n(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
          U
        ]),
        2
      ), O = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, I = n(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
        y,
        N
      ]);
      r.languages.insertBefore("csharp", "class-name", {
        attribute: {
          // Attributes
          // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
          pattern: a(
            /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
            [O, I]
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            target: {
              pattern: a(/^<<0>>(?=\s*:)/.source, [O]),
              alias: "keyword"
            },
            "attribute-arguments": {
              pattern: a(/\(<<0>>*\)/.source, [N]),
              inside: r.languages.csharp
            },
            "class-name": {
              pattern: RegExp(y),
              inside: {
                punctuation: /\./
              }
            },
            punctuation: /[:,]/
          }
        }
      });
      var q = /:[^}\r\n]+/.source, ae = s(
        n(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
          U
        ]),
        2
      ), Q = n(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        ae,
        q
      ]), ne = s(
        n(
          /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
          [B]
        ),
        2
      ), le = n(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        ne,
        q
      ]);
      function W(X, G) {
        return {
          interpolation: {
            pattern: a(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [X]),
            lookbehind: !0,
            inside: {
              "format-string": {
                pattern: a(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                  G,
                  q
                ]),
                lookbehind: !0,
                inside: {
                  punctuation: /^:/
                }
              },
              punctuation: /^\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                alias: "language-csharp",
                inside: r.languages.csharp
              }
            }
          },
          string: /[\s\S]+/
        };
      }
      r.languages.insertBefore("csharp", "string", {
        "interpolation-string": [
          {
            pattern: a(
              /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
              [Q]
            ),
            lookbehind: !0,
            greedy: !0,
            inside: W(Q, ae)
          },
          {
            pattern: a(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
              le
            ]),
            lookbehind: !0,
            greedy: !0,
            inside: W(le, ne)
          }
        ],
        char: {
          pattern: RegExp(C),
          greedy: !0
        }
      }), r.languages.dotnet = r.languages.cs = r.languages.csharp;
    })(t);
  }
  return sS;
}
var oS, u6;
function f2e() {
  if (u6) return oS;
  u6 = 1;
  var e = yy();
  oS = t, t.displayName = "aspnet", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.aspnet = r.languages.extend("markup", {
      "page-directive": {
        pattern: /<%\s*@.*%>/,
        alias: "tag",
        inside: {
          "page-directive": {
            pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
            alias: "tag"
          },
          rest: r.languages.markup.tag.inside
        }
      },
      directive: {
        pattern: /<%.*%>/,
        alias: "tag",
        inside: {
          directive: {
            pattern: /<%\s*?[$=%#:]{0,2}|%>/,
            alias: "tag"
          },
          rest: r.languages.csharp
        }
      }
    }), r.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, r.languages.insertBefore(
      "inside",
      "punctuation",
      {
        directive: r.languages.aspnet.directive
      },
      r.languages.aspnet.tag.inside["attr-value"]
    ), r.languages.insertBefore("aspnet", "comment", {
      "asp-comment": {
        pattern: /<%--[\s\S]*?--%>/,
        alias: ["asp", "comment"]
      }
    }), r.languages.insertBefore(
      "aspnet",
      r.languages.javascript ? "script" : "tag",
      {
        "asp-script": {
          pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
          lookbehind: !0,
          alias: ["asp", "script"],
          inside: r.languages.csharp || {}
        }
      }
    );
  }
  return oS;
}
var lS, c6;
function p2e() {
  if (c6) return lS;
  c6 = 1, lS = e, e.displayName = "autohotkey", e.aliases = [];
  function e(t) {
    t.languages.autohotkey = {
      comment: [
        {
          pattern: /(^|\s);.*/,
          lookbehind: !0
        },
        {
          pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
          lookbehind: !0,
          greedy: !0
        }
      ],
      tag: {
        // labels
        pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
        lookbehind: !0
      },
      string: /"(?:[^"\n\r]|"")*"/,
      variable: /%\w+%/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
      boolean: /\b(?:false|true)\b/,
      selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
      constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
      builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
      symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
      important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
      keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
      function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
      punctuation: /[{}[\]():,]/
    };
  }
  return lS;
}
var uS, d6;
function h2e() {
  if (d6) return uS;
  d6 = 1, uS = e, e.displayName = "autoit", e.aliases = [];
  function e(t) {
    t.languages.autoit = {
      comment: [
        /;.*/,
        {
          // The multi-line comments delimiters can actually be commented out with ";"
          pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
          lookbehind: !0
        }
      ],
      url: {
        pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
        lookbehind: !0
      },
      string: {
        pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
        greedy: !0,
        inside: {
          variable: /([%$@])\w+\1/
        }
      },
      directive: {
        pattern: /(^[\t ]*)#[\w-]+/m,
        lookbehind: !0,
        alias: "keyword"
      },
      function: /\b\w+(?=\()/,
      // Variables and macros
      variable: /[$@]\w+/,
      keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      boolean: /\b(?:False|True)\b/i,
      operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
      punctuation: /[\[\]().,:]/
    };
  }
  return uS;
}
var cS, f6;
function m2e() {
  if (f6) return cS;
  f6 = 1, cS = e, e.displayName = "avisynth", e.aliases = ["avs"];
  function e(t) {
    (function(r) {
      function n(c, d) {
        return c.replace(/<<(\d+)>>/g, function(p, f) {
          return d[+f];
        });
      }
      function a(c, d, p) {
        return RegExp(n(c, d), p);
      }
      var s = /bool|clip|float|int|string|val/.source, i = [
        // bools
        /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
        // control
        /apply|assert|default|eval|import|nop|select|undefined/.source,
        // global
        /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
        // conv
        /hex(?:value)?|value/.source,
        // numeric
        /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
        // trig
        /a?sinh?|a?cosh?|a?tan[2h]?/.source,
        // bit
        /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
        // runtime
        /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
        // script
        /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
        // string
        /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
        // version
        /isversionorgreater|version(?:number|string)/.source,
        // helper
        /buildpixeltype|colorspacenametopixeltype/.source,
        // avsplus
        /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
      ].join("|"), o = [
        // content
        /has(?:audio|video)/.source,
        // resolution
        /height|width/.source,
        // framerate
        /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
        // interlacing
        /getparity|is(?:field|frame)based/.source,
        // color format
        /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
        // audio
        /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
      ].join("|"), l = [
        // source
        /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
        // color
        /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
        // overlay
        /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
        // geometry
        /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
        // pixel
        /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
        // timeline
        /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
        // interlace
        /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
        // audio
        /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
        // conditional
        /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
        // export
        /imagewriter/.source,
        // debug
        /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
      ].join("|"), u = [i, o, l].join("|");
      r.languages.avisynth = {
        comment: [
          {
            // Matches [* *] nestable block comments, but only supports 1 level of nested comments
            // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
            pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // Matches /* */ block comments
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // Matches # comments
            pattern: /(^|[^\\$])#.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        // Handle before strings because optional arguments are surrounded by double quotes
        argument: {
          pattern: a(/\b(?:<<0>>)\s+("?)\w+\1/.source, [s], "i"),
          inside: {
            keyword: /^\w+/
          }
        },
        // Optional argument assignment
        "argument-label": {
          pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
          lookbehind: !0,
          inside: {
            "argument-name": {
              pattern: /^\w+/,
              alias: "punctuation"
            },
            punctuation: /=$/
          }
        },
        string: [
          {
            // triple double-quoted
            pattern: /"""[\s\S]*?"""/,
            greedy: !0
          },
          {
            // single double-quoted
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: !0,
            inside: {
              constant: {
                // These *are* case-sensitive!
                pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
              }
            }
          }
        ],
        // The special "last" variable that takes the value of the last implicitly returned clip
        variable: /\b(?:last)\b/i,
        boolean: /\b(?:false|no|true|yes)\b/i,
        keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
        constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
        // AviSynth's internal functions, filters, and properties
        "builtin-function": {
          pattern: a(/\b(?:<<0>>)\b/.source, [u], "i"),
          alias: "function"
        },
        "type-cast": {
          pattern: a(/\b(?:<<0>>)(?=\s*\()/.source, [s], "i"),
          alias: "keyword"
        },
        // External/user-defined filters
        function: {
          pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
          lookbehind: !0
        },
        // Matches a \ as the first or last character on a line
        "line-continuation": {
          pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
        operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
        punctuation: /[{}\[\]();,.]/
      }, r.languages.avs = r.languages.avisynth;
    })(t);
  }
  return cS;
}
var dS, p6;
function g2e() {
  if (p6) return dS;
  p6 = 1, dS = e, e.displayName = "avroIdl", e.aliases = [];
  function e(t) {
    t.languages["avro-idl"] = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: !0,
        greedy: !0
      },
      annotation: {
        pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
        greedy: !0,
        alias: "function"
      },
      "function-identifier": {
        pattern: /`[^\r\n`]+`(?=\s*\()/,
        greedy: !0,
        alias: "function"
      },
      identifier: {
        pattern: /`[^\r\n`]+`/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: [
        {
          pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
          lookbehind: !0
        },
        /-?\b(?:Infinity|NaN)\b/
      ],
      operator: /=/,
      punctuation: /[()\[\]{}<>.:,;-]/
    }, t.languages.avdl = t.languages["avro-idl"];
  }
  return dS;
}
var fS, h6;
function DW() {
  if (h6) return fS;
  h6 = 1, fS = e, e.displayName = "bash", e.aliases = ["shell"];
  function e(t) {
    (function(r) {
      var n = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", a = {
        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
        lookbehind: !0,
        alias: "punctuation",
        // this looks reasonably well in all themes
        inside: null
        // see below
      }, s = {
        bash: a,
        environment: {
          pattern: RegExp("\\$" + n),
          alias: "constant"
        },
        variable: [
          // [0]: Arithmetic Environment
          {
            pattern: /\$?\(\([\s\S]+?\)\)/,
            greedy: !0,
            inside: {
              // If there is a $ sign at the beginning highlight $(( and )) as variable
              variable: [
                {
                  pattern: /(^\$\(\([\s\S]+)\)\)/,
                  lookbehind: !0
                },
                /^\$\(\(/
              ],
              number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
              // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
              operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
              // If there is no $ sign at the beginning highlight (( and )) as punctuation
              punctuation: /\(\(?|\)\)?|,|;/
            }
          },
          // [1]: Command Substitution
          {
            pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
            greedy: !0,
            inside: {
              variable: /^\$\(|^`|\)$|`$/
            }
          },
          // [2]: Brace expansion
          {
            pattern: /\$\{[^}]+\}/,
            greedy: !0,
            inside: {
              operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
              punctuation: /[\[\]]/,
              environment: {
                pattern: RegExp("(\\{)" + n),
                lookbehind: !0,
                alias: "constant"
              }
            }
          },
          /\$(?:\w+|[#?*!@$])/
        ],
        // Escape sequences from echo and printf's manuals, and escaped quotes.
        entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
      };
      r.languages.bash = {
        shebang: {
          pattern: /^#!\s*\/.*/,
          alias: "important"
        },
        comment: {
          pattern: /(^|[^"{\\$])#.*/,
          lookbehind: !0
        },
        "function-name": [
          // a) function foo {
          // b) foo() {
          // c) function foo() {
          // but not “foo {”
          {
            // a) and c)
            pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
            lookbehind: !0,
            alias: "function"
          },
          {
            // b)
            pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
            alias: "function"
          }
        ],
        // Highlight variable names as variables in for and select beginnings.
        "for-or-select": {
          pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
          alias: "variable",
          lookbehind: !0
        },
        // Highlight variable names as variables in the left-hand part
        // of assignments (“=” and “+=”).
        "assign-left": {
          pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
          inside: {
            environment: {
              pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + n),
              lookbehind: !0,
              alias: "constant"
            }
          },
          alias: "variable",
          lookbehind: !0
        },
        string: [
          // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
          {
            pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
            lookbehind: !0,
            greedy: !0,
            inside: s
          },
          // Here-document with quotes around the tag
          // → No expansion (so no “inside”).
          {
            pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
            lookbehind: !0,
            greedy: !0,
            inside: {
              bash: a
            }
          },
          // “Normal” string
          {
            // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
            pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
            lookbehind: !0,
            greedy: !0,
            inside: s
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
            pattern: /(^|[^$\\])'[^']*'/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
            pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
            greedy: !0,
            inside: {
              entity: s.entity
            }
          }
        ],
        environment: {
          pattern: RegExp("\\$?" + n),
          alias: "constant"
        },
        variable: s.variable,
        function: {
          pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        keyword: {
          pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
        builtin: {
          pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
          lookbehind: !0,
          // Alias added to make those easier to distinguish from strings.
          alias: "class-name"
        },
        boolean: {
          pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        "file-descriptor": {
          pattern: /\B&\d\b/,
          alias: "important"
        },
        operator: {
          // Lots of redirections here, but not just that.
          pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
          inside: {
            "file-descriptor": {
              pattern: /^\d/,
              alias: "important"
            }
          }
        },
        punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
        number: {
          pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
          lookbehind: !0
        }
      }, a.inside = r.languages.bash;
      for (var i = [
        "comment",
        "function-name",
        "for-or-select",
        "assign-left",
        "string",
        "environment",
        "function",
        "keyword",
        "builtin",
        "boolean",
        "file-descriptor",
        "operator",
        "punctuation",
        "number"
      ], o = s.variable[1].inside, l = 0; l < i.length; l++)
        o[i[l]] = r.languages.bash[i[l]];
      r.languages.shell = r.languages.bash;
    })(t);
  }
  return fS;
}
var pS, m6;
function OW() {
  if (m6) return pS;
  m6 = 1, pS = e, e.displayName = "basic", e.aliases = [];
  function e(t) {
    t.languages.basic = {
      comment: {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          keyword: /^REM/i
        }
      },
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: !0
      },
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
      function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
      operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
      punctuation: /[,;:()]/
    };
  }
  return pS;
}
var hS, g6;
function b2e() {
  if (g6) return hS;
  g6 = 1, hS = e, e.displayName = "batch", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /%%?[~:\w]+%?|!\S+!/, a = {
        pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
        alias: "attr-name",
        inside: {
          punctuation: /:/
        }
      }, s = /"(?:[\\"]"|[^"])*"(?!")/, i = /(?:\b|-)\d+\b/;
      r.languages.batch = {
        comment: [
          /^::.*/m,
          {
            pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
            lookbehind: !0
          }
        ],
        label: {
          pattern: /^:.*/m,
          alias: "property"
        },
        command: [
          {
            // FOR command
            pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
            lookbehind: !0,
            inside: {
              keyword: /\b(?:do|in)\b|^for\b/i,
              string: s,
              parameter: a,
              variable: n,
              number: i,
              punctuation: /[()',]/
            }
          },
          {
            // IF command
            pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
            lookbehind: !0,
            inside: {
              keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
              string: s,
              parameter: a,
              variable: n,
              number: i,
              operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
            }
          },
          {
            // ELSE command
            pattern: /((?:^|[&()])[ \t]*)else\b/im,
            lookbehind: !0,
            inside: {
              keyword: /^else\b/i
            }
          },
          {
            // SET command
            pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
            lookbehind: !0,
            inside: {
              keyword: /^set\b/i,
              string: s,
              parameter: a,
              variable: [n, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
              number: i,
              operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
              punctuation: /[()',]/
            }
          },
          {
            // Other commands
            pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
            lookbehind: !0,
            inside: {
              keyword: /^\w+\b/,
              string: s,
              parameter: a,
              label: {
                pattern: /(^\s*):\S+/m,
                lookbehind: !0,
                alias: "property"
              },
              variable: n,
              number: i,
              operator: /\^/
            }
          }
        ],
        operator: /[&@]/,
        punctuation: /[()']/
      };
    })(t);
  }
  return hS;
}
var mS, b6;
function y2e() {
  if (b6) return mS;
  b6 = 1, mS = e, e.displayName = "bbcode", e.aliases = ["shortcode"];
  function e(t) {
    t.languages.bbcode = {
      tag: {
        pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
        inside: {
          tag: {
            pattern: /^\[\/?[^\s=\]]+/,
            inside: {
              punctuation: /^\[\/?/
            }
          },
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
            inside: {
              punctuation: [
                /^=/,
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\]/,
          "attr-name": /[^\s=\]]+/
        }
      }
    }, t.languages.shortcode = t.languages.bbcode;
  }
  return mS;
}
var gS, y6;
function v2e() {
  if (y6) return gS;
  y6 = 1, gS = e, e.displayName = "bicep", e.aliases = [];
  function e(t) {
    t.languages.bicep = {
      comment: [
        {
          // multiline comments eg /* ASDF */
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // singleline comments eg // ASDF
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      property: [
        {
          pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
          lookbehind: !0
        },
        {
          pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: [
        {
          pattern: /'''[^'][\s\S]*?'''/,
          greedy: !0
        },
        {
          pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      "interpolated-string": {
        pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}\r\n]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0
              },
              punctuation: /^\$\{|\}$/
            }
          },
          string: /[\s\S]+/
        }
      },
      datatype: {
        pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
        lookbehind: !0,
        alias: "class-name"
      },
      boolean: /\b(?:false|true)\b/,
      // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
      keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
      decorator: /@\w+\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.bicep["interpolated-string"].inside.interpolation.inside.expression.inside = t.languages.bicep;
  }
  return gS;
}
var bS, v6;
function w2e() {
  if (v6) return bS;
  v6 = 1, bS = e, e.displayName = "birb", e.aliases = [];
  function e(t) {
    t.languages.birb = t.languages.extend("clike", {
      string: {
        pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      "class-name": [
        /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
        // matches variable and function return types (parameters as well).
        /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
      ],
      keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
      variable: /\b[a-z_]\w*\b/
    }), t.languages.insertBefore("birb", "function", {
      metadata: {
        pattern: /<\w+>/,
        greedy: !0,
        alias: "symbol"
      }
    });
  }
  return bS;
}
var yS, w6;
function x2e() {
  if (w6) return yS;
  w6 = 1;
  var e = Wu();
  yS = t, t.displayName = "bison", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.bison = r.languages.extend("c", {}), r.languages.insertBefore("bison", "comment", {
      bison: {
        // This should match all the beginning of the file
        // including the prologue(s), the bison declarations and
        // the grammar rules.
        pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
        inside: {
          c: {
            // Allow for one level of nested braces
            pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
            inside: {
              delimiter: {
                pattern: /^%?\{|%?\}$/,
                alias: "punctuation"
              },
              "bison-variable": {
                pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
                alias: "variable",
                inside: {
                  punctuation: /<|>/
                }
              },
              rest: r.languages.c
            }
          },
          comment: r.languages.c.comment,
          string: r.languages.c.string,
          property: /\S+(?=:)/,
          keyword: /%\w+/,
          number: {
            pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
            lookbehind: !0
          },
          punctuation: /%[%?]|[|:;\[\]<>]/
        }
      }
    });
  }
  return yS;
}
var vS, x6;
function E2e() {
  if (x6) return vS;
  x6 = 1, vS = e, e.displayName = "bnf", e.aliases = ["rbnf"];
  function e(t) {
    t.languages.bnf = {
      string: {
        pattern: /"[^\r\n"]*"|'[^\r\n']*'/
      },
      definition: {
        pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
        alias: ["rule", "keyword"],
        inside: {
          punctuation: /^<|>$/
        }
      },
      rule: {
        pattern: /<[^<>\r\n\t]+>/,
        inside: {
          punctuation: /^<|>$/
        }
      },
      operator: /::=|[|()[\]{}*+?]|\.{3}/
    }, t.languages.rbnf = t.languages.bnf;
  }
  return vS;
}
var wS, E6;
function S2e() {
  if (E6) return wS;
  E6 = 1, wS = e, e.displayName = "brainfuck", e.aliases = [];
  function e(t) {
    t.languages.brainfuck = {
      pointer: {
        pattern: /<|>/,
        alias: "keyword"
      },
      increment: {
        pattern: /\+/,
        alias: "inserted"
      },
      decrement: {
        pattern: /-/,
        alias: "deleted"
      },
      branching: {
        pattern: /\[|\]/,
        alias: "important"
      },
      operator: /[.,]/,
      comment: /\S+/
    };
  }
  return wS;
}
var xS, S6;
function _2e() {
  if (S6) return xS;
  S6 = 1, xS = e, e.displayName = "brightscript", e.aliases = [];
  function e(t) {
    t.languages.brightscript = {
      comment: /(?:\brem|').*/i,
      "directive-statement": {
        pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
        lookbehind: !0,
        alias: "property",
        inside: {
          "error-message": {
            pattern: /(^#error).+/,
            lookbehind: !0
          },
          directive: {
            pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
            alias: "keyword"
          },
          expression: {
            pattern: /[\s\S]+/,
            inside: null
            // see below
          }
        }
      },
      property: {
        pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\bAs[\t ]+)\w+/i,
        lookbehind: !0
      },
      keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?!\d)\w+(?=[\t ]*\()/,
      number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
      operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
      punctuation: /[.,;()[\]{}]/,
      constant: /\b(?:LINE_NUM)\b/i
    }, t.languages.brightscript["directive-statement"].inside.expression.inside = t.languages.brightscript;
  }
  return xS;
}
var ES, _6;
function k2e() {
  if (_6) return ES;
  _6 = 1, ES = e, e.displayName = "bro", e.aliases = [];
  function e(t) {
    t.languages.bro = {
      comment: {
        pattern: /(^|[^\\$])#.*/,
        lookbehind: !0,
        inside: {
          italic: /\b(?:FIXME|TODO|XXX)\b/
        }
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      boolean: /\b[TF]\b/,
      function: {
        pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
        lookbehind: !0
      },
      builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
      constant: {
        pattern: /(\bconst[ \t]+)\w+/i,
        lookbehind: !0
      },
      keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
      operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return ES;
}
var SS, k6;
function C2e() {
  if (k6) return SS;
  k6 = 1, SS = e, e.displayName = "bsl", e.aliases = [];
  function e(t) {
    t.languages.bsl = {
      comment: /\/\/.*/,
      string: [
        // Строки
        // Strings
        {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: !0
        },
        // Дата и время
        // Date & time
        {
          pattern: /'(?:[^'\r\n\\]|\\.)*'/
        }
      ],
      keyword: [
        {
          // RU
          pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
          lookbehind: !0
        },
        {
          // EN
          pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
        }
      ],
      number: {
        pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
        lookbehind: !0
      },
      operator: [
        /[<>+\-*/]=?|[%=]/,
        // RU
        {
          pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
          lookbehind: !0
        },
        // EN
        {
          pattern: /\b(?:and|not|or)\b/i
        }
      ],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
      directive: [
        // Теги препроцессора вида &Клиент, &Сервер, ...
        // Preprocessor tags of the type &Client, &Server, ...
        {
          pattern: /^([ \t]*)&.*/m,
          lookbehind: !0,
          greedy: !0,
          alias: "important"
        },
        // Инструкции препроцессора вида:
        // #Если Сервер Тогда
        // ...
        // #КонецЕсли
        // Preprocessor instructions of the form:
        // #If Server Then
        // ...
        // #EndIf
        {
          pattern: /^([ \t]*)#.*/gm,
          lookbehind: !0,
          greedy: !0,
          alias: "important"
        }
      ]
    }, t.languages.oscript = t.languages.bsl;
  }
  return SS;
}
var _S, C6;
function A2e() {
  if (C6) return _S;
  C6 = 1, _S = e, e.displayName = "cfscript", e.aliases = [];
  function e(t) {
    t.languages.cfscript = t.languages.extend("clike", {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          inside: {
            annotation: {
              pattern: /(?:^|[^.])@[\w\.]+/,
              alias: "punctuation"
            }
          }
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
      operator: [
        /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
        /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
      ],
      scope: {
        pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
        alias: "global"
      },
      type: {
        pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
        alias: "builtin"
      }
    }), t.languages.insertBefore("cfscript", "keyword", {
      // This must be declared before keyword because we use "function" inside the lookahead
      "function-variable": {
        pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      }
    }), delete t.languages.cfscript["class-name"], t.languages.cfc = t.languages.cfscript;
  }
  return _S;
}
var kS, A6;
function T2e() {
  if (A6) return kS;
  A6 = 1;
  var e = dD();
  kS = t, t.displayName = "chaiscript", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.chaiscript = r.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        {
          // e.g. class Rectangle { ... }
          pattern: /(\bclass\s+)\w+/,
          lookbehind: !0
        },
        {
          // e.g. attr Rectangle::height, def Rectangle::area() { ... }
          pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
          lookbehind: !0
        }
      ],
      keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
      number: [r.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
      operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
    }), r.languages.insertBefore("chaiscript", "operator", {
      "parameter-type": {
        // e.g. def foo(int x, Vector y) {...}
        pattern: /([,(]\s*)\w+(?=\s+\w)/,
        lookbehind: !0,
        alias: "class-name"
      }
    }), r.languages.insertBefore("chaiscript", "string", {
      "string-interpolation": {
        pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
            lookbehind: !0,
            inside: {
              "interpolation-expression": {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0,
                inside: r.languages.chaiscript
              },
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
  }
  return kS;
}
var CS, T6;
function R2e() {
  if (T6) return CS;
  T6 = 1, CS = e, e.displayName = "cil", e.aliases = [];
  function e(t) {
    t.languages.cil = {
      comment: /\/\/.*/,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      directive: {
        pattern: /(^|\W)\.[a-z]+(?=\s)/,
        lookbehind: !0,
        alias: "class-name"
      },
      // Actually an assembly reference
      variable: /\[[\w\.]+\]/,
      keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
      function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
      punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
    };
  }
  return CS;
}
var AS, R6;
function I2e() {
  if (R6) return AS;
  R6 = 1, AS = e, e.displayName = "clojure", e.aliases = [];
  function e(t) {
    t.languages.clojure = {
      comment: {
        pattern: /;.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: !0
      },
      char: /\\\w+/,
      symbol: {
        pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
        lookbehind: !0
      },
      boolean: /\b(?:false|nil|true)\b/,
      number: {
        pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
        lookbehind: !0
      },
      function: {
        pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
        lookbehind: !0
      },
      operator: /[#@^`~]/,
      punctuation: /[{}\[\](),]/
    };
  }
  return AS;
}
var TS, I6;
function N2e() {
  if (I6) return TS;
  I6 = 1, TS = e, e.displayName = "cmake", e.aliases = [];
  function e(t) {
    t.languages.cmake = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
            inside: {
              punctuation: /\$\{|\}/,
              variable: /\w+/
            }
          }
        }
      },
      variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
      property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
      keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
      boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
      namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
      operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
      inserted: {
        pattern: /\b\w+::\w+\b/,
        alias: "class-name"
      },
      number: /\b\d+(?:\.\d+)*\b/,
      function: /\b[a-z_]\w*(?=\s*\()\b/i,
      punctuation: /[()>}]|\$[<{]/
    };
  }
  return TS;
}
var RS, N6;
function D2e() {
  if (N6) return RS;
  N6 = 1, RS = e, e.displayName = "cobol", e.aliases = [];
  function e(t) {
    t.languages.cobol = {
      comment: {
        pattern: /\*>.*|(^[ \t]*)\*.*/m,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
        greedy: !0
      },
      level: {
        pattern: /(^[ \t]*)\d+\b/m,
        lookbehind: !0,
        greedy: !0,
        alias: "number"
      },
      "class-name": {
        // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
        pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
        lookbehind: !0,
        inside: {
          number: {
            pattern: /(\()\d+/,
            lookbehind: !0
          },
          punctuation: /[()]/
        }
      },
      keyword: {
        pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
        lookbehind: !0
      },
      number: {
        pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
        lookbehind: !0
      },
      operator: [
        /<>|[<>]=?|[=+*/&]/,
        {
          pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
          lookbehind: !0
        }
      ],
      punctuation: /[.:,()]/
    };
  }
  return RS;
}
var IS, D6;
function O2e() {
  if (D6) return IS;
  D6 = 1, IS = e, e.displayName = "coffeescript", e.aliases = ["coffee"];
  function e(t) {
    (function(r) {
      var n = /#(?!\{).+/, a = {
        pattern: /#\{[^}]+\}/,
        alias: "variable"
      };
      r.languages.coffeescript = r.languages.extend("javascript", {
        comment: n,
        string: [
          // Strings are multiline
          {
            pattern: /'(?:\\[\s\S]|[^\\'])*'/,
            greedy: !0
          },
          {
            // Strings are multiline
            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
            greedy: !0,
            inside: {
              interpolation: a
            }
          }
        ],
        keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
        "class-member": {
          pattern: /@(?!\d)\w+/,
          alias: "variable"
        }
      }), r.languages.insertBefore("coffeescript", "comment", {
        "multiline-comment": {
          pattern: /###[\s\S]+?###/,
          alias: "comment"
        },
        // Block regexp can contain comments and interpolation
        "block-regex": {
          pattern: /\/{3}[\s\S]*?\/{3}/,
          alias: "regex",
          inside: {
            comment: n,
            interpolation: a
          }
        }
      }), r.languages.insertBefore("coffeescript", "string", {
        "inline-javascript": {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          inside: {
            delimiter: {
              pattern: /^`|`$/,
              alias: "punctuation"
            },
            script: {
              pattern: /[\s\S]+/,
              alias: "language-javascript",
              inside: r.languages.javascript
            }
          }
        },
        // Block strings
        "multiline-string": [
          {
            pattern: /'''[\s\S]*?'''/,
            greedy: !0,
            alias: "string"
          },
          {
            pattern: /"""[\s\S]*?"""/,
            greedy: !0,
            alias: "string",
            inside: {
              interpolation: a
            }
          }
        ]
      }), r.languages.insertBefore("coffeescript", "keyword", {
        // Object property
        property: /(?!\d)\w+(?=\s*:(?!:))/
      }), delete r.languages.coffeescript["template-string"], r.languages.coffee = r.languages.coffeescript;
    })(t);
  }
  return IS;
}
var NS, O6;
function P2e() {
  if (O6) return NS;
  O6 = 1, NS = e, e.displayName = "concurnas", e.aliases = ["conc"];
  function e(t) {
    t.languages.concurnas = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
        lookbehind: !0,
        greedy: !0
      },
      langext: {
        pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
        greedy: !0,
        inside: {
          "class-name": /^\w+/,
          string: {
            pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
            lookbehind: !0
          },
          punctuation: /\|\|/
        }
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
        lookbehind: !0
      },
      keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
      punctuation: /[{}[\];(),.:]/,
      operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
      annotation: {
        pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
        alias: "builtin"
      }
    }, t.languages.insertBefore("concurnas", "langext", {
      "regex-literal": {
        pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: t.languages.concurnas
          },
          regex: /[\s\S]+/
        }
      },
      "string-literal": {
        pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: t.languages.concurnas
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.conc = t.languages.concurnas;
  }
  return NS;
}
var DS, P6;
function L2e() {
  if (P6) return DS;
  P6 = 1, DS = e, e.displayName = "coq", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var n = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source, a = 0; a < 2; a++)
        n = n.replace(/<self>/g, function() {
          return n;
        });
      n = n.replace(/<self>/g, "[]"), r.languages.coq = {
        comment: RegExp(n),
        string: {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: !0
        },
        attribute: [
          {
            pattern: RegExp(
              /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
                /<comment>/g,
                function() {
                  return n;
                }
              )
            ),
            greedy: !0,
            alias: "attr-name",
            inside: {
              comment: RegExp(n),
              string: {
                pattern: /"(?:[^"]|"")*"(?!")/,
                greedy: !0
              },
              operator: /=/,
              punctuation: /^#\[|\]$|[,()]/
            }
          },
          {
            pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
            alias: "attr-name"
          }
        ],
        keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
        number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
        punct: {
          pattern: /@\{|\{\||\[=|:>/,
          alias: "punctuation"
        },
        operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
        punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
      };
    })(t);
  }
  return DS;
}
var OS, L6;
function vy() {
  if (L6) return OS;
  L6 = 1, OS = e, e.displayName = "ruby", e.aliases = ["rb"];
  function e(t) {
    (function(r) {
      r.languages.ruby = r.languages.extend("clike", {
        comment: {
          pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
          greedy: !0
        },
        "class-name": {
          pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
          lookbehind: !0,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
        operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
        punctuation: /[(){}[\].,;]/
      }), r.languages.insertBefore("ruby", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      var n = {
        pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
        lookbehind: !0,
        inside: {
          content: {
            pattern: /^(#\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: r.languages.ruby
          },
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          }
        }
      };
      delete r.languages.ruby.function;
      var a = "(?:" + [
        /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
        /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
        /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
        /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
        /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
      ].join("|") + ")", s = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
      r.languages.insertBefore("ruby", "keyword", {
        "regex-literal": [
          {
            pattern: RegExp(
              /%r/.source + a + /[egimnosux]{0,6}/.source
            ),
            greedy: !0,
            inside: {
              interpolation: n,
              regex: /[\s\S]+/
            }
          },
          {
            pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
            lookbehind: !0,
            greedy: !0,
            inside: {
              interpolation: n,
              regex: /[\s\S]+/
            }
          }
        ],
        variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        symbol: [
          {
            pattern: RegExp(/(^|[^:]):/.source + s),
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: RegExp(
              /([\r\n{(,][ \t]*)/.source + s + /(?=:(?!:))/.source
            ),
            lookbehind: !0,
            greedy: !0
          }
        ],
        "method-definition": {
          pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
          lookbehind: !0,
          inside: {
            function: /\b\w+$/,
            keyword: /^self\b/,
            "class-name": /^\w+/,
            punctuation: /\./
          }
        }
      }), r.languages.insertBefore("ruby", "string", {
        "string-literal": [
          {
            pattern: RegExp(/%[qQiIwWs]?/.source + a),
            greedy: !0,
            inside: {
              interpolation: n,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
            greedy: !0,
            inside: {
              interpolation: n,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: !0,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?/
                }
              },
              interpolation: n,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: !0,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?'|'$/
                }
              },
              string: /[\s\S]+/
            }
          }
        ],
        "command-literal": [
          {
            pattern: RegExp(/%x/.source + a),
            greedy: !0,
            inside: {
              interpolation: n,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          },
          {
            pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
            greedy: !0,
            inside: {
              interpolation: n,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          }
        ]
      }), delete r.languages.ruby.string, r.languages.insertBefore("ruby", "number", {
        builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
        constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
      }), r.languages.rb = r.languages.ruby;
    })(t);
  }
  return OS;
}
var PS, M6;
function M2e() {
  if (M6) return PS;
  M6 = 1;
  var e = vy();
  PS = t, t.displayName = "crystal", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      n.languages.crystal = n.languages.extend("ruby", {
        keyword: [
          /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
          {
            pattern: /(\.\s*)(?:is_a|responds_to)\?/,
            lookbehind: !0
          }
        ],
        number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
        operator: [/->/, n.languages.ruby.operator],
        punctuation: /[(){}[\].,;\\]/
      }), n.languages.insertBefore("crystal", "string-literal", {
        attribute: {
          pattern: /@\[.*?\]/,
          inside: {
            delimiter: {
              pattern: /^@\[|\]$/,
              alias: "punctuation"
            },
            attribute: {
              pattern: /^(\s*)\w+/,
              lookbehind: !0,
              alias: "class-name"
            },
            args: {
              pattern: /\S(?:[\s\S]*\S)?/,
              inside: n.languages.crystal
            }
          }
        },
        expansion: {
          pattern: /\{(?:\{.*?\}|%.*?%)\}/,
          inside: {
            content: {
              pattern: /^(\{.)[\s\S]+(?=.\}$)/,
              lookbehind: !0,
              inside: n.languages.crystal
            },
            delimiter: {
              pattern: /^\{[\{%]|[\}%]\}$/,
              alias: "operator"
            }
          }
        },
        char: {
          pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
          greedy: !0
        }
      });
    }(r);
  }
  return PS;
}
var LS, F6;
function F2e() {
  if (F6) return LS;
  F6 = 1;
  var e = yy();
  LS = t, t.displayName = "cshtml", t.aliases = ["razor"];
  function t(r) {
    r.register(e), function(n) {
      var a = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source, s = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
      function i(y, b) {
        for (var v = 0; v < b; v++)
          y = y.replace(/<self>/g, function() {
            return "(?:" + y + ")";
          });
        return y.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + s + ")").replace(/<comment>/g, "(?:" + a + ")");
      }
      var o = i(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2), l = i(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2), u = i(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2), c = i(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2), d = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source, p = /(?!\d)[^\s>\/=$<%]+/.source + d + /\s*\/?>/.source, f = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + d + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
      // eslint-disable-next-line regexp/strict
      /<\/?(?!\1\b)/.source + p + "|" + // nested start tag
      i(
        // eslint-disable-next-line regexp/strict
        /<\1/.source + d + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
        // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + p + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
        /<\/\1\s*>/.source,
        2
      )) + ")*" + // eslint-disable-next-line regexp/strict
      /<\/\1\s*>/.source + "|" + /</.source + p + ")";
      n.languages.cshtml = n.languages.extend("markup", {});
      var h = n.languages.insertBefore(
        "csharp",
        "string",
        {
          html: {
            pattern: RegExp(f),
            greedy: !0,
            inside: n.languages.cshtml
          }
        },
        {
          csharp: n.languages.extend("csharp", {})
        }
      ), m = {
        pattern: /\S[\s\S]*/,
        alias: "language-csharp",
        inside: h
      };
      n.languages.insertBefore("cshtml", "prolog", {
        "razor-comment": {
          pattern: /@\*[\s\S]*?\*@/,
          greedy: !0,
          alias: "comment"
        },
        block: {
          pattern: RegExp(
            /(^|[^@])@/.source + "(?:" + [
              // @{ ... }
              u,
              // @code{ ... }
              /(?:code|functions)\s*/.source + u,
              // @for (...) { ... }
              /(?:for|foreach|lock|switch|using|while)\s*/.source + o + /\s*/.source + u,
              // @do { ... } while (...);
              /do\s*/.source + u + /\s*while\s*/.source + o + /(?:\s*;)?/.source,
              // @try { ... } catch (...) { ... } finally { ... }
              /try\s*/.source + u + /\s*catch\s*/.source + o + /\s*/.source + u + /\s*finally\s*/.source + u,
              // @if (...) {...} else if (...) {...} else {...}
              /if\s*/.source + o + /\s*/.source + u + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + o + ")?" + /\s*/.source + u + ")*"
            ].join("|") + ")"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^@\w*/,
            csharp: m
          }
        },
        directive: {
          pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^@\w+/,
            csharp: m
          }
        },
        value: {
          pattern: RegExp(
            /(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + o + ")(?:" + /[?!]?\.\w+\b/.source + "|" + o + "|" + l + "|" + c + o + ")*"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "variable",
          inside: {
            keyword: /^@/,
            csharp: m
          }
        },
        "delegate-operator": {
          pattern: /(^|[^@])@(?=<)/,
          lookbehind: !0,
          alias: "operator"
        }
      }), n.languages.razor = n.languages.cshtml;
    }(r);
  }
  return LS;
}
var MS, $6;
function $2e() {
  if ($6) return MS;
  $6 = 1, MS = e, e.displayName = "csp", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(a) {
        return RegExp(
          /([ \t])/.source + "(?:" + a + ")" + /(?=[\s;]|$)/.source,
          "i"
        );
      }
      r.languages.csp = {
        directive: {
          pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
          lookbehind: !0,
          alias: "property"
        },
        scheme: {
          pattern: n(/[a-z][a-z0-9.+-]*:/.source),
          lookbehind: !0
        },
        none: {
          pattern: n(/'none'/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        nonce: {
          pattern: n(/'nonce-[-+/\w=]+'/.source),
          lookbehind: !0,
          alias: "number"
        },
        hash: {
          pattern: n(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
          lookbehind: !0,
          alias: "number"
        },
        host: {
          pattern: n(
            /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
          ),
          lookbehind: !0,
          alias: "url",
          inside: {
            important: /\*/
          }
        },
        keyword: [
          {
            pattern: n(/'unsafe-[a-z-]+'/.source),
            lookbehind: !0,
            alias: "unsafe"
          },
          {
            pattern: n(/'[a-z-]+'/.source),
            lookbehind: !0,
            alias: "safe"
          }
        ],
        punctuation: /;/
      };
    })(t);
  }
  return MS;
}
var FS, B6;
function B2e() {
  if (B6) return FS;
  B6 = 1, FS = e, e.displayName = "cssExtras", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, a;
      r.languages.css.selector = {
        pattern: r.languages.css.selector.pattern,
        lookbehind: !0,
        inside: a = {
          "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
          "pseudo-class": /:[-\w]+/,
          class: /\.[-\w]+/,
          id: /#[-\w]+/,
          attribute: {
            pattern: RegExp(`\\[(?:[^[\\]"']|` + n.source + ")*\\]"),
            greedy: !0,
            inside: {
              punctuation: /^\[|\]$/,
              "case-sensitivity": {
                pattern: /(\s)[si]$/i,
                lookbehind: !0,
                alias: "keyword"
              },
              namespace: {
                pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                lookbehind: !0,
                inside: {
                  punctuation: /\|$/
                }
              },
              "attr-name": {
                pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                lookbehind: !0
              },
              "attr-value": [
                n,
                {
                  pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                  lookbehind: !0
                }
              ],
              operator: /[|~*^$]?=/
            }
          },
          "n-th": [
            {
              pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
              lookbehind: !0,
              inside: {
                number: /[\dn]+/,
                operator: /[+-]/
              }
            },
            {
              pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
              lookbehind: !0
            }
          ],
          combinator: />|\+|~|\|\|/,
          // the `tag` token has been existed and removed.
          // because we can't find a perfect tokenize to match it.
          // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
          punctuation: /[(),]/
        }
      }, r.languages.css.atrule.inside["selector-function-argument"].inside = a, r.languages.insertBefore("css", "property", {
        variable: {
          pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
          lookbehind: !0
        }
      });
      var s = {
        pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
        lookbehind: !0
      }, i = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: !0
      };
      r.languages.insertBefore("css", "function", {
        operator: {
          pattern: /(\s)[+\-*\/](?=\s)/,
          lookbehind: !0
        },
        // CAREFUL!
        // Previewers and Inline color use hexcode and color.
        hexcode: {
          pattern: /\B#[\da-f]{3,8}\b/i,
          alias: "color"
        },
        color: [
          {
            pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
            lookbehind: !0
          },
          {
            pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
            inside: {
              unit: s,
              number: i,
              function: /[\w-]+(?=\()/,
              punctuation: /[(),]/
            }
          }
        ],
        // it's important that there is no boundary assertion after the hex digits
        entity: /\\[\da-f]{1,8}/i,
        unit: s,
        number: i
      });
    })(t);
  }
  return FS;
}
var $S, U6;
function U2e() {
  if (U6) return $S;
  U6 = 1, $S = e, e.displayName = "csv", e.aliases = [];
  function e(t) {
    t.languages.csv = {
      value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
      punctuation: /,/
    };
  }
  return $S;
}
var BS, z6;
function z2e() {
  if (z6) return BS;
  z6 = 1, BS = e, e.displayName = "cypher", e.aliases = [];
  function e(t) {
    t.languages.cypher = {
      // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
      comment: /\/\/.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
        greedy: !0
      },
      "class-name": {
        pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
        lookbehind: !0,
        greedy: !0
      },
      relationship: {
        pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      identifier: {
        pattern: /`(?:[^`\\\r\n])*`/,
        greedy: !0
      },
      variable: /\$\w+/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
      keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
      function: /\b\w+\b(?=\s*\()/,
      boolean: /\b(?:false|null|true)\b/i,
      number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
      operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
      punctuation: /[()[\]{},;.]/
    };
  }
  return BS;
}
var US, q6;
function q2e() {
  if (q6) return US;
  q6 = 1, US = e, e.displayName = "d", e.aliases = [];
  function e(t) {
    t.languages.d = t.languages.extend("clike", {
      comment: [
        {
          // Shebang
          pattern: /^\s*#!.+/,
          greedy: !0
        },
        {
          pattern: RegExp(
            /(^|[^\\])/.source + "(?:" + [
              // /+ comment +/
              // Allow one level of nesting
              /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
              // // comment
              /\/\/.*/.source,
              // /* comment */
              /\/\*[\s\S]*?\*\//.source
            ].join("|") + ")"
          ),
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: [
        {
          pattern: RegExp(
            [
              // r"", x""
              /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
              // q"[]", q"()", q"<>", q"{}"
              /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
              // q"IDENT
              // ...
              // IDENT"
              /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
              // q"//", q"||", etc.
              // eslint-disable-next-line regexp/strict
              /\bq"(.)[\s\S]*?\2"/.source,
              // eslint-disable-next-line regexp/strict
              /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
            ].join("|"),
            "m"
          ),
          greedy: !0
        },
        {
          pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
          greedy: !0,
          alias: "token-string"
        }
      ],
      // In order: $, keywords and special tokens, globally defined symbols
      keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
      number: [
        // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
        // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
        /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
        {
          pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
          lookbehind: !0
        }
      ],
      operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
    }), t.languages.insertBefore("d", "string", {
      // Characters
      // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
      char: /'(?:\\(?:\W|\w+)|[^\\])'/
    }), t.languages.insertBefore("d", "keyword", {
      property: /\B@\w*/
    }), t.languages.insertBefore("d", "function", {
      register: {
        // Iasm registers
        pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
        alias: "variable"
      }
    });
  }
  return US;
}
var zS, j6;
function j2e() {
  if (j6) return zS;
  j6 = 1, zS = e, e.displayName = "dart", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = [
        /\b(?:async|sync|yield)\*/,
        /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
      ], a = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, s = {
        pattern: RegExp(a + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: !0,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          }
        }
      };
      r.languages.dart = r.languages.extend("clike", {
        "class-name": [
          s,
          {
            // variables and parameters
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(
              a + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
            ),
            lookbehind: !0,
            inside: s.inside
          }
        ],
        keyword: n,
        operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
      }), r.languages.insertBefore("dart", "string", {
        "string-literal": {
          pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
              lookbehind: !0,
              inside: {
                punctuation: /^\$\{?|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  inside: r.languages.dart
                }
              }
            },
            string: /[\s\S]+/
          }
        },
        string: void 0
      }), r.languages.insertBefore("dart", "class-name", {
        metadata: {
          pattern: /@\w+/,
          alias: "function"
        }
      }), r.languages.insertBefore("dart", "class-name", {
        generics: {
          pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
          inside: {
            "class-name": s,
            keyword: n,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        }
      });
    })(t);
  }
  return zS;
}
var qS, H6;
function H2e() {
  if (H6) return qS;
  H6 = 1, qS = e, e.displayName = "dataweave", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.dataweave = {
        url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
        property: {
          pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
          greedy: !0
        },
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: !0
        },
        "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
        date: {
          pattern: /\|[\w:+-]+\|/,
          greedy: !0
        },
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        regex: {
          pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
          greedy: !0
        },
        keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
        function: /\b[A-Z_]\w*(?=\s*\()/i,
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\];(),.:@]/,
        operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
        boolean: /\b(?:false|true)\b/
      };
    })(t);
  }
  return qS;
}
var jS, V6;
function V2e() {
  if (V6) return jS;
  V6 = 1, jS = e, e.displayName = "dax", e.aliases = [];
  function e(t) {
    t.languages.dax = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
        lookbehind: !0
      },
      "data-field": {
        pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
        alias: "symbol"
      },
      measure: {
        pattern: /\[[ \w\xA0-\uFFFF]+\]/,
        alias: "constant"
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
      keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
      boolean: {
        pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
        alias: "constant"
      },
      number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
      operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
      punctuation: /[;\[\](){}`,.]/
    };
  }
  return jS;
}
var HS, G6;
function G2e() {
  if (G6) return HS;
  G6 = 1, HS = e, e.displayName = "dhall", e.aliases = [];
  function e(t) {
    t.languages.dhall = {
      // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
      // The multi-line pattern is essentially this:
      //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
      comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
      string: {
        pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0,
                alias: "language-dhall",
                inside: null
                // see blow
              },
              punctuation: /\$\{|\}/
            }
          }
        }
      },
      label: {
        pattern: /`[^`]*`/,
        greedy: !0
      },
      url: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
        pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
        greedy: !0
      },
      env: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
        pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
        greedy: !0,
        inside: {
          function: /^env/,
          operator: /^:/,
          variable: /[\s\S]+/
        }
      },
      hash: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
        pattern: /\bsha256:[\da-fA-F]{64}\b/,
        inside: {
          function: /sha256/,
          operator: /:/,
          number: /[\da-fA-F]{64}/
        }
      },
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
      keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
      builtin: /\b(?:None|Some)\b/,
      boolean: /\b(?:False|True)\b/,
      number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
      operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
      punctuation: /\.\.|[{}\[\](),./]/,
      // we'll just assume that every capital word left is a type name
      "class-name": /\b[A-Z]\w*\b/
    }, t.languages.dhall.string.inside.interpolation.inside.expression.inside = t.languages.dhall;
  }
  return HS;
}
var VS, W6;
function W2e() {
  if (W6) return VS;
  W6 = 1, VS = e, e.displayName = "diff", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.diff = {
        coord: [
          // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
          /^(?:\*{3}|-{3}|\+{3}).*$/m,
          // Match "@@ ... @@" coord lines in unified diff.
          /^@@.*@@$/m,
          // Match coord lines in normal diff (starts with a number).
          /^\d.*$/m
        ]
        // deleted, inserted, unchanged, diff
      };
      var n = {
        "deleted-sign": "-",
        "deleted-arrow": "<",
        "inserted-sign": "+",
        "inserted-arrow": ">",
        unchanged: " ",
        diff: "!"
      };
      Object.keys(n).forEach(function(a) {
        var s = n[a], i = [];
        /^\w+$/.test(a) || i.push(/\w+/.exec(a)[0]), a === "diff" && i.push("bold"), r.languages.diff[a] = {
          pattern: RegExp(
            "^(?:[" + s + `].*(?:\r
?|
|(?![\\s\\S])))+`,
            "m"
          ),
          alias: i,
          inside: {
            line: {
              pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
              lookbehind: !0
            },
            prefix: {
              pattern: /[\s\S]/,
              alias: /\w+/.exec(a)[0]
            }
          }
        };
      }), Object.defineProperty(r.languages.diff, "PREFIXES", {
        value: n
      });
    })(t);
  }
  return VS;
}
var GS, K6;
function Ia() {
  if (K6) return GS;
  K6 = 1, GS = e, e.displayName = "markupTemplating", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(a, s) {
        return "___" + a.toUpperCase() + s + "___";
      }
      Object.defineProperties(r.languages["markup-templating"] = {}, {
        buildPlaceholders: {
          /**
           * Tokenize all inline templating expressions matching `placeholderPattern`.
           *
           * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
           * `true` will be replaced.
           *
           * @param {object} env The environment of the `before-tokenize` hook.
           * @param {string} language The language id.
           * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
           * @param {(match: string) => boolean} [replaceFilter]
           */
          value: function(a, s, i, o) {
            if (a.language === s) {
              var l = a.tokenStack = [];
              a.code = a.code.replace(i, function(u) {
                if (typeof o == "function" && !o(u))
                  return u;
                for (var c = l.length, d; a.code.indexOf(d = n(s, c)) !== -1; )
                  ++c;
                return l[c] = u, d;
              }), a.grammar = r.languages.markup;
            }
          }
        },
        tokenizePlaceholders: {
          /**
           * Replace placeholders with proper tokens after tokenizing.
           *
           * @param {object} env The environment of the `after-tokenize` hook.
           * @param {string} language The language id.
           */
          value: function(a, s) {
            if (a.language !== s || !a.tokenStack)
              return;
            a.grammar = r.languages[s];
            var i = 0, o = Object.keys(a.tokenStack);
            function l(u) {
              for (var c = 0; c < u.length && !(i >= o.length); c++) {
                var d = u[c];
                if (typeof d == "string" || d.content && typeof d.content == "string") {
                  var p = o[i], f = a.tokenStack[p], h = typeof d == "string" ? d : d.content, m = n(s, p), y = h.indexOf(m);
                  if (y > -1) {
                    ++i;
                    var b = h.substring(0, y), v = new r.Token(
                      s,
                      r.tokenize(f, a.grammar),
                      "language-" + s,
                      f
                    ), x = h.substring(y + m.length), _ = [];
                    b && _.push.apply(_, l([b])), _.push(v), x && _.push.apply(_, l([x])), typeof d == "string" ? u.splice.apply(u, [c, 1].concat(_)) : d.content = _;
                  }
                } else d.content && l(d.content);
              }
              return u;
            }
            l(a.tokens);
          }
        }
      });
    })(t);
  }
  return GS;
}
var WS, Y6;
function K2e() {
  if (Y6) return WS;
  Y6 = 1;
  var e = Ia();
  WS = t, t.displayName = "django", t.aliases = ["jinja2"];
  function t(r) {
    r.register(e), function(n) {
      n.languages.django = {
        comment: /^\{#[\s\S]*?#\}$/,
        tag: {
          pattern: /(^\{%[+-]?\s*)\w+/,
          lookbehind: !0,
          alias: "keyword"
        },
        delimiter: {
          pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
          alias: "punctuation"
        },
        string: {
          pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: !0
        },
        filter: {
          pattern: /(\|)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        test: {
          pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        function: /\b[a-z_]\w+(?=\s*\()/i,
        keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
        operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        number: /\b\d+(?:\.\d+)?\b/,
        boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
        variable: /\b\w+\b/,
        punctuation: /[{}[\](),.:;]/
      };
      var a = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g, s = n.languages["markup-templating"];
      n.hooks.add("before-tokenize", function(i) {
        s.buildPlaceholders(i, "django", a);
      }), n.hooks.add("after-tokenize", function(i) {
        s.tokenizePlaceholders(i, "django");
      }), n.languages.jinja2 = n.languages.django, n.hooks.add("before-tokenize", function(i) {
        s.buildPlaceholders(i, "jinja2", a);
      }), n.hooks.add("after-tokenize", function(i) {
        s.tokenizePlaceholders(i, "jinja2");
      });
    }(r);
  }
  return WS;
}
var KS, X6;
function Y2e() {
  if (X6) return KS;
  X6 = 1, KS = e, e.displayName = "dnsZoneFile", e.aliases = [];
  function e(t) {
    t.languages["dns-zone-file"] = {
      comment: /;.*/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: !0
      },
      variable: [
        {
          pattern: /(^\$ORIGIN[ \t]+)\S+/m,
          lookbehind: !0
        },
        {
          pattern: /(^|\s)@(?=\s|$)/,
          lookbehind: !0
        }
      ],
      keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
      class: {
        // https://tools.ietf.org/html/rfc1035#page-13
        pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      type: {
        // https://en.wikipedia.org/wiki/List_of_DNS_record_types
        pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      punctuation: /[()]/
    }, t.languages["dns-zone"] = t.languages["dns-zone-file"];
  }
  return KS;
}
var YS, Z6;
function X2e() {
  if (Z6) return YS;
  Z6 = 1, YS = e, e.displayName = "docker", e.aliases = ["dockerfile"];
  function e(t) {
    (function(r) {
      var n = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source, a = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
        /<SP_BS>/g,
        function() {
          return n;
        }
      ), s = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source, i = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
        /<STR>/g,
        function() {
          return s;
        }
      ), o = {
        pattern: RegExp(s),
        greedy: !0
      }, l = {
        pattern: /(^[ \t]*)#.*/m,
        lookbehind: !0,
        greedy: !0
      };
      function u(c, d) {
        return c = c.replace(/<OPT>/g, function() {
          return i;
        }).replace(/<SP>/g, function() {
          return a;
        }), RegExp(c, d);
      }
      r.languages.docker = {
        instruction: {
          pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
          lookbehind: !0,
          greedy: !0,
          inside: {
            options: {
              pattern: u(
                /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
                "i"
              ),
              lookbehind: !0,
              greedy: !0,
              inside: {
                property: {
                  pattern: /(^|\s)--[\w-]+/,
                  lookbehind: !0
                },
                string: [
                  o,
                  {
                    pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                    lookbehind: !0
                  }
                ],
                operator: /\\$/m,
                punctuation: /=/
              }
            },
            keyword: [
              {
                // https://docs.docker.com/engine/reference/builder/#healthcheck
                pattern: u(
                  /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
                  "i"
                ),
                lookbehind: !0,
                greedy: !0
              },
              {
                // https://docs.docker.com/engine/reference/builder/#from
                pattern: u(
                  /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
                  "i"
                ),
                lookbehind: !0,
                greedy: !0
              },
              {
                // https://docs.docker.com/engine/reference/builder/#onbuild
                pattern: u(/(^ONBUILD<SP>)\w+/.source, "i"),
                lookbehind: !0,
                greedy: !0
              },
              {
                pattern: /^\w+/,
                greedy: !0
              }
            ],
            comment: l,
            string: o,
            variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
            operator: /\\$/m
          }
        },
        comment: l
      }, r.languages.dockerfile = r.languages.docker;
    })(t);
  }
  return YS;
}
var XS, J6;
function Z2e() {
  if (J6) return XS;
  J6 = 1, XS = e, e.displayName = "dot", e.aliases = ["gv"];
  function e(t) {
    (function(r) {
      var n = "(?:" + [
        // an identifier
        /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
        // a number
        /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
        // a double-quoted string
        /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
        // HTML-like string
        /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
      ].join("|") + ")", a = {
        markup: {
          pattern: /(^<)[\s\S]+(?=>$)/,
          lookbehind: !0,
          alias: ["language-markup", "language-html", "language-xml"],
          inside: r.languages.markup
        }
      };
      function s(i, o) {
        return RegExp(
          i.replace(/<ID>/g, function() {
            return n;
          }),
          o
        );
      }
      r.languages.dot = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
          greedy: !0
        },
        "graph-name": {
          pattern: s(
            /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
            "i"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "class-name",
          inside: a
        },
        "attr-value": {
          pattern: s(/(=[ \t\r\n]*)<ID>/.source),
          lookbehind: !0,
          greedy: !0,
          inside: a
        },
        "attr-name": {
          pattern: s(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
          lookbehind: !0,
          greedy: !0,
          inside: a
        },
        keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
        "compass-point": {
          pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
          lookbehind: !0,
          alias: "builtin"
        },
        node: {
          pattern: s(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
          lookbehind: !0,
          greedy: !0,
          inside: a
        },
        operator: /[=:]|-[->]/,
        punctuation: /[\[\]{};,]/
      }, r.languages.gv = r.languages.dot;
    })(t);
  }
  return XS;
}
var ZS, Q6;
function J2e() {
  if (Q6) return ZS;
  Q6 = 1, ZS = e, e.displayName = "ebnf", e.aliases = [];
  function e(t) {
    t.languages.ebnf = {
      comment: /\(\*[\s\S]*?\*\)/,
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: !0
      },
      special: {
        pattern: /\?[^?\r\n]*\?/,
        greedy: !0,
        alias: "class-name"
      },
      definition: {
        pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
        lookbehind: !0,
        alias: ["rule", "keyword"]
      },
      rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
      punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
      operator: /[-=|*/!]/
    };
  }
  return ZS;
}
var JS, e$;
function Q2e() {
  if (e$) return JS;
  e$ = 1, JS = e, e.displayName = "editorconfig", e.aliases = [];
  function e(t) {
    t.languages.editorconfig = {
      // https://editorconfig-specification.readthedocs.io
      comment: /[;#].*/,
      section: {
        pattern: /(^[ \t]*)\[.+\]/m,
        lookbehind: !0,
        alias: "selector",
        inside: {
          regex: /\\\\[\[\]{},!?.*]/,
          // Escape special characters with '\\'
          operator: /[!?]|\.\.|\*{1,2}/,
          punctuation: /[\[\]{},]/
        }
      },
      key: {
        pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      value: {
        pattern: /=.*/,
        alias: "attr-value",
        inside: {
          punctuation: /^=/
        }
      }
    };
  }
  return JS;
}
var QS, t$;
function eOe() {
  if (t$) return QS;
  t$ = 1, QS = e, e.displayName = "eiffel", e.aliases = [];
  function e(t) {
    t.languages.eiffel = {
      comment: /--.*/,
      string: [
        // Aligned-verbatim-strings
        {
          pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
          greedy: !0
        },
        // Non-aligned-verbatim-strings
        {
          pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
          greedy: !0
        },
        // Single-line string
        {
          pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
          greedy: !0
        }
      ],
      // normal char | special char | char code
      char: /'(?:%.|[^%'\r\n])+'/,
      keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
      boolean: /\b(?:False|True)\b/i,
      // Convention: class-names are always all upper-case characters
      "class-name": /\b[A-Z][\dA-Z_]*\b/,
      number: [
        // hexa | octal | bin
        /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
        // Decimal
        /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
      ],
      punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
      operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
    };
  }
  return QS;
}
var e_, r$;
function tOe() {
  if (r$) return e_;
  r$ = 1;
  var e = Ia();
  e_ = t, t.displayName = "ejs", t.aliases = ["eta"];
  function t(r) {
    r.register(e), function(n) {
      n.languages.ejs = {
        delimiter: {
          pattern: /^<%[-_=]?|[-_]?%>$/,
          alias: "punctuation"
        },
        comment: /^#[\s\S]*/,
        "language-javascript": {
          pattern: /[\s\S]+/,
          inside: n.languages.javascript
        }
      }, n.hooks.add("before-tokenize", function(a) {
        var s = /<%(?!%)[\s\S]+?%>/g;
        n.languages["markup-templating"].buildPlaceholders(
          a,
          "ejs",
          s
        );
      }), n.hooks.add("after-tokenize", function(a) {
        n.languages["markup-templating"].tokenizePlaceholders(a, "ejs");
      }), n.languages.eta = n.languages.ejs;
    }(r);
  }
  return e_;
}
var t_, n$;
function rOe() {
  if (n$) return t_;
  n$ = 1, t_ = e, e.displayName = "elixir", e.aliases = [];
  function e(t) {
    t.languages.elixir = {
      doc: {
        pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
        inside: {
          attribute: /^@\w+/,
          string: /['"][\s\S]+/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
      regex: {
        pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
        greedy: !0
      },
      string: [
        {
          // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
          pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
          greedy: !0,
          inside: {
            // See interpolation below
          }
        },
        {
          pattern: /("""|''')[\s\S]*?\1/,
          greedy: !0,
          inside: {
            // See interpolation below
          }
        },
        {
          // Multi-line strings are allowed
          pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: !0,
          inside: {
            // See interpolation below
          }
        }
      ],
      atom: {
        // Look-behind prevents bad highlighting of the :: operator
        pattern: /(^|[^:]):\w+/,
        lookbehind: !0,
        alias: "symbol"
      },
      module: {
        pattern: /\b[A-Z]\w*\b/,
        alias: "class-name"
      },
      // Look-ahead prevents bad highlighting of the :: operator
      "attr-name": /\b\w+\??:(?!:)/,
      argument: {
        // Look-behind prevents bad highlighting of the && operator
        pattern: /(^|[^&])&\d+/,
        lookbehind: !0,
        alias: "variable"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "variable"
      },
      function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
      number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
      keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      operator: [
        /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
        {
          // We don't want to match <<
          pattern: /([^<])<(?!<)/,
          lookbehind: !0
        },
        {
          // We don't want to match >>
          pattern: /([^>])>(?!>)/,
          lookbehind: !0
        }
      ],
      punctuation: /<<|>>|[.,%\[\]{}()]/
    }, t.languages.elixir.string.forEach(function(r) {
      r.inside = {
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            rest: t.languages.elixir
          }
        }
      };
    });
  }
  return t_;
}
var r_, i$;
function nOe() {
  if (i$) return r_;
  i$ = 1, r_ = e, e.displayName = "elm", e.aliases = [];
  function e(t) {
    t.languages.elm = {
      comment: /--.*|\{-[\s\S]*?-\}/,
      char: {
        pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
        greedy: !0
      },
      string: [
        {
          // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
          pattern: /"""[\s\S]*?"""/,
          greedy: !0
        },
        {
          pattern: /"(?:[^\\"\r\n]|\\.)*"/,
          greedy: !0
        }
      ],
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|exposing|import)\b/
        }
      },
      keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
      // decimal integers and floating point numbers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
      // Most of this is needed because of the meaning of a single '.'.
      // If it stands alone freely, it is the function composition.
      // It may also be a separator between a module name and an identifier => no
      // operator. If it comes together with other special characters it is an
      // operator too.
      // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
      // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
      operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
      // In Elm, nearly everything is a variable, do not highlight these.
      hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
      constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
      punctuation: /[{}[\]|(),.:]/
    };
  }
  return r_;
}
var n_, a$;
function iOe() {
  if (a$) return n_;
  a$ = 1;
  var e = vy(), t = Ia();
  n_ = r, r.displayName = "erb", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      a.languages.erb = {
        delimiter: {
          pattern: /^(\s*)<%=?|%>(?=\s*$)/,
          lookbehind: !0,
          alias: "punctuation"
        },
        ruby: {
          pattern: /\s*\S[\s\S]*/,
          alias: "language-ruby",
          inside: a.languages.ruby
        }
      }, a.hooks.add("before-tokenize", function(s) {
        var i = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
        a.languages["markup-templating"].buildPlaceholders(
          s,
          "erb",
          i
        );
      }), a.hooks.add("after-tokenize", function(s) {
        a.languages["markup-templating"].tokenizePlaceholders(s, "erb");
      });
    }(n);
  }
  return n_;
}
var i_, s$;
function aOe() {
  if (s$) return i_;
  s$ = 1, i_ = e, e.displayName = "erlang", e.aliases = [];
  function e(t) {
    t.languages.erlang = {
      comment: /%.+/,
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      "quoted-function": {
        pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
        alias: "function"
      },
      "quoted-atom": {
        pattern: /'(?:\\.|[^\\'\r\n])+'/,
        alias: "atom"
      },
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
      number: [
        /\$\\?./,
        /\b\d+#[a-z0-9]+/i,
        /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
      ],
      function: /\b[a-z][\w@]*(?=\()/,
      variable: {
        // Look-behind is used to prevent wrong highlighting of atoms containing "@"
        pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
        lookbehind: !0
      },
      operator: [
        /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
        {
          // We don't want to match <<
          pattern: /(^|[^<])<(?!<)/,
          lookbehind: !0
        },
        {
          // We don't want to match >>
          pattern: /(^|[^>])>(?!>)/,
          lookbehind: !0
        }
      ],
      atom: /\b[a-z][\w@]*/,
      punctuation: /[()[\]{}:;,.#|]|<<|>>/
    };
  }
  return i_;
}
var a_, o$;
function PW() {
  if (o$) return a_;
  o$ = 1, a_ = e, e.displayName = "lua", e.aliases = [];
  function e(t) {
    t.languages.lua = {
      comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
      // \z may be used to skip the following space
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
        greedy: !0
      },
      number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
      keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
      function: /(?!\d)\w+(?=\s*(?:[({]))/,
      operator: [
        /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
        {
          // Match ".." but don't break "..."
          pattern: /(^|[^.])\.\.(?!\.)/,
          lookbehind: !0
        }
      ],
      punctuation: /[\[\](){},;]|\.+|:+/
    };
  }
  return a_;
}
var s_, l$;
function sOe() {
  if (l$) return s_;
  l$ = 1;
  var e = PW(), t = Ia();
  s_ = r, r.displayName = "etlua", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      a.languages.etlua = {
        delimiter: {
          pattern: /^<%[-=]?|-?%>$/,
          alias: "punctuation"
        },
        "language-lua": {
          pattern: /[\s\S]+/,
          inside: a.languages.lua
        }
      }, a.hooks.add("before-tokenize", function(s) {
        var i = /<%[\s\S]+?%>/g;
        a.languages["markup-templating"].buildPlaceholders(
          s,
          "etlua",
          i
        );
      }), a.hooks.add("after-tokenize", function(s) {
        a.languages["markup-templating"].tokenizePlaceholders(s, "etlua");
      });
    }(n);
  }
  return s_;
}
var o_, u$;
function oOe() {
  if (u$) return o_;
  u$ = 1, o_ = e, e.displayName = "excelFormula", e.aliases = [];
  function e(t) {
    t.languages["excel-formula"] = {
      comment: {
        pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      reference: {
        // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
        // Sales!B2
        // 'Winter sales'!B2
        // [Sales.xlsx]Jan!B2:B5
        // D:\Reports\[Sales.xlsx]Jan!B2:B5
        // '[Sales.xlsx]Jan sales'!B2:B5
        // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
        pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
        greedy: !0,
        alias: "string",
        inside: {
          operator: /!$/,
          punctuation: /'/,
          sheet: {
            pattern: /[^[\]]+$/,
            alias: "function"
          },
          file: {
            pattern: /\[[^[\]]+\]$/,
            inside: {
              punctuation: /[[\]]/
            }
          },
          path: /[\s\S]+/
        }
      },
      "function-name": {
        pattern: /\b[A-Z]\w*(?=\()/i,
        alias: "keyword"
      },
      range: {
        pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
        alias: "property",
        inside: {
          operator: /:/,
          cell: /\$?[A-Z]+\$?\d+/i,
          column: /\$?[A-Z]+/i,
          row: /\$?\d+/
        }
      },
      cell: {
        // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
        // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
        pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
        alias: "property"
      },
      number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      operator: /[-+*/^%=&,]|<[=>]?|>=?/,
      punctuation: /[[\]();{}|]/
    }, t.languages.xlsx = t.languages.xls = t.languages["excel-formula"];
  }
  return o_;
}
var l_, c$;
function lOe() {
  if (c$) return l_;
  c$ = 1, l_ = e, e.displayName = "factor", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
      }, a = {
        number: /\\[^\s']|%\w/
      }, s = {
        comment: [
          {
            // ! single-line exclamation point comments with whitespace after/around the !
            pattern: /(^|\s)(?:! .*|!$)/,
            lookbehind: !0,
            inside: n
          },
          /* from basis/multiline: */
          {
            // /* comment */, /* comment*/
            pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            inside: n
          },
          {
            // ![[ comment ]] , ![===[ comment]===]
            pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            inside: n
          }
        ],
        number: [
          {
            // basic base 10 integers 9, -9
            pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
            lookbehind: !0
          },
          {
            // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
            pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
            lookbehind: !0
          },
          {
            // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
            pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
            lookbehind: !0
          },
          {
            // positive mixed numbers 23+1/5 +23+1/5
            pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
            lookbehind: !0
          },
          {
            // negative mixed numbers -23-1/5
            pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
            lookbehind: !0
          },
          {
            // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
            // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
            pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
            lookbehind: !0
          },
          {
            // NAN literal syntax NAN: 80000deadbeef, NAN: a
            pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
            lookbehind: !0
          },
          {
            /*
            base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
            "The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.
            The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
            <https://docs.factorcode.org/content/article-syntax-floats.html>
            */
            pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
            lookbehind: !0
          }
        ],
        // R/ regexp?\/\\/
        regexp: {
          pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
          lookbehind: !0,
          alias: "number",
          inside: {
            variable: /\\\S/,
            keyword: /[+?*\[\]^$(){}.|]/,
            operator: {
              pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
              lookbehind: !0
            }
          }
        },
        boolean: {
          pattern: /(^|\s)[tf](?=\s|$)/,
          lookbehind: !0
        },
        // SBUF" asd", URL" ://...", P" /etc/"
        "custom-string": {
          pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: {
            number: /\\\S|%\w|\//
          }
        },
        "multiline-string": [
          {
            // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
            pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            alias: "string",
            inside: {
              number: a.number,
              // trailing semicolon on its own line
              "semicolon-or-setlocal": {
                pattern: /([\r\n][ \t]*);(?=\s|$)/,
                lookbehind: !0,
                alias: "function"
              }
            }
          },
          {
            // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
            pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            alias: "string",
            inside: a
          },
          {
            // [[ string ]], [==[ string]==]
            pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            alias: "string",
            inside: a
          }
        ],
        "special-using": {
          pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
          lookbehind: !0,
          alias: "function",
          inside: {
            // this is essentially a regex for vocab names, which i don't want to specify
            // but the USING: gets picked up as a vocab name
            string: {
              pattern: /(\s)[^:\s]+/,
              lookbehind: !0
            }
          }
        },
        /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
        trying to do better is more work and regex-computation-time than it's worth though.
        - we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
        - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
        - we'd like if the following variable name conventions were recognised specifically:
        special row variables = ..a b..
        type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
        word throws unconditional error = *
        any other word-like variable name = a ? q' etc
        https://docs.factorcode.org/content/article-effects.html
        these are pretty complicated to highlight properly without a real parser, and therefore out of scope
        the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
        */
        // current solution is not great
        "stack-effect-delimiter": [
          {
            // opening parenthesis
            pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
            lookbehind: !0,
            alias: "operator"
          },
          {
            // middle --
            pattern: /(\s)--(?=\s)/,
            lookbehind: !0,
            alias: "operator"
          },
          {
            // closing parenthesis
            pattern: /(\s)\)(?=\s|$)/,
            lookbehind: !0,
            alias: "operator"
          }
        ],
        combinators: {
          pattern: null,
          lookbehind: !0,
          alias: "keyword"
        },
        "kernel-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "sequences-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "math-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "constructor-word": {
          // <array> but not <=>
          pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
          lookbehind: !0,
          alias: "keyword"
        },
        "other-builtin-syntax": {
          pattern: null,
          lookbehind: !0,
          alias: "operator"
        },
        /*
        full list of supported word naming conventions: (the convention appears outside of the [brackets])
        set-[x]
        change-[x]
        with-[x]
        new-[x]
        >[string]
        [base]>
        [string]>[number]
        +[symbol]+
        [boolean-word]?
        ?[of]
        [slot-reader]>>
        >>[slot-setter]
        [slot-writer]<<
        ([implementation-detail])
        [mutater]!
        [variant]*
        [prettyprint].
        $[help-markup]
        <constructors>, SYNTAX:, etc are supported by their own patterns.
        `with` and `new` from `kernel` are their own builtins.
        see <https://docs.factorcode.org/content/article-conventions.html>
        */
        "conventionally-named-word": {
          pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
          lookbehind: !0,
          alias: "keyword"
        },
        "colon-syntax": {
          pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "function"
        },
        "semicolon-or-setlocal": {
          pattern: /(\s)(?:;|:>)(?=\s|$)/,
          lookbehind: !0,
          alias: "function"
        },
        // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
        "curly-brace-literal-delimiter": [
          {
            // opening
            pattern: /(^|\s)[a-z]*\{(?=\s)/i,
            lookbehind: !0,
            alias: "operator"
          },
          {
            // closing
            pattern: /(\s)\}(?=\s|$)/,
            lookbehind: !0,
            alias: "operator"
          }
        ],
        // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
        "quotation-delimiter": [
          {
            // opening
            pattern: /(^|\s)\[(?=\s)/,
            lookbehind: !0,
            alias: "operator"
          },
          {
            // closing
            pattern: /(\s)\](?=\s|$)/,
            lookbehind: !0,
            alias: "operator"
          }
        ],
        "normal-word": {
          pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
          lookbehind: !0
        },
        /*
        basic first-class string "a"
        with escaped double-quote "a\""
        escaped backslash "\\"
        and general escapes since Factor has so many "\N"
        syntax that works in the reference implementation that isn't fully
        supported because it's an implementation detail:
        "string 1""string 2" -> 2 strings (works anyway)
        "string"5 -> string, 5
        "string"[ ] -> string, quotation
        { "a"} -> array<string>
        the rest of those examples all properly recognise the string, but not
        the other object (number, quotation, etc)
        this is fine for a regex-only implementation.
        */
        string: {
          pattern: /"(?:\\\S|[^"\\])*"/,
          greedy: !0,
          inside: a
        }
      }, i = function(c) {
        return (c + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
      }, o = function(c) {
        return new RegExp("(^|\\s)(?:" + c.map(i).join("|") + ")(?=\\s|$)");
      }, l = {
        "kernel-builtin": [
          "or",
          "2nipd",
          "4drop",
          "tuck",
          "wrapper",
          "nip",
          "wrapper?",
          "callstack>array",
          "die",
          "dupd",
          "callstack",
          "callstack?",
          "3dup",
          "hashcode",
          "pick",
          "4nip",
          "build",
          ">boolean",
          "nipd",
          "clone",
          "5nip",
          "eq?",
          "?",
          "=",
          "swapd",
          "2over",
          "clear",
          "2dup",
          "get-retainstack",
          "not",
          "tuple?",
          "dup",
          "3nipd",
          "call",
          "-rotd",
          "object",
          "drop",
          "assert=",
          "assert?",
          "-rot",
          "execute",
          "boa",
          "get-callstack",
          "curried?",
          "3drop",
          "pickd",
          "overd",
          "over",
          "roll",
          "3nip",
          "swap",
          "and",
          "2nip",
          "rotd",
          "throw",
          "(clone)",
          "hashcode*",
          "spin",
          "reach",
          "4dup",
          "equal?",
          "get-datastack",
          "assert",
          "2drop",
          "<wrapper>",
          "boolean?",
          "identity-hashcode",
          "identity-tuple?",
          "null",
          "composed?",
          "new",
          "5drop",
          "rot",
          "-roll",
          "xor",
          "identity-tuple",
          "boolean"
        ],
        "other-builtin-syntax": [
          // syntax
          "=======",
          "recursive",
          "flushable",
          ">>",
          "<<<<<<",
          "M\\",
          "B",
          "PRIVATE>",
          "\\",
          "======",
          "final",
          "inline",
          "delimiter",
          "deprecated",
          "<PRIVATE",
          ">>>>>>",
          "<<<<<<<",
          "parse-complex",
          "malformed-complex",
          "read-only",
          ">>>>>>>",
          "call-next-method",
          "<<",
          "foldable",
          // literals
          "$",
          "$[",
          "${"
        ],
        "sequences-builtin": [
          "member-eq?",
          "mismatch",
          "append",
          "assert-sequence=",
          "longer",
          "repetition",
          "clone-like",
          "3sequence",
          "assert-sequence?",
          "last-index-from",
          "reversed",
          "index-from",
          "cut*",
          "pad-tail",
          "join-as",
          "remove-eq!",
          "concat-as",
          "but-last",
          "snip",
          "nths",
          "nth",
          "sequence",
          "longest",
          "slice?",
          "<slice>",
          "remove-nth",
          "tail-slice",
          "empty?",
          "tail*",
          "member?",
          "virtual-sequence?",
          "set-length",
          "drop-prefix",
          "iota",
          "unclip",
          "bounds-error?",
          "unclip-last-slice",
          "non-negative-integer-expected",
          "non-negative-integer-expected?",
          "midpoint@",
          "longer?",
          "?set-nth",
          "?first",
          "rest-slice",
          "prepend-as",
          "prepend",
          "fourth",
          "sift",
          "subseq-start",
          "new-sequence",
          "?last",
          "like",
          "first4",
          "1sequence",
          "reverse",
          "slice",
          "virtual@",
          "repetition?",
          "set-last",
          "index",
          "4sequence",
          "max-length",
          "set-second",
          "immutable-sequence",
          "first2",
          "first3",
          "supremum",
          "unclip-slice",
          "suffix!",
          "insert-nth",
          "tail",
          "3append",
          "short",
          "suffix",
          "concat",
          "flip",
          "immutable?",
          "reverse!",
          "2sequence",
          "sum",
          "delete-all",
          "indices",
          "snip-slice",
          "<iota>",
          "check-slice",
          "sequence?",
          "head",
          "append-as",
          "halves",
          "sequence=",
          "collapse-slice",
          "?second",
          "slice-error?",
          "product",
          "bounds-check?",
          "bounds-check",
          "immutable",
          "virtual-exemplar",
          "harvest",
          "remove",
          "pad-head",
          "last",
          "set-fourth",
          "cartesian-product",
          "remove-eq",
          "shorten",
          "shorter",
          "reversed?",
          "shorter?",
          "shortest",
          "head-slice",
          "pop*",
          "tail-slice*",
          "but-last-slice",
          "iota?",
          "append!",
          "cut-slice",
          "new-resizable",
          "head-slice*",
          "sequence-hashcode",
          "pop",
          "set-nth",
          "?nth",
          "second",
          "join",
          "immutable-sequence?",
          "<reversed>",
          "3append-as",
          "virtual-sequence",
          "subseq?",
          "remove-nth!",
          "length",
          "last-index",
          "lengthen",
          "assert-sequence",
          "copy",
          "move",
          "third",
          "first",
          "tail?",
          "set-first",
          "prefix",
          "bounds-error",
          "<repetition>",
          "exchange",
          "surround",
          "cut",
          "min-length",
          "set-third",
          "push-all",
          "head?",
          "subseq-start-from",
          "delete-slice",
          "rest",
          "sum-lengths",
          "head*",
          "infimum",
          "remove!",
          "glue",
          "slice-error",
          "subseq",
          "push",
          "replace-slice",
          "subseq-as",
          "unclip-last"
        ],
        "math-builtin": [
          "number=",
          "next-power-of-2",
          "?1+",
          "fp-special?",
          "imaginary-part",
          "float>bits",
          "number?",
          "fp-infinity?",
          "bignum?",
          "fp-snan?",
          "denominator",
          "gcd",
          "*",
          "+",
          "fp-bitwise=",
          "-",
          "u>=",
          "/",
          ">=",
          "bitand",
          "power-of-2?",
          "log2-expects-positive",
          "neg?",
          "<",
          "log2",
          ">",
          "integer?",
          "number",
          "bits>double",
          "2/",
          "zero?",
          "bits>float",
          "float?",
          "shift",
          "ratio?",
          "rect>",
          "even?",
          "ratio",
          "fp-sign",
          "bitnot",
          ">fixnum",
          "complex?",
          "/i",
          "integer>fixnum",
          "/f",
          "sgn",
          ">bignum",
          "next-float",
          "u<",
          "u>",
          "mod",
          "recip",
          "rational",
          ">float",
          "2^",
          "integer",
          "fixnum?",
          "neg",
          "fixnum",
          "sq",
          "bignum",
          ">rect",
          "bit?",
          "fp-qnan?",
          "simple-gcd",
          "complex",
          "<fp-nan>",
          "real",
          ">fraction",
          "double>bits",
          "bitor",
          "rem",
          "fp-nan-payload",
          "real-part",
          "log2-expects-positive?",
          "prev-float",
          "align",
          "unordered?",
          "float",
          "fp-nan?",
          "abs",
          "bitxor",
          "integer>fixnum-strict",
          "u<=",
          "odd?",
          "<=",
          "/mod",
          ">integer",
          "real?",
          "rational?",
          "numerator"
        ]
        // that's all for now
      };
      Object.keys(l).forEach(function(c) {
        s[c].pattern = o(l[c]);
      });
      var u = [
        // kernel
        "2bi",
        "while",
        "2tri",
        "bi*",
        "4dip",
        "both?",
        "same?",
        "tri@",
        "curry",
        "prepose",
        "3bi",
        "?if",
        "tri*",
        "2keep",
        "3keep",
        "curried",
        "2keepd",
        "when",
        "2bi*",
        "2tri*",
        "4keep",
        "bi@",
        "keepdd",
        "do",
        "unless*",
        "tri-curry",
        "if*",
        "loop",
        "bi-curry*",
        "when*",
        "2bi@",
        "2tri@",
        "with",
        "2with",
        "either?",
        "bi",
        "until",
        "3dip",
        "3curry",
        "tri-curry*",
        "tri-curry@",
        "bi-curry",
        "keepd",
        "compose",
        "2dip",
        "if",
        "3tri",
        "unless",
        "tuple",
        "keep",
        "2curry",
        "tri",
        "most",
        "while*",
        "dip",
        "composed",
        "bi-curry@",
        // sequences
        "find-last-from",
        "trim-head-slice",
        "map-as",
        "each-from",
        "none?",
        "trim-tail",
        "partition",
        "if-empty",
        "accumulate*",
        "reject!",
        "find-from",
        "accumulate-as",
        "collector-for-as",
        "reject",
        "map",
        "map-sum",
        "accumulate!",
        "2each-from",
        "follow",
        "supremum-by",
        "map!",
        "unless-empty",
        "collector",
        "padding",
        "reduce-index",
        "replicate-as",
        "infimum-by",
        "trim-tail-slice",
        "count",
        "find-index",
        "filter",
        "accumulate*!",
        "reject-as",
        "map-integers",
        "map-find",
        "reduce",
        "selector",
        "interleave",
        "2map",
        "filter-as",
        "binary-reduce",
        "map-index-as",
        "find",
        "produce",
        "filter!",
        "replicate",
        "cartesian-map",
        "cartesian-each",
        "find-index-from",
        "map-find-last",
        "3map-as",
        "3map",
        "find-last",
        "selector-as",
        "2map-as",
        "2map-reduce",
        "accumulate",
        "each",
        "each-index",
        "accumulate*-as",
        "when-empty",
        "all?",
        "collector-as",
        "push-either",
        "new-like",
        "collector-for",
        "2selector",
        "push-if",
        "2all?",
        "map-reduce",
        "3each",
        "any?",
        "trim-slice",
        "2reduce",
        "change-nth",
        "produce-as",
        "2each",
        "trim",
        "trim-head",
        "cartesian-find",
        "map-index",
        // math
        "if-zero",
        "each-integer",
        "unless-zero",
        "(find-integer)",
        "when-zero",
        "find-last-integer",
        "(all-integers?)",
        "times",
        "(each-integer)",
        "find-integer",
        "all-integers?",
        // math.combinators
        "unless-negative",
        "if-positive",
        "when-positive",
        "when-negative",
        "unless-positive",
        "if-negative",
        // combinators
        "case",
        "2cleave",
        "cond>quot",
        "case>quot",
        "3cleave",
        "wrong-values",
        "to-fixed-point",
        "alist>quot",
        "cond",
        "cleave",
        "call-effect",
        "recursive-hashcode",
        "spread",
        "deep-spread>quot",
        // combinators.short-circuit
        "2||",
        "0||",
        "n||",
        "0&&",
        "2&&",
        "3||",
        "1||",
        "1&&",
        "n&&",
        "3&&",
        // combinators.smart
        "smart-unless*",
        "keep-inputs",
        "reduce-outputs",
        "smart-when*",
        "cleave>array",
        "smart-with",
        "smart-apply",
        "smart-if",
        "inputs/outputs",
        "output>sequence-n",
        "map-outputs",
        "map-reduce-outputs",
        "dropping",
        "output>array",
        "smart-map-reduce",
        "smart-2map-reduce",
        "output>array-n",
        "nullary",
        "input<sequence",
        "append-outputs",
        "drop-inputs",
        "inputs",
        "smart-2reduce",
        "drop-outputs",
        "smart-reduce",
        "preserving",
        "smart-when",
        "outputs",
        "append-outputs-as",
        "smart-unless",
        "smart-if*",
        "sum-outputs",
        "input<sequence-unsafe",
        "output>sequence"
        // tafn
      ];
      s.combinators.pattern = o(u), r.languages.factor = s;
    })(t);
  }
  return l_;
}
var u_, d$;
function uOe() {
  if (d$) return u_;
  d$ = 1, u_ = e, e.displayName = "$false", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.false = {
        comment: {
          pattern: /\{[^}]*\}/
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        "character-code": {
          pattern: /'(?:[^\r]|\r\n?)/,
          alias: "number"
        },
        "assembler-code": {
          pattern: /\d+`/,
          alias: "important"
        },
        number: /\d+/,
        operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
        punctuation: /\[|\]/,
        variable: /[a-z]/,
        "non-standard": {
          pattern: /[()<BDO®]/,
          alias: "bold"
        }
      };
    })(t);
  }
  return u_;
}
var c_, f$;
function cOe() {
  if (f$) return c_;
  f$ = 1, c_ = e, e.displayName = "firestoreSecurityRules", e.aliases = [];
  function e(t) {
    t.languages["firestore-security-rules"] = t.languages.extend(
      "clike",
      {
        comment: /\/\/.*/,
        keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
        operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
      }
    ), delete t.languages["firestore-security-rules"]["class-name"], t.languages.insertBefore("firestore-security-rules", "keyword", {
      path: {
        pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          variable: {
            pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
            inside: {
              operator: /=/,
              keyword: /\*\*/,
              punctuation: /[.$(){}]/
            }
          },
          punctuation: /\//
        }
      },
      method: {
        // to make the pattern shorter, the actual method names are omitted
        pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
        lookbehind: !0,
        alias: "builtin",
        inside: {
          punctuation: /,/
        }
      }
    });
  }
  return c_;
}
var d_, p$;
function dOe() {
  if (p$) return d_;
  p$ = 1, d_ = e, e.displayName = "flow", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.flow = r.languages.extend("javascript", {}), r.languages.insertBefore("flow", "keyword", {
        type: [
          {
            pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
            alias: "tag"
          }
        ]
      }), r.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete r.languages.flow.parameter, r.languages.insertBefore("flow", "operator", {
        "flow-punctuation": {
          pattern: /\{\||\|\}/,
          alias: "punctuation"
        }
      }), Array.isArray(r.languages.flow.keyword) || (r.languages.flow.keyword = [r.languages.flow.keyword]), r.languages.flow.keyword.unshift(
        {
          pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
          lookbehind: !0
        }
      );
    })(t);
  }
  return d_;
}
var f_, h$;
function fOe() {
  if (h$) return f_;
  h$ = 1, f_ = e, e.displayName = "fortran", e.aliases = [];
  function e(t) {
    t.languages.fortran = {
      "quoted-number": {
        pattern: /[BOZ](['"])[A-F0-9]+\1/i,
        alias: "number"
      },
      string: {
        pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
        inside: {
          comment: {
            pattern: /(&(?:\r\n?|\n)\s*)!.*/,
            lookbehind: !0
          }
        }
      },
      comment: {
        pattern: /!.*/,
        greedy: !0
      },
      boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
      keyword: [
        // Types
        /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
        // END statements
        /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
        // Statements
        /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
        // Others
        /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
      ],
      operator: [
        /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
        {
          // Use lookbehind to prevent confusion with (/ /)
          pattern: /(^|(?!\().)\/(?!\))/,
          lookbehind: !0
        }
      ],
      punctuation: /\(\/|\/\)|[(),;:&]/
    };
  }
  return f_;
}
var p_, m$;
function pOe() {
  if (m$) return p_;
  m$ = 1, p_ = e, e.displayName = "fsharp", e.aliases = [];
  function e(t) {
    t.languages.fsharp = t.languages.extend("clike", {
      comment: [
        {
          pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
        lookbehind: !0,
        inside: {
          operator: /->|\*/,
          punctuation: /\./
        }
      },
      keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
      number: [
        /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
        /\b0b[01]+(?:uy|y)?\b/,
        /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
        /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
      ],
      operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
    }), t.languages.insertBefore("fsharp", "keyword", {
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          directive: {
            pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    }), t.languages.insertBefore("fsharp", "punctuation", {
      "computation-expression": {
        pattern: /\b[_a-z]\w*(?=\s*\{)/i,
        alias: "keyword"
      }
    }), t.languages.insertBefore("fsharp", "string", {
      annotation: {
        pattern: /\[<.+?>\]/,
        greedy: !0,
        inside: {
          punctuation: /^\[<|>\]$/,
          "class-name": {
            pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
            lookbehind: !0
          },
          "annotation-content": {
            pattern: /[\s\S]+/,
            inside: t.languages.fsharp
          }
        }
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
        greedy: !0
      }
    });
  }
  return p_;
}
var h_, g$;
function hOe() {
  if (g$) return h_;
  g$ = 1;
  var e = Ia();
  h_ = t, t.displayName = "ftl", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      for (var a = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source, s = 0; s < 2; s++)
        a = a.replace(/<expr>/g, function() {
          return a;
        });
      a = a.replace(/<expr>/g, /[^\s\S]/.source);
      var i = {
        comment: /<#--[\s\S]*?-->/,
        string: [
          {
            // raw string
            pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
            greedy: !0
          },
          {
            pattern: RegExp(
              /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
                /<expr>/g,
                function() {
                  return a;
                }
              )
            ),
            greedy: !0,
            inside: {
              interpolation: {
                pattern: RegExp(
                  /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
                    /<expr>/g,
                    function() {
                      return a;
                    }
                  )
                ),
                lookbehind: !0,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^\$\{|\}$/,
                    alias: "punctuation"
                  },
                  rest: null
                }
              }
            }
          }
        ],
        keyword: /\b(?:as)\b/,
        boolean: /\b(?:false|true)\b/,
        "builtin-function": {
          pattern: /((?:^|[^?])\?\s*)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        function: /\b\w+(?=\s*\()/,
        number: /\b\d+(?:\.\d+)?\b/,
        operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
        punctuation: /[,;.:()[\]{}]/
      };
      i.string[1].inside.interpolation.inside.rest = i, n.languages.ftl = {
        "ftl-comment": {
          // the pattern is shortened to be more efficient
          pattern: /^<#--[\s\S]*/,
          alias: "comment"
        },
        "ftl-directive": {
          pattern: /^<[\s\S]+>$/,
          inside: {
            directive: {
              pattern: /(^<\/?)[#@][a-z]\w*/i,
              lookbehind: !0,
              alias: "keyword"
            },
            punctuation: /^<\/?|\/?>$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: i
            }
          }
        },
        "ftl-interpolation": {
          pattern: /^\$\{[\s\S]*\}$/,
          inside: {
            punctuation: /^\$\{|\}$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: i
            }
          }
        }
      }, n.hooks.add("before-tokenize", function(o) {
        var l = RegExp(
          /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
            /<expr>/g,
            function() {
              return a;
            }
          ),
          "gi"
        );
        n.languages["markup-templating"].buildPlaceholders(
          o,
          "ftl",
          l
        );
      }), n.hooks.add("after-tokenize", function(o) {
        n.languages["markup-templating"].tokenizePlaceholders(o, "ftl");
      });
    }(r);
  }
  return h_;
}
var m_, b$;
function mOe() {
  if (b$) return m_;
  b$ = 1, m_ = e, e.displayName = "gap", e.aliases = [];
  function e(t) {
    t.languages.gap = {
      shell: {
        pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
        greedy: !0,
        inside: {
          gap: {
            pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
            lookbehind: !0,
            inside: null
            // see below
          },
          punctuation: /^gap>/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          continuation: {
            pattern: /([\r\n])>/,
            lookbehind: !0,
            alias: "punctuation"
          }
        }
      },
      keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: !0
      },
      continuation: {
        pattern: /([\r\n])>/,
        lookbehind: !0,
        alias: "punctuation"
      },
      operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
      punctuation: /[()[\]{},;.:]/
    }, t.languages.gap.shell.inside.gap.inside = t.languages.gap;
  }
  return m_;
}
var g_, y$;
function gOe() {
  if (y$) return g_;
  y$ = 1, g_ = e, e.displayName = "gcode", e.aliases = [];
  function e(t) {
    t.languages.gcode = {
      comment: /;.*|\B\(.*?\)\B/,
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      keyword: /\b[GM]\d+(?:\.\d+)?\b/,
      property: /\b[A-Z]/,
      checksum: {
        pattern: /(\*)\d+/,
        lookbehind: !0,
        alias: "number"
      },
      // T0:0:0
      punctuation: /[:*]/
    };
  }
  return g_;
}
var b_, v$;
function bOe() {
  if (v$) return b_;
  v$ = 1, b_ = e, e.displayName = "gdscript", e.aliases = [];
  function e(t) {
    t.languages.gdscript = {
      comment: /#.*/,
      string: {
        pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
        greedy: !0
      },
      "class-name": {
        // class_name Foo, extends Bar, class InnerClass
        // export(int) var baz, export(int, 0) var i
        // as Node
        // const FOO: int = 9, var bar: bool = true
        // func add(reference: Item, amount: int) -> Item:
        pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
        lookbehind: !0
      },
      keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      variable: /\$\w+/,
      number: [
        /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
        /\b(?:INF|NAN|PI|TAU)\b/
      ],
      constant: /\b[A-Z][A-Z_\d]*\b/,
      boolean: /\b(?:false|true)\b/,
      operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
      punctuation: /[.:,;()[\]{}]/
    };
  }
  return b_;
}
var y_, w$;
function yOe() {
  if (w$) return y_;
  w$ = 1, y_ = e, e.displayName = "gedcom", e.aliases = [];
  function e(t) {
    t.languages.gedcom = {
      "line-value": {
        // Preceded by level, optional pointer, and tag
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
        lookbehind: !0,
        inside: {
          pointer: {
            pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
            alias: "variable"
          }
        }
      },
      tag: {
        // Preceded by level and optional pointer
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
        lookbehind: !0,
        alias: "string"
      },
      level: {
        pattern: /(^[\t ]*)\d+/m,
        lookbehind: !0,
        alias: "number"
      },
      pointer: {
        pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
        alias: "variable"
      }
    };
  }
  return y_;
}
var v_, x$;
function vOe() {
  if (x$) return v_;
  x$ = 1, v_ = e, e.displayName = "gherkin", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
      r.languages.gherkin = {
        pystring: {
          pattern: /("""|''')[\s\S]+?\1/,
          alias: "string"
        },
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: !0
        },
        tag: {
          pattern: /(^[ \t]*)@\S*/m,
          lookbehind: !0
        },
        feature: {
          pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
          lookbehind: !0,
          inside: {
            important: {
              pattern: /(:)[^\r\n]+/,
              lookbehind: !0
            },
            keyword: /[^:\r\n]+:/
          }
        },
        scenario: {
          pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
          lookbehind: !0,
          inside: {
            important: {
              pattern: /(:)[^\r\n]*/,
              lookbehind: !0
            },
            keyword: /[^:\r\n]+:/
          }
        },
        "table-body": {
          // Look-behind is used to skip the table head, which has the same format as any table row
          pattern: RegExp("(" + n + ")(?:" + n + ")+"),
          lookbehind: !0,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            },
            td: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "string"
            },
            punctuation: /\|/
          }
        },
        "table-head": {
          pattern: RegExp(n),
          inside: {
            th: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "variable"
            },
            punctuation: /\|/
          }
        },
        atrule: {
          pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
          lookbehind: !0
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            }
          }
        },
        outline: {
          pattern: /<[^>]+>/,
          alias: "variable"
        }
      };
    })(t);
  }
  return v_;
}
var w_, E$;
function wOe() {
  if (E$) return w_;
  E$ = 1, w_ = e, e.displayName = "git", e.aliases = [];
  function e(t) {
    t.languages.git = {
      /*
       * A simple one line comment like in a git status command
       * For instance:
       * $ git status
       * # On branch infinite-scroll
       * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
       * # and have 1 and 2 different commits each, respectively.
       * nothing to commit (working directory clean)
       */
      comment: /^#.*/m,
      /*
       * Regexp to match the changed lines in a git diff output. Check the example below.
       */
      deleted: /^[-–].*/m,
      inserted: /^\+.*/m,
      /*
       * a string (double and simple quote)
       */
      string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      /*
       * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
       * For instance:
       * $ git add file.txt
       */
      command: {
        pattern: /^.*\$ git .*$/m,
        inside: {
          /*
           * A git command can contain a parameter starting by a single or a double dash followed by a string
           * For instance:
           * $ git diff --cached
           * $ git log -p
           */
          parameter: /\s--?\w+/
        }
      },
      /*
       * Coordinates displayed in a git diff command
       * For instance:
       * $ git diff
       * diff --git file.txt file.txt
       * index 6214953..1d54a52 100644
       * --- file.txt
       * +++ file.txt
       * @@ -1 +1,2 @@
       * -Here's my tetx file
       * +Here's my text file
       * +And this is the second line
       */
      coord: /^@@.*@@$/m,
      /*
       * Match a "commit [SHA1]" line in a git log output.
       * For instance:
       * $ git log
       * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
       * Author: lgiraudel
       * Date:   Mon Feb 17 11:18:34 2014 +0100
       *
       *     Add of a new line
       */
      "commit-sha1": /^commit \w{40}$/m
    };
  }
  return w_;
}
var x_, S$;
function xOe() {
  if (S$) return x_;
  S$ = 1;
  var e = Wu();
  x_ = t, t.displayName = "glsl", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.glsl = r.languages.extend("c", {
      keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
    });
  }
  return x_;
}
var E_, _$;
function EOe() {
  if (_$) return E_;
  _$ = 1, E_ = e, e.displayName = "gml", e.aliases = [];
  function e(t) {
    t.languages.gamemakerlanguage = t.languages.gml = t.languages.extend("clike", {
      keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
      number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
      operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
      constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
      variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
    });
  }
  return E_;
}
var S_, k$;
function SOe() {
  if (k$) return S_;
  k$ = 1, S_ = e, e.displayName = "gn", e.aliases = ["gni"];
  function e(t) {
    t.languages.gn = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      "string-literal": {
        pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
            lookbehind: !0,
            inside: {
              number: /^\$0x[\s\S]{2}$/,
              variable: /^\$\w+$/,
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: null
                // see below
              }
            }
          },
          string: /[\s\S]+/
        }
      },
      keyword: /\b(?:else|if)\b/,
      boolean: /\b(?:false|true)\b/,
      "builtin-function": {
        // a few functions get special highlighting to improve readability
        pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
        alias: "keyword"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
      number: /-?\b\d+\b/,
      operator: /[-+!=<>]=?|&&|\|\|/,
      punctuation: /[(){}[\],.]/
    }, t.languages.gn["string-literal"].inside.interpolation.inside.expression.inside = t.languages.gn, t.languages.gni = t.languages.gn;
  }
  return S_;
}
var __, C$;
function _Oe() {
  if (C$) return __;
  C$ = 1, __ = e, e.displayName = "goModule", e.aliases = [];
  function e(t) {
    t.languages["go-mod"] = t.languages["go-module"] = {
      comment: {
        pattern: /\/\/.*/,
        greedy: !0
      },
      version: {
        pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
        lookbehind: !0,
        alias: "number"
      },
      "go-version": {
        pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
        lookbehind: !0,
        alias: "number"
      },
      keyword: {
        pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
        lookbehind: !0
      },
      operator: /=>/,
      punctuation: /[()[\],]/
    };
  }
  return __;
}
var k_, A$;
function kOe() {
  if (A$) return k_;
  A$ = 1, k_ = e, e.displayName = "go", e.aliases = [];
  function e(t) {
    t.languages.go = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
      boolean: /\b(?:_|false|iota|nil|true)\b/,
      number: [
        // binary and octal integers
        /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
        // hexadecimal integers and floats
        /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        // decimal integers and floats
        /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
      ],
      operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
      builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
    }), t.languages.insertBefore("go", "string", {
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
        greedy: !0
      }
    }), delete t.languages.go["class-name"];
  }
  return k_;
}
var C_, T$;
function COe() {
  if (T$) return C_;
  T$ = 1, C_ = e, e.displayName = "graphql", e.aliases = [];
  function e(t) {
    t.languages.graphql = {
      comment: /#.*/,
      description: {
        pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
        greedy: !0,
        alias: "string",
        inside: {
          "language-markdown": {
            pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: t.languages.markdown
          }
        }
      },
      string: {
        pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:false|true)\b/,
      variable: /\$[a-z_]\w*/i,
      directive: {
        pattern: /@[a-z_]\w*/i,
        alias: "function"
      },
      "attr-name": {
        pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
        greedy: !0
      },
      "atom-input": {
        pattern: /\b[A-Z]\w*Input\b/,
        alias: "class-name"
      },
      scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
      constant: /\b[A-Z][A-Z_\d]*\b/,
      "class-name": {
        pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
        lookbehind: !0
      },
      fragment: {
        pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      "definition-mutation": {
        pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      "definition-query": {
        pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
      operator: /[!=|&]|\.{3}/,
      "property-query": /\w+(?=\s*\()/,
      object: /\w+(?=\s*\{)/,
      punctuation: /[!(){}\[\]:=,]/,
      property: /\w+/
    }, t.hooks.add("after-tokenize", function(n) {
      if (n.language !== "graphql")
        return;
      var a = n.tokens.filter(function(b) {
        return typeof b != "string" && b.type !== "comment" && b.type !== "scalar";
      }), s = 0;
      function i(b) {
        return a[s + b];
      }
      function o(b, v) {
        v = v || 0;
        for (var x = 0; x < b.length; x++) {
          var _ = i(x + v);
          if (!_ || _.type !== b[x])
            return !1;
        }
        return !0;
      }
      function l(b, v) {
        for (var x = 1, _ = s; _ < a.length; _++) {
          var E = a[_], w = E.content;
          if (E.type === "punctuation" && typeof w == "string") {
            if (b.test(w))
              x++;
            else if (v.test(w) && (x--, x === 0))
              return _;
          }
        }
        return -1;
      }
      function u(b, v) {
        var x = b.alias;
        x ? Array.isArray(x) || (b.alias = x = [x]) : b.alias = x = [], x.push(v);
      }
      for (; s < a.length; ) {
        var c = a[s++];
        if (c.type === "keyword" && c.content === "mutation") {
          var d = [];
          if (o(["definition-mutation", "punctuation"]) && i(1).content === "(") {
            s += 2;
            var p = l(/^\($/, /^\)$/);
            if (p === -1)
              continue;
            for (; s < p; s++) {
              var f = i(0);
              f.type === "variable" && (u(f, "variable-input"), d.push(f.content));
            }
            s = p + 1;
          }
          if (o(["punctuation", "property-query"]) && i(0).content === "{" && (s++, u(i(0), "property-mutation"), d.length > 0)) {
            var h = l(/^\{$/, /^\}$/);
            if (h === -1)
              continue;
            for (var m = s; m < h; m++) {
              var y = a[m];
              y.type === "variable" && d.indexOf(y.content) >= 0 && u(y, "variable-input");
            }
          }
        }
      }
    });
  }
  return C_;
}
var A_, R$;
function AOe() {
  if (R$) return A_;
  R$ = 1, A_ = e, e.displayName = "groovy", e.aliases = [];
  function e(t) {
    t.languages.groovy = t.languages.extend("clike", {
      string: [
        {
          // https://groovy-lang.org/syntax.html#_dollar_slashy_string
          pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
          greedy: !0
        },
        {
          // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
          // simple division (see JS regex), so find a fix maybe?
          pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: !0
        }
      ],
      keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
      number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
      operator: {
        pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
        lookbehind: !0
      },
      punctuation: /\.+|[{}[\];(),:$]/
    }), t.languages.insertBefore("groovy", "string", {
      shebang: {
        pattern: /#!.+/,
        alias: "comment"
      }
    }), t.languages.insertBefore("groovy", "punctuation", {
      "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    }), t.languages.insertBefore("groovy", "function", {
      annotation: {
        pattern: /(^|[^.])@\w+/,
        lookbehind: !0,
        alias: "punctuation"
      }
    }), t.hooks.add("wrap", function(r) {
      if (r.language === "groovy" && r.type === "string") {
        var n = r.content.value[0];
        if (n != "'") {
          var a = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
          n === "$" && (a = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/), r.content.value = r.content.value.replace(/&lt;/g, "<").replace(/&amp;/g, "&"), r.content = t.highlight(r.content.value, {
            expression: {
              pattern: a,
              lookbehind: !0,
              inside: t.languages.groovy
            }
          }), r.classes.push(n === "/" ? "regex" : "gstring");
        }
      }
    });
  }
  return A_;
}
var T_, I$;
function TOe() {
  if (I$) return T_;
  I$ = 1;
  var e = vy();
  T_ = t, t.displayName = "haml", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      n.languages.haml = {
        // Multiline stuff should appear before the rest
        "multiline-comment": {
          pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
          lookbehind: !0,
          alias: "comment"
        },
        "multiline-code": [
          {
            pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
            lookbehind: !0,
            inside: n.languages.ruby
          },
          {
            pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
            lookbehind: !0,
            inside: n.languages.ruby
          }
        ],
        // See at the end of the file for known filters
        filter: {
          pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "symbol"
            }
          }
        },
        markup: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
          lookbehind: !0,
          inside: n.languages.markup
        },
        doctype: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
          lookbehind: !0
        },
        tag: {
          // Allows for one nested group of braces
          pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
          lookbehind: !0,
          inside: {
            attributes: [
              {
                // Lookbehind tries to prevent interpolations from breaking it all
                // Allows for one nested group of braces
                pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
                lookbehind: !0,
                inside: n.languages.ruby
              },
              {
                pattern: /\([^)]+\)/,
                inside: {
                  "attr-value": {
                    pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                    lookbehind: !0
                  },
                  "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                  punctuation: /[=(),]/
                }
              },
              {
                pattern: /\[[^\]]+\]/,
                inside: n.languages.ruby
              }
            ],
            punctuation: /[<>]/
          }
        },
        code: {
          pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
          lookbehind: !0,
          inside: n.languages.ruby
        },
        // Interpolations in plain text
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            ruby: {
              pattern: /[\s\S]+/,
              inside: n.languages.ruby
            }
          }
        },
        punctuation: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
          lookbehind: !0
        }
      };
      for (var a = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+", s = [
        "css",
        {
          filter: "coffee",
          language: "coffeescript"
        },
        "erb",
        "javascript",
        "less",
        "markdown",
        "ruby",
        "scss",
        "textile"
      ], i = {}, o = 0, l = s.length; o < l; o++) {
        var u = s[o];
        u = typeof u == "string" ? {
          filter: u,
          language: u
        } : u, n.languages[u.language] && (i["filter-" + u.filter] = {
          pattern: RegExp(
            a.replace("{{filter_name}}", function() {
              return u.filter;
            })
          ),
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "symbol"
            },
            text: {
              pattern: /[\s\S]+/,
              alias: [u.language, "language-" + u.language],
              inside: n.languages[u.language]
            }
          }
        });
      }
      n.languages.insertBefore("haml", "filter", i);
    }(r);
  }
  return T_;
}
var R_, N$;
function ROe() {
  if (N$) return R_;
  N$ = 1;
  var e = Ia();
  R_ = t, t.displayName = "handlebars", t.aliases = ["hbs"];
  function t(r) {
    r.register(e), function(n) {
      n.languages.handlebars = {
        comment: /\{\{![\s\S]*?\}\}/,
        delimiter: {
          pattern: /^\{\{\{?|\}\}\}?$/,
          alias: "punctuation"
        },
        string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
        boolean: /\b(?:false|true)\b/,
        block: {
          pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
          lookbehind: !0,
          alias: "keyword"
        },
        brackets: {
          pattern: /\[[^\]]+\]/,
          inside: {
            punctuation: /\[|\]/,
            variable: /[\s\S]+/
          }
        },
        punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
        variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
      }, n.hooks.add("before-tokenize", function(a) {
        var s = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
        n.languages["markup-templating"].buildPlaceholders(
          a,
          "handlebars",
          s
        );
      }), n.hooks.add("after-tokenize", function(a) {
        n.languages["markup-templating"].tokenizePlaceholders(
          a,
          "handlebars"
        );
      }), n.languages.hbs = n.languages.handlebars;
    }(r);
  }
  return R_;
}
var I_, D$;
function fD() {
  if (D$) return I_;
  D$ = 1, I_ = e, e.displayName = "haskell", e.aliases = ["hs"];
  function e(t) {
    t.languages.haskell = {
      comment: {
        pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
        lookbehind: !0
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
        alias: "string"
      },
      string: {
        pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
        greedy: !0
      },
      keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|hiding|import|qualified)\b/,
          punctuation: /\./
        }
      },
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
      // decimal integers and floating point numbers | octal integers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
      operator: [
        {
          // infix operator
          pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
          greedy: !0
        },
        {
          // function composition
          pattern: /(\s)\.(?=\s)/,
          lookbehind: !0
        },
        // Most of this is needed because of the meaning of a single '.'.
        // If it stands alone freely, it is the function composition.
        // It may also be a separator between a module name and an identifier => no
        // operator. If it comes together with other special characters it is an
        // operator too.
        //
        // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
        /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
      ],
      // In Haskell, nearly everything is a variable, do not highlight these.
      hvariable: {
        pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      constant: {
        pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /[{}[\];(),.:]/
    }, t.languages.hs = t.languages.haskell;
  }
  return I_;
}
var N_, O$;
function IOe() {
  if (O$) return N_;
  O$ = 1, N_ = e, e.displayName = "haxe", e.aliases = [];
  function e(t) {
    t.languages.haxe = t.languages.extend("clike", {
      string: {
        // Strings can be multi-line
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
          lookbehind: !0
        },
        // based on naming convention
        /\b[A-Z]\w*/
      ],
      // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
      keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
      function: {
        pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
        greedy: !0
      },
      operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
    }), t.languages.insertBefore("haxe", "string", {
      "string-interpolation": {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{?|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: t.languages.haxe
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("haxe", "class-name", {
      regex: {
        pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
        greedy: !0,
        inside: {
          "regex-flags": /\b[a-z]+$/,
          "regex-source": {
            pattern: /^(~\/)[\s\S]+(?=\/$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^~\/|\/$/
        }
      }
    }), t.languages.insertBefore("haxe", "keyword", {
      preprocessor: {
        pattern: /#(?:else|elseif|end|if)\b.*/,
        alias: "property"
      },
      metadata: {
        pattern: /@:?[\w.]+/,
        alias: "symbol"
      },
      reification: {
        pattern: /\$(?:\w+|(?=\{))/,
        alias: "important"
      }
    });
  }
  return N_;
}
var D_, P$;
function NOe() {
  if (P$) return D_;
  P$ = 1, D_ = e, e.displayName = "hcl", e.aliases = [];
  function e(t) {
    t.languages.hcl = {
      comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
      heredoc: {
        pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
        greedy: !0,
        alias: "string"
      },
      keyword: [
        {
          pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
          inside: {
            type: {
              pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
              lookbehind: !0,
              alias: "variable"
            }
          }
        },
        {
          pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
          inside: {
            type: {
              pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
              lookbehind: !0,
              alias: "variable"
            }
          }
        },
        /[\w-]+(?=\s+\{)/
      ],
      property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
      string: {
        pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
            lookbehind: !0,
            inside: {
              type: {
                pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
                lookbehind: !0,
                alias: "variable"
              },
              keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
              function: /\w+(?=\()/,
              string: {
                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                greedy: !0
              },
              number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
              punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
            }
          }
        }
      },
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      boolean: /\b(?:false|true)\b/i,
      punctuation: /[=\[\]{}]/
    };
  }
  return D_;
}
var O_, L$;
function DOe() {
  if (L$) return O_;
  L$ = 1;
  var e = Wu();
  O_ = t, t.displayName = "hlsl", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.hlsl = r.languages.extend("c", {
      // Regarding keywords and class names:
      // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
      "class-name": [
        r.languages.c["class-name"],
        /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
      ],
      keyword: [
        // HLSL keyword
        /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
        // scalar, vector, and matrix types
        /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
      ],
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
      number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
      boolean: /\b(?:false|true)\b/
    });
  }
  return O_;
}
var P_, M$;
function OOe() {
  if (M$) return P_;
  M$ = 1, P_ = e, e.displayName = "hoon", e.aliases = [];
  function e(t) {
    t.languages.hoon = {
      comment: {
        pattern: /::.*/,
        greedy: !0
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      constant: /%(?:\.[ny]|[\w-]+)/,
      "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
      function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
      keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
    };
  }
  return P_;
}
var L_, F$;
function POe() {
  if (F$) return L_;
  F$ = 1, L_ = e, e.displayName = "hpkp", e.aliases = [];
  function e(t) {
    t.languages.hpkp = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return L_;
}
var M_, $$;
function LOe() {
  if ($$) return M_;
  $$ = 1, M_ = e, e.displayName = "hsts", e.aliases = [];
  function e(t) {
    t.languages.hsts = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return M_;
}
var F_, B$;
function MOe() {
  if (B$) return F_;
  B$ = 1, F_ = e, e.displayName = "http", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(d) {
        return RegExp("(^(?:" + d + "):[ 	]*(?![ 	]))[^]+", "i");
      }
      r.languages.http = {
        "request-line": {
          pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
          inside: {
            // HTTP Method
            method: {
              pattern: /^[A-Z]+\b/,
              alias: "property"
            },
            // Request Target e.g. http://example.com, /path/to/file
            "request-target": {
              pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
              lookbehind: !0,
              alias: "url",
              inside: r.languages.uri
            },
            // HTTP Version
            "http-version": {
              pattern: /^(\s)HTTP\/[\d.]+/,
              lookbehind: !0,
              alias: "property"
            }
          }
        },
        "response-status": {
          pattern: /^HTTP\/[\d.]+ \d+ .+/m,
          inside: {
            // HTTP Version
            "http-version": {
              pattern: /^HTTP\/[\d.]+/,
              alias: "property"
            },
            // Status Code
            "status-code": {
              pattern: /^(\s)\d+(?=\s)/,
              lookbehind: !0,
              alias: "number"
            },
            // Reason Phrase
            "reason-phrase": {
              pattern: /^(\s).+/,
              lookbehind: !0,
              alias: "string"
            }
          }
        },
        header: {
          pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
          inside: {
            "header-value": [
              {
                pattern: n(/Content-Security-Policy/.source),
                lookbehind: !0,
                alias: ["csp", "languages-csp"],
                inside: r.languages.csp
              },
              {
                pattern: n(/Public-Key-Pins(?:-Report-Only)?/.source),
                lookbehind: !0,
                alias: ["hpkp", "languages-hpkp"],
                inside: r.languages.hpkp
              },
              {
                pattern: n(/Strict-Transport-Security/.source),
                lookbehind: !0,
                alias: ["hsts", "languages-hsts"],
                inside: r.languages.hsts
              },
              {
                pattern: n(/[^:]+/.source),
                lookbehind: !0
              }
            ],
            "header-name": {
              pattern: /^[^:]+/,
              alias: "keyword"
            },
            punctuation: /^:/
          }
        }
      };
      var a = r.languages, s = {
        "application/javascript": a.javascript,
        "application/json": a.json || a.javascript,
        "application/xml": a.xml,
        "text/xml": a.xml,
        "text/html": a.html,
        "text/css": a.css,
        "text/plain": a.plain
      }, i = {
        "application/json": !0,
        "application/xml": !0
      };
      function o(d) {
        var p = d.replace(/^[a-z]+\//, ""), f = "\\w+/(?:[\\w.-]+\\+)+" + p + "(?![+\\w.-])";
        return "(?:" + d + "|" + f + ")";
      }
      var l;
      for (var u in s)
        if (s[u]) {
          l = l || {};
          var c = i[u] ? o(u) : u;
          l[u.replace(/\//g, "-")] = {
            pattern: RegExp(
              "(" + /content-type:\s*/.source + c + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
              // However, when writing code by hand (e.g. to display on a website) people can forget about this,
              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
              // the body does not start with a [\w-] character (as headers do).
              /[^ \t\w-][\s\S]*/.source,
              "i"
            ),
            lookbehind: !0,
            inside: s[u]
          };
        }
      l && r.languages.insertBefore("http", "header", l);
    })(t);
  }
  return F_;
}
var $_, U$;
function FOe() {
  if (U$) return $_;
  U$ = 1, $_ = e, e.displayName = "ichigojam", e.aliases = [];
  function e(t) {
    t.languages.ichigojam = {
      comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: !0
      },
      number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
      function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
      label: /(?:\B@\S+)/,
      operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
      punctuation: /[\[,;:()\]]/
    };
  }
  return $_;
}
var B_, z$;
function $Oe() {
  if (z$) return B_;
  z$ = 1, B_ = e, e.displayName = "icon", e.aliases = [];
  function e(t) {
    t.languages.icon = {
      comment: /#.*/,
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
        greedy: !0
      },
      number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
      "builtin-keyword": {
        pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
        alias: "variable"
      },
      directive: {
        pattern: /\$\w+/,
        alias: "builtin"
      },
      keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
      function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
      operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
      punctuation: /[\[\](){},;]/
    };
  }
  return B_;
}
var U_, q$;
function BOe() {
  if (q$) return U_;
  q$ = 1, U_ = e, e.displayName = "icuMessageFormat", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(u, c) {
        return c <= 0 ? /[]/.source : u.replace(/<SELF>/g, function() {
          return n(u, c - 1);
        });
      }
      var a = /'[{}:=,](?:[^']|'')*'(?!')/, s = {
        pattern: /''/,
        greedy: !0,
        alias: "operator"
      }, i = {
        pattern: a,
        greedy: !0,
        inside: {
          escape: s
        }
      }, o = n(
        /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
          /<STR>/g,
          function() {
            return a.source;
          }
        ),
        8
      ), l = {
        pattern: RegExp(o),
        inside: {
          message: {
            pattern: /^(\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "message-delimiter": {
            pattern: /./,
            alias: "punctuation"
          }
        }
      };
      r.languages["icu-message-format"] = {
        argument: {
          pattern: RegExp(o),
          greedy: !0,
          inside: {
            content: {
              pattern: /^(\{)[\s\S]+(?=\}$)/,
              lookbehind: !0,
              inside: {
                "argument-name": {
                  pattern: /^(\s*)[^{}:=,\s]+/,
                  lookbehind: !0
                },
                "choice-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                  pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\|/,
                    range: {
                      pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                      lookbehind: !0,
                      inside: {
                        operator: /[<#\u2264]/,
                        number: /\S+/
                      }
                    },
                    rest: null
                    // see below
                  }
                },
                "plural-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    offset: /^offset:\s*\d+/,
                    "nested-message": l,
                    selector: {
                      pattern: /=\d+|[^{}:=,\s]+/,
                      inside: {
                        keyword: /^(?:few|many|one|other|two|zero)$/
                      }
                    }
                  }
                },
                "select-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    "nested-message": l,
                    selector: {
                      pattern: /[^{}:=,\s]+/,
                      inside: {
                        keyword: /^other$/
                      }
                    }
                  }
                },
                keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                "arg-type": {
                  pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                  alias: "keyword"
                },
                "arg-skeleton": {
                  pattern: /(,\s*)::[^{}:=,\s]+/,
                  lookbehind: !0
                },
                "arg-style": {
                  pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                  lookbehind: !0
                },
                "arg-style-text": {
                  pattern: RegExp(
                    /(^\s*,\s*(?=\S))/.source + n(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
                  ),
                  lookbehind: !0,
                  alias: "string"
                },
                punctuation: /,/
              }
            },
            "argument-delimiter": {
              pattern: /./,
              alias: "operator"
            }
          }
        },
        escape: s,
        string: i
      }, l.inside.message.inside = r.languages["icu-message-format"], r.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = r.languages["icu-message-format"];
    })(t);
  }
  return U_;
}
var z_, j$;
function UOe() {
  if (j$) return z_;
  j$ = 1;
  var e = fD();
  z_ = t, t.displayName = "idris", t.aliases = ["idr"];
  function t(r) {
    r.register(e), r.languages.idris = r.languages.extend("haskell", {
      comment: {
        pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
      },
      keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
      builtin: void 0
    }), r.languages.insertBefore("idris", "keyword", {
      "import-statement": {
        pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    }), r.languages.idr = r.languages.idris;
  }
  return z_;
}
var q_, H$;
function zOe() {
  if (H$) return q_;
  H$ = 1, q_ = e, e.displayName = "iecst", e.aliases = [];
  function e(t) {
    t.languages.iecst = {
      comment: [
        {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: [
        /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
        /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
      ],
      "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
      address: {
        pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
        alias: "symbol"
      },
      number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/,
      operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      punctuation: /[()[\].,;]/
    };
  }
  return q_;
}
var j_, V$;
function qOe() {
  if (V$) return j_;
  V$ = 1, j_ = e, e.displayName = "ignore", e.aliases = ["gitignore", "hgignore", "npmignore"];
  function e(t) {
    (function(r) {
      r.languages.ignore = {
        // https://git-scm.com/docs/gitignore
        comment: /^#.*/m,
        entry: {
          pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
          alias: "string",
          inside: {
            operator: /^!|\*\*?|\?/,
            regex: {
              pattern: /(^|[^\\])\[[^\[\]]*\]/,
              lookbehind: !0
            },
            punctuation: /\//
          }
        }
      }, r.languages.gitignore = r.languages.ignore, r.languages.hgignore = r.languages.ignore, r.languages.npmignore = r.languages.ignore;
    })(t);
  }
  return j_;
}
var H_, G$;
function jOe() {
  if (G$) return H_;
  G$ = 1, H_ = e, e.displayName = "inform7", e.aliases = [];
  function e(t) {
    t.languages.inform7 = {
      string: {
        pattern: /"[^"]*"/,
        inside: {
          substitution: {
            pattern: /\[[^\[\]]+\]/,
            inside: {
              delimiter: {
                pattern: /\[|\]/,
                alias: "punctuation"
              }
              // See rest below
            }
          }
        }
      },
      comment: {
        pattern: /\[[^\[\]]+\]/,
        greedy: !0
      },
      title: {
        pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
        alias: "important"
      },
      number: {
        pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
        lookbehind: !0
      },
      verb: {
        pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
        lookbehind: !0,
        alias: "operator"
      },
      keyword: {
        pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
        lookbehind: !0
      },
      property: {
        pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
        lookbehind: !0,
        alias: "symbol"
      },
      position: {
        pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
        lookbehind: !0,
        alias: "keyword"
      },
      type: {
        pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
        lookbehind: !0,
        alias: "variable"
      },
      punctuation: /[.,:;(){}]/
    }, t.languages.inform7.string.inside.substitution.inside.rest = t.languages.inform7, t.languages.inform7.string.inside.substitution.inside.rest.text = {
      pattern: /\S(?:\s*\S)*/,
      alias: "comment"
    };
  }
  return H_;
}
var V_, W$;
function HOe() {
  if (W$) return V_;
  W$ = 1, V_ = e, e.displayName = "ini", e.aliases = [];
  function e(t) {
    t.languages.ini = {
      /**
       * The component mimics the behavior of the Win32 API parser.
       *
       * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
       */
      comment: {
        pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
        lookbehind: !0
      },
      section: {
        pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
        lookbehind: !0,
        inside: {
          "section-name": {
            pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
            lookbehind: !0,
            alias: "selector"
          },
          punctuation: /\[|\]/
        }
      },
      key: {
        pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      value: {
        pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
        lookbehind: !0,
        alias: "attr-value",
        inside: {
          "inner-value": {
            pattern: /^("|').+(?=\1$)/,
            lookbehind: !0
          }
        }
      },
      punctuation: /=/
    };
  }
  return V_;
}
var G_, K$;
function VOe() {
  if (K$) return G_;
  K$ = 1, G_ = e, e.displayName = "io", e.aliases = [];
  function e(t) {
    t.languages.io = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
        lookbehind: !0,
        greedy: !0
      },
      "triple-quoted-string": {
        pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /"(?:\\.|[^\\\r\n"])*"/,
        greedy: !0
      },
      keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
      builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
      operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return G_;
}
var W_, Y$;
function GOe() {
  if (Y$) return W_;
  Y$ = 1, W_ = e, e.displayName = "j", e.aliases = [];
  function e(t) {
    t.languages.j = {
      comment: {
        pattern: /\bNB\..*/,
        greedy: !0
      },
      string: {
        pattern: /'(?:''|[^'\r\n])*'/,
        greedy: !0
      },
      keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
      verb: {
        // Negative look-ahead prevents bad highlighting
        // of ^: ;. =. =: !. !:
        pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
        alias: "keyword"
      },
      number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
      adverb: {
        pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
        alias: "builtin"
      },
      operator: /[=a][.:]|_\./,
      conjunction: {
        pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
        alias: "variable"
      },
      punctuation: /[()]/
    };
  }
  return W_;
}
var K_, X$;
function pD() {
  if (X$) return K_;
  X$ = 1, K_ = e, e.displayName = "java", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, a = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, s = {
        pattern: RegExp(a + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: !0,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /\./
        }
      };
      r.languages.java = r.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
          lookbehind: !0,
          greedy: !0
        },
        "class-name": [
          s,
          {
            // variables and parameters
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(
              a + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
            ),
            lookbehind: !0,
            inside: s.inside
          }
        ],
        keyword: n,
        function: [
          r.languages.clike.function,
          {
            pattern: /(::\s*)[a-z_]\w*/,
            lookbehind: !0
          }
        ],
        number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        operator: {
          pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
          lookbehind: !0
        }
      }), r.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          // http://openjdk.java.net/jeps/355#Description
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: !0,
          alias: "string"
        },
        char: {
          pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
          greedy: !0
        }
      }), r.languages.insertBefore("java", "class-name", {
        annotation: {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: !0,
          alias: "punctuation"
        },
        generics: {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": s,
            keyword: n,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        },
        namespace: {
          pattern: RegExp(
            /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
              /<keyword>/g,
              function() {
                return n.source;
              }
            )
          ),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      });
    })(t);
  }
  return K_;
}
var Y_, Z$;
function wy() {
  if (Z$) return Y_;
  Z$ = 1, Y_ = e, e.displayName = "javadoclike", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = r.languages.javadoclike = {
        parameter: {
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
          lookbehind: !0
        },
        keyword: {
          // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
          // @word, {@word}
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
          lookbehind: !0
        },
        punctuation: /[{}]/
      };
      function a(i, o) {
        var l = "doc-comment", u = r.languages[i];
        if (u) {
          var c = u[l];
          if (!c) {
            var d = {};
            d[l] = {
              pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
              lookbehind: !0,
              alias: "comment"
            }, u = r.languages.insertBefore(i, "comment", d), c = u[l];
          }
          if (c instanceof RegExp && (c = u[l] = {
            pattern: c
          }), Array.isArray(c))
            for (var p = 0, f = c.length; p < f; p++)
              c[p] instanceof RegExp && (c[p] = {
                pattern: c[p]
              }), o(c[p]);
          else
            o(c);
        }
      }
      function s(i, o) {
        typeof i == "string" && (i = [i]), i.forEach(function(l) {
          a(l, function(u) {
            u.inside || (u.inside = {}), u.inside.rest = o;
          });
        });
      }
      Object.defineProperty(n, "addSupport", {
        value: s
      }), n.addSupport(["java", "javascript", "php"], n);
    })(t);
  }
  return Y_;
}
var X_, J$;
function WOe() {
  if (J$) return X_;
  J$ = 1;
  var e = pD(), t = wy();
  X_ = r, r.displayName = "javadoc", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      var s = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m, i = /#\s*\w+(?:\s*\([^()]*\))?/.source, o = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
        /<mem>/g,
        function() {
          return i;
        }
      );
      a.languages.javadoc = a.languages.extend("javadoclike", {}), a.languages.insertBefore("javadoc", "keyword", {
        reference: {
          pattern: RegExp(
            /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + o + ")"
          ),
          lookbehind: !0,
          inside: {
            function: {
              pattern: /(#\s*)\w+(?=\s*\()/,
              lookbehind: !0
            },
            field: {
              pattern: /(#\s*)\w+/,
              lookbehind: !0
            },
            namespace: {
              pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
              inside: {
                punctuation: /\./
              }
            },
            "class-name": /\b[A-Z]\w*/,
            keyword: a.languages.java.keyword,
            punctuation: /[#()[\],.]/
          }
        },
        "class-name": {
          // @param <T> the first generic type parameter
          pattern: /(@param\s+)<[A-Z]\w*>/,
          lookbehind: !0,
          inside: {
            punctuation: /[.<>]/
          }
        },
        "code-section": [
          {
            pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
            lookbehind: !0,
            inside: {
              code: {
                // there can't be any HTML inside of {@code} tags
                pattern: s,
                lookbehind: !0,
                inside: a.languages.java,
                alias: "language-java"
              }
            }
          },
          {
            pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
            lookbehind: !0,
            inside: {
              line: {
                pattern: s,
                lookbehind: !0,
                inside: {
                  // highlight HTML tags and entities
                  tag: a.languages.markup.tag,
                  entity: a.languages.markup.entity,
                  code: {
                    // everything else is Java code
                    pattern: /.+/,
                    inside: a.languages.java,
                    alias: "language-java"
                  }
                }
              }
            }
          }
        ],
        tag: a.languages.markup.tag,
        entity: a.languages.markup.entity
      }), a.languages.javadoclike.addSupport("java", a.languages.javadoc);
    }(n);
  }
  return X_;
}
var Z_, Q$;
function KOe() {
  if (Q$) return Z_;
  Q$ = 1, Z_ = e, e.displayName = "javastacktrace", e.aliases = [];
  function e(t) {
    t.languages.javastacktrace = {
      // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: com.example.myproject.MyProjectServletException
      // Caused by: MidLevelException: LowLevelException
      // Suppressed: Resource$CloseFailException: Resource ID = 0
      summary: {
        pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
            lookbehind: !0
          },
          // the current thread if the summary starts with 'Exception in thread'
          string: {
            pattern: /^(\s*)"[^"]*"/,
            lookbehind: !0
          },
          exceptions: {
            pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
            lookbehind: !0,
            inside: {
              "class-name": /[\w$]+$/,
              namespace: /\b[a-z]\w*\b/,
              punctuation: /\./
            }
          },
          message: {
            pattern: /(:\s*)\S.*/,
            lookbehind: !0,
            alias: "string"
          },
          punctuation: /:/
        }
      },
      // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
      // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
      // at java.base/java.lang.Class.forName0(Native Method)
      // at Util.<init>(Unknown Source)
      // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
      // at com.foo.loader//com.foo.bar.App.run(App.java:12)
      // at acme@2.1/org.acme.Lib.test(Lib.java:80)
      // at MyClass.mash(MyClass.java:9)
      //
      // More information:
      // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
      //
      // A valid Java module name is defined as:
      //   "A module name consists of one or more Java identifiers (§3.8) separated by "." tokens."
      // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
      //
      // A Java module version is defined by this class:
      // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
      // This is the implementation of the `parse` method in JDK13:
      // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
      // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
      "stack-frame": {
        pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /^(\s*)at(?= )/,
            lookbehind: !0
          },
          source: [
            // (Main.java:15)
            // (Main.scala:15)
            {
              pattern: /(\()\w+\.\w+:\d+(?=\))/,
              lookbehind: !0,
              inside: {
                file: /^\w+\.\w+/,
                punctuation: /:/,
                "line-number": {
                  pattern: /\b\d+\b/,
                  alias: "number"
                }
              }
            },
            // (Unknown Source)
            // (Native Method)
            // (...something...)
            {
              pattern: /(\()[^()]*(?=\))/,
              lookbehind: !0,
              inside: {
                keyword: /^(?:Native Method|Unknown Source)$/
              }
            }
          ],
          "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
          function: /(?:<init>|[\w$]+)(?=\()/,
          "class-loader": {
            pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
            lookbehind: !0,
            alias: "namespace",
            inside: {
              punctuation: /\./
            }
          },
          module: {
            pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
            lookbehind: !0,
            inside: {
              version: {
                pattern: /(@)[\s\S]+/,
                lookbehind: !0,
                alias: "number"
              },
              punctuation: /[@.]/
            }
          },
          namespace: {
            pattern: /(?:\b[a-z]\w*\.)+/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()/.]/
        }
      },
      // ... 32 more
      // ... 32 common frames omitted
      more: {
        pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /\.{3}/,
          number: /\d+/,
          keyword: /\b[a-z]+(?: [a-z]+)*\b/
        }
      }
    };
  }
  return Z_;
}
var J_, e8;
function YOe() {
  if (e8) return J_;
  e8 = 1, J_ = e, e.displayName = "jexl", e.aliases = [];
  function e(t) {
    t.languages.jexl = {
      string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
      transform: {
        pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
        alias: "function",
        lookbehind: !0
      },
      function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
      number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
      operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
      boolean: /\b(?:false|true)\b/,
      keyword: /\bin\b/,
      punctuation: /[{}[\](),.]/
    };
  }
  return J_;
}
var Q_, t8;
function XOe() {
  if (t8) return Q_;
  t8 = 1, Q_ = e, e.displayName = "jolie", e.aliases = [];
  function e(t) {
    t.languages.jolie = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": {
        pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
      operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
      punctuation: /[()[\]{},;.:]/,
      builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
    }), t.languages.insertBefore("jolie", "keyword", {
      aggregates: {
        pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
        lookbehind: !0,
        inside: {
          keyword: /\bwith\b/,
          "class-name": /\w+/,
          punctuation: /,/
        }
      },
      redirects: {
        pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
        lookbehind: !0,
        inside: {
          punctuation: /,/,
          "class-name": /\w+/,
          operator: /=>/
        }
      },
      property: {
        pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
      }
    });
  }
  return Q_;
}
var ek, r8;
function ZOe() {
  if (r8) return ek;
  r8 = 1, ek = e, e.displayName = "jq", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\\\((?:[^()]|\([^()]*\))*\)/.source, a = RegExp(
        /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
          /__/g,
          function() {
            return n;
          }
        )
      ), s = {
        interpolation: {
          pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + n),
          lookbehind: !0,
          inside: {
            content: {
              pattern: /^(\\\()[\s\S]+(?=\)$)/,
              lookbehind: !0,
              inside: null
              // see below
            },
            punctuation: /^\\\(|\)$/
          }
        }
      }, i = r.languages.jq = {
        comment: /#.*/,
        property: {
          pattern: RegExp(a.source + /(?=\s*:(?!:))/.source),
          lookbehind: !0,
          greedy: !0,
          inside: s
        },
        string: {
          pattern: a,
          lookbehind: !0,
          greedy: !0,
          inside: s
        },
        function: {
          pattern: /(\bdef\s+)[a-z_]\w+/i,
          lookbehind: !0
        },
        variable: /\B\$\w+/,
        "property-literal": {
          pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
          alias: "property"
        },
        keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
        operator: [
          {
            pattern: /\|=?/,
            alias: "pipe"
          },
          /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
        ],
        "c-style-function": {
          pattern: /\b[a-z_]\w*(?=\s*\()/i,
          alias: "function"
        },
        punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
        dot: {
          pattern: /\./,
          alias: "important"
        }
      };
      s.interpolation.inside.content.inside = i;
    })(t);
  }
  return ek;
}
var tk, n8;
function JOe() {
  if (n8) return tk;
  n8 = 1, tk = e, e.displayName = "jsExtras", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.insertBefore("javascript", "function-variable", {
        "method-variable": {
          pattern: RegExp(
            "(\\.\\s*)" + r.languages.javascript["function-variable"].pattern.source
          ),
          lookbehind: !0,
          alias: ["function-variable", "method", "function", "property-access"]
        }
      }), r.languages.insertBefore("javascript", "function", {
        method: {
          pattern: RegExp(
            "(\\.\\s*)" + r.languages.javascript.function.source
          ),
          lookbehind: !0,
          alias: ["function", "property-access"]
        }
      }), r.languages.insertBefore("javascript", "constant", {
        "known-class-name": [
          {
            // standard built-ins
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
            pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
            alias: "class-name"
          },
          {
            // errors
            pattern: /\b(?:[A-Z]\w*)Error\b/,
            alias: "class-name"
          }
        ]
      });
      function n(u, c) {
        return RegExp(
          u.replace(/<ID>/g, function() {
            return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
          }),
          c
        );
      }
      r.languages.insertBefore("javascript", "keyword", {
        imports: {
          // https://tc39.es/ecma262/#sec-imports
          pattern: n(
            /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
          ),
          lookbehind: !0,
          inside: r.languages.javascript
        },
        exports: {
          // https://tc39.es/ecma262/#sec-exports
          pattern: n(
            /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
          ),
          lookbehind: !0,
          inside: r.languages.javascript
        }
      }), r.languages.javascript.keyword.unshift(
        {
          pattern: /\b(?:as|default|export|from|import)\b/,
          alias: "module"
        },
        {
          pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
          alias: "control-flow"
        },
        {
          pattern: /\bnull\b/,
          alias: ["null", "nil"]
        },
        {
          pattern: /\bundefined\b/,
          alias: "nil"
        }
      ), r.languages.insertBefore("javascript", "operator", {
        spread: {
          pattern: /\.{3}/,
          alias: "operator"
        },
        arrow: {
          pattern: /=>/,
          alias: "operator"
        }
      }), r.languages.insertBefore("javascript", "punctuation", {
        "property-access": {
          pattern: n(/(\.\s*)#?<ID>/.source),
          lookbehind: !0
        },
        "maybe-class-name": {
          pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
          lookbehind: !0
        },
        dom: {
          // this contains only a few commonly used DOM variables
          pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
          alias: "variable"
        },
        console: {
          pattern: /\bconsole(?=\s*\.)/,
          alias: "class-name"
        }
      });
      for (var a = [
        "function",
        "function-variable",
        "method",
        "method-variable",
        "property-access"
      ], s = 0; s < a.length; s++) {
        var i = a[s], o = r.languages.javascript[i];
        r.util.type(o) === "RegExp" && (o = r.languages.javascript[i] = {
          pattern: o
        });
        var l = o.inside || {};
        o.inside = l, l["maybe-class-name"] = /^[A-Z][\s\S]*/;
      }
    })(t);
  }
  return tk;
}
var rk, i8;
function QOe() {
  if (i8) return rk;
  i8 = 1, rk = e, e.displayName = "jsTemplates", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = r.languages.javascript["template-string"], a = n.pattern.source, s = n.inside.interpolation, i = s.inside["interpolation-punctuation"], o = s.pattern.source;
      function l(m, y) {
        if (r.languages[m])
          return {
            pattern: RegExp("((?:" + y + ")\\s*)" + a),
            lookbehind: !0,
            greedy: !0,
            inside: {
              "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
              },
              "embedded-code": {
                pattern: /[\s\S]+/,
                alias: m
              }
            }
          };
      }
      r.languages.javascript["template-string"] = [
        // styled-jsx:
        //   css`a { color: #25F; }`
        // styled-components:
        //   styled.h1`color: red;`
        l(
          "css",
          /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source
        ),
        // html`<p></p>`
        // div.innerHTML = `<p></p>`
        l("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
        // svg`<path fill="#fff" d="M55.37 ..."/>`
        l("svg", /\bsvg/.source),
        // md`# h1`, markdown`## h2`
        l("markdown", /\b(?:markdown|md)/.source),
        // gql`...`, graphql`...`, graphql.experimental`...`
        l(
          "graphql",
          /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source
        ),
        // sql`...`
        l("sql", /\bsql/.source),
        // vanilla template string
        n
      ].filter(Boolean);
      function u(m, y) {
        return "___" + y.toUpperCase() + "_" + m + "___";
      }
      function c(m, y, b) {
        var v = {
          code: m,
          grammar: y,
          language: b
        };
        return r.hooks.run("before-tokenize", v), v.tokens = r.tokenize(v.code, v.grammar), r.hooks.run("after-tokenize", v), v.tokens;
      }
      function d(m) {
        var y = {};
        y["interpolation-punctuation"] = i;
        var b = r.tokenize(m, y);
        if (b.length === 3) {
          var v = [1, 1];
          v.push.apply(
            v,
            c(b[1], r.languages.javascript, "javascript")
          ), b.splice.apply(b, v);
        }
        return new r.Token(
          "interpolation",
          b,
          s.alias,
          m
        );
      }
      function p(m, y, b) {
        var v = r.tokenize(m, {
          interpolation: {
            pattern: RegExp(o),
            lookbehind: !0
          }
        }), x = 0, _ = {}, E = v.map(function(S) {
          if (typeof S == "string")
            return S;
          for (var B = S.content, U; m.indexOf(
            U = u(x++, b)
          ) !== -1; )
            ;
          return _[U] = B, U;
        }).join(""), w = c(E, y, b), C = Object.keys(_);
        x = 0;
        function k(S) {
          for (var B = 0; B < S.length; B++) {
            if (x >= C.length)
              return;
            var U = S[B];
            if (typeof U == "string" || typeof U.content == "string") {
              var N = C[x], O = typeof U == "string" ? U : (
                /** @type {string} */
                U.content
              ), I = O.indexOf(N);
              if (I !== -1) {
                ++x;
                var q = O.substring(0, I), ae = d(
                  _[N]
                ), Q = O.substring(I + N.length), ne = [];
                if (q && ne.push(q), ne.push(ae), Q) {
                  var le = [Q];
                  k(le), ne.push.apply(ne, le);
                }
                typeof U == "string" ? (S.splice.apply(S, [B, 1].concat(ne)), B += ne.length - 1) : U.content = ne;
              }
            } else {
              var W = U.content;
              Array.isArray(W) ? k(W) : k([W]);
            }
          }
        }
        return k(w), new r.Token(
          b,
          w,
          "language-" + b,
          m
        );
      }
      var f = {
        javascript: !0,
        js: !0,
        typescript: !0,
        ts: !0,
        jsx: !0,
        tsx: !0
      };
      r.hooks.add("after-tokenize", function(m) {
        if (!(m.language in f))
          return;
        function y(b) {
          for (var v = 0, x = b.length; v < x; v++) {
            var _ = b[v];
            if (typeof _ != "string") {
              var E = _.content;
              if (!Array.isArray(E)) {
                typeof E != "string" && y([E]);
                continue;
              }
              if (_.type === "template-string") {
                var w = E[1];
                if (E.length === 3 && typeof w != "string" && w.type === "embedded-code") {
                  var C = h(w), k = w.alias, S = Array.isArray(k) ? k[0] : k, B = r.languages[S];
                  if (!B)
                    continue;
                  E[1] = p(C, B, S);
                }
              } else
                y(E);
            }
          }
        }
        y(m.tokens);
      });
      function h(m) {
        return typeof m == "string" ? m : Array.isArray(m) ? m.map(h).join("") : h(m.content);
      }
    })(t);
  }
  return rk;
}
var nk, a8;
function hD() {
  if (a8) return nk;
  a8 = 1, nk = e, e.displayName = "typescript", e.aliases = ["ts"];
  function e(t) {
    (function(r) {
      r.languages.typescript = r.languages.extend("javascript", {
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
      }), r.languages.typescript.keyword.push(
        /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
        // keywords that have to be followed by an identifier
        /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
        // This is for `import type *, {}`
        /\btype\b(?=\s*(?:[\{*]|$))/
      ), delete r.languages.typescript.parameter, delete r.languages.typescript["literal-property"];
      var n = r.languages.extend("typescript", {});
      delete n["class-name"], r.languages.typescript["class-name"].inside = n, r.languages.insertBefore("typescript", "function", {
        decorator: {
          pattern: /@[$\w\xA0-\uFFFF]+/,
          inside: {
            at: {
              pattern: /^@/,
              alias: "operator"
            },
            function: /^[\s\S]+/
          }
        },
        "generic-function": {
          // e.g. foo<T extends "bar" | "baz">( ...
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
          greedy: !0,
          inside: {
            function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
            generic: {
              pattern: /<[\s\S]+/,
              // everything after the first <
              alias: "class-name",
              inside: n
            }
          }
        }
      }), r.languages.ts = r.languages.typescript;
    })(t);
  }
  return nk;
}
var ik, s8;
function e4e() {
  if (s8) return ik;
  s8 = 1;
  var e = wy(), t = hD();
  ik = r, r.displayName = "jsdoc", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      var s = a.languages.javascript, i = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, o = "(@(?:arg|argument|param|property)\\s+(?:" + i + "\\s+)?)";
      a.languages.jsdoc = a.languages.extend("javadoclike", {
        parameter: {
          // @param {string} foo - foo bar
          pattern: RegExp(
            o + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source
          ),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      }), a.languages.insertBefore("jsdoc", "keyword", {
        "optional-parameter": {
          // @param {string} [baz.foo="bar"] foo bar
          pattern: RegExp(
            o + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
          ),
          lookbehind: !0,
          inside: {
            parameter: {
              pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
              lookbehind: !0,
              inside: {
                punctuation: /\./
              }
            },
            code: {
              pattern: /(=)[\s\S]*(?=\]$)/,
              lookbehind: !0,
              inside: s,
              alias: "language-javascript"
            },
            punctuation: /[=[\]]/
          }
        },
        "class-name": [
          {
            pattern: RegExp(
              /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
                /<TYPE>/g,
                function() {
                  return i;
                }
              )
            ),
            lookbehind: !0,
            inside: {
              punctuation: /\./
            }
          },
          {
            pattern: RegExp("(@[a-z]+\\s+)" + i),
            lookbehind: !0,
            inside: {
              string: s.string,
              number: s.number,
              boolean: s.boolean,
              keyword: a.languages.typescript.keyword,
              operator: /=>|\.\.\.|[&|?:*]/,
              punctuation: /[.,;=<>{}()[\]]/
            }
          }
        ],
        example: {
          pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
          lookbehind: !0,
          inside: {
            code: {
              pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
              lookbehind: !0,
              inside: s,
              alias: "language-javascript"
            }
          }
        }
      }), a.languages.javadoclike.addSupport("javascript", a.languages.jsdoc);
    }(n);
  }
  return ik;
}
var ak, o8;
function mD() {
  if (o8) return ak;
  o8 = 1, ak = e, e.displayName = "json", e.aliases = ["webmanifest"];
  function e(t) {
    t.languages.json = {
      property: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: !0
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      punctuation: /[{}[\],]/,
      operator: /:/,
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      }
    }, t.languages.webmanifest = t.languages.json;
  }
  return ak;
}
var sk, l8;
function t4e() {
  if (l8) return sk;
  l8 = 1;
  var e = mD();
  sk = t, t.displayName = "json5", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
      n.languages.json5 = n.languages.extend("json", {
        property: [
          {
            pattern: RegExp(a.source + "(?=\\s*:)"),
            greedy: !0
          },
          {
            pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
            alias: "unquoted"
          }
        ],
        string: {
          pattern: a,
          greedy: !0
        },
        number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
      });
    }(r);
  }
  return sk;
}
var ok, u8;
function r4e() {
  if (u8) return ok;
  u8 = 1;
  var e = mD();
  ok = t, t.displayName = "jsonp", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.jsonp = r.languages.extend("json", {
      punctuation: /[{}[\]();,.]/
    }), r.languages.insertBefore("jsonp", "punctuation", {
      function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
    });
  }
  return ok;
}
var lk, c8;
function n4e() {
  if (c8) return lk;
  c8 = 1, lk = e, e.displayName = "jsstacktrace", e.aliases = [];
  function e(t) {
    t.languages.jsstacktrace = {
      "error-message": {
        pattern: /^\S.*/m,
        alias: "string"
      },
      "stack-frame": {
        pattern: /(^[ \t]+)at[ \t].*/m,
        lookbehind: !0,
        inside: {
          "not-my-code": {
            pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
            alias: "comment"
          },
          filename: {
            pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
            lookbehind: !0,
            alias: "url"
          },
          function: {
            pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
            lookbehind: !0,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()]/,
          keyword: /\b(?:at|new)\b/,
          alias: {
            pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
            alias: "variable"
          },
          "line-number": {
            pattern: /:\d+(?::\d+)?\b/,
            alias: "number",
            inside: {
              punctuation: /:/
            }
          }
        }
      }
    };
  }
  return lk;
}
var uk, d8;
function LW() {
  if (d8) return uk;
  d8 = 1, uk = e, e.displayName = "jsx", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = r.util.clone(r.languages.javascript), a = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, s = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, i = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
      function o(c, d) {
        return c = c.replace(/<S>/g, function() {
          return a;
        }).replace(/<BRACES>/g, function() {
          return s;
        }).replace(/<SPREAD>/g, function() {
          return i;
        }), RegExp(c, d);
      }
      i = o(i).source, r.languages.jsx = r.languages.extend("markup", n), r.languages.jsx.tag.pattern = o(
        /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
      ), r.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, r.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, r.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, r.languages.jsx.tag.inside.comment = n.comment, r.languages.insertBefore(
        "inside",
        "attr-name",
        {
          spread: {
            pattern: o(/<SPREAD>/.source),
            inside: r.languages.jsx
          }
        },
        r.languages.jsx.tag
      ), r.languages.insertBefore(
        "inside",
        "special-attr",
        {
          script: {
            // Allow for two levels of nesting
            pattern: o(/=<BRACES>/.source),
            alias: "language-javascript",
            inside: {
              "script-punctuation": {
                pattern: /^=(?=\{)/,
                alias: "punctuation"
              },
              rest: r.languages.jsx
            }
          }
        },
        r.languages.jsx.tag
      );
      var l = function(c) {
        return c ? typeof c == "string" ? c : typeof c.content == "string" ? c.content : c.content.map(l).join("") : "";
      }, u = function(c) {
        for (var d = [], p = 0; p < c.length; p++) {
          var f = c[p], h = !1;
          if (typeof f != "string" && (f.type === "tag" && f.content[0] && f.content[0].type === "tag" ? f.content[0].content[0].content === "</" ? d.length > 0 && d[d.length - 1].tagName === l(f.content[0].content[1]) && d.pop() : f.content[f.content.length - 1].content === "/>" || d.push({
            tagName: l(f.content[0].content[1]),
            openedBraces: 0
          }) : d.length > 0 && f.type === "punctuation" && f.content === "{" ? d[d.length - 1].openedBraces++ : d.length > 0 && d[d.length - 1].openedBraces > 0 && f.type === "punctuation" && f.content === "}" ? d[d.length - 1].openedBraces-- : h = !0), (h || typeof f == "string") && d.length > 0 && d[d.length - 1].openedBraces === 0) {
            var m = l(f);
            p < c.length - 1 && (typeof c[p + 1] == "string" || c[p + 1].type === "plain-text") && (m += l(c[p + 1]), c.splice(p + 1, 1)), p > 0 && (typeof c[p - 1] == "string" || c[p - 1].type === "plain-text") && (m = l(c[p - 1]) + m, c.splice(p - 1, 1), p--), c[p] = new r.Token(
              "plain-text",
              m,
              null,
              m
            );
          }
          f.content && typeof f.content != "string" && u(f.content);
        }
      };
      r.hooks.add("after-tokenize", function(c) {
        c.language !== "jsx" && c.language !== "tsx" || u(c.tokens);
      });
    })(t);
  }
  return uk;
}
var ck, f8;
function i4e() {
  if (f8) return ck;
  f8 = 1, ck = e, e.displayName = "julia", e.aliases = [];
  function e(t) {
    t.languages.julia = {
      comment: {
        // support one level of nested comments
        // https://github.com/JuliaLang/julia/pull/6128
        pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
        lookbehind: !0
      },
      regex: {
        // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
        pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
        greedy: !0
      },
      string: {
        // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
        // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
        // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
        pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
        greedy: !0
      },
      char: {
        // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
        pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
      operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
      punctuation: /::?|[{}[\]();,.?]/,
      // https://docs.julialang.org/en/v1/base/numbers/#Base.im
      constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
    };
  }
  return ck;
}
var dk, p8;
function a4e() {
  if (p8) return dk;
  p8 = 1, dk = e, e.displayName = "keepalived", e.aliases = [];
  function e(t) {
    t.languages.keepalived = {
      comment: {
        pattern: /[#!].*/,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
        lookbehind: !0,
        greedy: !0
      },
      // support IPv4, IPv6, subnet mask
      ip: {
        pattern: RegExp(
          /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
            /<ipv4>/g,
            function() {
              return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
            }
          ),
          "i"
        ),
        alias: "number"
      },
      // support *nix / Windows, directory / file
      path: {
        pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
        lookbehind: !0,
        alias: "string"
      },
      variable: /\$\{?\w+\}?/,
      email: {
        pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
        alias: "string"
      },
      "conditional-configuration": {
        pattern: /@\^?[\w-]+/,
        alias: "variable"
      },
      operator: /=/,
      property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
      constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
      number: {
        pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
        lookbehind: !0
      },
      boolean: /\b(?:false|no|off|on|true|yes)\b/,
      punctuation: /[\{\}]/
    };
  }
  return dk;
}
var fk, h8;
function s4e() {
  if (h8) return fk;
  h8 = 1, fk = e, e.displayName = "keyman", e.aliases = [];
  function e(t) {
    t.languages.keyman = {
      comment: {
        pattern: /\bc .*/i,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: !0
      },
      "virtual-key": {
        pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
        greedy: !0,
        alias: "function"
        // alias for styles
      },
      // https://help.keyman.com/developer/language/guide/headers
      "header-keyword": {
        pattern: /&\w+/,
        alias: "bold"
        // alias for styles
      },
      "header-statement": {
        pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
        alias: "bold"
        // alias for styles
      },
      "rule-keyword": {
        pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
        alias: "keyword"
      },
      "structural-keyword": {
        pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
        alias: "keyword"
      },
      "compile-target": {
        pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
        alias: "property"
      },
      // U+####, x###, d### characters and numbers
      number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
      operator: /[+>\\$]|\.\./,
      punctuation: /[()=,]/
    };
  }
  return fk;
}
var pk, m8;
function o4e() {
  if (m8) return pk;
  m8 = 1, pk = e, e.displayName = "kotlin", e.aliases = ["kt", "kts"];
  function e(t) {
    (function(r) {
      r.languages.kotlin = r.languages.extend("clike", {
        keyword: {
          // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
          pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
          lookbehind: !0
        },
        function: [
          {
            pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
            greedy: !0
          },
          {
            pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
        operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
      }), delete r.languages.kotlin["class-name"];
      var n = {
        "interpolation-punctuation": {
          pattern: /^\$\{?|\}$/,
          alias: "punctuation"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: r.languages.kotlin
        }
      };
      r.languages.insertBefore("kotlin", "string", {
        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
        "string-literal": [
          {
            pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
            alias: "multiline",
            inside: {
              interpolation: {
                pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                inside: n
              },
              string: /[\s\S]+/
            }
          },
          {
            pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
            alias: "singleline",
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                lookbehind: !0,
                inside: n
              },
              string: /[\s\S]+/
            }
          }
        ],
        char: {
          // https://kotlinlang.org/spec/expressions.html#character-literals
          pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
          greedy: !0
        }
      }), delete r.languages.kotlin.string, r.languages.insertBefore("kotlin", "keyword", {
        annotation: {
          pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
          alias: "builtin"
        }
      }), r.languages.insertBefore("kotlin", "function", {
        label: {
          pattern: /\b\w+@|@\w+\b/,
          alias: "symbol"
        }
      }), r.languages.kt = r.languages.kotlin, r.languages.kts = r.languages.kotlin;
    })(t);
  }
  return pk;
}
var hk, g8;
function l4e() {
  if (g8) return hk;
  g8 = 1, hk = e, e.displayName = "kumir", e.aliases = ["kum"];
  function e(t) {
    (function(r) {
      var n = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
      function a(s, i) {
        return RegExp(s.replace(/<nonId>/g, n), i);
      }
      r.languages.kumir = {
        comment: {
          pattern: /\|.*/
        },
        prolog: {
          pattern: /#.*/,
          greedy: !0
        },
        string: {
          pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
          greedy: !0
        },
        boolean: {
          pattern: a(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
          lookbehind: !0
        },
        "operator-word": {
          pattern: a(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        "system-variable": {
          pattern: a(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        type: [
          {
            pattern: a(
              /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source
            ),
            lookbehind: !0,
            alias: "builtin"
          },
          {
            pattern: a(
              /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
            ),
            lookbehind: !0,
            alias: "important"
          }
        ],
        /**
         * Should be performed after searching for type names because of "таб".
         * "таб" is a reserved word, but never used without a preceding type name.
         * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
         */
        keyword: {
          pattern: a(
            /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source
          ),
          lookbehind: !0
        },
        /** Should be performed after searching for reserved words. */
        name: {
          // eslint-disable-next-line regexp/no-super-linear-backtracking
          pattern: a(
            /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
          ),
          lookbehind: !0
        },
        /** Should be performed after searching for names. */
        number: {
          pattern: a(
            /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
            "i"
          ),
          lookbehind: !0
        },
        /** Should be performed after searching for words. */
        punctuation: /:=|[(),:;\[\]]/,
        /**
         * Should be performed after searching for
         * - numeric constants (because of "+" and "-");
         * - punctuation marks (because of ":=" and "=").
         */
        "operator-char": {
          pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
          alias: "operator"
        }
      }, r.languages.kum = r.languages.kumir;
    })(t);
  }
  return hk;
}
var mk, b8;
function u4e() {
  if (b8) return mk;
  b8 = 1, mk = e, e.displayName = "kusto", e.aliases = [];
  function e(t) {
    t.languages.kusto = {
      comment: {
        pattern: /\/\/.*/,
        greedy: !0
      },
      string: {
        pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
        greedy: !0
      },
      verb: {
        pattern: /(\|\s*)[a-z][\w-]*/i,
        lookbehind: !0,
        alias: "keyword"
      },
      command: {
        pattern: /\.[a-z][a-z\d-]*\b/,
        alias: "keyword"
      },
      "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
      keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
      boolean: /\b(?:false|null|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/,
      datetime: [
        {
          // RFC 822 + RFC 850
          pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
          alias: "number"
        },
        {
          // ISO 8601
          pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
          alias: "number"
        }
      ],
      number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
      operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
      punctuation: /[()\[\]{},;.:]/
    };
  }
  return mk;
}
var gk, y8;
function c4e() {
  if (y8) return gk;
  y8 = 1, gk = e, e.displayName = "latex", e.aliases = ["tex", "context"];
  function e(t) {
    (function(r) {
      var n = /\\(?:[^a-z()[\]]|[a-z*]+)/i, a = {
        "equation-command": {
          pattern: n,
          alias: "regex"
        }
      };
      r.languages.latex = {
        comment: /%.*/,
        // the verbatim environment prints whitespace to the document
        cdata: {
          pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
          lookbehind: !0
        },
        /*
         * equations can be between $$ $$ or $ $ or \( \) or \[ \]
         * (all are multiline)
         */
        equation: [
          {
            pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
            inside: a,
            alias: "string"
          },
          {
            pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
            lookbehind: !0,
            inside: a,
            alias: "string"
          }
        ],
        /*
         * arguments which are keywords or references are highlighted
         * as keywords
         */
        keyword: {
          pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: !0
        },
        url: {
          pattern: /(\\url\{)[^}]+(?=\})/,
          lookbehind: !0
        },
        /*
         * section or chapter headlines are highlighted as bold so that
         * they stand out more
         */
        headline: {
          pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: !0,
          alias: "class-name"
        },
        function: {
          pattern: n,
          alias: "selector"
        },
        punctuation: /[[\]{}&]/
      }, r.languages.tex = r.languages.latex, r.languages.context = r.languages.latex;
    })(t);
  }
  return gk;
}
var bk, v8;
function xy() {
  if (v8) return bk;
  v8 = 1;
  var e = Ia();
  bk = t, t.displayName = "php", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, s = [
        {
          pattern: /\b(?:false|true)\b/i,
          alias: "boolean"
        },
        {
          pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
          greedy: !0,
          lookbehind: !0
        },
        /\b(?:null)\b/i,
        /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
      ], i = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, o = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, l = /[{}\[\](),:;]/;
      n.languages.php = {
        delimiter: {
          pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
          alias: "important"
        },
        comment: a,
        variable: /\$+(?:\w+\b|(?=\{))/,
        package: {
          pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        "class-name-definition": {
          pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
          lookbehind: !0,
          alias: "class-name"
        },
        "function-definition": {
          pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
          lookbehind: !0,
          alias: "function"
        },
        keyword: [
          {
            pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
            alias: "type-casting",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
            alias: "type-hint",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
            alias: "return-type",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
            alias: "type-declaration",
            greedy: !0
          },
          {
            pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
            alias: "type-declaration",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:parent|self|static)(?=\s*::)/i,
            alias: "static-context",
            greedy: !0
          },
          {
            // yield from
            pattern: /(\byield\s+)from\b/i,
            lookbehind: !0
          },
          // `class` is always a keyword unlike other keywords
          /\bclass\b/i,
          {
            // https://www.php.net/manual/en/reserved.keywords.php
            //
            // keywords cannot be preceded by "->"
            // the complex lookbehind means `(?<!(?:->|::)\s*)`
            pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
            lookbehind: !0
          }
        ],
        "argument-name": {
          pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
          lookbehind: !0
        },
        "class-name": [
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
            greedy: !0
          },
          {
            pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            lookbehind: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            lookbehind: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*\$)/i,
            alias: "type-declaration",
            greedy: !0
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: ["class-name-fully-qualified", "type-declaration"],
            greedy: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*::)/i,
            alias: "static-context",
            greedy: !0
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
            alias: ["class-name-fully-qualified", "static-context"],
            greedy: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
            alias: "type-hint",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: ["class-name-fully-qualified", "type-hint"],
            greedy: !0,
            lookbehind: !0,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
            alias: "return-type",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: ["class-name-fully-qualified", "return-type"],
            greedy: !0,
            lookbehind: !0,
            inside: {
              punctuation: /\\/
            }
          }
        ],
        constant: s,
        function: {
          pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        property: {
          pattern: /(->\s*)\w+/,
          lookbehind: !0
        },
        number: i,
        operator: o,
        punctuation: l
      };
      var u = {
        pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
        lookbehind: !0,
        inside: n.languages.php
      }, c = [
        {
          pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
          alias: "nowdoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: {
                punctuation: /^<<<'?|[';]$/
              }
            }
          }
        },
        {
          pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: {
                punctuation: /^<<<"?|[";]$/
              }
            },
            interpolation: u
          }
        },
        {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          alias: "backtick-quoted-string",
          greedy: !0
        },
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          alias: "single-quoted-string",
          greedy: !0
        },
        {
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          alias: "double-quoted-string",
          greedy: !0,
          inside: {
            interpolation: u
          }
        }
      ];
      n.languages.insertBefore("php", "variable", {
        string: c,
        attribute: {
          pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
          greedy: !0,
          inside: {
            "attribute-content": {
              pattern: /^(#\[)[\s\S]+(?=\]$)/,
              lookbehind: !0,
              // inside can appear subset of php
              inside: {
                comment: a,
                string: c,
                "attribute-class-name": [
                  {
                    pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                    alias: "class-name",
                    greedy: !0,
                    lookbehind: !0
                  },
                  {
                    pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                    alias: ["class-name", "class-name-fully-qualified"],
                    greedy: !0,
                    lookbehind: !0,
                    inside: {
                      punctuation: /\\/
                    }
                  }
                ],
                constant: s,
                number: i,
                operator: o,
                punctuation: l
              }
            },
            delimiter: {
              pattern: /^#\[|\]$/,
              alias: "punctuation"
            }
          }
        }
      }), n.hooks.add("before-tokenize", function(d) {
        if (/<\?/.test(d.code)) {
          var p = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
          n.languages["markup-templating"].buildPlaceholders(
            d,
            "php",
            p
          );
        }
      }), n.hooks.add("after-tokenize", function(d) {
        n.languages["markup-templating"].tokenizePlaceholders(d, "php");
      });
    }(r);
  }
  return bk;
}
var yk, w8;
function d4e() {
  if (w8) return yk;
  w8 = 1;
  var e = Ia(), t = xy();
  yk = r, r.displayName = "latte", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      a.languages.latte = {
        comment: /^\{\*[\s\S]*/,
        "latte-tag": {
          // https://latte.nette.org/en/tags
          pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
          lookbehind: !0,
          alias: "important"
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          alias: "punctuation"
        },
        php: {
          pattern: /\S(?:[\s\S]*\S)?/,
          alias: "language-php",
          inside: a.languages.php
        }
      };
      var s = a.languages.extend("markup", {});
      a.languages.insertBefore(
        "inside",
        "attr-value",
        {
          "n-attr": {
            pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
            inside: {
              "attr-name": {
                pattern: /^[^\s=]+/,
                alias: "important"
              },
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  punctuation: [
                    /^=/,
                    {
                      pattern: /^(\s*)["']|["']$/,
                      lookbehind: !0
                    }
                  ],
                  php: {
                    pattern: /\S(?:[\s\S]*\S)?/,
                    inside: a.languages.php
                  }
                }
              }
            }
          }
        },
        s.tag
      ), a.hooks.add("before-tokenize", function(i) {
        if (i.language === "latte") {
          var o = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
          a.languages["markup-templating"].buildPlaceholders(
            i,
            "latte",
            o
          ), i.grammar = s;
        }
      }), a.hooks.add("after-tokenize", function(i) {
        a.languages["markup-templating"].tokenizePlaceholders(i, "latte");
      });
    }(n);
  }
  return yk;
}
var vk, x8;
function f4e() {
  if (x8) return vk;
  x8 = 1, vk = e, e.displayName = "less", e.aliases = [];
  function e(t) {
    t.languages.less = t.languages.extend("css", {
      comment: [
        /\/\*[\s\S]*?\*\//,
        {
          pattern: /(^|[^\\])\/\/.*/,
          lookbehind: !0
        }
      ],
      atrule: {
        pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          punctuation: /[:()]/
        }
      },
      // selectors and mixins are considered the same
      selector: {
        pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          // mixin parameters
          variable: /@+[\w-]+/
        }
      },
      property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
      operator: /[+\-*\/]/
    }), t.languages.insertBefore("less", "property", {
      variable: [
        // Variable declaration (the colon must be consumed!)
        {
          pattern: /@[\w-]+\s*:/,
          inside: {
            punctuation: /:/
          }
        },
        // Variable usage
        /@@?[\w-]+/
      ],
      "mixin-usage": {
        pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
        lookbehind: !0,
        alias: "function"
      }
    });
  }
  return vk;
}
var wk, E8;
function gD() {
  if (E8) return wk;
  E8 = 1, wk = e, e.displayName = "scheme", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.scheme = {
        // this supports "normal" single-line comments:
        //   ; comment
        // and (potentially nested) multiline comments:
        //   #| comment #| nested |# still comment |#
        // (only 1 level of nesting is supported)
        comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        symbol: {
          pattern: /'[^()\[\]#'\s]+/,
          greedy: !0
        },
        char: {
          pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
          greedy: !0
        },
        "lambda-parameter": [
          // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
            lookbehind: !0
          },
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
            lookbehind: !0
          }
        ],
        keyword: {
          pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        builtin: {
          // all functions of the base library of R7RS plus some of built-ins of R5Rs
          pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        operator: {
          pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        number: {
          // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
          //
          // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
          // <num R>       := <prefix R><complex R>
          // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
          // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
          // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
          // <ureal R>     := <uint R>(?:\/<uint R>)?
          //                | <decimal R>
          //
          // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
          // <uint R>      := <digit R>+
          // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
          // <radix 2>     := #b
          // <radix 8>     := #o
          // <radix 10>    := (?:#d)?
          // <radix 16>    := #x
          // <digit 2>     := [01]
          // <digit 8>     := [0-7]
          // <digit 10>    := \d
          // <digit 16>    := [0-9a-f]
          //
          // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
          // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
          // pattern:
          pattern: RegExp(
            n({
              "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
              "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
              "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
              "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
              "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
              "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
              "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
              "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
              "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
              "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
              "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
            }),
            "i"
          ),
          lookbehind: !0
        },
        boolean: {
          pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        function: {
          pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        identifier: {
          pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
          lookbehind: !0,
          greedy: !0
        },
        punctuation: /[()\[\]']/
      };
      function n(a) {
        for (var s in a)
          a[s] = a[s].replace(/<[\w\s]+>/g, function(i) {
            return "(?:" + a[i].trim() + ")";
          });
        return a[s];
      }
    })(t);
  }
  return wk;
}
var xk, S8;
function p4e() {
  if (S8) return xk;
  S8 = 1;
  var e = gD();
  xk = t, t.displayName = "lilypond", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      for (var a = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source, s = 5, i = 0; i < s; i++)
        a = a.replace(/<expr>/g, function() {
          return a;
        });
      a = a.replace(/<expr>/g, /[^\s\S]/.source);
      var o = n.languages.lilypond = {
        comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
        "embedded-scheme": {
          pattern: RegExp(
            /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
              /<expr>/g,
              function() {
                return a;
              }
            ),
            "m"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            scheme: {
              pattern: /^(#)[\s\S]+$/,
              lookbehind: !0,
              alias: "language-scheme",
              inside: {
                "embedded-lilypond": {
                  pattern: /#\{[\s\S]*?#\}/,
                  greedy: !0,
                  inside: {
                    punctuation: /^#\{|#\}$/,
                    lilypond: {
                      pattern: /[\s\S]+/,
                      alias: "language-lilypond",
                      inside: null
                      // see below
                    }
                  }
                },
                rest: n.languages.scheme
              }
            },
            punctuation: /#/
          }
        },
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        "class-name": {
          pattern: /(\\new\s+)[\w-]+/,
          lookbehind: !0
        },
        keyword: {
          pattern: /\\[a-z][-\w]*/i,
          inside: {
            punctuation: /^\\/
          }
        },
        operator: /[=|]|<<|>>/,
        punctuation: {
          pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
          lookbehind: !0
        },
        number: /\b\d+(?:\/\d+)?\b/
      };
      o["embedded-scheme"].inside.scheme.inside["embedded-lilypond"].inside.lilypond.inside = o, n.languages.ly = o;
    }(r);
  }
  return xk;
}
var Ek, _8;
function h4e() {
  if (_8) return Ek;
  _8 = 1;
  var e = Ia();
  Ek = t, t.displayName = "liquid", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.liquid = {
      comment: {
        pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
        lookbehind: !0
      },
      delimiter: {
        pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
      object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
      function: [
        {
          pattern: /(\|\s*)\w+/,
          lookbehind: !0,
          alias: "filter"
        },
        {
          // array functions
          pattern: /(\.\s*)(?:first|last|size)/,
          lookbehind: !0
        }
      ],
      boolean: /\b(?:false|nil|true)\b/,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
      punctuation: /[.,\[\]()]/,
      empty: {
        pattern: /\bempty\b/,
        alias: "keyword"
      }
    }, r.hooks.add("before-tokenize", function(n) {
      var a = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g, s = !1;
      r.languages["markup-templating"].buildPlaceholders(
        n,
        "liquid",
        a,
        function(i) {
          var o = /^\{%-?\s*(\w+)/.exec(i);
          if (o) {
            var l = o[1];
            if (l === "raw" && !s)
              return s = !0, !0;
            if (l === "endraw")
              return s = !1, !0;
          }
          return !s;
        }
      );
    }), r.hooks.add("after-tokenize", function(n) {
      r.languages["markup-templating"].tokenizePlaceholders(n, "liquid");
    });
  }
  return Ek;
}
var Sk, k8;
function m4e() {
  if (k8) return Sk;
  k8 = 1, Sk = e, e.displayName = "lisp", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(m) {
        return RegExp(/(\()/.source + "(?:" + m + ")" + /(?=[\s\)])/.source);
      }
      function a(m) {
        return RegExp(
          /([\s([])/.source + "(?:" + m + ")" + /(?=[\s)])/.source
        );
      }
      var s = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source, i = "&" + s, o = "(\\()", l = "(?=\\))", u = "(?=\\s)", c = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source, d = {
        // Three or four semicolons are considered a heading.
        // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
        heading: {
          pattern: /;;;.*/,
          alias: ["comment", "title"]
        },
        comment: /;.*/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0,
          inside: {
            argument: /[-A-Z]+(?=[.,\s])/,
            symbol: RegExp("`" + s + "'")
          }
        },
        "quoted-symbol": {
          pattern: RegExp("#?'" + s),
          alias: ["variable", "symbol"]
        },
        "lisp-property": {
          pattern: RegExp(":" + s),
          alias: "property"
        },
        splice: {
          pattern: RegExp(",@?" + s),
          alias: ["symbol", "variable"]
        },
        keyword: [
          {
            pattern: RegExp(
              o + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + u
            ),
            lookbehind: !0
          },
          {
            pattern: RegExp(
              o + "(?:append|by|collect|concat|do|finally|for|in|return)" + u
            ),
            lookbehind: !0
          }
        ],
        declare: {
          pattern: n(/declare/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        interactive: {
          pattern: n(/interactive/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        boolean: {
          pattern: a(/nil|t/.source),
          lookbehind: !0
        },
        number: {
          pattern: a(/[-+]?\d+(?:\.\d*)?/.source),
          lookbehind: !0
        },
        defvar: {
          pattern: RegExp(o + "def(?:const|custom|group|var)\\s+" + s),
          lookbehind: !0,
          inside: {
            keyword: /^def[a-z]+/,
            variable: RegExp(s)
          }
        },
        defun: {
          pattern: RegExp(
            o + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + s + /\s+\(/.source + c + /\)/.source
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^(?:cl-)?def\S+/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            function: {
              pattern: RegExp("(^\\s)" + s),
              lookbehind: !0
            },
            punctuation: /[()]/
          }
        },
        lambda: {
          pattern: RegExp(
            o + "lambda\\s+\\(\\s*(?:&?" + s + "(?:\\s+&?" + s + ")*\\s*)?\\)"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^lambda/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            punctuation: /[()]/
          }
        },
        car: {
          pattern: RegExp(o + s),
          lookbehind: !0
        },
        punctuation: [
          // open paren, brackets, and close paren
          /(?:['`,]?\(|[)\[\]])/,
          // cons
          {
            pattern: /(\s)\.(?=\s)/,
            lookbehind: !0
          }
        ]
      }, p = {
        "lisp-marker": RegExp(i),
        varform: {
          pattern: RegExp(
            /\(/.source + s + /\s+(?=\S)/.source + c + /\)/.source
          ),
          inside: d
        },
        argument: {
          pattern: RegExp(/(^|[\s(])/.source + s),
          lookbehind: !0,
          alias: "variable"
        },
        rest: d
      }, f = "\\S+(?:\\s+\\S+)*", h = {
        pattern: RegExp(o + c + l),
        lookbehind: !0,
        inside: {
          "rest-vars": {
            pattern: RegExp("&(?:body|rest)\\s+" + f),
            inside: p
          },
          "other-marker-vars": {
            pattern: RegExp("&(?:aux|optional)\\s+" + f),
            inside: p
          },
          keys: {
            pattern: RegExp("&key\\s+" + f + "(?:\\s+&allow-other-keys)?"),
            inside: p
          },
          argument: {
            pattern: RegExp(s),
            alias: "variable"
          },
          punctuation: /[()]/
        }
      };
      d.lambda.inside.arguments = h, d.defun.inside.arguments = r.util.clone(h), d.defun.inside.arguments.inside.sublist = h, r.languages.lisp = d, r.languages.elisp = d, r.languages.emacs = d, r.languages["emacs-lisp"] = d;
    })(t);
  }
  return Sk;
}
var _k, C8;
function g4e() {
  if (C8) return _k;
  C8 = 1, _k = e, e.displayName = "livescript", e.aliases = [];
  function e(t) {
    t.languages.livescript = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\\])#.*/,
          lookbehind: !0
        }
      ],
      "interpolated-string": {
        /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
         * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
        pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          variable: {
            pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
            lookbehind: !0
          },
          interpolation: {
            pattern: /(^|[^\\])#\{[^}]+\}/m,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^#\{|\}$/,
                alias: "variable"
              }
              // See rest below
            }
          },
          string: /[\s\S]+/
        }
      },
      string: [
        {
          pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: !0
        },
        {
          pattern: /<\[[\s\S]*?\]>/,
          greedy: !0
        },
        /\\[^\s,;\])}]+/
      ],
      regex: [
        {
          pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
          greedy: !0,
          inside: {
            comment: {
              pattern: /(^|[^\\])#.*/,
              lookbehind: !0
            }
          }
        },
        {
          pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
          greedy: !0
        }
      ],
      keyword: {
        pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
        lookbehind: !0
      },
      "keyword-operator": {
        pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
        lookbehind: !0,
        alias: "operator"
      },
      boolean: {
        pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
        lookbehind: !0
      },
      argument: {
        // Don't match .&. nor &&
        pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
        lookbehind: !0,
        alias: "variable"
      },
      number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
      identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
      operator: [
        // Spaced .
        {
          pattern: /( )\.(?= )/,
          lookbehind: !0
        },
        // Full list, in order:
        // .= .~ .. ...
        // .&. .^. .<<. .>>. .>>>.
        // := :: ::=
        // &&
        // || |>
        // < << <<< <<<<
        // <- <-- <-! <--!
        // <~ <~~ <~! <~~!
        // <| <= <?
        // > >> >= >?
        // - -- -> -->
        // + ++
        // @ @@
        // % %%
        // * **
        // ! != !~=
        // !~> !~~>
        // !-> !-->
        // ~ ~> ~~> ~=
        // = ==
        // ^ ^^
        // / ?
        /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
      ],
      punctuation: /[(){}\[\]|.,:;`]/
    }, t.languages.livescript["interpolated-string"].inside.interpolation.inside.rest = t.languages.livescript;
  }
  return _k;
}
var kk, A8;
function b4e() {
  if (A8) return kk;
  A8 = 1, kk = e, e.displayName = "llvm", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.llvm = {
        comment: /;.*/,
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        boolean: /\b(?:false|true)\b/,
        variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
        label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
        type: {
          pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
          alias: "class-name"
        },
        keyword: /\b[a-z_][a-z_0-9]*\b/,
        number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
        punctuation: /[{}[\];(),.!*=<>]/
      };
    })(t);
  }
  return kk;
}
var Ck, T8;
function y4e() {
  if (T8) return Ck;
  T8 = 1, Ck = e, e.displayName = "log", e.aliases = [];
  function e(t) {
    t.languages.log = {
      string: {
        // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
        greedy: !0
      },
      exception: {
        pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
        lookbehind: !0,
        greedy: !0,
        alias: ["javastacktrace", "language-javastacktrace"],
        inside: t.languages.javastacktrace || {
          keyword: /\bat\b/,
          function: /[a-z_][\w$]*(?=\()/,
          punctuation: /[.:()]/
        }
      },
      level: [
        {
          pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
          alias: ["error", "important"]
        },
        {
          pattern: /\b(?:WARN|WARNING|WRN)\b/,
          alias: ["warning", "important"]
        },
        {
          pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
          alias: ["info", "keyword"]
        },
        {
          pattern: /\b(?:DBG|DEBUG|FINE)\b/,
          alias: ["debug", "keyword"]
        },
        {
          pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
          alias: ["trace", "comment"]
        }
      ],
      property: {
        pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
        lookbehind: !0
      },
      separator: {
        pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
        lookbehind: !0,
        alias: "comment"
      },
      url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
      email: {
        pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
        lookbehind: !0,
        alias: "url"
      },
      "ip-address": {
        pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
        alias: "constant"
      },
      "mac-address": {
        pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
        alias: "constant"
      },
      domain: {
        pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
        lookbehind: !0,
        alias: "constant"
      },
      uuid: {
        pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
        alias: "constant"
      },
      hash: {
        pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
        alias: "constant"
      },
      "file-path": {
        pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
        lookbehind: !0,
        greedy: !0,
        alias: "string"
      },
      date: {
        pattern: RegExp(
          /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
          "i"
        ),
        alias: "number"
      },
      time: {
        pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
        alias: "number"
      },
      boolean: /\b(?:false|null|true)\b/i,
      number: {
        pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
        lookbehind: !0
      },
      operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
      punctuation: /[\[\].,]/
    };
  }
  return Ck;
}
var Ak, R8;
function v4e() {
  if (R8) return Ak;
  R8 = 1, Ak = e, e.displayName = "lolcode", e.aliases = [];
  function e(t) {
    t.languages.lolcode = {
      comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
      string: {
        pattern: /"(?::.|[^":])*"/,
        inside: {
          variable: /:\{[^}]+\}/,
          symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
        },
        greedy: !0
      },
      number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
      symbol: {
        pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
        lookbehind: !0,
        inside: {
          keyword: /A(?=\s)/
        }
      },
      label: {
        pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
        lookbehind: !0,
        alias: "string"
      },
      function: {
        pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
        lookbehind: !0
      },
      keyword: [
        {
          pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
          lookbehind: !0
        },
        /'Z(?=\s|,|$)/
      ],
      boolean: {
        pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
        lookbehind: !0
      },
      variable: {
        pattern: /(^|\s)IT(?=\s|,|$)/,
        lookbehind: !0
      },
      operator: {
        pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
        lookbehind: !0
      },
      punctuation: /\.{3}|…|,|!/
    };
  }
  return Ak;
}
var Tk, I8;
function w4e() {
  if (I8) return Tk;
  I8 = 1, Tk = e, e.displayName = "magma", e.aliases = [];
  function e(t) {
    t.languages.magma = {
      output: {
        pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
        lookbehind: !0,
        greedy: !0
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
        lookbehind: !0,
        greedy: !0
      },
      // http://magma.maths.usyd.edu.au/magma/handbook/text/82
      keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
      boolean: /\b(?:false|true)\b/,
      generator: {
        pattern: /\b[a-z_]\w*(?=\s*<)/i,
        alias: "class-name"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: !0
      },
      operator: /->|[-+*/^~!|#=]|:=|\.\./,
      punctuation: /[()[\]{}<>,;.:]/
    };
  }
  return Tk;
}
var Rk, N8;
function x4e() {
  if (N8) return Rk;
  N8 = 1, Rk = e, e.displayName = "makefile", e.aliases = [];
  function e(t) {
    t.languages.makefile = {
      comment: {
        pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
        lookbehind: !0
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "builtin-target": {
        pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
        alias: "builtin"
      },
      target: {
        pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
        alias: "symbol",
        inside: {
          variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
        }
      },
      variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
      // Directives
      keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
      function: {
        pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
        lookbehind: !0
      },
      operator: /(?:::|[?:+!])?=|[|@]/,
      punctuation: /[:;(){}]/
    };
  }
  return Rk;
}
var Ik, D8;
function E4e() {
  if (D8) return Ik;
  D8 = 1, Ik = e, e.displayName = "markdown", e.aliases = ["md"];
  function e(t) {
    (function(r) {
      var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
      function a(p) {
        return p = p.replace(/<inner>/g, function() {
          return n;
        }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + p + ")");
      }
      var s = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
        /__/g,
        function() {
          return s;
        }
      ), o = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
      r.languages.markdown = r.languages.extend("markup", {}), r.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
          pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            punctuation: /^---|---$/,
            "front-matter": {
              pattern: /\S+(?:\s+\S+)*/,
              alias: ["yaml", "language-yaml"],
              inside: r.languages.yaml
            }
          }
        },
        blockquote: {
          // > ...
          pattern: /^>(?:[\t ]*>)*/m,
          alias: "punctuation"
        },
        table: {
          pattern: RegExp(
            "^" + i + o + "(?:" + i + ")*",
            "m"
          ),
          inside: {
            "table-data-rows": {
              pattern: RegExp(
                "^(" + i + o + ")(?:" + i + ")*$"
              ),
              lookbehind: !0,
              inside: {
                "table-data": {
                  pattern: RegExp(s),
                  inside: r.languages.markdown
                },
                punctuation: /\|/
              }
            },
            "table-line": {
              pattern: RegExp("^(" + i + ")" + o + "$"),
              lookbehind: !0,
              inside: {
                punctuation: /\||:?-{3,}:?/
              }
            },
            "table-header-row": {
              pattern: RegExp("^" + i + "$"),
              inside: {
                "table-header": {
                  pattern: RegExp(s),
                  alias: "important",
                  inside: r.languages.markdown
                },
                punctuation: /\|/
              }
            }
          }
        },
        code: [
          {
            // Prefixed by 4 spaces or 1 tab and preceded by an empty line
            pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
            lookbehind: !0,
            alias: "keyword"
          },
          {
            // ```optional language
            // code block
            // ```
            pattern: /^```[\s\S]*?^```$/m,
            greedy: !0,
            inside: {
              "code-block": {
                pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                lookbehind: !0
              },
              "code-language": {
                pattern: /^(```).+/,
                lookbehind: !0
              },
              punctuation: /```/
            }
          }
        ],
        title: [
          {
            // title 1
            // =======
            // title 2
            // -------
            pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
            alias: "important",
            inside: {
              punctuation: /==+$|--+$/
            }
          },
          {
            // # title 1
            // ###### title 6
            pattern: /(^\s*)#.+/m,
            lookbehind: !0,
            alias: "important",
            inside: {
              punctuation: /^#+|#+$/
            }
          }
        ],
        hr: {
          // ***
          // ---
          // * * *
          // -----------
          pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        list: {
          // * item
          // + item
          // - item
          // 1. item
          pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        "url-reference": {
          // [id]: http://example.com "Optional title"
          // [id]: http://example.com 'Optional title'
          // [id]: http://example.com (Optional title)
          // [id]: <http://example.com> "Optional title"
          pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
          inside: {
            variable: {
              pattern: /^(!?\[)[^\]]+/,
              lookbehind: !0
            },
            string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
            punctuation: /^[\[\]!:]|[<>]/
          },
          alias: "url"
        },
        bold: {
          // **strong**
          // __strong__
          // allow one nested instance of italic text using the same delimiter
          pattern: a(
            /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^..)[\s\S]+(?=..$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /\*\*|__/
          }
        },
        italic: {
          // *em*
          // _em_
          // allow one nested instance of bold text using the same delimiter
          pattern: a(
            /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^.)[\s\S]+(?=.$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /[*_]/
          }
        },
        strike: {
          // ~~strike through~~
          // ~strike~
          // eslint-disable-next-line regexp/strict
          pattern: a(/(~~?)(?:(?!~)<inner>)+\2/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^~~?)[\s\S]+(?=\1$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /~~?/
          }
        },
        "code-snippet": {
          // `code`
          // ``code``
          pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
          lookbehind: !0,
          greedy: !0,
          alias: ["code", "keyword"]
        },
        url: {
          // [example](http://example.com "Optional title")
          // [example][id]
          // [example] [id]
          pattern: a(
            /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            operator: /^!/,
            content: {
              pattern: /(^\[)[^\]]+(?=\])/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            variable: {
              pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
              lookbehind: !0
            },
            url: {
              pattern: /(^\]\()[^\s)]+/,
              lookbehind: !0
            },
            string: {
              pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
              lookbehind: !0
            }
          }
        }
      }), ["url", "bold", "italic", "strike"].forEach(function(p) {
        ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(f) {
          p !== f && (r.languages.markdown[p].inside.content.inside[f] = r.languages.markdown[f]);
        });
      }), r.hooks.add("after-tokenize", function(p) {
        if (p.language !== "markdown" && p.language !== "md")
          return;
        function f(h) {
          if (!(!h || typeof h == "string"))
            for (var m = 0, y = h.length; m < y; m++) {
              var b = h[m];
              if (b.type !== "code") {
                f(b.content);
                continue;
              }
              var v = b.content[1], x = b.content[3];
              if (v && x && v.type === "code-language" && x.type === "code-block" && typeof v.content == "string") {
                var _ = v.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                _ = (/[a-z][\w-]*/i.exec(_) || [""])[0].toLowerCase();
                var E = "language-" + _;
                x.alias ? typeof x.alias == "string" ? x.alias = [x.alias, E] : x.alias.push(E) : x.alias = [E];
              }
            }
        }
        f(p.tokens);
      }), r.hooks.add("wrap", function(p) {
        if (p.type === "code-block") {
          for (var f = "", h = 0, m = p.classes.length; h < m; h++) {
            var y = p.classes[h], b = /language-(.+)/.exec(y);
            if (b) {
              f = b[1];
              break;
            }
          }
          var v = r.languages[f];
          if (v)
            p.content = r.highlight(
              d(p.content.value),
              v,
              f
            );
          else if (f && f !== "none" && r.plugins.autoloader) {
            var x = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
            p.attributes.id = x, r.plugins.autoloader.loadLanguages(f, function() {
              var _ = document.getElementById(x);
              _ && (_.innerHTML = r.highlight(
                _.textContent,
                r.languages[f],
                f
              ));
            });
          }
        }
      });
      var l = RegExp(r.languages.markup.tag.pattern.source, "gi"), u = {
        amp: "&",
        lt: "<",
        gt: ">",
        quot: '"'
      }, c = String.fromCodePoint || String.fromCharCode;
      function d(p) {
        var f = p.replace(l, "");
        return f = f.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(h, m) {
          if (m = m.toLowerCase(), m[0] === "#") {
            var y;
            return m[1] === "x" ? y = parseInt(m.slice(2), 16) : y = Number(m.slice(1)), c(y);
          } else {
            var b = u[m];
            return b || h;
          }
        }), f;
      }
      r.languages.md = r.languages.markdown;
    })(t);
  }
  return Ik;
}
var Nk, O8;
function S4e() {
  if (O8) return Nk;
  O8 = 1, Nk = e, e.displayName = "matlab", e.aliases = [];
  function e(t) {
    t.languages.matlab = {
      comment: [/%\{[\s\S]*?\}%/, /%.+/],
      string: {
        pattern: /\B'(?:''|[^'\r\n])*'/,
        greedy: !0
      },
      // FIXME We could handle imaginary numbers as a whole
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
      keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
      function: /\b(?!\d)\w+(?=\s*\()/,
      operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
      punctuation: /\.{3}|[.,;\[\](){}!]/
    };
  }
  return Nk;
}
var Dk, P8;
function _4e() {
  if (P8) return Dk;
  P8 = 1, Dk = e, e.displayName = "maxscript", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
      r.languages.maxscript = {
        comment: {
          pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
          greedy: !0
        },
        string: {
          pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
          lookbehind: !0,
          greedy: !0
        },
        path: {
          pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
          greedy: !0,
          alias: "string"
        },
        "function-call": {
          pattern: RegExp(
            "((?:" + // start of line
            (/^/.source + "|" + // operators and other language constructs
            /[;=<>+\-*/^({\[]/.source + "|" + // keywords as part of statements
            /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + n.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + // variable
            ("(?!" + n.source + ")" + /[a-z_]/.source + "|" + // number
            /\d|-\.?\d/.source + "|" + // other expressions or literals
            /[({'"$@#?]/.source) + "))",
            "im"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "function"
        },
        "function-definition": {
          pattern: /(\b(?:fn|function)\s+)\w+\b/i,
          lookbehind: !0,
          alias: "function"
        },
        argument: {
          pattern: /\b[a-z_]\w*(?=:)/i,
          alias: "attr-name"
        },
        keyword: n,
        boolean: /\b(?:false|true)\b/,
        time: {
          pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
          lookbehind: !0,
          alias: "number"
        },
        number: [
          {
            pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
            lookbehind: !0
          },
          /\b(?:e|pi)\b/
        ],
        constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
        color: {
          pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
          alias: "constant"
        },
        operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
        punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
      };
    })(t);
  }
  return Dk;
}
var Ok, L8;
function k4e() {
  if (L8) return Ok;
  L8 = 1, Ok = e, e.displayName = "mel", e.aliases = [];
  function e(t) {
    t.languages.mel = {
      comment: /\/\/.*/,
      code: {
        pattern: /`(?:\\.|[^\\`\r\n])*`/,
        greedy: !0,
        alias: "italic",
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          }
          // See rest below
        }
      },
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      variable: /\$\w+/,
      number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
      flag: {
        pattern: /-[^\d\W]\w*/,
        alias: "operator"
      },
      keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
      function: /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
      operator: [
        /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
        {
          // We don't want to match <<
          pattern: /(^|[^<])<(?!<)/,
          lookbehind: !0
        },
        {
          // We don't want to match >>
          pattern: /(^|[^>])>(?!>)/,
          lookbehind: !0
        }
      ],
      punctuation: /<<|>>|[.,:;?\[\](){}]/
    }, t.languages.mel.code.inside.rest = t.languages.mel;
  }
  return Ok;
}
var Pk, M8;
function C4e() {
  if (M8) return Pk;
  M8 = 1, Pk = e, e.displayName = "mermaid", e.aliases = [];
  function e(t) {
    t.languages.mermaid = {
      comment: {
        pattern: /%%.*/,
        greedy: !0
      },
      style: {
        pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
        lookbehind: !0,
        inside: {
          property: /\b\w[\w-]*(?=[ \t]*:)/,
          operator: /:/,
          punctuation: /,/
        }
      },
      "inter-arrow-label": {
        pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          arrow: {
            pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
            alias: "operator"
          },
          label: {
            pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
            lookbehind: !0,
            alias: "property"
          },
          "arrow-head": {
            pattern: /^\S+/,
            alias: ["arrow", "operator"]
          }
        }
      },
      arrow: [
        // This might look complex but it really isn't.
        // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
        // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
        // characters in the one lookbehind because that would create too many false negatives. So we have to split the
        // arrows into different patterns.
        {
          // ER diagram
          pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // flow chart
          // (?:==+|--+|-\.*-)
          pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // sequence diagram
          pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // class diagram
          pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
          lookbehind: !0,
          alias: "operator"
        }
      ],
      label: {
        pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      text: {
        pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
        alias: "string"
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: !0
      },
      annotation: {
        pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
        alias: "important"
      },
      keyword: [
        // This language has both case-sensitive and case-insensitive keywords
        {
          pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
          lookbehind: !0,
          greedy: !0
        }
      ],
      entity: /#[a-z0-9]+;/,
      operator: {
        pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
        lookbehind: !0
      },
      punctuation: /[(){};]/
    };
  }
  return Pk;
}
var Lk, F8;
function A4e() {
  if (F8) return Lk;
  F8 = 1, Lk = e, e.displayName = "mizar", e.aliases = [];
  function e(t) {
    t.languages.mizar = {
      comment: /::.+/,
      keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
      parameter: {
        pattern: /\$(?:10|\d)/,
        alias: "variable"
      },
      variable: /\b\w+(?=:)/,
      number: /(?:\b|-)\d+\b/,
      operator: /\.\.\.|->|&|\.?=/,
      punctuation: /\(#|#\)|[,:;\[\](){}]/
    };
  }
  return Lk;
}
var Mk, $8;
function T4e() {
  if ($8) return Mk;
  $8 = 1, Mk = e, e.displayName = "mongodb", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = [
        // query and projection
        "$eq",
        "$gt",
        "$gte",
        "$in",
        "$lt",
        "$lte",
        "$ne",
        "$nin",
        "$and",
        "$not",
        "$nor",
        "$or",
        "$exists",
        "$type",
        "$expr",
        "$jsonSchema",
        "$mod",
        "$regex",
        "$text",
        "$where",
        "$geoIntersects",
        "$geoWithin",
        "$near",
        "$nearSphere",
        "$all",
        "$elemMatch",
        "$size",
        "$bitsAllClear",
        "$bitsAllSet",
        "$bitsAnyClear",
        "$bitsAnySet",
        "$comment",
        "$elemMatch",
        "$meta",
        "$slice",
        // update
        "$currentDate",
        "$inc",
        "$min",
        "$max",
        "$mul",
        "$rename",
        "$set",
        "$setOnInsert",
        "$unset",
        "$addToSet",
        "$pop",
        "$pull",
        "$push",
        "$pullAll",
        "$each",
        "$position",
        "$slice",
        "$sort",
        "$bit",
        // aggregation pipeline stages
        "$addFields",
        "$bucket",
        "$bucketAuto",
        "$collStats",
        "$count",
        "$currentOp",
        "$facet",
        "$geoNear",
        "$graphLookup",
        "$group",
        "$indexStats",
        "$limit",
        "$listLocalSessions",
        "$listSessions",
        "$lookup",
        "$match",
        "$merge",
        "$out",
        "$planCacheStats",
        "$project",
        "$redact",
        "$replaceRoot",
        "$replaceWith",
        "$sample",
        "$set",
        "$skip",
        "$sort",
        "$sortByCount",
        "$unionWith",
        "$unset",
        "$unwind",
        "$setWindowFields",
        // aggregation pipeline operators
        "$abs",
        "$accumulator",
        "$acos",
        "$acosh",
        "$add",
        "$addToSet",
        "$allElementsTrue",
        "$and",
        "$anyElementTrue",
        "$arrayElemAt",
        "$arrayToObject",
        "$asin",
        "$asinh",
        "$atan",
        "$atan2",
        "$atanh",
        "$avg",
        "$binarySize",
        "$bsonSize",
        "$ceil",
        "$cmp",
        "$concat",
        "$concatArrays",
        "$cond",
        "$convert",
        "$cos",
        "$dateFromParts",
        "$dateToParts",
        "$dateFromString",
        "$dateToString",
        "$dayOfMonth",
        "$dayOfWeek",
        "$dayOfYear",
        "$degreesToRadians",
        "$divide",
        "$eq",
        "$exp",
        "$filter",
        "$first",
        "$floor",
        "$function",
        "$gt",
        "$gte",
        "$hour",
        "$ifNull",
        "$in",
        "$indexOfArray",
        "$indexOfBytes",
        "$indexOfCP",
        "$isArray",
        "$isNumber",
        "$isoDayOfWeek",
        "$isoWeek",
        "$isoWeekYear",
        "$last",
        "$last",
        "$let",
        "$literal",
        "$ln",
        "$log",
        "$log10",
        "$lt",
        "$lte",
        "$ltrim",
        "$map",
        "$max",
        "$mergeObjects",
        "$meta",
        "$min",
        "$millisecond",
        "$minute",
        "$mod",
        "$month",
        "$multiply",
        "$ne",
        "$not",
        "$objectToArray",
        "$or",
        "$pow",
        "$push",
        "$radiansToDegrees",
        "$range",
        "$reduce",
        "$regexFind",
        "$regexFindAll",
        "$regexMatch",
        "$replaceOne",
        "$replaceAll",
        "$reverseArray",
        "$round",
        "$rtrim",
        "$second",
        "$setDifference",
        "$setEquals",
        "$setIntersection",
        "$setIsSubset",
        "$setUnion",
        "$size",
        "$sin",
        "$slice",
        "$split",
        "$sqrt",
        "$stdDevPop",
        "$stdDevSamp",
        "$strcasecmp",
        "$strLenBytes",
        "$strLenCP",
        "$substr",
        "$substrBytes",
        "$substrCP",
        "$subtract",
        "$sum",
        "$switch",
        "$tan",
        "$toBool",
        "$toDate",
        "$toDecimal",
        "$toDouble",
        "$toInt",
        "$toLong",
        "$toObjectId",
        "$toString",
        "$toLower",
        "$toUpper",
        "$trim",
        "$trunc",
        "$type",
        "$week",
        "$year",
        "$zip",
        "$count",
        "$dateAdd",
        "$dateDiff",
        "$dateSubtract",
        "$dateTrunc",
        "$getField",
        "$rand",
        "$sampleRate",
        "$setField",
        "$unsetField",
        // aggregation pipeline query modifiers
        "$comment",
        "$explain",
        "$hint",
        "$max",
        "$maxTimeMS",
        "$min",
        "$orderby",
        "$query",
        "$returnKey",
        "$showDiskLoc",
        "$natural"
      ], a = [
        "ObjectId",
        "Code",
        "BinData",
        "DBRef",
        "Timestamp",
        "NumberLong",
        "NumberDecimal",
        "MaxKey",
        "MinKey",
        "RegExp",
        "ISODate",
        "UUID"
      ];
      n = n.map(function(i) {
        return i.replace("$", "\\$");
      });
      var s = "(?:" + n.join("|") + ")\\b";
      r.languages.mongodb = r.languages.extend("javascript", {}), r.languages.insertBefore("mongodb", "string", {
        property: {
          pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
          greedy: !0,
          inside: {
            keyword: RegExp(`^(['"])?` + s + "(?:\\1)?$")
          }
        }
      }), r.languages.mongodb.string.inside = {
        url: {
          // url pattern
          pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
          greedy: !0
        },
        entity: {
          // ipv4
          pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
          greedy: !0
        }
      }, r.languages.insertBefore("mongodb", "constant", {
        builtin: {
          pattern: RegExp("\\b(?:" + a.join("|") + ")\\b"),
          alias: "keyword"
        }
      });
    })(t);
  }
  return Mk;
}
var Fk, B8;
function R4e() {
  if (B8) return Fk;
  B8 = 1, Fk = e, e.displayName = "monkey", e.aliases = [];
  function e(t) {
    t.languages.monkey = {
      comment: {
        pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: !0
      },
      preprocessor: {
        pattern: /(^[ \t]*)#.+/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      function: /\b\w+(?=\()/,
      "type-char": {
        pattern: /\b[?%#$]/,
        alias: "class-name"
      },
      number: {
        pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
        lookbehind: !0
      },
      keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
      operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
      punctuation: /[.,:;()\[\]]/
    };
  }
  return Fk;
}
var $k, U8;
function I4e() {
  if (U8) return $k;
  U8 = 1, $k = e, e.displayName = "moonscript", e.aliases = ["moon"];
  function e(t) {
    t.languages.moonscript = {
      comment: /--.*/,
      string: [
        {
          pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
          greedy: !0
        },
        {
          pattern: /"[^"]*"/,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /#\{[^{}]*\}/,
              inside: {
                moonscript: {
                  pattern: /(^#\{)[\s\S]+(?=\})/,
                  lookbehind: !0,
                  inside: null
                  // see beow
                },
                "interpolation-punctuation": {
                  pattern: /#\{|\}/,
                  alias: "punctuation"
                }
              }
            }
          }
        }
      ],
      "class-name": [
        {
          pattern: /(\b(?:class|extends)[ \t]+)\w+/,
          lookbehind: !0
        },
        // class-like names start with a capital letter
        /\b[A-Z]\w*/
      ],
      keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
      variable: /@@?\w*/,
      property: {
        pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
        lookbehind: !0
      },
      function: {
        pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
        inside: {
          punctuation: /\./
        }
      },
      boolean: /\b(?:false|true)\b/,
      number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
      operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
      punctuation: /[.,()[\]{}\\]/
    }, t.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = t.languages.moonscript, t.languages.moon = t.languages.moonscript;
  }
  return $k;
}
var Bk, z8;
function N4e() {
  if (z8) return Bk;
  z8 = 1, Bk = e, e.displayName = "n1ql", e.aliases = [];
  function e(t) {
    t.languages.n1ql = {
      comment: {
        pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
        greedy: !0
      },
      string: {
        pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
        greedy: !0
      },
      identifier: {
        pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
        greedy: !0
      },
      parameter: /\$[\w.]+/,
      // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
      keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
      punctuation: /[;[\](),.{}:]/
    };
  }
  return Bk;
}
var Uk, q8;
function D4e() {
  if (q8) return Uk;
  q8 = 1, Uk = e, e.displayName = "n4js", e.aliases = ["n4jsd"];
  function e(t) {
    t.languages.n4js = t.languages.extend("javascript", {
      // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
      keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
    }), t.languages.insertBefore("n4js", "constant", {
      // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
      annotation: {
        pattern: /@+\w+/,
        alias: "operator"
      }
    }), t.languages.n4jsd = t.languages.n4js;
  }
  return Uk;
}
var zk, j8;
function O4e() {
  if (j8) return zk;
  j8 = 1, zk = e, e.displayName = "nand2tetrisHdl", e.aliases = [];
  function e(t) {
    t.languages["nand2tetris-hdl"] = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
      number: /\b\d+\b/,
      operator: /=|\.\./,
      punctuation: /[{}[\];(),:]/
    };
  }
  return zk;
}
var qk, H8;
function P4e() {
  if (H8) return qk;
  H8 = 1, qk = e, e.displayName = "naniscript", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\{[^\r\n\[\]{}]*\}/, a = {
        "quoted-string": {
          pattern: /"(?:[^"\\]|\\.)*"/,
          alias: "operator"
        },
        "command-param-id": {
          pattern: /(\s)\w+:/,
          lookbehind: !0,
          alias: "property"
        },
        "command-param-value": [
          {
            pattern: n,
            alias: "selector"
          },
          {
            pattern: /([\t ])\S+/,
            lookbehind: !0,
            greedy: !0,
            alias: "operator"
          },
          {
            pattern: /\S(?:.*\S)?/,
            alias: "operator"
          }
        ]
      };
      r.languages.naniscript = {
        // ; ...
        comment: {
          pattern: /^([\t ]*);.*/m,
          lookbehind: !0
        },
        // > ...
        // Define is a control line starting with '>' followed by a word, a space and a text.
        define: {
          pattern: /^>.+/m,
          alias: "tag",
          inside: {
            value: {
              pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
              lookbehind: !0,
              alias: "operator"
            },
            key: {
              pattern: /(^>)\w+/,
              lookbehind: !0
            }
          }
        },
        // # ...
        label: {
          pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
          lookbehind: !0,
          alias: "regex"
        },
        command: {
          pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
          lookbehind: !0,
          alias: "function",
          inside: {
            "command-name": /^@\w+/,
            expression: {
              pattern: n,
              greedy: !0,
              alias: "selector"
            },
            "command-params": {
              pattern: /\s*\S[\s\S]*/,
              inside: a
            }
          }
        },
        // Generic is any line that doesn't start with operators: ;>#@
        "generic-text": {
          pattern: /(^[ \t]*)[^#@>;\s].*/m,
          lookbehind: !0,
          alias: "punctuation",
          inside: {
            // \{ ... \} ... \[ ... \] ... \"
            "escaped-char": /\\[{}\[\]"]/,
            expression: {
              pattern: n,
              greedy: !0,
              alias: "selector"
            },
            "inline-command": {
              pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
              greedy: !0,
              alias: "function",
              inside: {
                "command-params": {
                  pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                  lookbehind: !0,
                  inside: a
                },
                "command-param-name": {
                  pattern: /^(\[[\t ]*)\w+/,
                  lookbehind: !0,
                  alias: "name"
                },
                "start-stop-char": /[\[\]]/
              }
            }
          }
        }
      }, r.languages.nani = r.languages.naniscript, r.hooks.add("after-tokenize", function(o) {
        var l = o.tokens;
        l.forEach(function(u) {
          if (typeof u != "string" && u.type === "generic-text") {
            var c = i(u);
            s(c) || (u.type = "bad-line", u.content = c);
          }
        });
      });
      function s(o) {
        for (var l = "[]{}", u = [], c = 0; c < o.length; c++) {
          var d = o[c], p = l.indexOf(d);
          if (p !== -1) {
            if (p % 2 === 0)
              u.push(p + 1);
            else if (u.pop() !== p)
              return !1;
          }
        }
        return u.length === 0;
      }
      function i(o) {
        return typeof o == "string" ? o : Array.isArray(o) ? o.map(i).join("") : i(o.content);
      }
    })(t);
  }
  return qk;
}
var jk, V8;
function L4e() {
  if (V8) return jk;
  V8 = 1, jk = e, e.displayName = "nasm", e.aliases = [];
  function e(t) {
    t.languages.nasm = {
      comment: /;.*$/m,
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      label: {
        pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [
        /\[?BITS (?:16|32|64)\]?/,
        {
          pattern: /(^\s*)section\s*[a-z.]+:?/im,
          lookbehind: !0
        },
        /(?:extern|global)[^;\r\n]*/i,
        /(?:CPU|DEFAULT|FLOAT).*$/m
      ],
      register: {
        pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
        alias: "variable"
      },
      number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
      operator: /[\[\]*+\-\/%<>=&|$!]/
    };
  }
  return jk;
}
var Hk, G8;
function M4e() {
  if (G8) return Hk;
  G8 = 1, Hk = e, e.displayName = "neon", e.aliases = [];
  function e(t) {
    t.languages.neon = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      datetime: {
        pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
        lookbehind: !0,
        alias: "number"
      },
      key: {
        pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
        lookbehind: !0,
        alias: "atrule"
      },
      number: {
        pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
        lookbehind: !0
      },
      null: {
        pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
        lookbehind: !0,
        alias: "keyword"
      },
      string: {
        pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
        lookbehind: !0,
        greedy: !0
      },
      literal: {
        pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
        lookbehind: !0,
        alias: "string"
      },
      punctuation: /[,:=[\]{}()-]/
    };
  }
  return Hk;
}
var Vk, W8;
function F4e() {
  if (W8) return Vk;
  W8 = 1, Vk = e, e.displayName = "nevod", e.aliases = [];
  function e(t) {
    t.languages.nevod = {
      comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
      string: {
        pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
        greedy: !0,
        inside: {
          "string-attrs": /!$|!\*$|\*$/
        }
      },
      namespace: {
        pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
        lookbehind: !0
      },
      pattern: {
        pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
        lookbehind: !0,
        inside: {
          "pattern-name": {
            pattern: /^#?[a-zA-Z0-9\-.]+/,
            alias: "class-name"
          },
          fields: {
            pattern: /\(.*\)/,
            inside: {
              "field-name": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "variable"
              },
              punctuation: /[,()]/,
              operator: {
                pattern: /~/,
                alias: "field-hidden-mark"
              }
            }
          }
        }
      },
      search: {
        pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
        alias: "function",
        lookbehind: !0
      },
      keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
      "standard-pattern": {
        pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
        inside: {
          "standard-pattern-name": {
            pattern: /^[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          quantifier: {
            pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
            alias: "number"
          },
          "standard-pattern-attr": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          punctuation: /[,()]/
        }
      },
      quantifier: {
        pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
        alias: "number"
      },
      operator: [
        {
          pattern: /=/,
          alias: "pattern-def"
        },
        {
          pattern: /&/,
          alias: "conjunction"
        },
        {
          pattern: /~/,
          alias: "exception"
        },
        {
          pattern: /\?/,
          alias: "optionality"
        },
        {
          pattern: /[[\]]/,
          alias: "repetition"
        },
        {
          pattern: /[{}]/,
          alias: "variation"
        },
        {
          pattern: /[+_]/,
          alias: "sequence"
        },
        {
          pattern: /\.{2,3}/,
          alias: "span"
        }
      ],
      "field-capture": [
        {
          pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
          lookbehind: !0,
          inside: {
            "field-name": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "variable"
            },
            colon: /:/
          }
        },
        {
          pattern: /[a-zA-Z0-9\-.]+\s*:/,
          inside: {
            "field-name": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "variable"
            },
            colon: /:/
          }
        }
      ],
      punctuation: /[:;,()]/,
      name: /[a-zA-Z0-9\-.]+/
    };
  }
  return Vk;
}
var Gk, K8;
function $4e() {
  if (K8) return Gk;
  K8 = 1, Gk = e, e.displayName = "nginx", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
      r.languages.nginx = {
        comment: {
          pattern: /(^|[\s{};])#.*/,
          lookbehind: !0,
          greedy: !0
        },
        directive: {
          pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: {
              pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
              lookbehind: !0,
              greedy: !0,
              inside: {
                escape: {
                  pattern: /\\["'\\nrt]/,
                  alias: "entity"
                },
                variable: n
              }
            },
            comment: {
              pattern: /(\s)#.*/,
              lookbehind: !0,
              greedy: !0
            },
            keyword: {
              pattern: /^\S+/,
              greedy: !0
            },
            // other patterns
            boolean: {
              pattern: /(\s)(?:off|on)(?!\S)/,
              lookbehind: !0
            },
            number: {
              pattern: /(\s)\d+[a-z]*(?!\S)/i,
              lookbehind: !0
            },
            variable: n
          }
        },
        punctuation: /[{};]/
      };
    })(t);
  }
  return Gk;
}
var Wk, Y8;
function B4e() {
  if (Y8) return Wk;
  Y8 = 1, Wk = e, e.displayName = "nim", e.aliases = [];
  function e(t) {
    t.languages.nim = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
        pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
        greedy: !0
      },
      char: {
        // Character literals are handled specifically to prevent issues with numeric type suffixes
        pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
        greedy: !0
      },
      function: {
        pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
        greedy: !0,
        inside: {
          operator: /\*$/
        }
      },
      // We don't want to highlight operators (and anything really) inside backticks
      identifier: {
        pattern: /`[^`\r\n]+`/,
        greedy: !0,
        inside: {
          punctuation: /`/
        }
      },
      // The negative look ahead prevents wrong highlighting of the .. operator
      number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
      keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
      operator: {
        // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
        // but allow the slice operator .. to take precedence over them
        // One can define his own operators in Nim so all combination of operators might be an operator.
        pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
        lookbehind: !0
      },
      punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
    };
  }
  return Wk;
}
var Kk, X8;
function U4e() {
  if (X8) return Kk;
  X8 = 1, Kk = e, e.displayName = "nix", e.aliases = [];
  function e(t) {
    t.languages.nix = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|#.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
        greedy: !0,
        inside: {
          interpolation: {
            // The lookbehind ensures the ${} is not preceded by \ or ''
            pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
            lookbehind: !0,
            inside: null
            // see below
          }
        }
      },
      url: [
        /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
        {
          pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
          lookbehind: !0
        }
      ],
      antiquotation: {
        pattern: /\$(?=\{)/,
        alias: "important"
      },
      number: /\b\d+\b/,
      keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
      function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
      boolean: /\b(?:false|true)\b/,
      operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
      punctuation: /[{}()[\].,:;]/
    }, t.languages.nix.string.inside.interpolation.inside = t.languages.nix;
  }
  return Kk;
}
var Yk, Z8;
function z4e() {
  if (Z8) return Yk;
  Z8 = 1, Yk = e, e.displayName = "nsis", e.aliases = [];
  function e(t) {
    t.languages.nsis = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: {
        pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
        lookbehind: !0
      },
      property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
      constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
      variable: /\$\w[\w\.]*/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
      punctuation: /[{}[\];(),.:]/,
      important: {
        pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
        lookbehind: !0
      }
    };
  }
  return Yk;
}
var Xk, J8;
function q4e() {
  if (J8) return Xk;
  J8 = 1;
  var e = Wu();
  Xk = t, t.displayName = "objectivec", t.aliases = ["objc"];
  function t(r) {
    r.register(e), r.languages.objectivec = r.languages.extend("c", {
      string: {
        pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
      operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    }), delete r.languages.objectivec["class-name"], r.languages.objc = r.languages.objectivec;
  }
  return Xk;
}
var Zk, Q8;
function j4e() {
  if (Q8) return Zk;
  Q8 = 1, Zk = e, e.displayName = "ocaml", e.aliases = [];
  function e(t) {
    t.languages.ocaml = {
      comment: {
        pattern: /\(\*[\s\S]*?\*\)/,
        greedy: !0
      },
      char: {
        pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
        greedy: !0
      },
      string: [
        {
          pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
          greedy: !0
        },
        {
          pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
          greedy: !0
        }
      ],
      number: [
        // binary and octal
        /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
        // hexadecimal
        /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
        // decimal
        /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
      ],
      directive: {
        pattern: /\B#\w+/,
        alias: "property"
      },
      label: {
        pattern: /\B~\w+/,
        alias: "property"
      },
      "type-variable": {
        pattern: /\B'\w+/,
        alias: "function"
      },
      variant: {
        pattern: /`\w+/,
        alias: "symbol"
      },
      // For the list of keywords and operators,
      // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
      keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      "operator-like-punctuation": {
        pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
        alias: "punctuation"
      },
      // Custom operators are allowed
      operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
      punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
    };
  }
  return Zk;
}
var Jk, eB;
function H4e() {
  if (eB) return Jk;
  eB = 1;
  var e = Wu();
  Jk = t, t.displayName = "opencl", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      n.languages.opencl = n.languages.extend("c", {
        // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
        keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
        // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
        // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
        // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
        number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
        boolean: /\b(?:false|true)\b/,
        "constant-opencl-kernel": {
          pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
          alias: "constant"
        }
      }), n.languages.insertBefore("opencl", "class-name", {
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
        "builtin-type": {
          pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
          alias: "keyword"
        }
      });
      var a = {
        // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
        "type-opencl-host": {
          pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
          alias: "keyword"
        },
        "boolean-opencl-host": {
          pattern: /\bCL_(?:FALSE|TRUE)\b/,
          alias: "boolean"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
        "constant-opencl-host": {
          pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
          alias: "constant"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
        "function-opencl-host": {
          pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
          alias: "function"
        }
      };
      n.languages.insertBefore("c", "keyword", a), n.languages.cpp && (a["type-opencl-host-cpp"] = {
        pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
        alias: "keyword"
      }, n.languages.insertBefore("cpp", "keyword", a));
    }(r);
  }
  return Jk;
}
var Qk, tB;
function V4e() {
  if (tB) return Qk;
  tB = 1, Qk = e, e.displayName = "openqasm", e.aliases = ["qasm"];
  function e(t) {
    t.languages.openqasm = {
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
        greedy: !0
      },
      keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
      "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
      function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
      constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
      number: {
        pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
        lookbehind: !0
      },
      operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
      punctuation: /[(){}\[\];,:.]/
    }, t.languages.qasm = t.languages.openqasm;
  }
  return Qk;
}
var eC, rB;
function G4e() {
  if (rB) return eC;
  rB = 1, eC = e, e.displayName = "oz", e.aliases = [];
  function e(t) {
    t.languages.oz = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: !0
      },
      atom: {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        alias: "builtin"
      },
      keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
      function: [
        /\b[a-z][A-Za-z\d]*(?=\()/,
        {
          pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
          lookbehind: !0
        }
      ],
      number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
      variable: /`(?:[^`\\]|\\.)+`/,
      "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
      operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
      punctuation: /[\[\](){}.:;?]/
    };
  }
  return eC;
}
var tC, nB;
function W4e() {
  if (nB) return tC;
  nB = 1, tC = e, e.displayName = "parigp", e.aliases = [];
  function e(t) {
    t.languages.parigp = {
      comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"/,
        greedy: !0
      },
      // PARI/GP does not care about white spaces at all
      // so let's process the keywords to build an appropriate regexp
      // (e.g. "b *r *e *a *k", etc.)
      keyword: function() {
        var r = [
          "breakpoint",
          "break",
          "dbg_down",
          "dbg_err",
          "dbg_up",
          "dbg_x",
          "forcomposite",
          "fordiv",
          "forell",
          "forpart",
          "forprime",
          "forstep",
          "forsubgroup",
          "forvec",
          "for",
          "iferr",
          "if",
          "local",
          "my",
          "next",
          "return",
          "until",
          "while"
        ];
        return r = r.map(function(n) {
          return n.split("").join(" *");
        }).join("|"), RegExp("\\b(?:" + r + ")\\b");
      }(),
      function: /\b\w(?:[\w ]*\w)?(?= *\()/,
      number: {
        // The lookbehind and the negative lookahead prevent from breaking the .. operator
        pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
        lookbehind: !0
      },
      operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
      punctuation: /[\[\]{}().,:;|]/
    };
  }
  return tC;
}
var rC, iB;
function K4e() {
  if (iB) return rC;
  iB = 1, rC = e, e.displayName = "parser", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = r.languages.parser = r.languages.extend("markup", {
        keyword: {
          pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
          lookbehind: !0
        },
        variable: {
          pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: !0,
          inside: {
            punctuation: /\.|:+/
          }
        },
        function: {
          pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: !0,
          inside: {
            keyword: {
              pattern: /(^@)(?:GET_|SET_)/,
              lookbehind: !0
            },
            punctuation: /\.|:+/
          }
        },
        escape: {
          pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
          alias: "builtin"
        },
        punctuation: /[\[\](){};]/
      });
      n = r.languages.insertBefore("parser", "keyword", {
        "parser-comment": {
          pattern: /(\s)#.*/,
          lookbehind: !0,
          alias: "comment"
        },
        expression: {
          // Allow for 3 levels of depth
          pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
          greedy: !0,
          lookbehind: !0,
          inside: {
            string: {
              pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
              lookbehind: !0
            },
            keyword: n.keyword,
            variable: n.variable,
            function: n.function,
            boolean: /\b(?:false|true)\b/,
            number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
            escape: n.escape,
            operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
            punctuation: n.punctuation
          }
        }
      }), r.languages.insertBefore(
        "inside",
        "punctuation",
        {
          expression: n.expression,
          keyword: n.keyword,
          variable: n.variable,
          function: n.function,
          escape: n.escape,
          "parser-punctuation": {
            pattern: n.punctuation,
            alias: "punctuation"
          }
        },
        n.tag.inside["attr-value"]
      );
    })(t);
  }
  return rC;
}
var nC, aB;
function Y4e() {
  if (aB) return nC;
  aB = 1, nC = e, e.displayName = "pascal", e.aliases = ["objectpascal"];
  function e(t) {
    t.languages.pascal = {
      directive: {
        pattern: /\{\$[\s\S]*?\}/,
        greedy: !0,
        alias: ["marco", "property"]
      },
      comment: {
        pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
        greedy: !0
      },
      string: {
        pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
        greedy: !0
      },
      asm: {
        pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      keyword: [
        {
          // Turbo Pascal
          pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
          lookbehind: !0
        },
        {
          // Free Pascal
          pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
          lookbehind: !0
        },
        {
          // Object Pascal
          pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
          lookbehind: !0
        },
        {
          // Modifiers
          pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
          lookbehind: !0
        }
      ],
      number: [
        // Hexadecimal, octal and binary
        /(?:[&%]\d+|\$[a-f\d]+)/i,
        // Decimal
        /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
      ],
      operator: [
        /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
        {
          pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
          lookbehind: !0
        }
      ],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/
    }, t.languages.pascal.asm.inside = t.languages.extend("pascal", {
      asm: void 0,
      keyword: void 0,
      operator: void 0
    }), t.languages.objectpascal = t.languages.pascal;
  }
  return nC;
}
var iC, sB;
function X4e() {
  if (sB) return iC;
  sB = 1, iC = e, e.displayName = "pascaligo", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source, a = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
        /<braces>/g,
        function() {
          return n;
        }
      ), s = r.languages.pascaligo = {
        comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
          greedy: !0
        },
        "class-name": [
          {
            pattern: RegExp(
              /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
                /<type>/g,
                function() {
                  return a;
                }
              ),
              "i"
            ),
            lookbehind: !0,
            inside: null
            // see below
          },
          {
            pattern: RegExp(
              /<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
                return a;
              }),
              "i"
            ),
            inside: null
            // see below
          },
          {
            pattern: RegExp(
              /(:\s*)<type>/.source.replace(/<type>/g, function() {
                return a;
              })
            ),
            lookbehind: !0,
            inside: null
            // see below
          }
        ],
        keyword: {
          pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
          lookbehind: !0
        },
        boolean: {
          pattern: /(^|[^&])\b(?:False|True)\b/i,
          lookbehind: !0
        },
        builtin: {
          pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
          lookbehind: !0
        },
        function: /\b\w+(?=\s*\()/,
        number: [
          // Hexadecimal, octal and binary
          /%[01]+|&[0-7]+|\$[a-f\d]+/i,
          // Decimal
          /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
        ],
        operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
        punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
      }, i = [
        "comment",
        "keyword",
        "builtin",
        "operator",
        "punctuation"
      ].reduce(function(o, l) {
        return o[l] = s[l], o;
      }, {});
      s["class-name"].forEach(function(o) {
        o.inside = i;
      });
    })(t);
  }
  return iC;
}
var aC, oB;
function Z4e() {
  if (oB) return aC;
  oB = 1, aC = e, e.displayName = "pcaxis", e.aliases = ["px"];
  function e(t) {
    t.languages.pcaxis = {
      string: /"[^"]*"/,
      keyword: {
        pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^[-A-Z\d]+/,
          language: {
            pattern: /^(\s*)\[[-\w]+\]/,
            lookbehind: !0,
            inside: {
              punctuation: /^\[|\]$/,
              property: /[-\w]+/
            }
          },
          "sub-key": {
            pattern: /^(\s*)\S[\s\S]*/,
            lookbehind: !0,
            inside: {
              parameter: {
                pattern: /"[^"]*"/,
                alias: "property"
              },
              punctuation: /^\(|\)$|,/
            }
          }
        }
      },
      operator: /=/,
      tlist: {
        pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
        greedy: !0,
        inside: {
          function: /^TLIST/,
          property: {
            pattern: /^(\s*\(\s*)\w+/,
            lookbehind: !0
          },
          string: /"[^"]*"/,
          punctuation: /[(),]/,
          operator: /-/
        }
      },
      punctuation: /[;,]/,
      number: {
        pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
        lookbehind: !0
      },
      boolean: /NO|YES/
    }, t.languages.px = t.languages.pcaxis;
  }
  return aC;
}
var sC, lB;
function J4e() {
  if (lB) return sC;
  lB = 1, sC = e, e.displayName = "peoplecode", e.aliases = ["pcode"];
  function e(t) {
    t.languages.peoplecode = {
      comment: RegExp(
        [
          // C-style multiline comments
          /\/\*[\s\S]*?\*\//.source,
          // REM comments
          /\bREM[^;]*;/.source,
          // Nested <* *> comments
          /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
          // /+ +/ comments
          /\/\+[\s\S]*?\+\//.source
        ].join("|")
      ),
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: !0
      },
      variable: /%\w+/,
      "function-definition": {
        pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
        lookbehind: !0,
        alias: "function"
      },
      "class-name": {
        pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
        lookbehind: !0,
        inside: {
          punctuation: /:/
        }
      },
      keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
      "operator-keyword": {
        pattern: /\b(?:and|not|or)\b/i,
        alias: "operator"
      },
      function: /[_a-z]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
      punctuation: /[:.;,()[\]]/
    }, t.languages.pcode = t.languages.peoplecode;
  }
  return sC;
}
var oC, uB;
function Q4e() {
  if (uB) return oC;
  uB = 1, oC = e, e.displayName = "perl", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
      r.languages.perl = {
        comment: [
          {
            // POD
            pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: /(^|[^\\$])#.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        // TODO Could be nice to handle Heredoc too.
        string: [
          {
            pattern: RegExp(
              /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // q/.../
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                // q a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // q(...)
                // q{...}
                // q[...]
                // q<...>
                n
              ].join("|") + ")"
            ),
            greedy: !0
          },
          // "...", `...`
          {
            pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
            greedy: !0
          },
          // '...'
          // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
          {
            pattern: /'(?:[^'\\\r\n]|\\.)*'/,
            greedy: !0
          }
        ],
        regex: [
          {
            pattern: RegExp(
              /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // m/.../
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                // m a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // m(...)
                // m{...}
                // m[...]
                // m<...>
                n
              ].join("|") + ")" + /[msixpodualngc]*/.source
            ),
            greedy: !0
          },
          // The lookbehinds prevent -s from breaking
          {
            pattern: RegExp(
              /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // s/.../.../
                // eslint-disable-next-line regexp/strict
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // s a...a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                // s(...)(...)
                // s{...}{...}
                // s[...][...]
                // s<...><...>
                // s(...)[...]
                n + /\s*/.source + n
              ].join("|") + ")" + /[msixpodualngcer]*/.source
            ),
            lookbehind: !0,
            greedy: !0
          },
          // /.../
          // The look-ahead tries to prevent two divisions on
          // the same line from being highlighted as regex.
          // This does not support multi-line regex.
          {
            pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
            greedy: !0
          }
        ],
        // FIXME Not sure about the handling of ::, ', and #
        variable: [
          // ${^POSTMATCH}
          /[&*$@%]\{\^[A-Z]+\}/,
          // $^V
          /[&*$@%]\^[A-Z_]/,
          // ${...}
          /[&*$@%]#?(?=\{)/,
          // $foo
          /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
          // $1
          /[&*$@%]\d+/,
          // $_, @_, %!
          // The negative lookahead prevents from breaking the %= operator
          /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
        ],
        filehandle: {
          // <>, <FOO>, _
          pattern: /<(?![<=])\S*?>|\b_\b/,
          alias: "symbol"
        },
        "v-string": {
          // v1.2, 1.2.3
          pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
          alias: "string"
        },
        function: {
          pattern: /(\bsub[ \t]+)\w+/,
          lookbehind: !0
        },
        keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
        operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
        punctuation: /[{}[\];(),:]/
      };
    })(t);
  }
  return oC;
}
var lC, cB;
function e3e() {
  if (cB) return lC;
  cB = 1;
  var e = xy();
  lC = t, t.displayName = "phpExtras", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.insertBefore("php", "variable", {
      this: {
        pattern: /\$this\b/,
        alias: "keyword"
      },
      global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
      scope: {
        pattern: /\b[\w\\]+::/,
        inside: {
          keyword: /\b(?:parent|self|static)\b/,
          punctuation: /::|\\/
        }
      }
    });
  }
  return lC;
}
var uC, dB;
function t3e() {
  if (dB) return uC;
  dB = 1;
  var e = xy(), t = wy();
  uC = r, r.displayName = "phpdoc", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      var s = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
      a.languages.phpdoc = a.languages.extend("javadoclike", {
        parameter: {
          pattern: RegExp(
            "(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + s + "\\s+)?)\\$\\w+"
          ),
          lookbehind: !0
        }
      }), a.languages.insertBefore("phpdoc", "keyword", {
        "class-name": [
          {
            pattern: RegExp(
              "(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + s
            ),
            lookbehind: !0,
            inside: {
              keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
              punctuation: /[|\\[\]()]/
            }
          }
        ]
      }), a.languages.javadoclike.addSupport("php", a.languages.phpdoc);
    }(n);
  }
  return uC;
}
var cC, fB;
function r3e() {
  if (fB) return cC;
  fB = 1;
  var e = cD();
  cC = t, t.displayName = "plsql", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.plsql = r.languages.extend("sql", {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|--.*/,
        greedy: !0
      },
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
      keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
      operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
    }), r.languages.insertBefore("plsql", "operator", {
      label: {
        pattern: /<<\s*\w+\s*>>/,
        alias: "symbol"
      }
    });
  }
  return cC;
}
var dC, pB;
function n3e() {
  if (pB) return dC;
  pB = 1, dC = e, e.displayName = "powerquery", e.aliases = [];
  function e(t) {
    t.languages.powerquery = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0,
        greedy: !0
      },
      "quoted-identifier": {
        pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      string: {
        pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      constant: [
        /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
        /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
        /\bOccurrence\.(?:All|First|Last)\b/,
        /\bOrder\.(?:Ascending|Descending)\b/,
        /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
        /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
        /\bQuoteStyle\.(?:Csv|None)\b/,
        /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
        /\bGroupKind\.(?:Global|Local)\b/,
        /\bExtraValues\.(?:Error|Ignore|List)\b/,
        /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
        /\bJoinSide\.(?:Left|Right)\b/,
        /\bPrecision\.(?:Decimal|Double)\b/,
        /\bRelativePosition\.From(?:End|Start)\b/,
        /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
        /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
        /\bnull\b/
      ],
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
      function: {
        pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
        lookbehind: !0
      },
      "data-type": {
        pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
        alias: "class-name"
      },
      number: {
        pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
        lookbehind: !0
      },
      operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
      punctuation: /[,;\[\](){}]/
    }, t.languages.pq = t.languages.powerquery, t.languages.mscript = t.languages.powerquery;
  }
  return dC;
}
var fC, hB;
function i3e() {
  if (hB) return fC;
  hB = 1, fC = e, e.displayName = "powershell", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = r.languages.powershell = {
        comment: [
          {
            pattern: /(^|[^`])<#[\s\S]*?#>/,
            lookbehind: !0
          },
          {
            pattern: /(^|[^`])#.*/,
            lookbehind: !0
          }
        ],
        string: [
          {
            pattern: /"(?:`[\s\S]|[^`"])*"/,
            greedy: !0,
            inside: null
            // see below
          },
          {
            pattern: /'(?:[^']|'')*'/,
            greedy: !0
          }
        ],
        // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
        // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
        namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
        boolean: /\$(?:false|true)\b/i,
        variable: /\$\w+\b/,
        // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
        // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
        // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
        function: [
          /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
          /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
        ],
        // per http://technet.microsoft.com/en-us/library/hh847744.aspx
        keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
        operator: {
          pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
          lookbehind: !0
        },
        punctuation: /[|{}[\];(),.]/
      };
      n.string[0].inside = {
        function: {
          // Allow for one level of nesting
          pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
          lookbehind: !0,
          inside: n
        },
        boolean: n.boolean,
        variable: n.variable
      };
    })(t);
  }
  return fC;
}
var pC, mB;
function a3e() {
  if (mB) return pC;
  mB = 1, pC = e, e.displayName = "processing", e.aliases = [];
  function e(t) {
    t.languages.processing = t.languages.extend("clike", {
      keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
      // Spaces are allowed between function name and parenthesis
      function: /\b\w+(?=\s*\()/,
      operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
    }), t.languages.insertBefore("processing", "number", {
      // Special case: XML is a type
      constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
      type: {
        pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
        alias: "class-name"
      }
    });
  }
  return pC;
}
var hC, gB;
function s3e() {
  if (gB) return hC;
  gB = 1, hC = e, e.displayName = "prolog", e.aliases = [];
  function e(t) {
    t.languages.prolog = {
      // Syntax depends on the implementation
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: !0
      },
      // Depending on the implementation, strings may allow escaped newlines and quote-escape
      string: {
        pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
        greedy: !0
      },
      builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
      // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
      function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
      number: /\b\d+(?:\.\d*)?/,
      // Custom operators are allowed
      operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
      punctuation: /[(){}\[\],]/
    };
  }
  return hC;
}
var mC, bB;
function o3e() {
  if (bB) return mC;
  bB = 1, mC = e, e.displayName = "promql", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = [
        "sum",
        "min",
        "max",
        "avg",
        "group",
        "stddev",
        "stdvar",
        "count",
        "count_values",
        "bottomk",
        "topk",
        "quantile"
      ], a = [
        "on",
        "ignoring",
        "group_right",
        "group_left",
        "by",
        "without"
      ], s = ["offset"], i = n.concat(a, s);
      r.languages.promql = {
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: !0
        },
        "vector-match": {
          // Match the comma-separated label lists inside vector matching:
          pattern: new RegExp(
            "((?:" + a.join("|") + ")\\s*)\\([^)]*\\)"
          ),
          lookbehind: !0,
          inside: {
            "label-key": {
              pattern: /\b[^,]+\b/,
              alias: "attr-name"
            },
            punctuation: /[(),]/
          }
        },
        "context-labels": {
          pattern: /\{[^{}]*\}/,
          inside: {
            "label-key": {
              pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
              alias: "attr-name"
            },
            "label-value": {
              pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
              greedy: !0,
              alias: "attr-value"
            },
            punctuation: /\{|\}|=~?|![=~]|,/
          }
        },
        "context-range": [
          {
            pattern: /\[[\w\s:]+\]/,
            // [1m]
            inside: {
              punctuation: /\[|\]|:/,
              "range-duration": {
                pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                alias: "number"
              }
            }
          },
          {
            pattern: /(\boffset\s+)\w+/,
            // offset 1m
            lookbehind: !0,
            inside: {
              "range-duration": {
                pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                alias: "number"
              }
            }
          }
        ],
        keyword: new RegExp("\\b(?:" + i.join("|") + ")\\b", "i"),
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
        operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
        punctuation: /[{};()`,.[\]]/
      };
    })(t);
  }
  return mC;
}
var gC, yB;
function l3e() {
  if (yB) return gC;
  yB = 1, gC = e, e.displayName = "properties", e.aliases = [];
  function e(t) {
    t.languages.properties = {
      comment: /^[ \t]*[#!].*$/m,
      "attr-value": {
        pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
        lookbehind: !0
      },
      "attr-name": /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
      punctuation: /[=:]/
    };
  }
  return gC;
}
var bC, vB;
function u3e() {
  if (vB) return bC;
  vB = 1, bC = e, e.displayName = "protobuf", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
      r.languages.protobuf = r.languages.extend("clike", {
        "class-name": [
          {
            pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
            lookbehind: !0
          },
          {
            pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
            lookbehind: !0
          }
        ],
        keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
        function: /\b[a-z_]\w*(?=\s*\()/i
      }), r.languages.insertBefore("protobuf", "operator", {
        map: {
          pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /[<>.,]/,
            builtin: n
          }
        },
        builtin: n,
        "positional-class-name": {
          pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /\./
          }
        },
        annotation: {
          pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
          lookbehind: !0
        }
      });
    })(t);
  }
  return bC;
}
var yC, wB;
function c3e() {
  if (wB) return yC;
  wB = 1, yC = e, e.displayName = "psl", e.aliases = [];
  function e(t) {
    t.languages.psl = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: !0,
        inside: {
          symbol: /\\[ntrbA-Z"\\]/
        }
      },
      "heredoc-string": {
        pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
        alias: "string",
        greedy: !0
      },
      keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
      constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
      boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
      variable: /\b(?:PslDebug|errno|exit_status)\b/,
      builtin: {
        pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
        alias: "builtin-function"
      },
      "foreach-variable": {
        pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
        lookbehind: !0,
        greedy: !0
      },
      function: /\b[_a-z]\w*\b(?=\s*\()/i,
      number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
      punctuation: /[(){}\[\];,]/
    };
  }
  return yC;
}
var vC, xB;
function d3e() {
  if (xB) return vC;
  xB = 1, vC = e, e.displayName = "pug", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.pug = {
        // Multiline stuff should appear before the rest
        // This handles both single-line and multi-line comments
        comment: {
          pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
          lookbehind: !0
        },
        // All the tag-related part is in lookbehind
        // so that it can be highlighted by the "tag" pattern
        "multiline-script": {
          pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        // See at the end of the file for known filters
        filter: {
          pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "variable"
            },
            text: /\S[\s\S]*/
          }
        },
        "multiline-plain-text": {
          pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0
        },
        markup: {
          pattern: /(^[\t ]*)<.+/m,
          lookbehind: !0,
          inside: r.languages.markup
        },
        doctype: {
          pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
          lookbehind: !0
        },
        // This handle all conditional and loop keywords
        "flow-control": {
          pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
          lookbehind: !0,
          inside: {
            each: {
              pattern: /^each .+? in\b/,
              inside: {
                keyword: /\b(?:each|in)\b/,
                punctuation: /,/
              }
            },
            branch: {
              pattern: /^(?:case|default|else|if|unless|when|while)\b/,
              alias: "keyword"
            },
            rest: r.languages.javascript
          }
        },
        keyword: {
          pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
          lookbehind: !0
        },
        mixin: [
          // Declaration
          {
            pattern: /(^[\t ]*)mixin .+/m,
            lookbehind: !0,
            inside: {
              keyword: /^mixin/,
              function: /\w+(?=\s*\(|\s*$)/,
              punctuation: /[(),.]/
            }
          },
          // Usage
          {
            pattern: /(^[\t ]*)\+.+/m,
            lookbehind: !0,
            inside: {
              name: {
                pattern: /^\+\w+/,
                alias: "function"
              },
              rest: r.languages.javascript
            }
          }
        ],
        script: {
          pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        "plain-text": {
          pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
          lookbehind: !0
        },
        tag: {
          pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
          lookbehind: !0,
          inside: {
            attributes: [
              {
                pattern: /&[^(]+\([^)]+\)/,
                inside: r.languages.javascript
              },
              {
                pattern: /\([^)]+\)/,
                inside: {
                  "attr-value": {
                    pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                    lookbehind: !0,
                    inside: r.languages.javascript
                  },
                  "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                  punctuation: /[!=(),]+/
                }
              }
            ],
            punctuation: /:/,
            "attr-id": /#[\w\-]+/,
            "attr-class": /\.[\w\-]+/
          }
        },
        code: [
          {
            pattern: /(^[\t ]*(?:-|!?=)).+/m,
            lookbehind: !0,
            inside: r.languages.javascript
          }
        ],
        punctuation: /[.\-!=|]+/
      };
      for (var n = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source, a = [
        {
          filter: "atpl",
          language: "twig"
        },
        {
          filter: "coffee",
          language: "coffeescript"
        },
        "ejs",
        "handlebars",
        "less",
        "livescript",
        "markdown",
        {
          filter: "sass",
          language: "scss"
        },
        "stylus"
      ], s = {}, i = 0, o = a.length; i < o; i++) {
        var l = a[i];
        l = typeof l == "string" ? {
          filter: l,
          language: l
        } : l, r.languages[l.language] && (s["filter-" + l.filter] = {
          pattern: RegExp(
            n.replace("<filter_name>", function() {
              return l.filter;
            }),
            "m"
          ),
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "variable"
            },
            text: {
              pattern: /\S[\s\S]*/,
              alias: [l.language, "language-" + l.language],
              inside: r.languages[l.language]
            }
          }
        });
      }
      r.languages.insertBefore("pug", "filter", s);
    })(t);
  }
  return vC;
}
var wC, EB;
function f3e() {
  if (EB) return wC;
  EB = 1, wC = e, e.displayName = "puppet", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.puppet = {
        heredoc: [
          // Matches the content of a quoted heredoc string (subject to interpolation)
          {
            pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: !0,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
              // See interpolation below
            }
          },
          // Matches the content of an unquoted heredoc string (no interpolation)
          {
            pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: !0,
            greedy: !0,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
            }
          },
          // Matches the start tag of heredoc strings
          {
            pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
            alias: "string",
            inside: {
              punctuation: {
                pattern: /(\().+?(?=\))/,
                lookbehind: !0
              }
            }
          }
        ],
        "multiline-comment": {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        },
        regex: {
          // Must be prefixed with the keyword "node" or a non-word char
          pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            // Extended regexes must have the x flag. They can contain single-line comments.
            "extended-regex": {
              pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
              inside: {
                comment: /#.*/
              }
            }
          }
        },
        comment: {
          pattern: /(^|[^\\])#.*/,
          lookbehind: !0,
          greedy: !0
        },
        string: {
          // Allow for one nested level of double quotes inside interpolation
          pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
          greedy: !0,
          inside: {
            "double-quoted": {
              pattern: /^"[\s\S]*"$/,
              inside: {
                // See interpolation below
              }
            }
          }
        },
        variable: {
          pattern: /\$(?:::)?\w+(?:::\w+)*/,
          inside: {
            punctuation: /::/
          }
        },
        "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
        function: [
          {
            pattern: /(\.)(?!\d)\w+/,
            lookbehind: !0
          },
          /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
        ],
        number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
        boolean: /\b(?:false|true)\b/,
        // Includes words reserved for future use
        keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
        datatype: {
          pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
          alias: "symbol"
        },
        operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
        punctuation: /[\[\]{}().,;]|:+/
      };
      var n = [
        {
          // Allow for one nested level of braces inside interpolation
          pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
          lookbehind: !0,
          inside: {
            "short-variable": {
              // Negative look-ahead prevent wrong highlighting of functions
              pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
              lookbehind: !0,
              alias: "variable",
              inside: {
                punctuation: /::/
              }
            },
            delimiter: {
              pattern: /^\$/,
              alias: "variable"
            },
            rest: r.languages.puppet
          }
        },
        {
          pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
          lookbehind: !0,
          alias: "variable",
          inside: {
            punctuation: /::/
          }
        }
      ];
      r.languages.puppet.heredoc[0].inside.interpolation = n, r.languages.puppet.string.inside["double-quoted"].inside.interpolation = n;
    })(t);
  }
  return wC;
}
var xC, SB;
function p3e() {
  if (SB) return xC;
  SB = 1, xC = e, e.displayName = "pure", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.pure = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
            lookbehind: !0
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: !0
          },
          /#!.+/
        ],
        "inline-lang": {
          pattern: /%<[\s\S]+?%>/,
          greedy: !0,
          inside: {
            lang: {
              pattern: /(^%< *)-\*-.+?-\*-/,
              lookbehind: !0,
              alias: "comment"
            },
            delimiter: {
              pattern: /^%<.*|%>$/,
              alias: "punctuation"
            }
          }
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: !0
        },
        number: {
          // The look-behind prevents wrong highlighting of the .. operator
          pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
          lookbehind: !0
        },
        keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
        function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
        special: {
          pattern: /\b__[a-z]+__\b/i,
          alias: "builtin"
        },
        // Any combination of operator chars can be an operator
        // eslint-disable-next-line no-misleading-character-class
        operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
        // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
        punctuation: /[(){}\[\];,|]/
      };
      var n = [
        "c",
        {
          lang: "c++",
          alias: "cpp"
        },
        "fortran"
      ], a = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
      n.forEach(function(s) {
        var i = s;
        if (typeof s != "string" && (i = s.alias, s = s.lang), r.languages[i]) {
          var o = {};
          o["inline-lang-" + i] = {
            pattern: RegExp(
              a.replace(
                "<lang>",
                s.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")
              ),
              "i"
            ),
            inside: r.util.clone(r.languages.pure["inline-lang"].inside)
          }, o["inline-lang-" + i].inside.rest = r.util.clone(
            r.languages[i]
          ), r.languages.insertBefore("pure", "inline-lang", o);
        }
      }), r.languages.c && (r.languages.pure["inline-lang"].inside.rest = r.util.clone(
        r.languages.c
      ));
    })(t);
  }
  return xC;
}
var EC, _B;
function h3e() {
  if (_B) return EC;
  _B = 1, EC = e, e.displayName = "purebasic", e.aliases = [];
  function e(t) {
    t.languages.purebasic = t.languages.extend("clike", {
      comment: /;.*/,
      keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
      function: /\b\w+(?:\.\w+)?\s*(?=\()/,
      number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
      operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
    }), t.languages.insertBefore("purebasic", "keyword", {
      tag: /#\w+\$?/,
      asm: {
        pattern: /(^[\t ]*)!.*/m,
        lookbehind: !0,
        alias: "tag",
        inside: {
          comment: /;.*/,
          string: {
            pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: !0
          },
          // Anonymous label references, i.e.: jmp @b
          "label-reference-anonymous": {
            pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
            lookbehind: !0,
            alias: "fasm-label"
          },
          // Named label reference, i.e.: jne label1
          "label-reference-addressed": {
            pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
            lookbehind: !0,
            alias: "fasm-label"
          },
          keyword: [
            /\b(?:extern|global)\b[^;\r\n]*/i,
            /\b(?:CPU|DEFAULT|FLOAT)\b.*/
          ],
          function: {
            pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
            lookbehind: !0
          },
          "function-inline": {
            pattern: /(:\s*)[\da-z]+(?=\s)/i,
            lookbehind: !0,
            alias: "function"
          },
          label: {
            pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
            lookbehind: !0,
            alias: "fasm-label"
          },
          register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
          number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
          operator: /[\[\]*+\-/%<>=&|$!,.:]/
        }
      }
    }), delete t.languages.purebasic["class-name"], delete t.languages.purebasic.boolean, t.languages.pbfasm = t.languages.purebasic;
  }
  return EC;
}
var SC, kB;
function m3e() {
  if (kB) return SC;
  kB = 1;
  var e = fD();
  SC = t, t.displayName = "purescript", t.aliases = ["purs"];
  function t(r) {
    r.register(e), r.languages.purescript = r.languages.extend("haskell", {
      keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|hiding|import)\b/,
          punctuation: /\./
        }
      },
      // These are builtin functions only. Constructors are highlighted later as a constant.
      builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
      operator: [
        // Infix operators
        r.languages.haskell.operator[0],
        // ASCII operators
        r.languages.haskell.operator[2],
        // All UTF16 Unicode operator symbols
        // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
        // See https://github.com/PrismJS/prism/issues/3006 for more details.
        /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
      ]
    }), r.languages.purs = r.languages.purescript;
  }
  return SC;
}
var _C, CB;
function g3e() {
  if (CB) return _C;
  CB = 1, _C = e, e.displayName = "python", e.aliases = ["py"];
  function e(t) {
    t.languages.python = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
      },
      "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: !0,
        inside: {
          interpolation: {
            // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
            lookbehind: !0,
            inside: {
              "format-spec": {
                pattern: /(:)[^:(){}]+(?=\}$)/,
                lookbehind: !0
              },
              "conversion-option": {
                pattern: /![sra](?=[:}]$)/,
                alias: "punctuation"
              },
              rest: null
            }
          },
          string: /[\s\S]+/
        }
      },
      "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: !0
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: !0
      },
      "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: !0
      },
      decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: !0,
        alias: ["annotation", "punctuation"],
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
      builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
      boolean: /\b(?:False|None|True)\b/,
      number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
      operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.python["string-interpolation"].inside.interpolation.inside.rest = t.languages.python, t.languages.py = t.languages.python;
  }
  return _C;
}
var kC, AB;
function b3e() {
  if (AB) return kC;
  AB = 1, kC = e, e.displayName = "q", e.aliases = [];
  function e(t) {
    t.languages.q = {
      string: /"(?:\\.|[^"\\\r\n])*"/,
      comment: [
        // From http://code.kx.com/wiki/Reference/Slash:
        // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
        {
          pattern: /([\t )\]}])\/.*/,
          lookbehind: !0,
          greedy: !0
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
        // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
        // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
        // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
        {
          pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
          lookbehind: !0,
          greedy: !0
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A \ on a line by itself with no preceding matching / will comment to end of file.
        {
          pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
          greedy: !0
        },
        {
          pattern: /^#!.+/m,
          greedy: !0
        }
      ],
      symbol: /`(?::\S+|[\w.]*)/,
      datetime: {
        pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
        alias: "number"
      },
      // The negative look-ahead prevents bad highlighting
      // of verbs 0: and 1:
      number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
      keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
      adverb: {
        pattern: /['\/\\]:?|\beach\b/,
        alias: "function"
      },
      verb: {
        pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
        alias: "operator"
      },
      punctuation: /[(){}\[\];.]/
    };
  }
  return kC;
}
var CC, TB;
function y3e() {
  if (TB) return CC;
  TB = 1, CC = e, e.displayName = "qml", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var n = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source, a = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source, s = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
        return n;
      }).replace(/<comment>/g, function() {
        return a;
      }), i = 0; i < 2; i++)
        s = s.replace(/<expr>/g, function() {
          return s;
        });
      s = s.replace(/<expr>/g, "[^\\s\\S]"), r.languages.qml = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: !0
        },
        "javascript-function": {
          pattern: RegExp(
            /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
              /<js>/g,
              function() {
                return s;
              }
            ),
            "m"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "language-javascript",
          inside: r.languages.javascript
        },
        "class-name": {
          pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
          lookbehind: !0
        },
        property: [
          {
            pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
            lookbehind: !0
          },
          {
            pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
            lookbehind: !0,
            inside: {
              keyword: /^property/,
              property: /\w+(?:\.\w+)*/
            }
          }
        ],
        "javascript-expression": {
          pattern: RegExp(
            /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
              /<js>/g,
              function() {
                return s;
              }
            ),
            "m"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "language-javascript",
          inside: r.languages.javascript
        },
        string: {
          pattern: /"(?:\\.|[^\\"\r\n])*"/,
          greedy: !0
        },
        keyword: /\b(?:as|import|on)\b/,
        punctuation: /[{}[\]:;,]/
      };
    })(t);
  }
  return CC;
}
var AC, RB;
function v3e() {
  if (RB) return AC;
  RB = 1, AC = e, e.displayName = "qore", e.aliases = [];
  function e(t) {
    t.languages.qore = t.languages.extend("clike", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
        lookbehind: !0
      },
      // Overridden to allow unescaped multi-line strings
      string: {
        pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
      boolean: /\b(?:false|true)\b/i,
      function: /\$?\b(?!\d)\w+(?=\()/,
      number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
      operator: {
        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
        lookbehind: !0
      },
      variable: /\$(?!\d)\w+\b/
    });
  }
  return AC;
}
var TC, IB;
function w3e() {
  if (IB) return TC;
  IB = 1, TC = e, e.displayName = "qsharp", e.aliases = ["qs"];
  function e(t) {
    (function(r) {
      function n(h, m) {
        return h.replace(/<<(\d+)>>/g, function(y, b) {
          return "(?:" + m[+b] + ")";
        });
      }
      function a(h, m, y) {
        return RegExp(n(h, m), "");
      }
      function s(h, m) {
        for (var y = 0; y < m; y++)
          h = h.replace(/<<self>>/g, function() {
            return "(?:" + h + ")";
          });
        return h.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var i = {
        // keywords which represent a return or variable type
        type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
        // all other keywords
        other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
      };
      function o(h) {
        return "\\b(?:" + h.trim().replace(/ /g, "|") + ")\\b";
      }
      var l = RegExp(
        o(i.type + " " + i.other)
      ), u = /\b[A-Za-z_]\w*\b/.source, c = n(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [u]), d = {
        keyword: l,
        punctuation: /[<>()?,.:[\]]/
      }, p = /"(?:\\.|[^\\"])*"/.source;
      r.languages.qsharp = r.languages.extend("clike", {
        comment: /\/\/.*/,
        string: [
          {
            pattern: a(/(^|[^$\\])<<0>>/.source, [p]),
            lookbehind: !0,
            greedy: !0
          }
        ],
        "class-name": [
          {
            // open Microsoft.Quantum.Canon;
            // open Microsoft.Quantum.Canon as CN;
            pattern: a(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
              c
            ]),
            lookbehind: !0,
            inside: d
          },
          {
            // namespace Quantum.App1;
            pattern: a(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [c]),
            lookbehind: !0,
            inside: d
          }
        ],
        keyword: l,
        number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
        operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
        punctuation: /::|[{}[\];(),.:]/
      }), r.languages.insertBefore("qsharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      });
      var f = s(
        n(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [p]),
        2
      );
      r.languages.insertBefore("qsharp", "string", {
        "interpolation-string": {
          pattern: a(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [f]),
          greedy: !0,
          inside: {
            interpolation: {
              pattern: a(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
                f
              ]),
              lookbehind: !0,
              inside: {
                punctuation: /^\{|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  alias: "language-qsharp",
                  inside: r.languages.qsharp
                }
              }
            },
            string: /[\s\S]+/
          }
        }
      });
    })(t), t.languages.qs = t.languages.qsharp;
  }
  return TC;
}
var RC, NB;
function x3e() {
  if (NB) return RC;
  NB = 1, RC = e, e.displayName = "r", e.aliases = [];
  function e(t) {
    t.languages.r = {
      comment: /#.*/,
      string: {
        pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "percent-operator": {
        // Includes user-defined operators
        // and %%, %*%, %/%, %in%, %o%, %x%
        pattern: /%[^%\s]*%/,
        alias: "operator"
      },
      boolean: /\b(?:FALSE|TRUE)\b/,
      ellipsis: /\.\.(?:\.|\d+)/,
      number: [
        /\b(?:Inf|NaN)\b/,
        /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
      ],
      keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
      operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
      punctuation: /[(){}\[\],;]/
    };
  }
  return RC;
}
var IC, DB;
function E3e() {
  if (DB) return IC;
  DB = 1;
  var e = gD();
  IC = t, t.displayName = "racket", t.aliases = ["rkt"];
  function t(r) {
    r.register(e), r.languages.racket = r.languages.extend("scheme", {
      "lambda-parameter": {
        // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
        // this will just prevent false positives of the `function` pattern
        pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
        lookbehind: !0
      }
    }), r.languages.insertBefore("racket", "string", {
      lang: {
        pattern: /^#lang.+/m,
        greedy: !0,
        alias: "keyword"
      }
    }), r.languages.rkt = r.languages.racket;
  }
  return IC;
}
var NC, OB;
function S3e() {
  if (OB) return NC;
  OB = 1, NC = e, e.displayName = "reason", e.aliases = [];
  function e(t) {
    t.languages.reason = t.languages.extend("clike", {
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
        greedy: !0
      },
      // 'class-name' must be matched *after* 'constructor' defined below
      "class-name": /\b[A-Z]\w*/,
      keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
      operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
    }), t.languages.insertBefore("reason", "class-name", {
      char: {
        pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
        greedy: !0
      },
      // Negative look-ahead prevents from matching things like String.capitalize
      constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
      label: {
        pattern: /\b[a-z]\w*(?=::)/,
        alias: "symbol"
      }
    }), delete t.languages.reason.function;
  }
  return NC;
}
var DC, PB;
function _3e() {
  if (PB) return DC;
  PB = 1, DC = e, e.displayName = "regex", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /\\[\\(){}[\]^$+*?|.]/,
        alias: "escape"
      }, a = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, s = {
        pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      }, i = {
        pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      }, o = "(?:[^\\\\-]|" + a.source + ")", l = RegExp(o + "-" + o), u = {
        pattern: /(<|')[^<>']+(?=[>']$)/,
        lookbehind: !0,
        alias: "variable"
      };
      r.languages.regex = {
        "char-class": {
          pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
          lookbehind: !0,
          inside: {
            "char-class-negation": {
              pattern: /(^\[)\^/,
              lookbehind: !0,
              alias: "operator"
            },
            "char-class-punctuation": {
              pattern: /^\[|\]$/,
              alias: "punctuation"
            },
            range: {
              pattern: l,
              inside: {
                escape: a,
                "range-punctuation": {
                  pattern: /-/,
                  alias: "operator"
                }
              }
            },
            "special-escape": n,
            "char-set": i,
            escape: a
          }
        },
        "special-escape": n,
        "char-set": s,
        backreference: [
          {
            // a backreference which is not an octal escape
            pattern: /\\(?![123][0-7]{2})[1-9]/,
            alias: "keyword"
          },
          {
            pattern: /\\k<[^<>']+>/,
            alias: "keyword",
            inside: {
              "group-name": u
            }
          }
        ],
        anchor: {
          pattern: /[$^]|\\[ABbGZz]/,
          alias: "function"
        },
        escape: a,
        group: [
          {
            // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
            // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
            // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
            pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
            alias: "punctuation",
            inside: {
              "group-name": u
            }
          },
          {
            pattern: /\)/,
            alias: "punctuation"
          }
        ],
        quantifier: {
          pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
          alias: "number"
        },
        alternation: {
          pattern: /\|/,
          alias: "keyword"
        }
      };
    })(t);
  }
  return DC;
}
var OC, LB;
function k3e() {
  if (LB) return OC;
  LB = 1, OC = e, e.displayName = "rego", e.aliases = [];
  function e(t) {
    t.languages.rego = {
      comment: /#.*/,
      property: {
        pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
      boolean: /\b(?:false|true)\b/,
      function: {
        pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
        inside: {
          namespace: /\b\w+\b(?=\s*\.)/,
          punctuation: /\./
        }
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
      punctuation: /[,;.\[\]{}()]/
    };
  }
  return OC;
}
var PC, MB;
function C3e() {
  if (MB) return PC;
  MB = 1, PC = e, e.displayName = "renpy", e.aliases = ["rpy"];
  function e(t) {
    t.languages.renpy = {
      comment: {
        pattern: /(^|[^\\])#.+/,
        lookbehind: !0
      },
      string: {
        pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
        greedy: !0
      },
      function: /\b[a-z_]\w*(?=\()/i,
      property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
      tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
      keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
      boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
      number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
      operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.rpy = t.languages.renpy;
  }
  return PC;
}
var LC, FB;
function A3e() {
  if (FB) return LC;
  FB = 1, LC = e, e.displayName = "rest", e.aliases = [];
  function e(t) {
    t.languages.rest = {
      table: [
        {
          pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
          lookbehind: !0,
          inside: {
            punctuation: /\||(?:\+[=-]+)+\+/
          }
        },
        {
          pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
          lookbehind: !0,
          inside: {
            punctuation: /[=-]+/
          }
        }
      ],
      // Directive-like patterns
      "substitution-def": {
        pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
        lookbehind: !0,
        inside: {
          substitution: {
            pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
            alias: "attr-value",
            inside: {
              punctuation: /^\||\|$/
            }
          },
          directive: {
            pattern: /( )(?! )[^:]+::/,
            lookbehind: !0,
            alias: "function",
            inside: {
              punctuation: /::$/
            }
          }
        }
      },
      "link-target": [
        {
          pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
          lookbehind: !0,
          alias: "string",
          inside: {
            punctuation: /^\[|\]$/
          }
        },
        {
          pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
          lookbehind: !0,
          alias: "string",
          inside: {
            punctuation: /^_|:$/
          }
        }
      ],
      directive: {
        pattern: /(^[\t ]*\.\. )[^:]+::/m,
        lookbehind: !0,
        alias: "function",
        inside: {
          punctuation: /::$/
        }
      },
      comment: {
        // The two alternatives try to prevent highlighting of blank comments
        pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
        lookbehind: !0
      },
      title: [
        // Overlined and underlined
        {
          pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
          inside: {
            punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        },
        // Underlined only
        {
          pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
          lookbehind: !0,
          inside: {
            punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        }
      ],
      hr: {
        pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
        lookbehind: !0,
        alias: "punctuation"
      },
      field: {
        pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      "command-line-option": {
        pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
        lookbehind: !0,
        alias: "symbol"
      },
      "literal-block": {
        pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^::/,
            alias: "punctuation"
          }
        }
      },
      "quoted-literal-block": {
        pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
            alias: "punctuation"
          }
        }
      },
      "list-bullet": {
        pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
        lookbehind: !0,
        alias: "punctuation"
      },
      "doctest-block": {
        pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /^>>>/
        }
      },
      inline: [
        {
          pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
          lookbehind: !0,
          inside: {
            bold: {
              pattern: /(^\*\*).+(?=\*\*$)/,
              lookbehind: !0
            },
            italic: {
              pattern: /(^\*).+(?=\*$)/,
              lookbehind: !0
            },
            "inline-literal": {
              pattern: /(^``).+(?=``$)/,
              lookbehind: !0,
              alias: "symbol"
            },
            role: {
              pattern: /^:[^:]+:|:[^:]+:$/,
              alias: "function",
              inside: {
                punctuation: /^:|:$/
              }
            },
            "interpreted-text": {
              pattern: /(^`).+(?=`$)/,
              lookbehind: !0,
              alias: "attr-value"
            },
            substitution: {
              pattern: /(^\|).+(?=\|$)/,
              lookbehind: !0,
              alias: "attr-value"
            },
            punctuation: /\*\*?|``?|\|/
          }
        }
      ],
      link: [
        {
          pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
          alias: "string",
          inside: {
            punctuation: /^\[|\]_$/
          }
        },
        {
          pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
          alias: "string",
          inside: {
            punctuation: /^_?`|`$|`?_?_$/
          }
        }
      ],
      // Line block start,
      // quote attribution,
      // explicit markup start,
      // and anonymous hyperlink target shortcut (__)
      punctuation: {
        pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
        lookbehind: !0
      }
    };
  }
  return LC;
}
var MC, $B;
function T3e() {
  if ($B) return MC;
  $B = 1, MC = e, e.displayName = "rip", e.aliases = [];
  function e(t) {
    t.languages.rip = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      char: {
        pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      regex: {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
      builtin: /@|\bSystem\b/,
      boolean: /\b(?:false|true)\b/,
      date: /\b\d{4}-\d{2}-\d{2}\b/,
      time: /\b\d{2}:\d{2}:\d{2}\b/,
      datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
      symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
      number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
      punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
      reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
    };
  }
  return MC;
}
var FC, BB;
function R3e() {
  if (BB) return FC;
  BB = 1, FC = e, e.displayName = "roboconf", e.aliases = [];
  function e(t) {
    t.languages.roboconf = {
      comment: /#.*/,
      keyword: {
        pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
        lookbehind: !0
      },
      component: {
        pattern: /[\w-]+(?=[ \t]*\{)/,
        alias: "variable"
      },
      property: /[\w.-]+(?=[ \t]*:)/,
      value: {
        pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
        lookbehind: !0,
        alias: "attr-value"
      },
      optional: {
        pattern: /\(optional\)/,
        alias: "builtin"
      },
      wildcard: {
        pattern: /(\.)\*/,
        lookbehind: !0,
        alias: "operator"
      },
      punctuation: /[{},.;:=]/
    };
  }
  return FC;
}
var $C, UB;
function I3e() {
  if (UB) return $C;
  UB = 1, $C = e, e.displayName = "robotframework", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /(^[ \t]*| {2}|\t)#.*/m,
        lookbehind: !0,
        greedy: !0
      }, a = {
        pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
        lookbehind: !0,
        inside: {
          punctuation: /^[$@&%]\{|\}$/
        }
      };
      function s(u, c) {
        var d = {};
        d["section-header"] = {
          pattern: /^ ?\*{3}.+?\*{3}/,
          alias: "keyword"
        };
        for (var p in c)
          d[p] = c[p];
        return d.tag = {
          pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
          lookbehind: !0,
          inside: {
            punctuation: /\[|\]/
          }
        }, d.variable = a, d.comment = n, {
          pattern: RegExp(
            /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
              /<name>/g,
              function() {
                return u;
              }
            ),
            "im"
          ),
          alias: "section",
          inside: d
        };
      }
      var i = {
        pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
        lookbehind: !0,
        alias: "string"
      }, o = {
        pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: !0,
        alias: "function",
        inside: {
          variable: a
        }
      }, l = {
        pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: !0,
        inside: {
          variable: a
        }
      };
      r.languages.robotframework = {
        settings: s("Settings", {
          documentation: {
            pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
            lookbehind: !0,
            alias: "string"
          },
          property: {
            pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: !0
          }
        }),
        variables: s("Variables"),
        "test-cases": s("Test Cases", {
          "test-name": o,
          documentation: i,
          property: l
        }),
        keywords: s("Keywords", {
          "keyword-name": o,
          documentation: i,
          property: l
        }),
        tasks: s("Tasks", {
          "task-name": o,
          documentation: i,
          property: l
        }),
        comment: n
      }, r.languages.robot = r.languages.robotframework;
    })(t);
  }
  return $C;
}
var BC, zB;
function N3e() {
  if (zB) return BC;
  zB = 1, BC = e, e.displayName = "rust", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, a = 0; a < 2; a++)
        n = n.replace(/<self>/g, function() {
          return n;
        });
      n = n.replace(/<self>/g, function() {
        return /[^\s\S]/.source;
      }), r.languages.rust = {
        comment: [
          {
            pattern: RegExp(/(^|[^\\])/.source + n),
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        string: {
          pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
          greedy: !0
        },
        char: {
          pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
          greedy: !0
        },
        attribute: {
          pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
          greedy: !0,
          alias: "attr-name",
          inside: {
            string: null
            // see below
          }
        },
        // Closure params should not be confused with bitwise OR |
        "closure-params": {
          pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            "closure-punctuation": {
              pattern: /^\||\|$/,
              alias: "punctuation"
            },
            rest: null
            // see below
          }
        },
        "lifetime-annotation": {
          pattern: /'\w+/,
          alias: "symbol"
        },
        "fragment-specifier": {
          pattern: /(\$\w+:)[a-z]+/,
          lookbehind: !0,
          alias: "punctuation"
        },
        variable: /\$\w+/,
        "function-definition": {
          pattern: /(\bfn\s+)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        "type-definition": {
          pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
          lookbehind: !0,
          alias: "class-name"
        },
        "module-declaration": [
          {
            pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
            lookbehind: !0,
            alias: "namespace"
          },
          {
            pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
            lookbehind: !0,
            alias: "namespace",
            inside: {
              punctuation: /::/
            }
          }
        ],
        keyword: [
          // https://github.com/rust-lang/reference/blob/master/src/keywords.md
          /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
          // primitives and str
          // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
          /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
        ],
        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
        // and Rust's naming conventions recommend snake_case anyway.
        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
        macro: {
          pattern: /\b\w+!/,
          alias: "property"
        },
        constant: /\b[A-Z_][A-Z_\d]+\b/,
        "class-name": /\b[A-Z]\w*\b/,
        namespace: {
          pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
          inside: {
            punctuation: /::/
          }
        },
        // Hex, oct, bin, dec numbers with visual separators and type suffix
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
        operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
      }, r.languages.rust["closure-params"].inside.rest = r.languages.rust, r.languages.rust.attribute.inside.string = r.languages.rust.string;
    })(t);
  }
  return BC;
}
var UC, qB;
function D3e() {
  if (qB) return UC;
  qB = 1, UC = e, e.displayName = "sas", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source, a = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i, s = {
        pattern: RegExp(n + "[bx]"),
        alias: "number"
      }, i = {
        pattern: /&[a-z_]\w*/i
      }, o = {
        pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, l = {
        pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
        alias: "keyword",
        lookbehind: !0
      }, u = [
        /\/\*[\s\S]*?\*\//,
        {
          pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
          lookbehind: !0
        }
      ], c = {
        pattern: RegExp(n),
        greedy: !0
      }, d = /[$%@.(){}\[\];,\\]/, p = {
        pattern: /%?\b\w+(?=\()/,
        alias: "keyword"
      }, f = {
        function: p,
        "arg-value": {
          pattern: /(=\s*)[A-Z\.]+/i,
          lookbehind: !0
        },
        operator: /=/,
        "macro-variable": i,
        arg: {
          pattern: /[A-Z]+/i,
          alias: "keyword"
        },
        number: a,
        "numeric-constant": s,
        punctuation: d,
        string: c
      }, h = {
        pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
        inside: {
          keyword: /^(?:format|put)(?==)/i,
          equals: /=/,
          format: {
            pattern: /(?:\w|\$\d)+\.\d?/,
            alias: "number"
          }
        }
      }, m = {
        pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
        inside: {
          keyword: /^(?:format|put)/i,
          format: {
            pattern: /[\w$]+\.\d?/,
            alias: "number"
          }
        }
      }, y = {
        pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, b = {
        pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, v = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source, x = {
        pattern: RegExp(
          /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
            /<act>/g,
            function() {
              return v;
            }
          ),
          "i"
        ),
        lookbehind: !0,
        inside: {
          keyword: RegExp(
            /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
              return v;
            }),
            "i"
          ),
          action: {
            pattern: /(?:action)/i,
            alias: "keyword"
          },
          comment: u,
          function: p,
          "arg-value": f["arg-value"],
          operator: f.operator,
          argument: f.arg,
          number: a,
          "numeric-constant": s,
          punctuation: d,
          string: c
        }
      }, _ = {
        pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
        lookbehind: !0
      };
      r.languages.sas = {
        datalines: {
          pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
          lookbehind: !0,
          alias: "string",
          inside: {
            keyword: {
              pattern: /^(?:cards|(?:data)?lines)/i
            },
            punctuation: /;/
          }
        },
        "proc-sql": {
          pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            sql: {
              pattern: RegExp(
                /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
                  /<str>/g,
                  function() {
                    return n;
                  }
                ),
                "im"
              ),
              alias: "language-sql",
              inside: r.languages.sql
            },
            "global-statements": y,
            "sql-statements": {
              pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
              lookbehind: !0,
              alias: "keyword"
            },
            number: a,
            "numeric-constant": s,
            punctuation: d,
            string: c
          }
        },
        "proc-groovy": {
          pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: u,
            groovy: {
              pattern: RegExp(
                /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                  /<str>/g,
                  function() {
                    return n;
                  }
                ),
                "im"
              ),
              lookbehind: !0,
              alias: "language-groovy",
              inside: r.languages.groovy
            },
            keyword: _,
            "submit-statement": b,
            "global-statements": y,
            number: a,
            "numeric-constant": s,
            punctuation: d,
            string: c
          }
        },
        "proc-lua": {
          pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: u,
            lua: {
              pattern: RegExp(
                /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                  /<str>/g,
                  function() {
                    return n;
                  }
                ),
                "im"
              ),
              lookbehind: !0,
              alias: "language-lua",
              inside: r.languages.lua
            },
            keyword: _,
            "submit-statement": b,
            "global-statements": y,
            number: a,
            "numeric-constant": s,
            punctuation: d,
            string: c
          }
        },
        "proc-cas": {
          pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: u,
            "statement-var": {
              pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
              lookbehind: !0,
              inside: {
                statement: {
                  pattern: /^saveresult\s+\S+/i,
                  inside: {
                    keyword: /^(?:saveresult)/i
                  }
                },
                rest: f
              }
            },
            "cas-actions": x,
            statement: {
              pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
              lookbehind: !0,
              inside: f
            },
            step: l,
            keyword: _,
            function: p,
            format: h,
            altformat: m,
            "global-statements": y,
            number: a,
            "numeric-constant": s,
            punctuation: d,
            string: c
          }
        },
        "proc-args": {
          pattern: RegExp(
            /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
              /<str>/g,
              function() {
                return n;
              }
            ),
            "im"
          ),
          lookbehind: !0,
          inside: f
        },
        /*Special keywords within macros*/
        "macro-keyword": o,
        "macro-variable": i,
        "macro-string-functions": {
          pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
          lookbehind: !0,
          inside: {
            function: {
              pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
              alias: "keyword"
            },
            "macro-keyword": o,
            "macro-variable": i,
            "escaped-char": {
              pattern: /%['"()<>=¬^~;,#]/
            },
            punctuation: d
          }
        },
        "macro-declaration": {
          pattern: /^%macro[^;]+(?=;)/im,
          inside: {
            keyword: /%macro/i
          }
        },
        "macro-end": {
          pattern: /^%mend[^;]+(?=;)/im,
          inside: {
            keyword: /%mend/i
          }
        },
        /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
        macro: {
          pattern: /%_\w+(?=\()/,
          alias: "keyword"
        },
        input: {
          pattern: /\binput\s[-\w\s/*.$&]+;/i,
          inside: {
            input: {
              alias: "keyword",
              pattern: /^input/i
            },
            comment: u,
            number: a,
            "numeric-constant": s
          }
        },
        "options-args": {
          pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
          lookbehind: !0,
          inside: f
        },
        "cas-actions": x,
        comment: u,
        function: p,
        format: h,
        altformat: m,
        "numeric-constant": s,
        datetime: {
          // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
          pattern: RegExp(n + "(?:dt?|t)"),
          alias: "number"
        },
        string: c,
        step: l,
        keyword: _,
        // In SAS Studio syntax highlighting, these operators are styled like keywords
        "operator-keyword": {
          pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
          alias: "operator"
        },
        // Decimal (1.2e23), hexadecimal (0c1x)
        number: a,
        operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
        punctuation: d
      };
    })(t);
  }
  return UC;
}
var zC, jB;
function O3e() {
  if (jB) return zC;
  jB = 1, zC = e, e.displayName = "sass", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.sass = r.languages.extend("css", {
        // Sass comments don't need to be closed, only indented
        comment: {
          pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
          lookbehind: !0,
          greedy: !0
        }
      }), r.languages.insertBefore("sass", "atrule", {
        // We want to consume the whole line
        "atrule-line": {
          // Includes support for = and + shortcuts
          pattern: /^(?:[ \t]*)[@+=].+/m,
          greedy: !0,
          inside: {
            atrule: /(?:@[\w-]+|[+=])/
          }
        }
      }), delete r.languages.sass.atrule;
      var n = /\$[-\w]+|#\{\$[-\w]+\}/, a = [
        /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
        {
          pattern: /(\s)-(?=\s)/,
          lookbehind: !0
        }
      ];
      r.languages.insertBefore("sass", "property", {
        // We want to consume the whole line
        "variable-line": {
          pattern: /^[ \t]*\$.+/m,
          greedy: !0,
          inside: {
            punctuation: /:/,
            variable: n,
            operator: a
          }
        },
        // We want to consume the whole line
        "property-line": {
          pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
          greedy: !0,
          inside: {
            property: [
              /[^:\s]+(?=\s*:)/,
              {
                pattern: /(:)[^:\s]+/,
                lookbehind: !0
              }
            ],
            punctuation: /:/,
            variable: n,
            operator: a,
            important: r.languages.sass.important
          }
        }
      }), delete r.languages.sass.property, delete r.languages.sass.important, r.languages.insertBefore("sass", "punctuation", {
        selector: {
          pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
          lookbehind: !0,
          greedy: !0
        }
      });
    })(t);
  }
  return zC;
}
var qC, HB;
function P3e() {
  if (HB) return qC;
  HB = 1;
  var e = pD();
  qC = t, t.displayName = "scala", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.scala = r.languages.extend("java", {
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
      number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
      builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
      symbol: /'[^\d\s\\]\w*/
    }), r.languages.insertBefore("scala", "triple-quoted-string", {
      "string-interpolation": {
        pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
        greedy: !0,
        inside: {
          id: {
            pattern: /^\w+/,
            greedy: !0,
            alias: "function"
          },
          escape: {
            pattern: /\\\$"|\$[$"]/,
            greedy: !0,
            alias: "symbol"
          },
          interpolation: {
            pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
            greedy: !0,
            inside: {
              punctuation: /^\$\{?|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: r.languages.scala
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    }), delete r.languages.scala["class-name"], delete r.languages.scala.function;
  }
  return qC;
}
var jC, VB;
function L3e() {
  if (VB) return jC;
  VB = 1, jC = e, e.displayName = "scss", e.aliases = [];
  function e(t) {
    t.languages.scss = t.languages.extend("css", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0
      },
      atrule: {
        pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
        inside: {
          rule: /@[\w-]+/
          // See rest below
        }
      },
      // url, compassified
      url: /(?:[-a-z]+-)?url(?=\()/i,
      // CSS selector regex is not appropriate for Sass
      // since there can be lot more things (var, @ directive, nesting..)
      // a selector must start at the end of a property or after a brace (end of other rules or nesting)
      // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
      // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
      // can "pass" as a selector- e.g: proper#{$erty})
      // this one was hard to do, so please be careful if you edit this one :)
      selector: {
        // Initial look-ahead is used to prevent matching of blank selectors
        pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
        inside: {
          parent: {
            pattern: /&/,
            alias: "important"
          },
          placeholder: /%[-\w]+/,
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      },
      property: {
        pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
        inside: {
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      }
    }), t.languages.insertBefore("scss", "atrule", {
      keyword: [
        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
        {
          pattern: /( )(?:from|through)(?= )/,
          lookbehind: !0
        }
      ]
    }), t.languages.insertBefore("scss", "important", {
      // var and interpolated vars
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }), t.languages.insertBefore("scss", "function", {
      "module-modifier": {
        pattern: /\b(?:as|hide|show|with)\b/i,
        alias: "keyword"
      },
      placeholder: {
        pattern: /%[-\w]+/,
        alias: "selector"
      },
      statement: {
        pattern: /\B!(?:default|optional)\b/i,
        alias: "keyword"
      },
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      operator: {
        pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
        lookbehind: !0
      }
    }), t.languages.scss.atrule.inside.rest = t.languages.scss;
  }
  return jC;
}
var HC, GB;
function M3e() {
  if (GB) return HC;
  GB = 1;
  var e = DW();
  HC = t, t.displayName = "shellSession", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = [
        // normal string
        /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
        /'[^']*'/.source,
        /\$'(?:[^'\\]|\\[\s\S])*'/.source,
        // here doc
        // 2 capturing groups
        /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
      ].join("|");
      n.languages["shell-session"] = {
        command: {
          pattern: RegExp(
            // user info
            /^/.source + "(?:" + // <user> ":" ( <path> )?
            (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // <path>
            // Since the path pattern is quite general, we will require it to start with a special character to
            // prevent false positives.
            /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + // shell symbol
            /[$#%](?=\s)/.source + // bash command
            /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
              /<<str>>/g,
              function() {
                return a;
              }
            ),
            "m"
          ),
          greedy: !0,
          inside: {
            info: {
              // foo@bar:~/files$ exit
              // foo@bar$ exit
              // ~/files$ exit
              pattern: /^[^#$%]+/,
              alias: "punctuation",
              inside: {
                user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
                punctuation: /:/,
                path: /[\s\S]+/
              }
            },
            bash: {
              pattern: /(^[$#%]\s*)\S[\s\S]*/,
              lookbehind: !0,
              alias: "language-bash",
              inside: n.languages.bash
            },
            "shell-symbol": {
              pattern: /^[$#%]/,
              alias: "important"
            }
          }
        },
        output: /.(?:.*(?:[\r\n]|.$))*/
      }, n.languages["sh-session"] = n.languages.shellsession = n.languages["shell-session"];
    }(r);
  }
  return HC;
}
var VC, WB;
function F3e() {
  if (WB) return VC;
  WB = 1, VC = e, e.displayName = "smali", e.aliases = [];
  function e(t) {
    t.languages.smali = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
        greedy: !0
      },
      "class-name": {
        pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
        lookbehind: !0,
        inside: {
          "class-name": {
            pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
            lookbehind: !0
          },
          namespace: {
            pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
            lookbehind: !0,
            inside: {
              punctuation: /\//
            }
          },
          builtin: /^L/
        }
      },
      builtin: [
        {
          // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
          pattern: /([();\[])[BCDFIJSVZ]+/,
          lookbehind: !0
        },
        {
          // e.g. .field mWifiOnUid:I
          pattern: /([\w$>]:)[BCDFIJSVZ]/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /(\.end\s+)[\w-]+/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
          lookbehind: !0
        }
      ],
      function: {
        pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
        lookbehind: !0
      },
      field: {
        pattern: /[\w$]+(?=:)/,
        alias: "variable"
      },
      register: {
        pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
        lookbehind: !0,
        alias: "variable"
      },
      boolean: {
        pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
        lookbehind: !0
      },
      number: {
        pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
        lookbehind: !0
      },
      label: {
        pattern: /(:)\w+/,
        lookbehind: !0,
        alias: "property"
      },
      operator: /->|\.\.|[\[=]/,
      punctuation: /[{}(),;:]/
    };
  }
  return VC;
}
var GC, KB;
function $3e() {
  if (KB) return GC;
  KB = 1, GC = e, e.displayName = "smalltalk", e.aliases = [];
  function e(t) {
    t.languages.smalltalk = {
      comment: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      char: {
        pattern: /\$./,
        greedy: !0
      },
      string: {
        pattern: /'(?:''|[^'])*'/,
        greedy: !0
      },
      symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
      "block-arguments": {
        pattern: /(\[\s*):[^\[|]*\|/,
        lookbehind: !0,
        inside: {
          variable: /:[\da-z]+/i,
          punctuation: /\|/
        }
      },
      "temporary-variables": {
        pattern: /\|[^|]+\|/,
        inside: {
          variable: /[\da-z]+/i,
          punctuation: /\|/
        }
      },
      keyword: /\b(?:new|nil|self|super)\b/,
      boolean: /\b(?:false|true)\b/,
      number: [
        /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
        /\b\d+(?:\.\d+)?(?:e-?\d+)?/
      ],
      operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
      punctuation: /[.;:?\[\](){}]/
    };
  }
  return GC;
}
var WC, YB;
function B3e() {
  if (YB) return WC;
  YB = 1;
  var e = Ia();
  WC = t, t.displayName = "smarty", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      n.languages.smarty = {
        comment: {
          pattern: /^\{\*[\s\S]*?\*\}/,
          greedy: !0
        },
        "embedded-php": {
          pattern: /^\{php\}[\s\S]*?\{\/php\}/,
          greedy: !0,
          inside: {
            smarty: {
              pattern: /^\{php\}|\{\/php\}$/,
              inside: null
              // see below
            },
            php: {
              pattern: /[\s\S]+/,
              alias: "language-php",
              inside: n.languages.php
            }
          }
        },
        string: [
          {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: !0,
            inside: {
              interpolation: {
                pattern: /\{[^{}]*\}|`[^`]*`/,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^[{`]|[`}]$/,
                    alias: "punctuation"
                  },
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: null
                    // see below
                  }
                }
              },
              variable: /\$\w+/
            }
          },
          {
            pattern: /'(?:\\.|[^'\\\r\n])*'/,
            greedy: !0
          }
        ],
        keyword: {
          pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
          lookbehind: !0,
          greedy: !0
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          greedy: !0,
          alias: "punctuation"
        },
        number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
        variable: [
          /\$(?!\d)\w+/,
          /#(?!\d)\w+#/,
          {
            pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
            lookbehind: !0
          },
          {
            pattern: /(\[)(?!\d)\w+(?=\])/,
            lookbehind: !0
          }
        ],
        function: {
          pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
          lookbehind: !0
        },
        "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
        boolean: /\b(?:false|no|off|on|true|yes)\b/,
        punctuation: /[\[\](){}.,:`]|->/,
        operator: [
          /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
          /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
          /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
        ]
      }, n.languages.smarty["embedded-php"].inside.smarty.inside = n.languages.smarty, n.languages.smarty.string[0].inside.interpolation.inside.expression.inside = n.languages.smarty;
      var a = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/, s = RegExp(
        // comments
        /\{\*[\s\S]*?\*\}/.source + "|" + // php tags
        /\{php\}[\s\S]*?\{\/php\}/.source + "|" + // smarty blocks
        /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
          /<str>/g,
          function() {
            return a.source;
          }
        ),
        "g"
      );
      n.hooks.add("before-tokenize", function(i) {
        var o = "{literal}", l = "{/literal}", u = !1;
        n.languages["markup-templating"].buildPlaceholders(
          i,
          "smarty",
          s,
          function(c) {
            return c === l && (u = !1), u ? !1 : (c === o && (u = !0), !0);
          }
        );
      }), n.hooks.add("after-tokenize", function(i) {
        n.languages["markup-templating"].tokenizePlaceholders(i, "smarty");
      });
    }(r);
  }
  return WC;
}
var KC, XB;
function U3e() {
  if (XB) return KC;
  XB = 1, KC = e, e.displayName = "sml", e.aliases = ["smlnj"];
  function e(t) {
    (function(r) {
      var n = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
      r.languages.sml = {
        // allow one level of nesting
        comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
        string: {
          pattern: /#?"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        "class-name": [
          {
            // This is only an approximation since the real grammar is context-free
            //
            // Why the main loop so complex?
            // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
            // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
            // followed by a long identifier.
            pattern: RegExp(
              /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
                return /\s*(?:[*,]|->)/.source;
              }).replace(/<TERMINAL>/g, function() {
                return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
              }).replace(/<LONG-ID>/g, function() {
                return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
              }).replace(/<KEYWORD>/g, function() {
                return n.source;
              }),
              "i"
            ),
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          {
            pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
            lookbehind: !0
          }
        ],
        function: {
          pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
          lookbehind: !0
        },
        keyword: n,
        variable: {
          pattern: /(^|[^\w'])'[\w']*/,
          lookbehind: !0
        },
        number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
        word: {
          pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
          alias: "constant"
        },
        boolean: /\b(?:false|true)\b/i,
        operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
        punctuation: /[(){}\[\].:,;]/
      }, r.languages.sml["class-name"][0].inside = r.languages.sml, r.languages.smlnj = r.languages.sml;
    })(t);
  }
  return KC;
}
var YC, ZB;
function z3e() {
  if (ZB) return YC;
  ZB = 1, YC = e, e.displayName = "solidity", e.aliases = ["sol"];
  function e(t) {
    t.languages.solidity = t.languages.extend("clike", {
      "class-name": {
        pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
        lookbehind: !0
      },
      keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
      operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
    }), t.languages.insertBefore("solidity", "keyword", {
      builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
    }), t.languages.insertBefore("solidity", "number", {
      version: {
        pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
        lookbehind: !0,
        alias: "number"
      }
    }), t.languages.sol = t.languages.solidity;
  }
  return YC;
}
var XC, JB;
function q3e() {
  if (JB) return XC;
  JB = 1, XC = e, e.displayName = "solutionFile", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
        pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
        alias: "constant",
        inside: {
          punctuation: /[{}]/
        }
      };
      r.languages["solution-file"] = {
        comment: {
          pattern: /#.*/,
          greedy: !0
        },
        string: {
          pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
          greedy: !0,
          inside: {
            guid: n
          }
        },
        object: {
          // Foo
          //   Bar("abs") = 9
          //   EndBar
          //   Prop = TRUE
          // EndFoo
          pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
          lookbehind: !0,
          greedy: !0,
          alias: "keyword"
        },
        property: {
          pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
          lookbehind: !0,
          inside: {
            guid: n
          }
        },
        guid: n,
        number: /\b\d+(?:\.\d+)*\b/,
        boolean: /\b(?:FALSE|TRUE)\b/,
        operator: /=/,
        punctuation: /[(),]/
      }, r.languages.sln = r.languages["solution-file"];
    })(t);
  }
  return XC;
}
var ZC, QB;
function j3e() {
  if (QB) return ZC;
  QB = 1;
  var e = Ia();
  ZC = t, t.displayName = "soy", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      var a = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, s = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
      n.languages.soy = {
        comment: [
          /\/\*[\s\S]*?\*\//,
          {
            pattern: /(\s)\/\/.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        "command-arg": {
          pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
          lookbehind: !0,
          alias: "string",
          inside: {
            punctuation: /\./
          }
        },
        parameter: {
          pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
          lookbehind: !0,
          alias: "variable"
        },
        keyword: [
          {
            pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
            lookbehind: !0
          },
          /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
        ],
        delimiter: {
          pattern: /^\{+\/?|\/?\}+$/,
          alias: "punctuation"
        },
        property: /\w+(?==)/,
        variable: {
          pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
          inside: {
            string: {
              pattern: a,
              greedy: !0
            },
            number: s,
            punctuation: /[\[\].?]/
          }
        },
        string: {
          pattern: a,
          greedy: !0
        },
        function: [
          /\w+(?=\()/,
          {
            pattern: /(\|[^\S\r\n]*)\w+/,
            lookbehind: !0
          }
        ],
        boolean: /\b(?:false|true)\b/,
        number: s,
        operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
        punctuation: /[{}()\[\]|.,:]/
      }, n.hooks.add("before-tokenize", function(i) {
        var o = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g, l = "{literal}", u = "{/literal}", c = !1;
        n.languages["markup-templating"].buildPlaceholders(
          i,
          "soy",
          o,
          function(d) {
            return d === u && (c = !1), c ? !1 : (d === l && (c = !0), !0);
          }
        );
      }), n.hooks.add("after-tokenize", function(i) {
        n.languages["markup-templating"].tokenizePlaceholders(i, "soy");
      });
    }(r);
  }
  return ZC;
}
var JC, e7;
function MW() {
  if (e7) return JC;
  e7 = 1, JC = e, e.displayName = "turtle", e.aliases = [];
  function e(t) {
    t.languages.turtle = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      "multiline-string": {
        pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
        greedy: !0,
        alias: "string",
        inside: {
          comment: /#.*/
        }
      },
      string: {
        pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
        greedy: !0
      },
      url: {
        pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
        greedy: !0,
        inside: {
          punctuation: /[<>]/
        }
      },
      function: {
        pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
        inside: {
          "local-name": {
            pattern: /([^:]*:)[\s\S]+/,
            lookbehind: !0
          },
          prefix: {
            pattern: /[\s\S]+/,
            inside: {
              punctuation: /:/
            }
          }
        }
      },
      number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      punctuation: /[{}.,;()[\]]|\^\^/,
      boolean: /\b(?:false|true)\b/,
      keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
      tag: {
        pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
        inside: {
          punctuation: /@/
        }
      }
    }, t.languages.trig = t.languages.turtle;
  }
  return JC;
}
var QC, t7;
function H3e() {
  if (t7) return QC;
  t7 = 1;
  var e = MW();
  QC = t, t.displayName = "sparql", t.aliases = ["rq"];
  function t(r) {
    r.register(e), r.languages.sparql = r.languages.extend("turtle", {
      boolean: /\b(?:false|true)\b/i,
      variable: {
        pattern: /[?$]\w+/,
        greedy: !0
      }
    }), r.languages.insertBefore("sparql", "punctuation", {
      keyword: [
        /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
        /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
        /\b(?:BASE|GRAPH|PREFIX)\b/i
      ]
    }), r.languages.rq = r.languages.sparql;
  }
  return QC;
}
var eA, r7;
function V3e() {
  if (r7) return eA;
  r7 = 1, eA = e, e.displayName = "splunkSpl", e.aliases = [];
  function e(t) {
    t.languages["splunk-spl"] = {
      comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: !0
      },
      // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
      keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
      "operator-word": {
        pattern: /\b(?:and|as|by|not|or|xor)\b/i,
        alias: "operator"
      },
      function: /\b\w+(?=\s*\()/,
      property: /\b\w+(?=\s*=(?!=))/,
      date: {
        // MM/DD/YYYY(:HH:MM:SS)?
        pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
        alias: "number"
      },
      number: /\b\d+(?:\.\d+)?\b/,
      boolean: /\b(?:f|false|t|true)\b/i,
      operator: /[<>=]=?|[-+*/%|]/,
      punctuation: /[()[\],]/
    };
  }
  return eA;
}
var tA, n7;
function G3e() {
  if (n7) return tA;
  n7 = 1, tA = e, e.displayName = "sqf", e.aliases = [];
  function e(t) {
    t.languages.sqf = t.languages.extend("clike", {
      string: {
        pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
        greedy: !0
      },
      keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
      number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
      operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
      "magic-variable": {
        pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
        alias: "keyword"
      },
      constant: /\bDIK(?:_[a-z\d]+)+\b/i
    }), t.languages.insertBefore("sqf", "string", {
      macro: {
        pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          directive: {
            pattern: /#[a-z]+\b/i,
            alias: "keyword"
          },
          comment: t.languages.sqf.comment
        }
      }
    }), delete t.languages.sqf["class-name"];
  }
  return tA;
}
var rA, i7;
function W3e() {
  if (i7) return rA;
  i7 = 1, rA = e, e.displayName = "squirrel", e.aliases = [];
  function e(t) {
    t.languages.squirrel = t.languages.extend("clike", {
      comment: [
        t.languages.clike.comment[0],
        {
          pattern: /(^|[^\\:])(?:\/\/|#).*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
      number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
      operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
      punctuation: /[(){}\[\],;.]/
    }), t.languages.insertBefore("squirrel", "string", {
      char: {
        pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
        lookbehind: !0,
        greedy: !0
      }
    }), t.languages.insertBefore("squirrel", "operator", {
      "attribute-punctuation": {
        pattern: /<\/|\/>/,
        alias: "important"
      },
      lambda: {
        pattern: /@(?=\()/,
        alias: "operator"
      }
    });
  }
  return rA;
}
var nA, a7;
function K3e() {
  if (a7) return nA;
  a7 = 1, nA = e, e.displayName = "stan", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
      r.languages.stan = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
        string: {
          // String literals can contain spaces and any printable ASCII characters except for " and \
          // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
          pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
          greedy: !0
        },
        directive: {
          pattern: /^([ \t]*)#include\b.*/m,
          lookbehind: !0,
          alias: "property"
        },
        "function-arg": {
          pattern: RegExp(
            "(" + n.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source
          ),
          lookbehind: !0,
          alias: "function"
        },
        constraint: {
          pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
          lookbehind: !0,
          inside: {
            expression: {
              pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            property: /\b[a-z]\w*(?=\s*=)/i,
            operator: /=/,
            punctuation: /^<|>$|,/
          }
        },
        keyword: [
          {
            pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
            alias: "program-block"
          },
          /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
          // these are functions that are known to take another function as their first argument.
          n
        ],
        function: /\b[a-z]\w*(?=\s*\()/i,
        number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        boolean: /\b(?:false|true)\b/,
        operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
        punctuation: /[()\[\]{},;]/
      }, r.languages.stan.constraint.inside.expression.inside = r.languages.stan;
    })(t);
  }
  return nA;
}
var iA, s7;
function Y3e() {
  if (s7) return iA;
  s7 = 1, iA = e, e.displayName = "stylus", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /(\b\d+)(?:%|[a-z]+)/,
        lookbehind: !0
      }, a = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: !0
      }, s = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: !0
        },
        url: {
          pattern: /\burl\((["']?).*?\1\)/i,
          greedy: !0
        },
        string: {
          pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
          greedy: !0
        },
        interpolation: null,
        // See below
        func: null,
        // See below
        important: /\B!(?:important|optional)\b/i,
        keyword: {
          pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
          lookbehind: !0
        },
        hexcode: /#[\da-f]{3,6}/i,
        color: [
          /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
          {
            pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
            inside: {
              unit: n,
              number: a,
              function: /[\w-]+(?=\()/,
              punctuation: /[(),]/
            }
          }
        ],
        entity: /\\[\da-f]{1,8}/i,
        unit: n,
        boolean: /\b(?:false|true)\b/,
        operator: [
          // We want non-word chars around "-" because it is
          // accepted in property names.
          /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
        ],
        number: a,
        punctuation: /[{}()\[\];:,]/
      };
      s.interpolation = {
        pattern: /\{[^\r\n}:]+\}/,
        alias: "variable",
        inside: {
          delimiter: {
            pattern: /^\{|\}$/,
            alias: "punctuation"
          },
          rest: s
        }
      }, s.func = {
        pattern: /[\w-]+\([^)]*\).*/,
        inside: {
          function: /^[^(]+/,
          rest: s
        }
      }, r.languages.stylus = {
        "atrule-declaration": {
          pattern: /(^[ \t]*)@.+/m,
          lookbehind: !0,
          inside: {
            atrule: /^@[\w-]+/,
            rest: s
          }
        },
        "variable-declaration": {
          pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
          lookbehind: !0,
          inside: {
            variable: /^\S+/,
            rest: s
          }
        },
        statement: {
          pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
          lookbehind: !0,
          inside: {
            keyword: /^\S+/,
            rest: s
          }
        },
        // A property/value pair cannot end with a comma or a brace
        // It cannot have indented content unless it ended with a semicolon
        "property-declaration": {
          pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
          lookbehind: !0,
          inside: {
            property: {
              pattern: /^[^\s:]+/,
              inside: {
                interpolation: s.interpolation
              }
            },
            rest: s
          }
        },
        // A selector can contain parentheses only as part of a pseudo-element
        // It can span multiple lines.
        // It must end with a comma or an accolade or have indented content.
        selector: {
          pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
          lookbehind: !0,
          inside: {
            interpolation: s.interpolation,
            comment: s.comment,
            punctuation: /[{},]/
          }
        },
        func: s.func,
        string: s.string,
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: !0,
          greedy: !0
        },
        interpolation: s.interpolation,
        punctuation: /[{}()\[\];:.]/
      };
    })(t);
  }
  return iA;
}
var aA, o7;
function X3e() {
  if (o7) return aA;
  o7 = 1, aA = e, e.displayName = "swift", e.aliases = [];
  function e(t) {
    t.languages.swift = {
      comment: {
        // Nested comments are supported up to 2 levels
        pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
        lookbehind: !0,
        greedy: !0
      },
      "string-literal": [
        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
        {
          pattern: RegExp(
            /(^|[^"#])/.source + "(?:" + // single-line string
            /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
            /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\\($/,
              alias: "punctuation"
            },
            punctuation: /\\(?=[\r\n])/,
            string: /[\s\S]+/
          }
        },
        {
          pattern: RegExp(
            /(^|[^"#])(#+)/.source + "(?:" + // single-line string
            /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
            /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\#+\($/,
              alias: "punctuation"
            },
            string: /[\s\S]+/
          }
        }
      ],
      directive: {
        // directives with conditions
        pattern: RegExp(
          /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
          //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
          // where <round> is a general parentheses expression.
          /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
        ),
        alias: "property",
        inside: {
          "directive-name": /^#\w+/,
          boolean: /\b(?:false|true)\b/,
          number: /\b\d+(?:\.\d+)*\b/,
          operator: /!|&&|\|\||[<>]=?/,
          punctuation: /[(),]/
        }
      },
      literal: {
        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
        alias: "constant"
      },
      "other-directive": {
        pattern: /#\w+\b/,
        alias: "property"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "atrule"
      },
      "function-definition": {
        pattern: /(\bfunc\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      label: {
        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
        pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
        lookbehind: !0,
        alias: "important"
      },
      keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
      boolean: /\b(?:false|true)\b/,
      nil: {
        pattern: /\bnil\b/,
        alias: "constant"
      },
      "short-argument": /\$\d+\b/,
      omit: {
        pattern: /\b_\b/,
        alias: "keyword"
      },
      number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
      // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
      "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
      // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
      // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
      // This regex only supports ASCII operators.
      operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
      punctuation: /[{}[\]();,.:\\]/
    }, t.languages.swift["string-literal"].forEach(function(r) {
      r.inside.interpolation.inside = t.languages.swift;
    });
  }
  return aA;
}
var sA, l7;
function Z3e() {
  if (l7) return sA;
  l7 = 1, sA = e, e.displayName = "systemd", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /^[;#].*/m,
        greedy: !0
      }, a = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
      r.languages.systemd = {
        comment: n,
        section: {
          pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
          greedy: !0,
          inside: {
            punctuation: /^\[|\]$/,
            "section-name": {
              pattern: /[\s\S]+/,
              alias: "selector"
            }
          }
        },
        key: {
          pattern: /^[^\s=]+(?=[ \t]*=)/m,
          greedy: !0,
          alias: "attr-name"
        },
        value: {
          // This pattern is quite complex because of two properties:
          //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
          //     the lookbehind. You will see this in the main loop where spaces are handled separately.
          //  2) Line continuations.
          //     After line continuations, empty lines and comments are ignored so we have to consume them.
          pattern: RegExp(
            /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
            "(?:" + a + `|(?=[^"\r
]))(?:` + (/[^\s\\]/.source + // handle spaces separately because of quotes
            '|[ 	]+(?:(?![ 	"])|' + a + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "attr-value",
          inside: {
            comment: n,
            quoted: {
              pattern: RegExp(/(^|\s)/.source + a),
              lookbehind: !0,
              greedy: !0
            },
            punctuation: /\\$/m,
            boolean: {
              pattern: /^(?:false|no|off|on|true|yes)$/,
              greedy: !0
            }
          }
        },
        punctuation: /=/
      };
    })(t);
  }
  return sA;
}
var oA, u7;
function bD() {
  if (u7) return oA;
  u7 = 1, oA = e, e.displayName = "t4Templating", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(s, i, o) {
        return {
          pattern: RegExp("<#" + s + "[\\s\\S]*?#>"),
          alias: "block",
          inside: {
            delimiter: {
              pattern: RegExp("^<#" + s + "|#>$"),
              alias: "important"
            },
            content: {
              pattern: /[\s\S]+/,
              inside: i,
              alias: o
            }
          }
        };
      }
      function a(s) {
        var i = r.languages[s], o = "language-" + s;
        return {
          block: {
            pattern: /<#[\s\S]+?#>/,
            inside: {
              directive: n("@", {
                "attr-value": {
                  pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                  inside: {
                    punctuation: /^=|^["']|["']$/
                  }
                },
                keyword: /\b\w+(?=\s)/,
                "attr-name": /\b\w+/
              }),
              expression: n("=", i, o),
              "class-feature": n("\\+", i, o),
              standard: n("", i, o)
            }
          }
        };
      }
      r.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
        value: a
      });
    })(t);
  }
  return oA;
}
var lA, c7;
function J3e() {
  if (c7) return lA;
  c7 = 1;
  var e = bD(), t = yy();
  lA = r, r.displayName = "t4Cs", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), n.languages.t4 = n.languages["t4-cs"] = n.languages["t4-templating"].createT4("csharp");
  }
  return lA;
}
var uA, d7;
function FW() {
  if (d7) return uA;
  d7 = 1;
  var e = OW();
  uA = t, t.displayName = "vbnet", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.vbnet = r.languages.extend("basic", {
      comment: [
        {
          pattern: /(?:!|REM\b).+/i,
          inside: {
            keyword: /^REM/i
          }
        },
        {
          pattern: /(^|[^\\:])'.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
      punctuation: /[,;:(){}]/
    });
  }
  return uA;
}
var cA, f7;
function Q3e() {
  if (f7) return cA;
  f7 = 1;
  var e = bD(), t = FW();
  cA = r, r.displayName = "t4Vb", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), n.languages["t4-vb"] = n.languages["t4-templating"].createT4("vbnet");
  }
  return cA;
}
var dA, p7;
function $W() {
  if (p7) return dA;
  p7 = 1, dA = e, e.displayName = "yaml", e.aliases = ["yml"];
  function e(t) {
    (function(r) {
      var n = /[*&][^\s[\]{},]+/, a = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, s = "(?:" + a.source + "(?:[ 	]+" + n.source + ")?|" + n.source + "(?:[ 	]+" + a.source + ")?)", i = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
        /<PLAIN>/g,
        function() {
          return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
        }
      ), o = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
      function l(u, c) {
        c = (c || "").replace(/m/g, "") + "m";
        var d = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
          return s;
        }).replace(/<<value>>/g, function() {
          return u;
        });
        return RegExp(d, c);
      }
      r.languages.yaml = {
        scalar: {
          pattern: RegExp(
            /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
              /<<prop>>/g,
              function() {
                return s;
              }
            )
          ),
          lookbehind: !0,
          alias: "string"
        },
        comment: /#.*/,
        key: {
          pattern: RegExp(
            /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
              return s;
            }).replace(/<<key>>/g, function() {
              return "(?:" + i + "|" + o + ")";
            })
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "atrule"
        },
        directive: {
          pattern: /(^[ \t]*)%.+/m,
          lookbehind: !0,
          alias: "important"
        },
        datetime: {
          pattern: l(
            /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
          ),
          lookbehind: !0,
          alias: "number"
        },
        boolean: {
          pattern: l(/false|true/.source, "i"),
          lookbehind: !0,
          alias: "important"
        },
        null: {
          pattern: l(/null|~/.source, "i"),
          lookbehind: !0,
          alias: "important"
        },
        string: {
          pattern: l(o),
          lookbehind: !0,
          greedy: !0
        },
        number: {
          pattern: l(
            /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
            "i"
          ),
          lookbehind: !0
        },
        tag: a,
        important: n,
        punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
      }, r.languages.yml = r.languages.yaml;
    })(t);
  }
  return dA;
}
var fA, h7;
function ePe() {
  if (h7) return fA;
  h7 = 1;
  var e = $W();
  fA = t, t.displayName = "tap", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.tap = {
      fail: /not ok[^#{\n\r]*/,
      pass: /ok[^#{\n\r]*/,
      pragma: /pragma [+-][a-z]+/,
      bailout: /bail out!.*/i,
      version: /TAP version \d+/i,
      plan: /\b\d+\.\.\d+(?: +#.*)?/,
      subtest: {
        pattern: /# Subtest(?:: .*)?/,
        greedy: !0
      },
      punctuation: /[{}]/,
      directive: /#.*/,
      yamlish: {
        pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
        lookbehind: !0,
        inside: r.languages.yaml,
        alias: "language-yaml"
      }
    };
  }
  return fA;
}
var pA, m7;
function tPe() {
  if (m7) return pA;
  m7 = 1, pA = e, e.displayName = "tcl", e.aliases = [];
  function e(t) {
    t.languages.tcl = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0
      },
      string: {
        pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
        greedy: !0
      },
      variable: [
        {
          pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
          lookbehind: !0
        },
        {
          pattern: /(\$)\{[^}]+\}/,
          lookbehind: !0
        },
        {
          pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
          lookbehind: !0
        }
      ],
      function: {
        pattern: /(^[\t ]*proc[ \t]+)\S+/m,
        lookbehind: !0
      },
      builtin: [
        {
          pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
          lookbehind: !0
        },
        /\b(?:else|elseif)\b/
      ],
      scope: {
        pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
        lookbehind: !0,
        alias: "constant"
      },
      keyword: {
        pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
        lookbehind: !0
      },
      operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
      punctuation: /[{}()\[\]]/
    };
  }
  return pA;
}
var hA, g7;
function rPe() {
  if (g7) return hA;
  g7 = 1, hA = e, e.displayName = "textile", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source, a = /\)|\((?![^|()\n]+\))/.source;
      function s(p, f) {
        return RegExp(
          p.replace(/<MOD>/g, function() {
            return "(?:" + n + ")";
          }).replace(/<PAR>/g, function() {
            return "(?:" + a + ")";
          }),
          f || ""
        );
      }
      var i = {
        css: {
          pattern: /\{[^{}]+\}/,
          inside: {
            rest: r.languages.css
          }
        },
        "class-id": {
          pattern: /(\()[^()]+(?=\))/,
          lookbehind: !0,
          alias: "attr-value"
        },
        lang: {
          pattern: /(\[)[^\[\]]+(?=\])/,
          lookbehind: !0,
          alias: "attr-value"
        },
        // Anything else is punctuation (the first pattern is for row/col spans inside tables)
        punctuation: /[\\\/]\d+|\S/
      }, o = r.languages.textile = r.languages.extend("markup", {
        phrase: {
          pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
          lookbehind: !0,
          inside: {
            // h1. Header 1
            "block-tag": {
              pattern: s(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
              inside: {
                modifier: {
                  pattern: s(
                    /(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source
                  ),
                  lookbehind: !0,
                  inside: i
                },
                tag: /^[a-z]\w*/,
                punctuation: /\.$/
              }
            },
            // # List item
            // * List item
            list: {
              pattern: s(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
              inside: {
                modifier: {
                  pattern: s(/(^[*#]+)<MOD>+/.source),
                  lookbehind: !0,
                  inside: i
                },
                punctuation: /^[*#]+/
              }
            },
            // | cell | cell | cell |
            table: {
              // Modifiers can be applied to the row: {color:red}.|1|2|3|
              // or the cell: |{color:red}.1|2|3|
              pattern: s(
                /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source,
                "m"
              ),
              inside: {
                modifier: {
                  // Modifiers for rows after the first one are
                  // preceded by a pipe and a line feed
                  pattern: s(
                    /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
                  ),
                  lookbehind: !0,
                  inside: i
                },
                punctuation: /\||^\./
              }
            },
            inline: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: s(
                /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
              ),
              lookbehind: !0,
              inside: {
                // Note: superscripts and subscripts are not handled specifically
                // *bold*, **bold**
                bold: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: !0
                },
                // _italic_, __italic__
                italic: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^(__?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: !0
                },
                // ??cite??
                cite: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                  lookbehind: !0,
                  alias: "string"
                },
                // @code@
                code: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^@<MOD>*).+?(?=@)/.source),
                  lookbehind: !0,
                  alias: "keyword"
                },
                // +inserted+
                inserted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^\+<MOD>*).+?(?=\+)/.source),
                  lookbehind: !0
                },
                // -deleted-
                deleted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^-<MOD>*).+?(?=-)/.source),
                  lookbehind: !0
                },
                // %span%
                span: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^%<MOD>*).+?(?=%)/.source),
                  lookbehind: !0
                },
                modifier: {
                  pattern: s(
                    /(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source
                  ),
                  lookbehind: !0,
                  inside: i
                },
                punctuation: /[*_%?@+\-^~]+/
              }
            },
            // [alias]http://example.com
            "link-ref": {
              pattern: /^\[[^\]]+\]\S+$/m,
              inside: {
                string: {
                  pattern: /(^\[)[^\]]+(?=\])/,
                  lookbehind: !0
                },
                url: {
                  pattern: /(^\])\S+$/,
                  lookbehind: !0
                },
                punctuation: /[\[\]]/
              }
            },
            // "text":http://example.com
            // "text":link-ref
            link: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: s(
                /"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source
              ),
              inside: {
                text: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: s(/(^"<MOD>*)[^"]+(?=")/.source),
                  lookbehind: !0
                },
                modifier: {
                  pattern: s(/(^")<MOD>+/.source),
                  lookbehind: !0,
                  inside: i
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: !0
                },
                punctuation: /[":]/
              }
            },
            // !image.jpg!
            // !image.jpg(Title)!:http://example.com
            image: {
              pattern: s(
                /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source
              ),
              inside: {
                source: {
                  pattern: s(
                    /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
                  ),
                  lookbehind: !0,
                  alias: "url"
                },
                modifier: {
                  pattern: s(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                  lookbehind: !0,
                  inside: i
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: !0
                },
                punctuation: /[!:]/
              }
            },
            // Footnote[1]
            footnote: {
              pattern: /\b\[\d+\]/,
              alias: "comment",
              inside: {
                punctuation: /\[|\]/
              }
            },
            // CSS(Cascading Style Sheet)
            acronym: {
              pattern: /\b[A-Z\d]+\([^)]+\)/,
              inside: {
                comment: {
                  pattern: /(\()[^()]+(?=\))/,
                  lookbehind: !0
                },
                punctuation: /[()]/
              }
            },
            // Prism(C)
            mark: {
              pattern: /\b\((?:C|R|TM)\)/,
              alias: "comment",
              inside: {
                punctuation: /[()]/
              }
            }
          }
        }
      }), l = o.phrase.inside, u = {
        inline: l.inline,
        link: l.link,
        image: l.image,
        footnote: l.footnote,
        acronym: l.acronym,
        mark: l.mark
      };
      o.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
      var c = l.inline.inside;
      c.bold.inside = u, c.italic.inside = u, c.inserted.inside = u, c.deleted.inside = u, c.span.inside = u;
      var d = l.table.inside;
      d.inline = u.inline, d.link = u.link, d.image = u.image, d.footnote = u.footnote, d.acronym = u.acronym, d.mark = u.mark;
    })(t);
  }
  return hA;
}
var mA, b7;
function nPe() {
  if (b7) return mA;
  b7 = 1, mA = e, e.displayName = "toml", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
      function a(s) {
        return s.replace(/__/g, function() {
          return n;
        });
      }
      r.languages.toml = {
        comment: {
          pattern: /#.*/,
          greedy: !0
        },
        table: {
          pattern: RegExp(
            a(
              /(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source
            ),
            "m"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "class-name"
        },
        key: {
          pattern: RegExp(
            a(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
            "m"
          ),
          lookbehind: !0,
          greedy: !0,
          alias: "property"
        },
        string: {
          pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
          greedy: !0
        },
        date: [
          {
            // Offset Date-Time, Local Date-Time, Local Date
            pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
            alias: "number"
          },
          {
            // Local Time
            pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
            alias: "number"
          }
        ],
        number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /[.,=[\]{}]/
      };
    })(t);
  }
  return mA;
}
var gA, y7;
function iPe() {
  if (y7) return gA;
  y7 = 1, gA = e, e.displayName = "tremor", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.tremor = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
          lookbehind: !0
        },
        "interpolated-string": null,
        // see below
        extractor: {
          pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
          greedy: !0,
          inside: {
            regex: {
              pattern: /(^re)\|[\s\S]+/,
              lookbehind: !0
            },
            function: /^\w+/,
            value: /\|[\s\S]+/
          }
        },
        identifier: {
          pattern: /`[^`]*`/,
          greedy: !0
        },
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
        keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
        boolean: /\b(?:false|null|true)\b/i,
        number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
        "pattern-punctuation": {
          pattern: /%(?=[({[])/,
          alias: "punctuation"
        },
        operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
        punctuation: /::|[;\[\]()\{\},.:]/
      };
      var n = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
      r.languages.tremor["interpolated-string"] = {
        pattern: RegExp(
          /(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + n + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + n + ')*")'
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: RegExp(n),
            inside: {
              punctuation: /^#\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: r.languages.tremor
              }
            }
          },
          string: /[\s\S]+/
        }
      }, r.languages.troy = r.languages.tremor, r.languages.trickle = r.languages.tremor;
    })(t);
  }
  return gA;
}
var bA, v7;
function aPe() {
  if (v7) return bA;
  v7 = 1;
  var e = LW(), t = hD();
  bA = r, r.displayName = "tsx", r.aliases = [];
  function r(n) {
    n.register(e), n.register(t), function(a) {
      var s = a.util.clone(a.languages.typescript);
      a.languages.tsx = a.languages.extend("jsx", s), delete a.languages.tsx.parameter, delete a.languages.tsx["literal-property"];
      var i = a.languages.tsx.tag;
      i.pattern = RegExp(
        /(^|[^\w$]|(?=<\/))/.source + "(?:" + i.pattern.source + ")",
        i.pattern.flags
      ), i.lookbehind = !0;
    }(n);
  }
  return bA;
}
var yA, w7;
function sPe() {
  if (w7) return yA;
  w7 = 1;
  var e = Ia();
  yA = t, t.displayName = "tt2", t.aliases = [];
  function t(r) {
    r.register(e), function(n) {
      n.languages.tt2 = n.languages.extend("clike", {
        comment: /#.*|\[%#[\s\S]*?%\]/,
        keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
        punctuation: /[[\]{},()]/
      }), n.languages.insertBefore("tt2", "number", {
        operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
        variable: {
          pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
        }
      }), n.languages.insertBefore("tt2", "keyword", {
        delimiter: {
          pattern: /^(?:\[%|%%)-?|-?%\]$/,
          alias: "punctuation"
        }
      }), n.languages.insertBefore("tt2", "string", {
        "single-quoted-string": {
          pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
          greedy: !0,
          alias: "string"
        },
        "double-quoted-string": {
          pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
          greedy: !0,
          alias: "string",
          inside: {
            variable: {
              pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
            }
          }
        }
      }), delete n.languages.tt2.string, n.hooks.add("before-tokenize", function(a) {
        var s = /\[%[\s\S]+?%\]/g;
        n.languages["markup-templating"].buildPlaceholders(
          a,
          "tt2",
          s
        );
      }), n.hooks.add("after-tokenize", function(a) {
        n.languages["markup-templating"].tokenizePlaceholders(a, "tt2");
      });
    }(r);
  }
  return yA;
}
var vA, x7;
function oPe() {
  if (x7) return vA;
  x7 = 1;
  var e = Ia();
  vA = t, t.displayName = "twig", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.twig = {
      comment: /^\{#[\s\S]*?#\}$/,
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: !0,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        }
      },
      keyword: /\b(?:even|if|odd)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [
        {
          pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
          lookbehind: !0
        },
        /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
      ],
      punctuation: /[()\[\]{}:.,]/
    }, r.hooks.add("before-tokenize", function(n) {
      if (n.language === "twig") {
        var a = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
        r.languages["markup-templating"].buildPlaceholders(n, "twig", a);
      }
    }), r.hooks.add("after-tokenize", function(n) {
      r.languages["markup-templating"].tokenizePlaceholders(n, "twig");
    });
  }
  return vA;
}
var wA, E7;
function lPe() {
  if (E7) return wA;
  E7 = 1, wA = e, e.displayName = "typoscript", e.aliases = ["tsconfig"];
  function e(t) {
    (function(r) {
      var n = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
      r.languages.typoscript = {
        comment: [
          {
            // multiline comments /* */
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: !0
          },
          {
            // double-slash comments - ignored when backslashes or colon is found in front
            // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
            pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // hash comments - ignored when leading quote is found for hex colors in strings
            pattern: /(^|[^"'])#.*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        function: [
          {
            // old include style
            pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
            inside: {
              string: {
                pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
                inside: {
                  keyword: n
                }
              },
              keyword: {
                pattern: /INCLUDE_TYPOSCRIPT/
              }
            }
          },
          {
            // new include style
            pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
            inside: {
              string: /"[^"\r\n]*"|'[^'\r\n]*'/
            }
          }
        ],
        string: {
          pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
          lookbehind: !0,
          inside: {
            function: /\{\$.*\}/,
            // constants include
            keyword: n,
            number: /^\d+$/,
            punctuation: /[,|:]/
          }
        },
        keyword: n,
        number: {
          // special highlighting for indexes of arrays in tags
          pattern: /\b\d+\s*[.{=]/,
          inside: {
            operator: /[.{=]/
          }
        },
        tag: {
          pattern: /\.?[-\w\\]+\.?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /[{}[\];(),.:|]/,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
      }, r.languages.tsconfig = r.languages.typoscript;
    })(t);
  }
  return wA;
}
var xA, S7;
function uPe() {
  if (S7) return xA;
  S7 = 1, xA = e, e.displayName = "unrealscript", e.aliases = ["uc", "uscript"];
  function e(t) {
    t.languages.unrealscript = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      category: {
        pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      metadata: {
        pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          property: /\b\w+(?=\s*=)/,
          operator: /=/,
          punctuation: /[<>|]/
        }
      },
      macro: {
        pattern: /`\w+/,
        alias: "property"
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
      operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
      punctuation: /[()[\]{};,.]/
    }, t.languages.uc = t.languages.uscript = t.languages.unrealscript;
  }
  return xA;
}
var EA, _7;
function cPe() {
  if (_7) return EA;
  _7 = 1, EA = e, e.displayName = "uorazor", e.aliases = [];
  function e(t) {
    t.languages.uorazor = {
      "comment-hash": {
        pattern: /#.*/,
        alias: "comment",
        greedy: !0
      },
      "comment-slash": {
        pattern: /\/\/.*/,
        alias: "comment",
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        },
        greedy: !0
      },
      "source-layers": {
        pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
        alias: "function"
      },
      "source-commands": {
        pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
        alias: "function"
      },
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: !0,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
      keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [
        {
          pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
          lookbehind: !0
        },
        /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
      ],
      punctuation: /[()\[\]{}:.,]/
    };
  }
  return EA;
}
var SA, k7;
function dPe() {
  if (k7) return SA;
  k7 = 1, SA = e, e.displayName = "uri", e.aliases = ["url"];
  function e(t) {
    t.languages.uri = {
      scheme: {
        pattern: /^[a-z][a-z0-9+.-]*:/im,
        greedy: !0,
        inside: {
          "scheme-delimiter": /:$/
        }
      },
      fragment: {
        pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "fragment-delimiter": /^#/
        }
      },
      query: {
        pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "query-delimiter": {
            pattern: /^\?/,
            greedy: !0
          },
          "pair-delimiter": /[&;]/,
          pair: {
            pattern: /^[^=][\s\S]*/,
            inside: {
              key: /^[^=]+/,
              value: {
                pattern: /(^=)[\s\S]+/,
                lookbehind: !0
              }
            }
          }
        }
      },
      authority: {
        pattern: RegExp(
          /^\/\//.source + // [ userinfo "@" ]
          /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
          ("(?:" + // IP-literal
          /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
          /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
          /(?::\d*)?/.source,
          "m"
        ),
        inside: {
          "authority-delimiter": /^\/\//,
          "user-info-segment": {
            pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
            inside: {
              "user-info-delimiter": /@$/,
              "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
            }
          },
          "port-segment": {
            pattern: /:\d*$/,
            inside: {
              "port-delimiter": /^:/,
              port: /^\d+/
            }
          },
          host: {
            pattern: /[\s\S]+/,
            inside: {
              "ip-literal": {
                pattern: /^\[[\s\S]+\]$/,
                inside: {
                  "ip-literal-delimiter": /^\[|\]$/,
                  "ipv-future": /^v[\s\S]+/,
                  "ipv6-address": /^[\s\S]+/
                }
              },
              "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
            }
          }
        }
      },
      path: {
        pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
        inside: {
          "path-separator": /\//
        }
      }
    }, t.languages.url = t.languages.uri;
  }
  return SA;
}
var _A, C7;
function fPe() {
  if (C7) return _A;
  C7 = 1, _A = e, e.displayName = "v", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = {
        pattern: /[\s\S]+/,
        inside: null
      };
      r.languages.v = r.languages.extend("clike", {
        string: {
          pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          alias: "quoted-string",
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
              lookbehind: !0,
              inside: {
                "interpolation-variable": {
                  pattern: /^\$\w[\s\S]*$/,
                  alias: "variable"
                },
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                "interpolation-expression": n
              }
            }
          }
        },
        "class-name": {
          pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
          lookbehind: !0
        },
        keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
        number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
        operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
        builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
      }), n.inside = r.languages.v, r.languages.insertBefore("v", "string", {
        char: {
          pattern: /`(?:\\`|\\?[^`]{1,2})`/,
          // using {1,2} instead of `u` flag for compatibility
          alias: "rune"
        }
      }), r.languages.insertBefore("v", "operator", {
        attribute: {
          pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
          lookbehind: !0,
          alias: "annotation",
          inside: {
            punctuation: /[\[\]]/,
            keyword: /\w+/
          }
        },
        generic: {
          pattern: /<\w+>(?=\s*[\)\{])/,
          inside: {
            punctuation: /[<>]/,
            "class-name": /\w+/
          }
        }
      }), r.languages.insertBefore("v", "function", {
        "generic-function": {
          // e.g. foo<T>( ...
          pattern: /\b\w+\s*<\w+>(?=\()/,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<\w+>/,
              inside: r.languages.v.generic.inside
            }
          }
        }
      });
    })(t);
  }
  return _A;
}
var kA, A7;
function pPe() {
  if (A7) return kA;
  A7 = 1, kA = e, e.displayName = "vala", e.aliases = [];
  function e(t) {
    t.languages.vala = t.languages.extend("clike", {
      // Classes copied from prism-csharp
      "class-name": [
        {
          // (Foo bar, Bar baz)
          pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
          inside: {
            punctuation: /\./
          }
        },
        {
          // [Foo]
          pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        {
          // class Foo : Bar
          pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        {
          // class Foo
          pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      ],
      keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
      function: /\b\w+(?=\s*\()/,
      number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
      punctuation: /[{}[\];(),.:]/,
      constant: /\b[A-Z0-9_]+\b/
    }), t.languages.insertBefore("vala", "string", {
      "raw-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      "template-string": {
        pattern: /@"[\s\S]*?"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
            inside: {
              delimiter: {
                pattern: /^\$\(?|\)$/,
                alias: "punctuation"
              },
              rest: t.languages.vala
            }
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("vala", "keyword", {
      regex: {
        pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^\//,
          "regex-flags": /^[a-z]+$/
        }
      }
    });
  }
  return kA;
}
var CA, T7;
function hPe() {
  if (T7) return CA;
  T7 = 1, CA = e, e.displayName = "velocity", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.velocity = r.languages.extend("markup", {});
      var n = {
        variable: {
          pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
          lookbehind: !0,
          inside: {}
          // See below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        number: /\b\d+\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
        punctuation: /[(){}[\]:,.]/
      };
      n.variable.inside = {
        string: n.string,
        function: {
          pattern: /([^\w-])[a-z][\w-]*(?=\()/,
          lookbehind: !0
        },
        number: n.number,
        boolean: n.boolean,
        punctuation: n.punctuation
      }, r.languages.insertBefore("velocity", "comment", {
        unparsed: {
          pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            punctuation: /^#\[\[|\]\]#$/
          }
        },
        "velocity-comment": [
          {
            pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
            lookbehind: !0,
            greedy: !0,
            alias: "comment"
          },
          {
            pattern: /(^|[^\\])##.*/,
            lookbehind: !0,
            greedy: !0,
            alias: "comment"
          }
        ],
        directive: {
          pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
          lookbehind: !0,
          inside: {
            keyword: {
              pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
              inside: {
                punctuation: /[{}]/
              }
            },
            rest: n
          }
        },
        variable: n.variable
      }), r.languages.velocity.tag.inside["attr-value"].inside.rest = r.languages.velocity;
    })(t);
  }
  return CA;
}
var AA, R7;
function mPe() {
  if (R7) return AA;
  R7 = 1, AA = e, e.displayName = "verilog", e.aliases = [];
  function e(t) {
    t.languages.verilog = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      "kernel-function": {
        // support for any kernel function (ex: $display())
        pattern: /\B\$\w+\b/,
        alias: "property"
      },
      // support for user defined constants (ex: `define)
      constant: /\B`\w+\b/,
      function: /\b\w+(?=\()/,
      // support for verilog and system verilog keywords
      keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
      // bold highlighting for all verilog and system verilog logic blocks
      important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
      // support for time ticks, vectors, and real numbers
      number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
      operator: /[-+{}^~%*\/?=!<>&|]+/,
      punctuation: /[[\];(),.:]/
    };
  }
  return AA;
}
var TA, I7;
function gPe() {
  if (I7) return TA;
  I7 = 1, TA = e, e.displayName = "vhdl", e.aliases = [];
  function e(t) {
    t.languages.vhdl = {
      comment: /--.+/,
      // support for all logic vectors
      "vhdl-vectors": {
        pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
        alias: "number"
      },
      // support for operator overloading included
      "quoted-function": {
        pattern: /"\S+?"(?=\()/,
        alias: "function"
      },
      string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
      constant: /\b(?:library|use)\b/i,
      // support for predefined attributes included
      keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\w+(?=\()/,
      // decimal, based, physical, and exponential numbers supported
      number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
      operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return TA;
}
var RA, N7;
function bPe() {
  if (N7) return RA;
  N7 = 1, RA = e, e.displayName = "vim", e.aliases = [];
  function e(t) {
    t.languages.vim = {
      string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
      comment: /".*/,
      function: /\b\w+(?=\()/,
      keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
      builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
      punctuation: /[{}[\](),;:]/
    };
  }
  return RA;
}
var IA, D7;
function yPe() {
  if (D7) return IA;
  D7 = 1, IA = e, e.displayName = "visualBasic", e.aliases = [];
  function e(t) {
    t.languages["visual-basic"] = {
      comment: {
        pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
        inside: {
          keyword: /^REM/i
        }
      },
      directive: {
        pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
        alias: "property",
        greedy: !0
      },
      string: {
        pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
        greedy: !0
      },
      date: {
        pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
        alias: "number"
      },
      number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
      boolean: /\b(?:False|Nothing|True)\b/i,
      keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
      operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
      punctuation: /[{}().,:?]/
    }, t.languages.vb = t.languages["visual-basic"], t.languages.vba = t.languages["visual-basic"];
  }
  return IA;
}
var NA, O7;
function vPe() {
  if (O7) return NA;
  O7 = 1, NA = e, e.displayName = "warpscript", e.aliases = [];
  function e(t) {
    t.languages.warpscript = {
      comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
        greedy: !0
      },
      variable: /\$\S+/,
      macro: {
        pattern: /@\S+/,
        alias: "property"
      },
      // WarpScript doesn't have any keywords, these are all functions under the control category
      // https://www.warp10.io/tags/control
      keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
      number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
      boolean: /\b(?:F|T|false|true)\b/,
      punctuation: /<%|%>|[{}[\]()]/,
      // Some operators from the "operators" category
      // https://www.warp10.io/tags/operators
      operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
    };
  }
  return NA;
}
var DA, P7;
function wPe() {
  if (P7) return DA;
  P7 = 1, DA = e, e.displayName = "wasm", e.aliases = [];
  function e(t) {
    t.languages.wasm = {
      comment: [
        /\(;[\s\S]*?;\)/,
        {
          pattern: /;;.*/,
          greedy: !0
        }
      ],
      string: {
        pattern: /"(?:\\[\s\S]|[^"\\])*"/,
        greedy: !0
      },
      keyword: [
        {
          pattern: /\b(?:align|offset)=/,
          inside: {
            operator: /=/
          }
        },
        {
          pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
          inside: {
            punctuation: /\./
          }
        },
        /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
      ],
      variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
      number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
      punctuation: /[()]/
    };
  }
  return DA;
}
var OA, L7;
function xPe() {
  if (L7) return OA;
  L7 = 1, OA = e, e.displayName = "webIdl", e.aliases = [];
  function e(t) {
    (function(r) {
      var n = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source, a = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + n + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source, s = {};
      r.languages["web-idl"] = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: !0
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        namespace: {
          pattern: RegExp(/(\bnamespace\s+)/.source + n),
          lookbehind: !0
        },
        "class-name": [
          {
            pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
            lookbehind: !0,
            inside: s
          },
          {
            pattern: RegExp(
              /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + a
            ),
            lookbehind: !0,
            inside: s
          },
          {
            // callback return type
            pattern: RegExp(
              "(" + /\bcallback\s+/.source + n + /\s*=\s*/.source + ")" + a
            ),
            lookbehind: !0,
            inside: s
          },
          {
            // typedef
            pattern: RegExp(/(\btypedef\b\s*)/.source + a),
            lookbehind: !0,
            inside: s
          },
          {
            pattern: RegExp(
              /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + n
            ),
            lookbehind: !0
          },
          {
            // inheritance
            pattern: RegExp(/(:\s*)/.source + n),
            lookbehind: !0
          },
          // includes and implements
          RegExp(n + /(?=\s+(?:implements|includes)\b)/.source),
          {
            pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + n),
            lookbehind: !0
          },
          {
            // function return type, parameter types, and dictionary members
            pattern: RegExp(
              a + "(?=" + /\s*(?:\.{3}\s*)?/.source + n + /\s*[(),;=]/.source + ")"
            ),
            inside: s
          }
        ],
        builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
        keyword: [
          /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
          // type keywords
          /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
        ],
        boolean: /\b(?:false|true)\b/,
        number: {
          pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
          lookbehind: !0
        },
        operator: /\.{3}|[=:?<>-]/,
        punctuation: /[(){}[\].,;]/
      };
      for (var i in r.languages["web-idl"])
        i !== "class-name" && (s[i] = r.languages["web-idl"][i]);
      r.languages.webidl = r.languages["web-idl"];
    })(t);
  }
  return OA;
}
var PA, M7;
function EPe() {
  if (M7) return PA;
  M7 = 1, PA = e, e.displayName = "wiki", e.aliases = [];
  function e(t) {
    t.languages.wiki = t.languages.extend("markup", {
      "block-comment": {
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        alias: "comment"
      },
      heading: {
        pattern: /^(=+)[^=\r\n].*?\1/m,
        inside: {
          punctuation: /^=+|=+$/,
          important: /.+/
        }
      },
      emphasis: {
        // TODO Multi-line
        pattern: /('{2,5}).+?\1/,
        inside: {
          "bold-italic": {
            pattern: /(''''').+?(?=\1)/,
            lookbehind: !0,
            alias: ["bold", "italic"]
          },
          bold: {
            pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: !0
          },
          italic: {
            pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: !0
          },
          punctuation: /^''+|''+$/
        }
      },
      hr: {
        pattern: /^-{4,}/m,
        alias: "punctuation"
      },
      url: [
        /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
        /\[\[.+?\]\]|\[.+?\]/
      ],
      variable: [
        /__[A-Z]+__/,
        // FIXME Nested structures should be handled
        // {{formatnum:{{#expr:{{{3}}}}}}}
        /\{{3}.+?\}{3}/,
        /\{\{.+?\}\}/
      ],
      symbol: [/^#redirect/im, /~{3,5}/],
      // Handle table attrs:
      // {|
      // ! style="text-align:left;"| Item
      // |}
      "table-tag": {
        pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
        lookbehind: !0,
        inside: {
          "table-bar": {
            pattern: /\|$/,
            alias: "punctuation"
          },
          rest: t.languages.markup.tag.inside
        }
      },
      punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
    }), t.languages.insertBefore("wiki", "tag", {
      // Prevent highlighting inside <nowiki>, <source> and <pre> tags
      nowiki: {
        pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
        inside: {
          tag: {
            pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
            inside: t.languages.markup.tag.inside
          }
        }
      }
    });
  }
  return PA;
}
var LA, F7;
function SPe() {
  if (F7) return LA;
  F7 = 1, LA = e, e.displayName = "wolfram", e.aliases = ["mathematica", "wl", "nb"];
  function e(t) {
    t.languages.wolfram = {
      // Allow one level of nesting - note: regex taken from applescipt
      comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: !0
      },
      keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
      context: {
        pattern: /\b\w+`+\w*/,
        alias: "class-name"
      },
      blank: {
        pattern: /\b\w+_\b/,
        alias: "regex"
      },
      "global-variable": {
        pattern: /\$\w+/,
        alias: "variable"
      },
      boolean: /\b(?:False|True)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
      operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.mathematica = t.languages.wolfram, t.languages.wl = t.languages.wolfram, t.languages.nb = t.languages.wolfram;
  }
  return LA;
}
var MA, $7;
function _Pe() {
  if ($7) return MA;
  $7 = 1, MA = e, e.displayName = "wren", e.aliases = [];
  function e(t) {
    t.languages.wren = {
      // Multiline comments in Wren can have nested multiline comments
      // Comments: // and /* */
      comment: [
        {
          // support 3 levels of nesting
          // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
          pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // Triple quoted strings are multiline but cannot have interpolation (raw strings)
      // Based on prism-python.js
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      // see below
      "string-literal": null,
      // #!/usr/bin/env wren on the first line
      hashbang: {
        pattern: /^#!\/.+/,
        greedy: !0,
        alias: "comment"
      },
      // Attributes are special keywords to add meta data to classes
      attribute: {
        // #! attributes are stored in class properties
        // #!myvar = true
        // #attributes are not stored and dismissed at compilation
        pattern: /#!?[ \t\u3000]*\w+/,
        alias: "keyword"
      },
      "class-name": [
        {
          // class definition
          // class Meta {}
          pattern: /(\bclass\s+)\w+/,
          lookbehind: !0
        },
        // A class must always start with an uppercase.
        // File.read
        /\b[A-Z][a-z\d_]*\b/
      ],
      // A constant can be a variable, class, property or method. Just named in all uppercase letters
      constant: /\b[A-Z][A-Z\d_]*\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      // Functions can be Class.method()
      function: /\b[a-z_]\w*(?=\s*[({])/i,
      operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
      punctuation: /[\[\](){}.,;]/
    }, t.languages.wren["string-literal"] = {
      // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
      pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          // "%(interpolation)"
          pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
          lookbehind: !0,
          inside: {
            expression: {
              pattern: /^(%\()[\s\S]+(?=\)$)/,
              lookbehind: !0,
              inside: t.languages.wren
            },
            "interpolation-punctuation": {
              pattern: /^%\(|\)$/,
              alias: "punctuation"
            }
          }
        },
        string: /[\s\S]+/
      }
    };
  }
  return MA;
}
var FA, B7;
function kPe() {
  if (B7) return FA;
  B7 = 1, FA = e, e.displayName = "xeora", e.aliases = ["xeoracube"];
  function e(t) {
    (function(r) {
      r.languages.xeora = r.languages.extend("markup", {
        constant: {
          pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
          inside: {
            punctuation: {
              pattern: /\$/
            }
          }
        },
        variable: {
          pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[$.]/
            },
            operator: {
              pattern: /#+|[-+*~=^@]/
            }
          }
        },
        "function-inline": {
          pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
          inside: {
            variable: {
              pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
              inside: {
                punctuation: {
                  pattern: /[,.|]/
                },
                operator: {
                  pattern: /#+|[-+*~=^@]/
                }
              }
            },
            punctuation: {
              pattern: /\$\w:|[$:?.,|]/
            }
          },
          alias: "function"
        },
        "function-block": {
          pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
          inside: {
            punctuation: {
              pattern: /[$:{}?.,|]/
            }
          },
          alias: "function"
        },
        "directive-inline": {
          pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            }
          },
          alias: "function"
        },
        "directive-block-open": {
          pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            },
            attribute: {
              pattern: /![A-Z]+$/,
              inside: {
                punctuation: {
                  pattern: /!/
                }
              },
              alias: "keyword"
            }
          },
          alias: "function"
        },
        "directive-block-separator": {
          pattern: /\}:[-\w.]+:\{/,
          inside: {
            punctuation: {
              pattern: /[:{}]/
            }
          },
          alias: "function"
        },
        "directive-block-close": {
          pattern: /\}:[-\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[:{}$]/
            }
          },
          alias: "function"
        }
      }), r.languages.insertBefore(
        "inside",
        "punctuation",
        {
          variable: r.languages.xeora["function-inline"].inside.variable
        },
        r.languages.xeora["function-block"]
      ), r.languages.xeoracube = r.languages.xeora;
    })(t);
  }
  return FA;
}
var $A, U7;
function CPe() {
  if (U7) return $A;
  U7 = 1, $A = e, e.displayName = "xmlDoc", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(o, l) {
        r.languages[o] && r.languages.insertBefore(o, "comment", {
          "doc-comment": l
        });
      }
      var a = r.languages.markup.tag, s = {
        pattern: /\/\/\/.*/,
        greedy: !0,
        alias: "comment",
        inside: {
          tag: a
        }
      }, i = {
        pattern: /'''.*/,
        greedy: !0,
        alias: "comment",
        inside: {
          tag: a
        }
      };
      n("csharp", s), n("fsharp", s), n("vbnet", i);
    })(t);
  }
  return $A;
}
var BA, z7;
function APe() {
  if (z7) return BA;
  z7 = 1, BA = e, e.displayName = "xojo", e.aliases = [];
  function e(t) {
    t.languages.xojo = {
      comment: {
        pattern: /(?:'|\/\/|Rem\b).+/i,
        greedy: !0
      },
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
      directive: {
        pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
        alias: "property"
      },
      keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
      operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
      punctuation: /[.,;:()]/
    };
  }
  return BA;
}
var UA, q7;
function TPe() {
  if (q7) return UA;
  q7 = 1, UA = e, e.displayName = "xquery", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.xquery = r.languages.extend("markup", {
        "xquery-comment": {
          pattern: /\(:[\s\S]*?:\)/,
          greedy: !0,
          alias: "comment"
        },
        string: {
          pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
          greedy: !0
        },
        extension: {
          pattern: /\(#.+?#\)/,
          alias: "symbol"
        },
        variable: /\$[-\w:]+/,
        axis: {
          pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
          lookbehind: !0,
          alias: "operator"
        },
        "keyword-operator": {
          pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
          lookbehind: !0,
          alias: "operator"
        },
        keyword: {
          pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
          lookbehind: !0
        },
        function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
        "xquery-element": {
          pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: !0,
          alias: "tag"
        },
        "xquery-attribute": {
          pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: !0,
          alias: "attr-name"
        },
        builtin: {
          pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
          lookbehind: !0
        },
        number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
        operator: [
          /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
          {
            pattern: /(\s)-(?=\s)/,
            lookbehind: !0
          }
        ],
        punctuation: /[[\](){},;:/]/
      }), r.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, r.languages.xquery.tag.inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/, r.languages.xquery.tag.inside["attr-value"].inside.punctuation = /^="|"$/, r.languages.xquery.tag.inside["attr-value"].inside.expression = {
        // Allow for two levels of nesting
        pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
        inside: r.languages.xquery,
        alias: "language-xquery"
      };
      var n = function(s) {
        return typeof s == "string" ? s : typeof s.content == "string" ? s.content : s.content.map(n).join("");
      }, a = function(s) {
        for (var i = [], o = 0; o < s.length; o++) {
          var l = s[o], u = !1;
          if (typeof l != "string" && (l.type === "tag" && l.content[0] && l.content[0].type === "tag" ? l.content[0].content[0].content === "</" ? i.length > 0 && i[i.length - 1].tagName === n(l.content[0].content[1]) && i.pop() : l.content[l.content.length - 1].content === "/>" || i.push({
            tagName: n(l.content[0].content[1]),
            openedBraces: 0
          }) : i.length > 0 && l.type === "punctuation" && l.content === "{" && // Ignore `{{`
          (!s[o + 1] || s[o + 1].type !== "punctuation" || s[o + 1].content !== "{") && (!s[o - 1] || s[o - 1].type !== "plain-text" || s[o - 1].content !== "{") ? i[i.length - 1].openedBraces++ : i.length > 0 && i[i.length - 1].openedBraces > 0 && l.type === "punctuation" && l.content === "}" ? i[i.length - 1].openedBraces-- : l.type !== "comment" && (u = !0)), (u || typeof l == "string") && i.length > 0 && i[i.length - 1].openedBraces === 0) {
            var c = n(l);
            o < s.length - 1 && (typeof s[o + 1] == "string" || s[o + 1].type === "plain-text") && (c += n(s[o + 1]), s.splice(o + 1, 1)), o > 0 && (typeof s[o - 1] == "string" || s[o - 1].type === "plain-text") && (c = n(s[o - 1]) + c, s.splice(o - 1, 1), o--), /^\s+$/.test(c) ? s[o] = c : s[o] = new r.Token(
              "plain-text",
              c,
              null,
              c
            );
          }
          l.content && typeof l.content != "string" && a(l.content);
        }
      };
      r.hooks.add("after-tokenize", function(s) {
        s.language === "xquery" && a(s.tokens);
      });
    })(t);
  }
  return UA;
}
var zA, j7;
function RPe() {
  if (j7) return zA;
  j7 = 1, zA = e, e.displayName = "yang", e.aliases = [];
  function e(t) {
    t.languages.yang = {
      // https://tools.ietf.org/html/rfc6020#page-34
      // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
        greedy: !0
      },
      keyword: {
        pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
        lookbehind: !0
      },
      namespace: {
        pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
        lookbehind: !0
      },
      boolean: /\b(?:false|true)\b/,
      operator: /\+/,
      punctuation: /[{};:]/
    };
  }
  return zA;
}
var qA, H7;
function IPe() {
  if (H7) return qA;
  H7 = 1, qA = e, e.displayName = "zig", e.aliases = [];
  function e(t) {
    (function(r) {
      function n(c) {
        return function() {
          return c;
        };
      }
      var a = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/, s = "\\b(?!" + a.source + ")(?!\\d)\\w+\\b", i = /align\s*\((?:[^()]|\([^()]*\))*\)/.source, o = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
        /<ALIGN>/g,
        n(i)
      ), l = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
        /<ID>/g,
        n(s)
      ), u = "(?!\\s)(?:!?\\s*(?:" + o + "\\s*)*" + l + ")+";
      r.languages.zig = {
        comment: [
          {
            pattern: /\/\/[/!].*/,
            alias: "doc-comment"
          },
          /\/{2}.*/
        ],
        string: [
          {
            // "string" and c"string"
            pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // multiline strings and c-strings
            pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
            lookbehind: !0,
            greedy: !0
          }
        ],
        char: {
          // characters 'a', '\n', '\xFF', '\u{10FFFF}'
          pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
          lookbehind: !0,
          greedy: !0
        },
        builtin: /\B@(?!\d)\w+(?=\s*\()/,
        label: {
          pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
          lookbehind: !0
        },
        "class-name": [
          // const Foo = struct {};
          /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
          {
            // const x: i32 = 9;
            // var x: Bar;
            // fn foo(x: bool, y: f32) void {}
            pattern: RegExp(
              /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, n(u)).replace(/<ALIGN>/g, n(i))
            ),
            lookbehind: !0,
            inside: null
            // see below
          },
          {
            // extern fn foo(x: f64) f64; (optional alignment)
            pattern: RegExp(
              /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, n(u)).replace(/<ALIGN>/g, n(i))
            ),
            lookbehind: !0,
            inside: null
            // see below
          }
        ],
        "builtin-type": {
          pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
          alias: "keyword"
        },
        keyword: a,
        function: /\b(?!\d)\w+(?=\s*\()/,
        number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
        punctuation: /[.:,;(){}[\]]/
      }, r.languages.zig["class-name"].forEach(function(c) {
        c.inside === null && (c.inside = r.languages.zig);
      });
    })(t);
  }
  return qA;
}
var jA, V7;
function NPe() {
  if (V7) return jA;
  V7 = 1;
  var e = WDe();
  return jA = e, e.register(YDe()), e.register(XDe()), e.register(ZDe()), e.register(JDe()), e.register(QDe()), e.register(e2e()), e.register(t2e()), e.register(r2e()), e.register(n2e()), e.register(i2e()), e.register(a2e()), e.register(s2e()), e.register(o2e()), e.register(l2e()), e.register(u2e()), e.register(c2e()), e.register(d2e()), e.register(f2e()), e.register(p2e()), e.register(h2e()), e.register(m2e()), e.register(g2e()), e.register(DW()), e.register(OW()), e.register(b2e()), e.register(y2e()), e.register(v2e()), e.register(w2e()), e.register(x2e()), e.register(E2e()), e.register(S2e()), e.register(_2e()), e.register(k2e()), e.register(C2e()), e.register(Wu()), e.register(A2e()), e.register(T2e()), e.register(R2e()), e.register(I2e()), e.register(N2e()), e.register(D2e()), e.register(O2e()), e.register(P2e()), e.register(L2e()), e.register(dD()), e.register(M2e()), e.register(yy()), e.register(F2e()), e.register($2e()), e.register(B2e()), e.register(U2e()), e.register(z2e()), e.register(q2e()), e.register(j2e()), e.register(H2e()), e.register(V2e()), e.register(G2e()), e.register(W2e()), e.register(K2e()), e.register(Y2e()), e.register(X2e()), e.register(Z2e()), e.register(J2e()), e.register(Q2e()), e.register(eOe()), e.register(tOe()), e.register(rOe()), e.register(nOe()), e.register(iOe()), e.register(aOe()), e.register(sOe()), e.register(oOe()), e.register(lOe()), e.register(uOe()), e.register(cOe()), e.register(dOe()), e.register(fOe()), e.register(pOe()), e.register(hOe()), e.register(mOe()), e.register(gOe()), e.register(bOe()), e.register(yOe()), e.register(vOe()), e.register(wOe()), e.register(xOe()), e.register(EOe()), e.register(SOe()), e.register(_Oe()), e.register(kOe()), e.register(COe()), e.register(AOe()), e.register(TOe()), e.register(ROe()), e.register(fD()), e.register(IOe()), e.register(NOe()), e.register(DOe()), e.register(OOe()), e.register(POe()), e.register(LOe()), e.register(MOe()), e.register(FOe()), e.register($Oe()), e.register(BOe()), e.register(UOe()), e.register(zOe()), e.register(qOe()), e.register(jOe()), e.register(HOe()), e.register(VOe()), e.register(GOe()), e.register(pD()), e.register(WOe()), e.register(wy()), e.register(KOe()), e.register(YOe()), e.register(XOe()), e.register(ZOe()), e.register(JOe()), e.register(QOe()), e.register(e4e()), e.register(mD()), e.register(t4e()), e.register(r4e()), e.register(n4e()), e.register(LW()), e.register(i4e()), e.register(a4e()), e.register(s4e()), e.register(o4e()), e.register(l4e()), e.register(u4e()), e.register(c4e()), e.register(d4e()), e.register(f4e()), e.register(p4e()), e.register(h4e()), e.register(m4e()), e.register(g4e()), e.register(b4e()), e.register(y4e()), e.register(v4e()), e.register(PW()), e.register(w4e()), e.register(x4e()), e.register(E4e()), e.register(Ia()), e.register(S4e()), e.register(_4e()), e.register(k4e()), e.register(C4e()), e.register(A4e()), e.register(T4e()), e.register(R4e()), e.register(I4e()), e.register(N4e()), e.register(D4e()), e.register(O4e()), e.register(P4e()), e.register(L4e()), e.register(M4e()), e.register(F4e()), e.register($4e()), e.register(B4e()), e.register(U4e()), e.register(z4e()), e.register(q4e()), e.register(j4e()), e.register(H4e()), e.register(V4e()), e.register(G4e()), e.register(W4e()), e.register(K4e()), e.register(Y4e()), e.register(X4e()), e.register(Z4e()), e.register(J4e()), e.register(Q4e()), e.register(e3e()), e.register(xy()), e.register(t3e()), e.register(r3e()), e.register(n3e()), e.register(i3e()), e.register(a3e()), e.register(s3e()), e.register(o3e()), e.register(l3e()), e.register(u3e()), e.register(c3e()), e.register(d3e()), e.register(f3e()), e.register(p3e()), e.register(h3e()), e.register(m3e()), e.register(g3e()), e.register(b3e()), e.register(y3e()), e.register(v3e()), e.register(w3e()), e.register(x3e()), e.register(E3e()), e.register(S3e()), e.register(_3e()), e.register(k3e()), e.register(C3e()), e.register(A3e()), e.register(T3e()), e.register(R3e()), e.register(I3e()), e.register(vy()), e.register(N3e()), e.register(D3e()), e.register(O3e()), e.register(P3e()), e.register(gD()), e.register(L3e()), e.register(M3e()), e.register(F3e()), e.register($3e()), e.register(B3e()), e.register(U3e()), e.register(z3e()), e.register(q3e()), e.register(j3e()), e.register(H3e()), e.register(V3e()), e.register(G3e()), e.register(cD()), e.register(W3e()), e.register(K3e()), e.register(Y3e()), e.register(X3e()), e.register(Z3e()), e.register(J3e()), e.register(bD()), e.register(Q3e()), e.register(ePe()), e.register(tPe()), e.register(rPe()), e.register(nPe()), e.register(iPe()), e.register(aPe()), e.register(sPe()), e.register(MW()), e.register(oPe()), e.register(hD()), e.register(lPe()), e.register(uPe()), e.register(cPe()), e.register(dPe()), e.register(fPe()), e.register(pPe()), e.register(FW()), e.register(hPe()), e.register(mPe()), e.register(gPe()), e.register(bPe()), e.register(yPe()), e.register(vPe()), e.register(wPe()), e.register(xPe()), e.register(EPe()), e.register(SPe()), e.register(_Pe()), e.register(kPe()), e.register(CPe()), e.register(APe()), e.register(TPe()), e.register($W()), e.register(RPe()), e.register(IPe()), jA;
}
var DPe = NPe();
const OPe = /* @__PURE__ */ da(DPe);
var BW = vIe(OPe, KDe);
BW.supportedLanguages = wIe;
const PPe = {
  'code[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  'code[class*="language-"]::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"]::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: "0.2em 0.3em",
    borderRadius: "0.3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(230, 4%, 64%)"
  },
  cdata: {
    color: "hsl(230, 4%, 64%)"
  },
  doctype: {
    color: "hsl(230, 8%, 24%)"
  },
  punctuation: {
    color: "hsl(230, 8%, 24%)"
  },
  entity: {
    color: "hsl(230, 8%, 24%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(35, 99%, 36%)"
  },
  "class-name": {
    color: "hsl(35, 99%, 36%)"
  },
  boolean: {
    color: "hsl(35, 99%, 36%)"
  },
  constant: {
    color: "hsl(35, 99%, 36%)"
  },
  number: {
    color: "hsl(35, 99%, 36%)"
  },
  atrule: {
    color: "hsl(35, 99%, 36%)"
  },
  keyword: {
    color: "hsl(301, 63%, 40%)"
  },
  property: {
    color: "hsl(5, 74%, 59%)"
  },
  tag: {
    color: "hsl(5, 74%, 59%)"
  },
  symbol: {
    color: "hsl(5, 74%, 59%)"
  },
  deleted: {
    color: "hsl(5, 74%, 59%)"
  },
  important: {
    color: "hsl(5, 74%, 59%)"
  },
  selector: {
    color: "hsl(119, 34%, 47%)"
  },
  string: {
    color: "hsl(119, 34%, 47%)"
  },
  char: {
    color: "hsl(119, 34%, 47%)"
  },
  builtin: {
    color: "hsl(119, 34%, 47%)"
  },
  inserted: {
    color: "hsl(119, 34%, 47%)"
  },
  regex: {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value": {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(119, 34%, 47%)"
  },
  variable: {
    color: "hsl(221, 87%, 60%)"
  },
  operator: {
    color: "hsl(221, 87%, 60%)"
  },
  function: {
    color: "hsl(221, 87%, 60%)"
  },
  url: {
    color: "hsl(198, 99%, 37%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(230, 8%, 24%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.selector": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-css .token.property": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.string.url": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-css .token.important": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-css .token.atrule .token.rule": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.operator": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    color: "hsl(344, 84%, 43%)"
  },
  ".language-json .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-json .token.null.keyword": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.url": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.content": {
    color: "hsl(221, 87%, 60%)"
  },
  ".language-markdown .token.url > .token.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.url-reference.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.code-snippet": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-markdown .token.bold .token.content": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.italic .token.content": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-markdown .token.strike .token.content": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.list.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    Opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.cr:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.lf:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.space:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    marginRight: "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  ".line-highlight.line-highlight": {
    background: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-highlight.line-highlight:before": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    backgroundColor: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".command-line .command-line-prompt": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".command-line .command-line-prompt > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    color: "hsl(301, 63%, 40%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    borderColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    borderColor: "hsl(0, 0, 95%)",
    borderRadius: "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    borderTopColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    borderBottomColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    stroke: "hsl(230, 8%, 24%)",
    fill: "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    stroke: "hsl(230, 8%, 24%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    stroke: "hsl(230, 8%, 24%)"
  }
};
var UW = D.forwardRef((e, t) => {
  const { children: r, ...n } = e, a = D.Children.toArray(r), s = a.find(MPe);
  if (s) {
    const i = s.props.children, o = a.map((l) => l === s ? D.Children.count(i) > 1 ? D.Children.only(null) : D.isValidElement(i) ? i.props.children : null : l);
    return /* @__PURE__ */ K(HR, { ...n, ref: t, children: D.isValidElement(i) ? D.cloneElement(i, void 0, o) : null });
  }
  return /* @__PURE__ */ K(HR, { ...n, ref: t, children: r });
});
UW.displayName = "Slot";
var HR = D.forwardRef((e, t) => {
  const { children: r, ...n } = e;
  if (D.isValidElement(r)) {
    const a = $Pe(r), s = FPe(n, r.props);
    return r.type !== D.Fragment && (s.ref = t ? ph(t, a) : a), D.cloneElement(r, s);
  }
  return D.Children.count(r) > 1 ? D.Children.only(null) : null;
});
HR.displayName = "SlotClone";
var LPe = ({ children: e }) => /* @__PURE__ */ K(ln, { children: e });
function MPe(e) {
  return D.isValidElement(e) && e.type === LPe;
}
function FPe(e, t) {
  const r = { ...t };
  for (const n in t) {
    const a = e[n], s = t[n];
    /^on[A-Z]/.test(n) ? a && s ? r[n] = (...o) => {
      s(...o), a(...o);
    } : a && (r[n] = a) : n === "style" ? r[n] = { ...a, ...s } : n === "className" && (r[n] = [a, s].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function $Pe(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
var BPe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], yD = BPe.reduce((e, t) => {
  const r = D.forwardRef((n, a) => {
    const { asChild: s, ...i } = n, o = s ? UW : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ K(o, { ...i, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), vD = "Collapsible", [UPe, Yze] = ds(vD), [zPe, wD] = UPe(vD), zW = D.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: r,
      open: n,
      defaultOpen: a,
      disabled: s,
      onOpenChange: i,
      ...o
    } = e, [l = !1, u] = Bs({
      prop: n,
      defaultProp: a,
      onChange: i
    });
    return /* @__PURE__ */ K(
      zPe,
      {
        scope: r,
        disabled: s,
        contentId: us(),
        open: l,
        onOpenToggle: D.useCallback(() => u((c) => !c), [u]),
        children: /* @__PURE__ */ K(
          yD.div,
          {
            "data-state": ED(l),
            "data-disabled": s ? "" : void 0,
            ...o,
            ref: t
          }
        )
      }
    );
  }
);
zW.displayName = vD;
var qW = "CollapsibleTrigger", jW = D.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: r, ...n } = e, a = wD(qW, r);
    return /* @__PURE__ */ K(
      yD.button,
      {
        type: "button",
        "aria-controls": a.contentId,
        "aria-expanded": a.open || !1,
        "data-state": ED(a.open),
        "data-disabled": a.disabled ? "" : void 0,
        disabled: a.disabled,
        ...n,
        ref: t,
        onClick: nr(e.onClick, a.onOpenToggle)
      }
    );
  }
);
jW.displayName = qW;
var xD = "CollapsibleContent", HW = D.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, a = wD(xD, e.__scopeCollapsible);
    return /* @__PURE__ */ K(Ra, { present: r || a.open, children: ({ present: s }) => /* @__PURE__ */ K(qPe, { ...n, ref: t, present: s }) });
  }
);
HW.displayName = xD;
var qPe = D.forwardRef((e, t) => {
  const { __scopeCollapsible: r, present: n, children: a, ...s } = e, i = wD(xD, r), [o, l] = D.useState(n), u = D.useRef(null), c = sn(t, u), d = D.useRef(0), p = d.current, f = D.useRef(0), h = f.current, m = i.open || o, y = D.useRef(m), b = D.useRef(void 0);
  return D.useEffect(() => {
    const v = requestAnimationFrame(() => y.current = !1);
    return () => cancelAnimationFrame(v);
  }, []), Ti(() => {
    const v = u.current;
    if (v) {
      b.current = b.current || {
        transitionDuration: v.style.transitionDuration,
        animationName: v.style.animationName
      }, v.style.transitionDuration = "0s", v.style.animationName = "none";
      const x = v.getBoundingClientRect();
      d.current = x.height, f.current = x.width, y.current || (v.style.transitionDuration = b.current.transitionDuration, v.style.animationName = b.current.animationName), l(n);
    }
  }, [i.open, n]), /* @__PURE__ */ K(
    yD.div,
    {
      "data-state": ED(i.open),
      "data-disabled": i.disabled ? "" : void 0,
      id: i.contentId,
      hidden: !m,
      ...s,
      ref: c,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": h ? `${h}px` : void 0,
        ...e.style
      },
      children: m && a
    }
  );
});
function ED(e) {
  return e ? "open" : "closed";
}
var jPe = zW;
const HPe = jPe, VPe = jW, GPe = HW, WPe = [
  "md",
  "markdown",
  "mdown",
  "mkdn",
  "mkd",
  "mdwn",
  "mkdown",
  "ron"
], KPe = WPe.map(function(e) {
  return "." + e;
});
function YPe(e, t) {
  const r = XPe(e) ? e : new vW(e), { format: n, ...a } = t;
  return {
    file: r,
    options: {
      format: n === "md" || n === "mdx" ? n : r.extname && (a.mdExtensions || KPe).includes(r.extname) ? "md" : "mdx",
      ...a
    }
  };
}
function XPe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
const ZPe = /[$_\p{ID_Start}]/u, JPe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, QPe = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, eLe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, tLe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, VW = {};
function Cs(e) {
  return e ? ZPe.test(String.fromCodePoint(e)) : !1;
}
function Ef(e, t) {
  const n = (t || VW).jsx ? QPe : JPe;
  return e ? n.test(String.fromCodePoint(e)) : !1;
}
function so(e, t) {
  return ((t || VW).jsx ? tLe : eLe).test(e);
}
let rLe = class {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (t) => this.replacement = t
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(t, r, n, a) {
    t && r && (n != null ? t[r][n] = a : t[r] = a);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(t, r, n) {
    t && r && (n != null ? t[r].splice(n, 1) : delete t[r]);
  }
}, nLe = class extends rLe {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(t, r) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (n) => this.replacement = n
    }, this.enter = t, this.leave = r;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(t, r, n, a) {
    if (t) {
      if (this.enter) {
        const i = this.should_skip, o = this.should_remove, l = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, r, n, a), this.replacement && (t = this.replacement, this.replace(r, n, a, t)), this.should_remove && this.remove(r, n, a);
        const u = this.should_skip, c = this.should_remove;
        if (this.should_skip = i, this.should_remove = o, this.replacement = l, u) return t;
        if (c) return null;
      }
      let s;
      for (s in t) {
        const i = t[s];
        if (i && typeof i == "object")
          if (Array.isArray(i)) {
            const o = (
              /** @type {Array<unknown>} */
              i
            );
            for (let l = 0; l < o.length; l += 1) {
              const u = o[l];
              G7(u) && (this.visit(u, t, s, l) || l--);
            }
          } else G7(i) && this.visit(i, t, s, null);
      }
      if (this.leave) {
        const i = this.replacement, o = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, r, n, a), this.replacement && (t = this.replacement, this.replace(r, n, a, t)), this.should_remove && this.remove(r, n, a);
        const l = this.should_remove;
        if (this.replacement = i, this.should_remove = o, l) return null;
      }
    }
    return t;
  }
};
function G7(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function iLe(e, { enter: t, leave: r }) {
  return new nLe(t, r).visit(e, null);
}
const HA = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;
function aLe(e, t) {
  const r = t;
  let n = r.runtime === "automatic";
  const a = {}, s = {};
  iLe(e, {
    enter(i) {
      if (i.type === "Program") {
        const o = i.comments || [];
        let l = -1;
        for (; ++l < o.length; ) {
          HA.lastIndex = 0;
          let u = HA.exec(o[l].value);
          for (; u; )
            a[u[1]] = u[2], u = HA.exec(o[l].value);
        }
        if (a.jsxRuntime)
          if (a.jsxRuntime === "automatic") {
            if (n = !0, a.jsx)
              throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");
            if (a.jsxFrag)
              throw new Error(
                "Unexpected `@jsxFrag` pragma w/ automatic runtime"
              );
          } else if (a.jsxRuntime === "classic") {
            if (n = !1, a.jsxImportSource)
              throw new Error(
                "Unexpected `@jsxImportSource` w/ classic runtime"
              );
          } else
            throw new Error(
              "Unexpected `jsxRuntime` `" + a.jsxRuntime + "`, expected `automatic` or `classic`"
            );
      }
    },
    // eslint-disable-next-line complexity
    leave(i) {
      if (i.type === "Program") {
        const m = [];
        if (s.fragment && m.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "Fragment" },
          local: { type: "Identifier", name: "_Fragment" }
        }), s.jsx && m.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsx" },
          local: { type: "Identifier", name: "_jsx" }
        }), s.jsxs && m.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxs" },
          local: { type: "Identifier", name: "_jsxs" }
        }), s.jsxDEV && m.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxDEV" },
          local: { type: "Identifier", name: "_jsxDEV" }
        }), m.length > 0) {
          let y = 0;
          for (; y < i.body.length; ) {
            const b = i.body[y];
            if ("directive" in b && b.directive)
              y++;
            else
              break;
          }
          i.body.splice(y, 0, {
            type: "ImportDeclaration",
            specifiers: m,
            source: {
              type: "Literal",
              value: (a.jsxImportSource || r.importSource || "react") + (r.development ? "/jsx-dev-runtime" : "/jsx-runtime")
            }
          });
        }
      }
      if (i.type !== "JSXElement" && i.type !== "JSXFragment")
        return;
      const o = [];
      let l = -1;
      for (; ++l < i.children.length; ) {
        const m = i.children[l];
        if (m.type === "JSXExpressionContainer")
          m.expression.type !== "JSXEmptyExpression" && o.push(m.expression);
        else if (m.type === "JSXText") {
          const y = m.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " ");
          if (y) {
            const b = { type: "Literal", value: y };
            rp(m, b), o.push(b);
          }
        } else
          m.type !== "JSXElement" && m.type !== "JSXFragment" && m.type, o.push(m);
      }
      let u;
      const c = [];
      let d = [], p;
      if (i.type === "JSXElement") {
        if (u = nb(i.openingElement.name), u.type === "Identifier" && /^[a-z]/.test(u.name)) {
          const v = { type: "Literal", value: u.name };
          rp(u, v), u = v;
        }
        let m;
        const y = i.openingElement.attributes;
        let b = -1;
        for (; ++b < y.length; ) {
          const v = y[b];
          if (v.type === "JSXSpreadAttribute")
            v.argument.type === "ObjectExpression" ? c.push(...v.argument.properties) : c.push({ type: "SpreadElement", argument: v.argument }), m = !0;
          else {
            const x = sLe(v);
            if (n && x.key.type === "Identifier" && x.key.name === "key") {
              if (m)
                throw new Error(
                  "Expected `key` to come before any spread expressions"
                );
              const _ = x.value;
              _.type !== "AssignmentPattern" && _.type !== "ArrayPattern" && _.type !== "ObjectPattern" && _.type, p = _;
            } else
              c.push(x);
          }
        }
      } else n ? (s.fragment = !0, u = { type: "Identifier", name: "_Fragment" }) : u = W7(
        a.jsxFrag || r.pragmaFrag || "React.Fragment"
      );
      n ? o.length > 0 && c.push({
        type: "Property",
        key: { type: "Identifier", name: "children" },
        value: o.length > 1 ? { type: "ArrayExpression", elements: o } : o[0],
        kind: "init",
        method: !1,
        shorthand: !1,
        computed: !1
      }) : d = o;
      let f;
      if (n) {
        d.push({ type: "ObjectExpression", properties: c }), p ? d.push(p) : r.development && d.push({ type: "Identifier", name: "undefined" });
        const m = o.length > 1;
        if (r.development) {
          s.jsxDEV = !0, f = {
            type: "Identifier",
            name: "_jsxDEV"
          }, d.push({ type: "Literal", value: m });
          const y = {
            type: "ObjectExpression",
            properties: [
              {
                type: "Property",
                method: !1,
                shorthand: !1,
                computed: !1,
                kind: "init",
                key: { type: "Identifier", name: "fileName" },
                value: {
                  type: "Literal",
                  value: r.filePath || "<source.js>"
                }
              }
            ]
          };
          i.loc && y.properties.push(
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "lineNumber" },
              value: { type: "Literal", value: i.loc.start.line }
            },
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "columnNumber" },
              value: { type: "Literal", value: i.loc.start.column + 1 }
            }
          ), d.push(y, { type: "ThisExpression" });
        } else m ? (s.jsxs = !0, f = { type: "Identifier", name: "_jsxs" }) : (s.jsx = !0, f = { type: "Identifier", name: "_jsx" });
      } else
        c.length > 0 ? d.unshift({ type: "ObjectExpression", properties: c }) : d.length > 0 && d.unshift({ type: "Literal", value: null }), f = W7(
          a.jsx || r.pragma || "React.createElement"
        );
      d.unshift(u);
      const h = {
        type: "CallExpression",
        callee: f,
        arguments: d,
        optional: !1
      };
      rp(i, h), this.replace(h);
    }
  });
}
function sLe(e) {
  let t;
  if (e.value)
    if (e.value.type === "JSXExpressionContainer") {
      const n = e.value.expression;
      n.type, t = n;
    } else {
      const n = e.value;
      n.type !== "JSXElement" && n.type, t = n, delete t.raw;
    }
  else
    t = { type: "Literal", value: !0 };
  const r = {
    type: "Property",
    key: nb(e.name),
    value: t,
    kind: "init",
    method: !1,
    shorthand: !1,
    computed: !1
  };
  return rp(e, r), r;
}
function nb(e) {
  let t;
  if (e.type === "JSXMemberExpression") {
    const r = nb(e.property);
    t = {
      type: "MemberExpression",
      object: nb(e.object),
      property: r,
      computed: r.type === "Literal",
      optional: !1
    };
  } else e.type === "JSXNamespacedName" ? t = {
    type: "Literal",
    value: e.namespace.name + ":" + e.name.name
  } : t = so(e.name) ? { type: "Identifier", name: e.name } : { type: "Literal", value: e.name };
  return rp(e, t), t;
}
function W7(e) {
  const t = e.split(".");
  let r = -1, n;
  for (; ++r < t.length; ) {
    const a = so(t[r]) ? { type: "Identifier", name: t[r] } : { type: "Literal", value: t[r] };
    n = n ? {
      type: "MemberExpression",
      object: n,
      property: a,
      computed: !!(r && a.type === "Literal"),
      optional: !1
    } : a;
  }
  return n;
}
function rp(e, t) {
  const r = ["start", "end", "loc", "range", "comments"];
  let n = -1;
  for (; ++n < r.length; ) {
    const a = r[n];
    a in e && (t[a] = e[a]);
  }
}
function oLe(e) {
  return function(t, r) {
    aLe(t, { filePath: r.history[0], ...e });
  };
}
var VA = { exports: {} }, GA, K7;
function lLe() {
  return K7 || (K7 = 1, GA = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }), GA;
}
var Uf = { exports: {} }, uLe = Uf.exports, Y7;
function X7() {
  return Y7 || (Y7 = 1, function(e, t) {
    (function(r, n) {
      n(t);
    })(uLe, function(r) {
      var n = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], a = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], s = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", i = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", o = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, l = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", u = {
        5: l,
        "5module": l + " export import",
        6: l + " const class extends export import super"
      }, c = /^in(stanceof)?$/, d = new RegExp("[" + i + "]"), p = new RegExp("[" + i + s + "]");
      function f(g, T) {
        for (var ee = 65536, fe = 0; fe < T.length; fe += 2) {
          if (ee += T[fe], ee > g)
            return !1;
          if (ee += T[fe + 1], ee >= g)
            return !0;
        }
        return !1;
      }
      function h(g, T) {
        return g < 65 ? g === 36 : g < 91 ? !0 : g < 97 ? g === 95 : g < 123 ? !0 : g <= 65535 ? g >= 170 && d.test(String.fromCharCode(g)) : T === !1 ? !1 : f(g, a);
      }
      function m(g, T) {
        return g < 48 ? g === 36 : g < 58 ? !0 : g < 65 ? !1 : g < 91 ? !0 : g < 97 ? g === 95 : g < 123 ? !0 : g <= 65535 ? g >= 170 && p.test(String.fromCharCode(g)) : T === !1 ? !1 : f(g, a) || f(g, n);
      }
      var y = function(T, ee) {
        ee === void 0 && (ee = {}), this.label = T, this.keyword = ee.keyword, this.beforeExpr = !!ee.beforeExpr, this.startsExpr = !!ee.startsExpr, this.isLoop = !!ee.isLoop, this.isAssign = !!ee.isAssign, this.prefix = !!ee.prefix, this.postfix = !!ee.postfix, this.binop = ee.binop || null, this.updateContext = null;
      };
      function b(g, T) {
        return new y(g, { beforeExpr: !0, binop: T });
      }
      var v = { beforeExpr: !0 }, x = { startsExpr: !0 }, _ = {};
      function E(g, T) {
        return T === void 0 && (T = {}), T.keyword = g, _[g] = new y(g, T);
      }
      var w = {
        num: new y("num", x),
        regexp: new y("regexp", x),
        string: new y("string", x),
        name: new y("name", x),
        privateId: new y("privateId", x),
        eof: new y("eof"),
        // Punctuation token types.
        bracketL: new y("[", { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new y("]"),
        braceL: new y("{", { beforeExpr: !0, startsExpr: !0 }),
        braceR: new y("}"),
        parenL: new y("(", { beforeExpr: !0, startsExpr: !0 }),
        parenR: new y(")"),
        comma: new y(",", v),
        semi: new y(";", v),
        colon: new y(":", v),
        dot: new y("."),
        question: new y("?", v),
        questionDot: new y("?."),
        arrow: new y("=>", v),
        template: new y("template"),
        invalidTemplate: new y("invalidTemplate"),
        ellipsis: new y("...", v),
        backQuote: new y("`", x),
        dollarBraceL: new y("${", { beforeExpr: !0, startsExpr: !0 }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new y("=", { beforeExpr: !0, isAssign: !0 }),
        assign: new y("_=", { beforeExpr: !0, isAssign: !0 }),
        incDec: new y("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new y("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: b("||", 1),
        logicalAND: b("&&", 2),
        bitwiseOR: b("|", 3),
        bitwiseXOR: b("^", 4),
        bitwiseAND: b("&", 5),
        equality: b("==/!=/===/!==", 6),
        relational: b("</>/<=/>=", 7),
        bitShift: b("<</>>/>>>", 8),
        plusMin: new y("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: b("%", 10),
        star: b("*", 10),
        slash: b("/", 10),
        starstar: new y("**", { beforeExpr: !0 }),
        coalesce: b("??", 1),
        // Keyword token types.
        _break: E("break"),
        _case: E("case", v),
        _catch: E("catch"),
        _continue: E("continue"),
        _debugger: E("debugger"),
        _default: E("default", v),
        _do: E("do", { isLoop: !0, beforeExpr: !0 }),
        _else: E("else", v),
        _finally: E("finally"),
        _for: E("for", { isLoop: !0 }),
        _function: E("function", x),
        _if: E("if"),
        _return: E("return", v),
        _switch: E("switch"),
        _throw: E("throw", v),
        _try: E("try"),
        _var: E("var"),
        _const: E("const"),
        _while: E("while", { isLoop: !0 }),
        _with: E("with"),
        _new: E("new", { beforeExpr: !0, startsExpr: !0 }),
        _this: E("this", x),
        _super: E("super", x),
        _class: E("class", x),
        _extends: E("extends", v),
        _export: E("export"),
        _import: E("import", x),
        _null: E("null", x),
        _true: E("true", x),
        _false: E("false", x),
        _in: E("in", { beforeExpr: !0, binop: 7 }),
        _instanceof: E("instanceof", { beforeExpr: !0, binop: 7 }),
        _typeof: E("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: E("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: E("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
      }, C = /\r\n?|\n|\u2028|\u2029/, k = new RegExp(C.source, "g");
      function S(g) {
        return g === 10 || g === 13 || g === 8232 || g === 8233;
      }
      function B(g, T, ee) {
        ee === void 0 && (ee = g.length);
        for (var fe = T; fe < ee; fe++) {
          var j = g.charCodeAt(fe);
          if (S(j))
            return fe < ee - 1 && j === 13 && g.charCodeAt(fe + 1) === 10 ? fe + 2 : fe + 1;
        }
        return -1;
      }
      var U = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, N = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, O = Object.prototype, I = O.hasOwnProperty, q = O.toString, ae = Object.hasOwn || function(g, T) {
        return I.call(g, T);
      }, Q = Array.isArray || function(g) {
        return q.call(g) === "[object Array]";
      }, ne = /* @__PURE__ */ Object.create(null);
      function le(g) {
        return ne[g] || (ne[g] = new RegExp("^(?:" + g.replace(/ /g, "|") + ")$"));
      }
      function W(g) {
        return g <= 65535 ? String.fromCharCode(g) : (g -= 65536, String.fromCharCode((g >> 10) + 55296, (g & 1023) + 56320));
      }
      var X = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, G = function(T, ee) {
        this.line = T, this.column = ee;
      };
      G.prototype.offset = function(T) {
        return new G(this.line, this.column + T);
      };
      var P = function(T, ee, fe) {
        this.start = ee, this.end = fe, T.sourceFile !== null && (this.source = T.sourceFile);
      };
      function he(g, T) {
        for (var ee = 1, fe = 0; ; ) {
          var j = B(g, fe, T);
          if (j < 0)
            return new G(ee, T - fe);
          ++ee, fe = j;
        }
      }
      var ye = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: !1,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: !1,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: !1,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: !0,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: !1,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: !1,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: !1
      }, pe = !1;
      function $(g) {
        var T = {};
        for (var ee in ye)
          T[ee] = g && ae(g, ee) ? g[ee] : ye[ee];
        if (T.ecmaVersion === "latest" ? T.ecmaVersion = 1e8 : T.ecmaVersion == null ? (!pe && typeof console == "object" && console.warn && (pe = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), T.ecmaVersion = 11) : T.ecmaVersion >= 2015 && (T.ecmaVersion -= 2009), T.allowReserved == null && (T.allowReserved = T.ecmaVersion < 5), (!g || g.allowHashBang == null) && (T.allowHashBang = T.ecmaVersion >= 14), Q(T.onToken)) {
          var fe = T.onToken;
          T.onToken = function(j) {
            return fe.push(j);
          };
        }
        return Q(T.onComment) && (T.onComment = F(T, T.onComment)), T;
      }
      function F(g, T) {
        return function(ee, fe, j, de, _e, Le) {
          var et = {
            type: ee ? "Block" : "Line",
            value: fe,
            start: j,
            end: de
          };
          g.locations && (et.loc = new P(this, _e, Le)), g.ranges && (et.range = [j, de]), T.push(et);
        };
      }
      var ge = 1, ce = 2, ie = 4, re = 8, Te = 16, V = 32, Pe = 64, z = 128, A = 256, R = ge | ce | A;
      function H(g, T) {
        return ce | (g ? ie : 0) | (T ? re : 0);
      }
      var be = 0, me = 1, Ce = 2, We = 3, xe = 4, we = 5, te = function(T, ee, fe) {
        this.options = T = $(T), this.sourceFile = T.sourceFile, this.keywords = le(u[T.ecmaVersion >= 6 ? 6 : T.sourceType === "module" ? "5module" : 5]);
        var j = "";
        T.allowReserved !== !0 && (j = o[T.ecmaVersion >= 6 ? 6 : T.ecmaVersion === 5 ? 5 : 3], T.sourceType === "module" && (j += " await")), this.reservedWords = le(j);
        var de = (j ? j + " " : "") + o.strict;
        this.reservedWordsStrict = le(de), this.reservedWordsStrictBind = le(de + " " + o.strictBind), this.input = String(ee), this.containsEsc = !1, fe ? (this.pos = fe, this.lineStart = this.input.lastIndexOf(`
`, fe - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(C).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = w.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = T.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && T.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(ge), this.regexpState = null, this.privateNameStack = [];
      }, Fe = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
      te.prototype.parse = function() {
        var T = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(T);
      }, Fe.inFunction.get = function() {
        return (this.currentVarScope().flags & ce) > 0;
      }, Fe.inGenerator.get = function() {
        return (this.currentVarScope().flags & re) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Fe.inAsync.get = function() {
        return (this.currentVarScope().flags & ie) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Fe.canAwait.get = function() {
        for (var g = this.scopeStack.length - 1; g >= 0; g--) {
          var T = this.scopeStack[g];
          if (T.inClassFieldInit || T.flags & A)
            return !1;
          if (T.flags & ce)
            return (T.flags & ie) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      }, Fe.allowSuper.get = function() {
        var g = this.currentThisScope(), T = g.flags, ee = g.inClassFieldInit;
        return (T & Pe) > 0 || ee || this.options.allowSuperOutsideMethod;
      }, Fe.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & z) > 0;
      }, Fe.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, Fe.allowNewDotTarget.get = function() {
        var g = this.currentThisScope(), T = g.flags, ee = g.inClassFieldInit;
        return (T & (ce | A)) > 0 || ee;
      }, Fe.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & A) > 0;
      }, te.extend = function() {
        for (var T = [], ee = arguments.length; ee--; ) T[ee] = arguments[ee];
        for (var fe = this, j = 0; j < T.length; j++)
          fe = T[j](fe);
        return fe;
      }, te.parse = function(T, ee) {
        return new this(ee, T).parse();
      }, te.parseExpressionAt = function(T, ee, fe) {
        var j = new this(fe, T, ee);
        return j.nextToken(), j.parseExpression();
      }, te.tokenizer = function(T, ee) {
        return new this(ee, T);
      }, Object.defineProperties(te.prototype, Fe);
      var Y = te.prototype, Je = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      Y.strictDirective = function(g) {
        if (this.options.ecmaVersion < 5)
          return !1;
        for (; ; ) {
          N.lastIndex = g, g += N.exec(this.input)[0].length;
          var T = Je.exec(this.input.slice(g));
          if (!T)
            return !1;
          if ((T[1] || T[2]) === "use strict") {
            N.lastIndex = g + T[0].length;
            var ee = N.exec(this.input), fe = ee.index + ee[0].length, j = this.input.charAt(fe);
            return j === ";" || j === "}" || C.test(ee[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(j) || j === "!" && this.input.charAt(fe + 1) === "=");
          }
          g += T[0].length, N.lastIndex = g, g += N.exec(this.input)[0].length, this.input[g] === ";" && g++;
        }
      }, Y.eat = function(g) {
        return this.type === g ? (this.next(), !0) : !1;
      }, Y.isContextual = function(g) {
        return this.type === w.name && this.value === g && !this.containsEsc;
      }, Y.eatContextual = function(g) {
        return this.isContextual(g) ? (this.next(), !0) : !1;
      }, Y.expectContextual = function(g) {
        this.eatContextual(g) || this.unexpected();
      }, Y.canInsertSemicolon = function() {
        return this.type === w.eof || this.type === w.braceR || C.test(this.input.slice(this.lastTokEnd, this.start));
      }, Y.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
      }, Y.semicolon = function() {
        !this.eat(w.semi) && !this.insertSemicolon() && this.unexpected();
      }, Y.afterTrailingComma = function(g, T) {
        if (this.type === g)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), T || this.next(), !0;
      }, Y.expect = function(g) {
        this.eat(g) || this.unexpected();
      }, Y.unexpected = function(g) {
        this.raise(g ?? this.start, "Unexpected token");
      };
      var xt = function() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      Y.checkPatternErrors = function(g, T) {
        if (g) {
          g.trailingComma > -1 && this.raiseRecoverable(g.trailingComma, "Comma is not permitted after the rest element");
          var ee = T ? g.parenthesizedAssign : g.parenthesizedBind;
          ee > -1 && this.raiseRecoverable(ee, T ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      }, Y.checkExpressionErrors = function(g, T) {
        if (!g)
          return !1;
        var ee = g.shorthandAssign, fe = g.doubleProto;
        if (!T)
          return ee >= 0 || fe >= 0;
        ee >= 0 && this.raise(ee, "Shorthand property assignments are valid only in destructuring patterns"), fe >= 0 && this.raiseRecoverable(fe, "Redefinition of __proto__ property");
      }, Y.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, Y.isSimpleAssignTarget = function(g) {
        return g.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(g.expression) : g.type === "Identifier" || g.type === "MemberExpression";
      };
      var Ze = te.prototype;
      Ze.parseTopLevel = function(g) {
        var T = /* @__PURE__ */ Object.create(null);
        for (g.body || (g.body = []); this.type !== w.eof; ) {
          var ee = this.parseStatement(null, !0, T);
          g.body.push(ee);
        }
        if (this.inModule)
          for (var fe = 0, j = Object.keys(this.undefinedExports); fe < j.length; fe += 1) {
            var de = j[fe];
            this.raiseRecoverable(this.undefinedExports[de].start, "Export '" + de + "' is not defined");
          }
        return this.adaptDirectivePrologue(g.body), this.next(), g.sourceType = this.options.sourceType, this.finishNode(g, "Program");
      };
      var rt = { kind: "loop" }, Mt = { kind: "switch" };
      Ze.isLet = function(g) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return !1;
        N.lastIndex = this.pos;
        var T = N.exec(this.input), ee = this.pos + T[0].length, fe = this.input.charCodeAt(ee);
        if (fe === 91 || fe === 92)
          return !0;
        if (g)
          return !1;
        if (fe === 123 || fe > 55295 && fe < 56320)
          return !0;
        if (h(fe, !0)) {
          for (var j = ee + 1; m(fe = this.input.charCodeAt(j), !0); )
            ++j;
          if (fe === 92 || fe > 55295 && fe < 56320)
            return !0;
          var de = this.input.slice(ee, j);
          if (!c.test(de))
            return !0;
        }
        return !1;
      }, Ze.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return !1;
        N.lastIndex = this.pos;
        var g = N.exec(this.input), T = this.pos + g[0].length, ee;
        return !C.test(this.input.slice(this.pos, T)) && this.input.slice(T, T + 8) === "function" && (T + 8 === this.input.length || !(m(ee = this.input.charCodeAt(T + 8)) || ee > 55295 && ee < 56320));
      }, Ze.parseStatement = function(g, T, ee) {
        var fe = this.type, j = this.startNode(), de;
        switch (this.isLet(g) && (fe = w._var, de = "let"), fe) {
          case w._break:
          case w._continue:
            return this.parseBreakContinueStatement(j, fe.keyword);
          case w._debugger:
            return this.parseDebuggerStatement(j);
          case w._do:
            return this.parseDoStatement(j);
          case w._for:
            return this.parseForStatement(j);
          case w._function:
            return g && (this.strict || g !== "if" && g !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(j, !1, !g);
          case w._class:
            return g && this.unexpected(), this.parseClass(j, !0);
          case w._if:
            return this.parseIfStatement(j);
          case w._return:
            return this.parseReturnStatement(j);
          case w._switch:
            return this.parseSwitchStatement(j);
          case w._throw:
            return this.parseThrowStatement(j);
          case w._try:
            return this.parseTryStatement(j);
          case w._const:
          case w._var:
            return de = de || this.value, g && de !== "var" && this.unexpected(), this.parseVarStatement(j, de);
          case w._while:
            return this.parseWhileStatement(j);
          case w._with:
            return this.parseWithStatement(j);
          case w.braceL:
            return this.parseBlock(!0, j);
          case w.semi:
            return this.parseEmptyStatement(j);
          case w._export:
          case w._import:
            if (this.options.ecmaVersion > 10 && fe === w._import) {
              N.lastIndex = this.pos;
              var _e = N.exec(this.input), Le = this.pos + _e[0].length, et = this.input.charCodeAt(Le);
              if (et === 40 || et === 46)
                return this.parseExpressionStatement(j, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (T || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), fe === w._import ? this.parseImport(j) : this.parseExport(j, ee);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction())
              return g && this.unexpected(), this.next(), this.parseFunctionStatement(j, !0, !g);
            var vt = this.value, Wt = this.parseExpression();
            return fe === w.name && Wt.type === "Identifier" && this.eat(w.colon) ? this.parseLabeledStatement(j, vt, Wt, g) : this.parseExpressionStatement(j, Wt);
        }
      }, Ze.parseBreakContinueStatement = function(g, T) {
        var ee = T === "break";
        this.next(), this.eat(w.semi) || this.insertSemicolon() ? g.label = null : this.type !== w.name ? this.unexpected() : (g.label = this.parseIdent(), this.semicolon());
        for (var fe = 0; fe < this.labels.length; ++fe) {
          var j = this.labels[fe];
          if ((g.label == null || j.name === g.label.name) && (j.kind != null && (ee || j.kind === "loop") || g.label && ee))
            break;
        }
        return fe === this.labels.length && this.raise(g.start, "Unsyntactic " + T), this.finishNode(g, ee ? "BreakStatement" : "ContinueStatement");
      }, Ze.parseDebuggerStatement = function(g) {
        return this.next(), this.semicolon(), this.finishNode(g, "DebuggerStatement");
      }, Ze.parseDoStatement = function(g) {
        return this.next(), this.labels.push(rt), g.body = this.parseStatement("do"), this.labels.pop(), this.expect(w._while), g.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(w.semi) : this.semicolon(), this.finishNode(g, "DoWhileStatement");
      }, Ze.parseForStatement = function(g) {
        this.next();
        var T = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(rt), this.enterScope(0), this.expect(w.parenL), this.type === w.semi)
          return T > -1 && this.unexpected(T), this.parseFor(g, null);
        var ee = this.isLet();
        if (this.type === w._var || this.type === w._const || ee) {
          var fe = this.startNode(), j = ee ? "let" : this.value;
          return this.next(), this.parseVar(fe, !0, j), this.finishNode(fe, "VariableDeclaration"), (this.type === w._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && fe.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === w._in ? T > -1 && this.unexpected(T) : g.await = T > -1), this.parseForIn(g, fe)) : (T > -1 && this.unexpected(T), this.parseFor(g, fe));
        }
        var de = this.isContextual("let"), _e = !1, Le = this.containsEsc, et = new xt(), vt = this.start, Wt = T > -1 ? this.parseExprSubscripts(et, "await") : this.parseExpression(!0, et);
        return this.type === w._in || (_e = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (T > -1 ? (this.type === w._in && this.unexpected(T), g.await = !0) : _e && this.options.ecmaVersion >= 8 && (Wt.start === vt && !Le && Wt.type === "Identifier" && Wt.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (g.await = !1)), de && _e && this.raise(Wt.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Wt, !1, et), this.checkLValPattern(Wt), this.parseForIn(g, Wt)) : (this.checkExpressionErrors(et, !0), T > -1 && this.unexpected(T), this.parseFor(g, Wt));
      }, Ze.parseFunctionStatement = function(g, T, ee) {
        return this.next(), this.parseFunction(g, kr | (ee ? 0 : tr), !1, T);
      }, Ze.parseIfStatement = function(g) {
        return this.next(), g.test = this.parseParenExpression(), g.consequent = this.parseStatement("if"), g.alternate = this.eat(w._else) ? this.parseStatement("if") : null, this.finishNode(g, "IfStatement");
      }, Ze.parseReturnStatement = function(g) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(w.semi) || this.insertSemicolon() ? g.argument = null : (g.argument = this.parseExpression(), this.semicolon()), this.finishNode(g, "ReturnStatement");
      }, Ze.parseSwitchStatement = function(g) {
        this.next(), g.discriminant = this.parseParenExpression(), g.cases = [], this.expect(w.braceL), this.labels.push(Mt), this.enterScope(0);
        for (var T, ee = !1; this.type !== w.braceR; )
          if (this.type === w._case || this.type === w._default) {
            var fe = this.type === w._case;
            T && this.finishNode(T, "SwitchCase"), g.cases.push(T = this.startNode()), T.consequent = [], this.next(), fe ? T.test = this.parseExpression() : (ee && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), ee = !0, T.test = null), this.expect(w.colon);
          } else
            T || this.unexpected(), T.consequent.push(this.parseStatement(null));
        return this.exitScope(), T && this.finishNode(T, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(g, "SwitchStatement");
      }, Ze.parseThrowStatement = function(g) {
        return this.next(), C.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), g.argument = this.parseExpression(), this.semicolon(), this.finishNode(g, "ThrowStatement");
      };
      var Qt = [];
      Ze.parseCatchClauseParam = function() {
        var g = this.parseBindingAtom(), T = g.type === "Identifier";
        return this.enterScope(T ? V : 0), this.checkLValPattern(g, T ? xe : Ce), this.expect(w.parenR), g;
      }, Ze.parseTryStatement = function(g) {
        if (this.next(), g.block = this.parseBlock(), g.handler = null, this.type === w._catch) {
          var T = this.startNode();
          this.next(), this.eat(w.parenL) ? T.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), T.param = null, this.enterScope(0)), T.body = this.parseBlock(!1), this.exitScope(), g.handler = this.finishNode(T, "CatchClause");
        }
        return g.finalizer = this.eat(w._finally) ? this.parseBlock() : null, !g.handler && !g.finalizer && this.raise(g.start, "Missing catch or finally clause"), this.finishNode(g, "TryStatement");
      }, Ze.parseVarStatement = function(g, T, ee) {
        return this.next(), this.parseVar(g, !1, T, ee), this.semicolon(), this.finishNode(g, "VariableDeclaration");
      }, Ze.parseWhileStatement = function(g) {
        return this.next(), g.test = this.parseParenExpression(), this.labels.push(rt), g.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(g, "WhileStatement");
      }, Ze.parseWithStatement = function(g) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), g.object = this.parseParenExpression(), g.body = this.parseStatement("with"), this.finishNode(g, "WithStatement");
      }, Ze.parseEmptyStatement = function(g) {
        return this.next(), this.finishNode(g, "EmptyStatement");
      }, Ze.parseLabeledStatement = function(g, T, ee, fe) {
        for (var j = 0, de = this.labels; j < de.length; j += 1) {
          var _e = de[j];
          _e.name === T && this.raise(ee.start, "Label '" + T + "' is already declared");
        }
        for (var Le = this.type.isLoop ? "loop" : this.type === w._switch ? "switch" : null, et = this.labels.length - 1; et >= 0; et--) {
          var vt = this.labels[et];
          if (vt.statementStart === g.start)
            vt.statementStart = this.start, vt.kind = Le;
          else
            break;
        }
        return this.labels.push({ name: T, kind: Le, statementStart: this.start }), g.body = this.parseStatement(fe ? fe.indexOf("label") === -1 ? fe + "label" : fe : "label"), this.labels.pop(), g.label = ee, this.finishNode(g, "LabeledStatement");
      }, Ze.parseExpressionStatement = function(g, T) {
        return g.expression = T, this.semicolon(), this.finishNode(g, "ExpressionStatement");
      }, Ze.parseBlock = function(g, T, ee) {
        for (g === void 0 && (g = !0), T === void 0 && (T = this.startNode()), T.body = [], this.expect(w.braceL), g && this.enterScope(0); this.type !== w.braceR; ) {
          var fe = this.parseStatement(null);
          T.body.push(fe);
        }
        return ee && (this.strict = !1), this.next(), g && this.exitScope(), this.finishNode(T, "BlockStatement");
      }, Ze.parseFor = function(g, T) {
        return g.init = T, this.expect(w.semi), g.test = this.type === w.semi ? null : this.parseExpression(), this.expect(w.semi), g.update = this.type === w.parenR ? null : this.parseExpression(), this.expect(w.parenR), g.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(g, "ForStatement");
      }, Ze.parseForIn = function(g, T) {
        var ee = this.type === w._in;
        return this.next(), T.type === "VariableDeclaration" && T.declarations[0].init != null && (!ee || this.options.ecmaVersion < 8 || this.strict || T.kind !== "var" || T.declarations[0].id.type !== "Identifier") && this.raise(
          T.start,
          (ee ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ), g.left = T, g.right = ee ? this.parseExpression() : this.parseMaybeAssign(), this.expect(w.parenR), g.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(g, ee ? "ForInStatement" : "ForOfStatement");
      }, Ze.parseVar = function(g, T, ee, fe) {
        for (g.declarations = [], g.kind = ee; ; ) {
          var j = this.startNode();
          if (this.parseVarId(j, ee), this.eat(w.eq) ? j.init = this.parseMaybeAssign(T) : !fe && ee === "const" && !(this.type === w._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !fe && j.id.type !== "Identifier" && !(T && (this.type === w._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : j.init = null, g.declarations.push(this.finishNode(j, "VariableDeclarator")), !this.eat(w.comma))
            break;
        }
        return g;
      }, Ze.parseVarId = function(g, T) {
        g.id = this.parseBindingAtom(), this.checkLValPattern(g.id, T === "var" ? me : Ce, !1);
      };
      var kr = 1, tr = 2, Oe = 4;
      Ze.parseFunction = function(g, T, ee, fe, j) {
        this.initFunction(g), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !fe) && (this.type === w.star && T & tr && this.unexpected(), g.generator = this.eat(w.star)), this.options.ecmaVersion >= 8 && (g.async = !!fe), T & kr && (g.id = T & Oe && this.type !== w.name ? null : this.parseIdent(), g.id && !(T & tr) && this.checkLValSimple(g.id, this.strict || g.generator || g.async ? this.treatFunctionsAsVar ? me : Ce : We));
        var de = this.yieldPos, _e = this.awaitPos, Le = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(H(g.async, g.generator)), T & kr || (g.id = this.type === w.name ? this.parseIdent() : null), this.parseFunctionParams(g), this.parseFunctionBody(g, ee, !1, j), this.yieldPos = de, this.awaitPos = _e, this.awaitIdentPos = Le, this.finishNode(g, T & kr ? "FunctionDeclaration" : "FunctionExpression");
      }, Ze.parseFunctionParams = function(g) {
        this.expect(w.parenL), g.params = this.parseBindingList(w.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, Ze.parseClass = function(g, T) {
        this.next();
        var ee = this.strict;
        this.strict = !0, this.parseClassId(g, T), this.parseClassSuper(g);
        var fe = this.enterClassBody(), j = this.startNode(), de = !1;
        for (j.body = [], this.expect(w.braceL); this.type !== w.braceR; ) {
          var _e = this.parseClassElement(g.superClass !== null);
          _e && (j.body.push(_e), _e.type === "MethodDefinition" && _e.kind === "constructor" ? (de && this.raiseRecoverable(_e.start, "Duplicate constructor in the same class"), de = !0) : _e.key && _e.key.type === "PrivateIdentifier" && Ie(fe, _e) && this.raiseRecoverable(_e.key.start, "Identifier '#" + _e.key.name + "' has already been declared"));
        }
        return this.strict = ee, this.next(), g.body = this.finishNode(j, "ClassBody"), this.exitClassBody(), this.finishNode(g, T ? "ClassDeclaration" : "ClassExpression");
      }, Ze.parseClassElement = function(g) {
        if (this.eat(w.semi))
          return null;
        var T = this.options.ecmaVersion, ee = this.startNode(), fe = "", j = !1, de = !1, _e = "method", Le = !1;
        if (this.eatContextual("static")) {
          if (T >= 13 && this.eat(w.braceL))
            return this.parseClassStaticBlock(ee), ee;
          this.isClassElementNameStart() || this.type === w.star ? Le = !0 : fe = "static";
        }
        if (ee.static = Le, !fe && T >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === w.star) && !this.canInsertSemicolon() ? de = !0 : fe = "async"), !fe && (T >= 9 || !de) && this.eat(w.star) && (j = !0), !fe && !de && !j) {
          var et = this.value;
          (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? _e = et : fe = et);
        }
        if (fe ? (ee.computed = !1, ee.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), ee.key.name = fe, this.finishNode(ee.key, "Identifier")) : this.parseClassElementName(ee), T < 13 || this.type === w.parenL || _e !== "method" || j || de) {
          var vt = !ee.static && Me(ee, "constructor"), Wt = vt && g;
          vt && _e !== "method" && this.raise(ee.key.start, "Constructor can't have get/set modifier"), ee.kind = vt ? "constructor" : _e, this.parseClassMethod(ee, j, de, Wt);
        } else
          this.parseClassField(ee);
        return ee;
      }, Ze.isClassElementNameStart = function() {
        return this.type === w.name || this.type === w.privateId || this.type === w.num || this.type === w.string || this.type === w.bracketL || this.type.keyword;
      }, Ze.parseClassElementName = function(g) {
        this.type === w.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), g.computed = !1, g.key = this.parsePrivateIdent()) : this.parsePropertyName(g);
      }, Ze.parseClassMethod = function(g, T, ee, fe) {
        var j = g.key;
        g.kind === "constructor" ? (T && this.raise(j.start, "Constructor can't be a generator"), ee && this.raise(j.start, "Constructor can't be an async method")) : g.static && Me(g, "prototype") && this.raise(j.start, "Classes may not have a static property named prototype");
        var de = g.value = this.parseMethod(T, ee, fe);
        return g.kind === "get" && de.params.length !== 0 && this.raiseRecoverable(de.start, "getter should have no params"), g.kind === "set" && de.params.length !== 1 && this.raiseRecoverable(de.start, "setter should have exactly one param"), g.kind === "set" && de.params[0].type === "RestElement" && this.raiseRecoverable(de.params[0].start, "Setter cannot use rest params"), this.finishNode(g, "MethodDefinition");
      }, Ze.parseClassField = function(g) {
        if (Me(g, "constructor") ? this.raise(g.key.start, "Classes can't have a field named 'constructor'") : g.static && Me(g, "prototype") && this.raise(g.key.start, "Classes can't have a static field named 'prototype'"), this.eat(w.eq)) {
          var T = this.currentThisScope(), ee = T.inClassFieldInit;
          T.inClassFieldInit = !0, g.value = this.parseMaybeAssign(), T.inClassFieldInit = ee;
        } else
          g.value = null;
        return this.semicolon(), this.finishNode(g, "PropertyDefinition");
      }, Ze.parseClassStaticBlock = function(g) {
        g.body = [];
        var T = this.labels;
        for (this.labels = [], this.enterScope(A | Pe); this.type !== w.braceR; ) {
          var ee = this.parseStatement(null);
          g.body.push(ee);
        }
        return this.next(), this.exitScope(), this.labels = T, this.finishNode(g, "StaticBlock");
      }, Ze.parseClassId = function(g, T) {
        this.type === w.name ? (g.id = this.parseIdent(), T && this.checkLValSimple(g.id, Ce, !1)) : (T === !0 && this.unexpected(), g.id = null);
      }, Ze.parseClassSuper = function(g) {
        g.superClass = this.eat(w._extends) ? this.parseExprSubscripts(null, !1) : null;
      }, Ze.enterClassBody = function() {
        var g = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        return this.privateNameStack.push(g), g.declared;
      }, Ze.exitClassBody = function() {
        var g = this.privateNameStack.pop(), T = g.declared, ee = g.used;
        if (this.options.checkPrivateFields)
          for (var fe = this.privateNameStack.length, j = fe === 0 ? null : this.privateNameStack[fe - 1], de = 0; de < ee.length; ++de) {
            var _e = ee[de];
            ae(T, _e.name) || (j ? j.used.push(_e) : this.raiseRecoverable(_e.start, "Private field '#" + _e.name + "' must be declared in an enclosing class"));
          }
      };
      function Ie(g, T) {
        var ee = T.key.name, fe = g[ee], j = "true";
        return T.type === "MethodDefinition" && (T.kind === "get" || T.kind === "set") && (j = (T.static ? "s" : "i") + T.kind), fe === "iget" && j === "iset" || fe === "iset" && j === "iget" || fe === "sget" && j === "sset" || fe === "sset" && j === "sget" ? (g[ee] = "true", !1) : fe ? !0 : (g[ee] = j, !1);
      }
      function Me(g, T) {
        var ee = g.computed, fe = g.key;
        return !ee && (fe.type === "Identifier" && fe.name === T || fe.type === "Literal" && fe.value === T);
      }
      Ze.parseExportAllDeclaration = function(g, T) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (g.exported = this.parseModuleExportName(), this.checkExport(T, g.exported, this.lastTokStart)) : g.exported = null), this.expectContextual("from"), this.type !== w.string && this.unexpected(), g.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(g, "ExportAllDeclaration");
      }, Ze.parseExport = function(g, T) {
        if (this.next(), this.eat(w.star))
          return this.parseExportAllDeclaration(g, T);
        if (this.eat(w._default))
          return this.checkExport(T, "default", this.lastTokStart), g.declaration = this.parseExportDefaultDeclaration(), this.finishNode(g, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement())
          g.declaration = this.parseExportDeclaration(g), g.declaration.type === "VariableDeclaration" ? this.checkVariableExport(T, g.declaration.declarations) : this.checkExport(T, g.declaration.id, g.declaration.id.start), g.specifiers = [], g.source = null;
        else {
          if (g.declaration = null, g.specifiers = this.parseExportSpecifiers(T), this.eatContextual("from"))
            this.type !== w.string && this.unexpected(), g.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause());
          else {
            for (var ee = 0, fe = g.specifiers; ee < fe.length; ee += 1) {
              var j = fe[ee];
              this.checkUnreserved(j.local), this.checkLocalExport(j.local), j.local.type === "Literal" && this.raise(j.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            g.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(g, "ExportNamedDeclaration");
      }, Ze.parseExportDeclaration = function(g) {
        return this.parseStatement(null);
      }, Ze.parseExportDefaultDeclaration = function() {
        var g;
        if (this.type === w._function || (g = this.isAsyncFunction())) {
          var T = this.startNode();
          return this.next(), g && this.next(), this.parseFunction(T, kr | Oe, !1, g);
        } else if (this.type === w._class) {
          var ee = this.startNode();
          return this.parseClass(ee, "nullableID");
        } else {
          var fe = this.parseMaybeAssign();
          return this.semicolon(), fe;
        }
      }, Ze.checkExport = function(g, T, ee) {
        g && (typeof T != "string" && (T = T.type === "Identifier" ? T.name : T.value), ae(g, T) && this.raiseRecoverable(ee, "Duplicate export '" + T + "'"), g[T] = !0);
      }, Ze.checkPatternExport = function(g, T) {
        var ee = T.type;
        if (ee === "Identifier")
          this.checkExport(g, T, T.start);
        else if (ee === "ObjectPattern")
          for (var fe = 0, j = T.properties; fe < j.length; fe += 1) {
            var de = j[fe];
            this.checkPatternExport(g, de);
          }
        else if (ee === "ArrayPattern")
          for (var _e = 0, Le = T.elements; _e < Le.length; _e += 1) {
            var et = Le[_e];
            et && this.checkPatternExport(g, et);
          }
        else ee === "Property" ? this.checkPatternExport(g, T.value) : ee === "AssignmentPattern" ? this.checkPatternExport(g, T.left) : ee === "RestElement" && this.checkPatternExport(g, T.argument);
      }, Ze.checkVariableExport = function(g, T) {
        if (g)
          for (var ee = 0, fe = T; ee < fe.length; ee += 1) {
            var j = fe[ee];
            this.checkPatternExport(g, j.id);
          }
      }, Ze.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, Ze.parseExportSpecifier = function(g) {
        var T = this.startNode();
        return T.local = this.parseModuleExportName(), T.exported = this.eatContextual("as") ? this.parseModuleExportName() : T.local, this.checkExport(
          g,
          T.exported,
          T.exported.start
        ), this.finishNode(T, "ExportSpecifier");
      }, Ze.parseExportSpecifiers = function(g) {
        var T = [], ee = !0;
        for (this.expect(w.braceL); !this.eat(w.braceR); ) {
          if (ee)
            ee = !1;
          else if (this.expect(w.comma), this.afterTrailingComma(w.braceR))
            break;
          T.push(this.parseExportSpecifier(g));
        }
        return T;
      }, Ze.parseImport = function(g) {
        return this.next(), this.type === w.string ? (g.specifiers = Qt, g.source = this.parseExprAtom()) : (g.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), g.source = this.type === w.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(g, "ImportDeclaration");
      }, Ze.parseImportSpecifier = function() {
        var g = this.startNode();
        return g.imported = this.parseModuleExportName(), this.eatContextual("as") ? g.local = this.parseIdent() : (this.checkUnreserved(g.imported), g.local = g.imported), this.checkLValSimple(g.local, Ce), this.finishNode(g, "ImportSpecifier");
      }, Ze.parseImportDefaultSpecifier = function() {
        var g = this.startNode();
        return g.local = this.parseIdent(), this.checkLValSimple(g.local, Ce), this.finishNode(g, "ImportDefaultSpecifier");
      }, Ze.parseImportNamespaceSpecifier = function() {
        var g = this.startNode();
        return this.next(), this.expectContextual("as"), g.local = this.parseIdent(), this.checkLValSimple(g.local, Ce), this.finishNode(g, "ImportNamespaceSpecifier");
      }, Ze.parseImportSpecifiers = function() {
        var g = [], T = !0;
        if (this.type === w.name && (g.push(this.parseImportDefaultSpecifier()), !this.eat(w.comma)))
          return g;
        if (this.type === w.star)
          return g.push(this.parseImportNamespaceSpecifier()), g;
        for (this.expect(w.braceL); !this.eat(w.braceR); ) {
          if (T)
            T = !1;
          else if (this.expect(w.comma), this.afterTrailingComma(w.braceR))
            break;
          g.push(this.parseImportSpecifier());
        }
        return g;
      }, Ze.parseWithClause = function() {
        var g = [];
        if (!this.eat(w._with))
          return g;
        this.expect(w.braceL);
        for (var T = {}, ee = !0; !this.eat(w.braceR); ) {
          if (ee)
            ee = !1;
          else if (this.expect(w.comma), this.afterTrailingComma(w.braceR))
            break;
          var fe = this.parseImportAttribute(), j = fe.key.type === "Identifier" ? fe.key.name : fe.key.value;
          ae(T, j) && this.raiseRecoverable(fe.key.start, "Duplicate attribute key '" + j + "'"), T[j] = !0, g.push(fe);
        }
        return g;
      }, Ze.parseImportAttribute = function() {
        var g = this.startNode();
        return g.key = this.type === w.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(w.colon), this.type !== w.string && this.unexpected(), g.value = this.parseExprAtom(), this.finishNode(g, "ImportAttribute");
      }, Ze.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === w.string) {
          var g = this.parseLiteral(this.value);
          return X.test(g.value) && this.raise(g.start, "An export name cannot include a lone surrogate."), g;
        }
        return this.parseIdent(!0);
      }, Ze.adaptDirectivePrologue = function(g) {
        for (var T = 0; T < g.length && this.isDirectiveCandidate(g[T]); ++T)
          g[T].directive = g[T].expression.raw.slice(1, -1);
      }, Ze.isDirectiveCandidate = function(g) {
        return this.options.ecmaVersion >= 5 && g.type === "ExpressionStatement" && g.expression.type === "Literal" && typeof g.expression.value == "string" && // Reject parenthesized strings.
        (this.input[g.start] === '"' || this.input[g.start] === "'");
      };
      var je = te.prototype;
      je.toAssignable = function(g, T, ee) {
        if (this.options.ecmaVersion >= 6 && g)
          switch (g.type) {
            case "Identifier":
              this.inAsync && g.name === "await" && this.raise(g.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              g.type = "ObjectPattern", ee && this.checkPatternErrors(ee, !0);
              for (var fe = 0, j = g.properties; fe < j.length; fe += 1) {
                var de = j[fe];
                this.toAssignable(de, T), de.type === "RestElement" && (de.argument.type === "ArrayPattern" || de.argument.type === "ObjectPattern") && this.raise(de.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              g.kind !== "init" && this.raise(g.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(g.value, T);
              break;
            case "ArrayExpression":
              g.type = "ArrayPattern", ee && this.checkPatternErrors(ee, !0), this.toAssignableList(g.elements, T);
              break;
            case "SpreadElement":
              g.type = "RestElement", this.toAssignable(g.argument, T), g.argument.type === "AssignmentPattern" && this.raise(g.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              g.operator !== "=" && this.raise(g.left.end, "Only '=' operator can be used for specifying default value."), g.type = "AssignmentPattern", delete g.operator, this.toAssignable(g.left, T);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(g.expression, T, ee);
              break;
            case "ChainExpression":
              this.raiseRecoverable(g.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!T)
                break;
            default:
              this.raise(g.start, "Assigning to rvalue");
          }
        else ee && this.checkPatternErrors(ee, !0);
        return g;
      }, je.toAssignableList = function(g, T) {
        for (var ee = g.length, fe = 0; fe < ee; fe++) {
          var j = g[fe];
          j && this.toAssignable(j, T);
        }
        if (ee) {
          var de = g[ee - 1];
          this.options.ecmaVersion === 6 && T && de && de.type === "RestElement" && de.argument.type !== "Identifier" && this.unexpected(de.argument.start);
        }
        return g;
      }, je.parseSpread = function(g) {
        var T = this.startNode();
        return this.next(), T.argument = this.parseMaybeAssign(!1, g), this.finishNode(T, "SpreadElement");
      }, je.parseRestBinding = function() {
        var g = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== w.name && this.unexpected(), g.argument = this.parseBindingAtom(), this.finishNode(g, "RestElement");
      }, je.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case w.bracketL:
              var g = this.startNode();
              return this.next(), g.elements = this.parseBindingList(w.bracketR, !0, !0), this.finishNode(g, "ArrayPattern");
            case w.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }, je.parseBindingList = function(g, T, ee, fe) {
        for (var j = [], de = !0; !this.eat(g); )
          if (de ? de = !1 : this.expect(w.comma), T && this.type === w.comma)
            j.push(null);
          else {
            if (ee && this.afterTrailingComma(g))
              break;
            if (this.type === w.ellipsis) {
              var _e = this.parseRestBinding();
              this.parseBindingListItem(_e), j.push(_e), this.type === w.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(g);
              break;
            } else
              j.push(this.parseAssignableListItem(fe));
          }
        return j;
      }, je.parseAssignableListItem = function(g) {
        var T = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(T), T;
      }, je.parseBindingListItem = function(g) {
        return g;
      }, je.parseMaybeDefault = function(g, T, ee) {
        if (ee = ee || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(w.eq))
          return ee;
        var fe = this.startNodeAt(g, T);
        return fe.left = ee, fe.right = this.parseMaybeAssign(), this.finishNode(fe, "AssignmentPattern");
      }, je.checkLValSimple = function(g, T, ee) {
        T === void 0 && (T = be);
        var fe = T !== be;
        switch (g.type) {
          case "Identifier":
            this.strict && this.reservedWordsStrictBind.test(g.name) && this.raiseRecoverable(g.start, (fe ? "Binding " : "Assigning to ") + g.name + " in strict mode"), fe && (T === Ce && g.name === "let" && this.raiseRecoverable(g.start, "let is disallowed as a lexically bound name"), ee && (ae(ee, g.name) && this.raiseRecoverable(g.start, "Argument name clash"), ee[g.name] = !0), T !== we && this.declareName(g.name, T, g.start));
            break;
          case "ChainExpression":
            this.raiseRecoverable(g.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            fe && this.raiseRecoverable(g.start, "Binding member expression");
            break;
          case "ParenthesizedExpression":
            return fe && this.raiseRecoverable(g.start, "Binding parenthesized expression"), this.checkLValSimple(g.expression, T, ee);
          default:
            this.raise(g.start, (fe ? "Binding" : "Assigning to") + " rvalue");
        }
      }, je.checkLValPattern = function(g, T, ee) {
        switch (T === void 0 && (T = be), g.type) {
          case "ObjectPattern":
            for (var fe = 0, j = g.properties; fe < j.length; fe += 1) {
              var de = j[fe];
              this.checkLValInnerPattern(de, T, ee);
            }
            break;
          case "ArrayPattern":
            for (var _e = 0, Le = g.elements; _e < Le.length; _e += 1) {
              var et = Le[_e];
              et && this.checkLValInnerPattern(et, T, ee);
            }
            break;
          default:
            this.checkLValSimple(g, T, ee);
        }
      }, je.checkLValInnerPattern = function(g, T, ee) {
        switch (T === void 0 && (T = be), g.type) {
          case "Property":
            this.checkLValInnerPattern(g.value, T, ee);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(g.left, T, ee);
            break;
          case "RestElement":
            this.checkLValPattern(g.argument, T, ee);
            break;
          default:
            this.checkLValPattern(g, T, ee);
        }
      };
      var tt = function(T, ee, fe, j, de) {
        this.token = T, this.isExpr = !!ee, this.preserveSpace = !!fe, this.override = j, this.generator = !!de;
      }, Ct = {
        b_stat: new tt("{", !1),
        b_expr: new tt("{", !0),
        b_tmpl: new tt("${", !1),
        p_stat: new tt("(", !1),
        p_expr: new tt("(", !0),
        q_tmpl: new tt("`", !0, !0, function(g) {
          return g.tryReadTemplateToken();
        }),
        f_stat: new tt("function", !1),
        f_expr: new tt("function", !0),
        f_expr_gen: new tt("function", !0, !1, null, !0),
        f_gen: new tt("function", !1, !1, null, !0)
      }, Kt = te.prototype;
      Kt.initialContext = function() {
        return [Ct.b_stat];
      }, Kt.curContext = function() {
        return this.context[this.context.length - 1];
      }, Kt.braceIsBlock = function(g) {
        var T = this.curContext();
        return T === Ct.f_expr || T === Ct.f_stat ? !0 : g === w.colon && (T === Ct.b_stat || T === Ct.b_expr) ? !T.isExpr : g === w._return || g === w.name && this.exprAllowed ? C.test(this.input.slice(this.lastTokEnd, this.start)) : g === w._else || g === w.semi || g === w.eof || g === w.parenR || g === w.arrow ? !0 : g === w.braceL ? T === Ct.b_stat : g === w._var || g === w._const || g === w.name ? !1 : !this.exprAllowed;
      }, Kt.inGeneratorContext = function() {
        for (var g = this.context.length - 1; g >= 1; g--) {
          var T = this.context[g];
          if (T.token === "function")
            return T.generator;
        }
        return !1;
      }, Kt.updateContext = function(g) {
        var T, ee = this.type;
        ee.keyword && g === w.dot ? this.exprAllowed = !1 : (T = ee.updateContext) ? T.call(this, g) : this.exprAllowed = ee.beforeExpr;
      }, Kt.overrideContext = function(g) {
        this.curContext() !== g && (this.context[this.context.length - 1] = g);
      }, w.parenR.updateContext = w.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = !0;
          return;
        }
        var g = this.context.pop();
        g === Ct.b_stat && this.curContext().token === "function" && (g = this.context.pop()), this.exprAllowed = !g.isExpr;
      }, w.braceL.updateContext = function(g) {
        this.context.push(this.braceIsBlock(g) ? Ct.b_stat : Ct.b_expr), this.exprAllowed = !0;
      }, w.dollarBraceL.updateContext = function() {
        this.context.push(Ct.b_tmpl), this.exprAllowed = !0;
      }, w.parenL.updateContext = function(g) {
        var T = g === w._if || g === w._for || g === w._with || g === w._while;
        this.context.push(T ? Ct.p_stat : Ct.p_expr), this.exprAllowed = !0;
      }, w.incDec.updateContext = function() {
      }, w._function.updateContext = w._class.updateContext = function(g) {
        g.beforeExpr && g !== w._else && !(g === w.semi && this.curContext() !== Ct.p_stat) && !(g === w._return && C.test(this.input.slice(this.lastTokEnd, this.start))) && !((g === w.colon || g === w.braceL) && this.curContext() === Ct.b_stat) ? this.context.push(Ct.f_expr) : this.context.push(Ct.f_stat), this.exprAllowed = !1;
      }, w.colon.updateContext = function() {
        this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
      }, w.backQuote.updateContext = function() {
        this.curContext() === Ct.q_tmpl ? this.context.pop() : this.context.push(Ct.q_tmpl), this.exprAllowed = !1;
      }, w.star.updateContext = function(g) {
        if (g === w._function) {
          var T = this.context.length - 1;
          this.context[T] === Ct.f_expr ? this.context[T] = Ct.f_expr_gen : this.context[T] = Ct.f_gen;
        }
        this.exprAllowed = !0;
      }, w.name.updateContext = function(g) {
        var T = !1;
        this.options.ecmaVersion >= 6 && g !== w.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (T = !0), this.exprAllowed = T;
      };
      var ct = te.prototype;
      ct.checkPropClash = function(g, T, ee) {
        if (!(this.options.ecmaVersion >= 9 && g.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (g.computed || g.method || g.shorthand))) {
          var fe = g.key, j;
          switch (fe.type) {
            case "Identifier":
              j = fe.name;
              break;
            case "Literal":
              j = String(fe.value);
              break;
            default:
              return;
          }
          var de = g.kind;
          if (this.options.ecmaVersion >= 6) {
            j === "__proto__" && de === "init" && (T.proto && (ee ? ee.doubleProto < 0 && (ee.doubleProto = fe.start) : this.raiseRecoverable(fe.start, "Redefinition of __proto__ property")), T.proto = !0);
            return;
          }
          j = "$" + j;
          var _e = T[j];
          if (_e) {
            var Le;
            de === "init" ? Le = this.strict && _e.init || _e.get || _e.set : Le = _e.init || _e[de], Le && this.raiseRecoverable(fe.start, "Redefinition of property");
          } else
            _e = T[j] = {
              init: !1,
              get: !1,
              set: !1
            };
          _e[de] = !0;
        }
      }, ct.parseExpression = function(g, T) {
        var ee = this.start, fe = this.startLoc, j = this.parseMaybeAssign(g, T);
        if (this.type === w.comma) {
          var de = this.startNodeAt(ee, fe);
          for (de.expressions = [j]; this.eat(w.comma); )
            de.expressions.push(this.parseMaybeAssign(g, T));
          return this.finishNode(de, "SequenceExpression");
        }
        return j;
      }, ct.parseMaybeAssign = function(g, T, ee) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(g);
          this.exprAllowed = !1;
        }
        var fe = !1, j = -1, de = -1, _e = -1;
        T ? (j = T.parenthesizedAssign, de = T.trailingComma, _e = T.doubleProto, T.parenthesizedAssign = T.trailingComma = -1) : (T = new xt(), fe = !0);
        var Le = this.start, et = this.startLoc;
        (this.type === w.parenL || this.type === w.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = g === "await");
        var vt = this.parseMaybeConditional(g, T);
        if (ee && (vt = ee.call(this, vt, Le, et)), this.type.isAssign) {
          var Wt = this.startNodeAt(Le, et);
          return Wt.operator = this.value, this.type === w.eq && (vt = this.toAssignable(vt, !1, T)), fe || (T.parenthesizedAssign = T.trailingComma = T.doubleProto = -1), T.shorthandAssign >= vt.start && (T.shorthandAssign = -1), this.type === w.eq ? this.checkLValPattern(vt) : this.checkLValSimple(vt), Wt.left = vt, this.next(), Wt.right = this.parseMaybeAssign(g), _e > -1 && (T.doubleProto = _e), this.finishNode(Wt, "AssignmentExpression");
        } else
          fe && this.checkExpressionErrors(T, !0);
        return j > -1 && (T.parenthesizedAssign = j), de > -1 && (T.trailingComma = de), vt;
      }, ct.parseMaybeConditional = function(g, T) {
        var ee = this.start, fe = this.startLoc, j = this.parseExprOps(g, T);
        if (this.checkExpressionErrors(T))
          return j;
        if (this.eat(w.question)) {
          var de = this.startNodeAt(ee, fe);
          return de.test = j, de.consequent = this.parseMaybeAssign(), this.expect(w.colon), de.alternate = this.parseMaybeAssign(g), this.finishNode(de, "ConditionalExpression");
        }
        return j;
      }, ct.parseExprOps = function(g, T) {
        var ee = this.start, fe = this.startLoc, j = this.parseMaybeUnary(T, !1, !1, g);
        return this.checkExpressionErrors(T) || j.start === ee && j.type === "ArrowFunctionExpression" ? j : this.parseExprOp(j, ee, fe, -1, g);
      }, ct.parseExprOp = function(g, T, ee, fe, j) {
        var de = this.type.binop;
        if (de != null && (!j || this.type !== w._in) && de > fe) {
          var _e = this.type === w.logicalOR || this.type === w.logicalAND, Le = this.type === w.coalesce;
          Le && (de = w.logicalAND.binop);
          var et = this.value;
          this.next();
          var vt = this.start, Wt = this.startLoc, en = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, j), vt, Wt, de, j), pi = this.buildBinary(T, ee, g, en, et, _e || Le);
          return (_e && this.type === w.coalesce || Le && (this.type === w.logicalOR || this.type === w.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(pi, T, ee, fe, j);
        }
        return g;
      }, ct.buildBinary = function(g, T, ee, fe, j, de) {
        fe.type === "PrivateIdentifier" && this.raise(fe.start, "Private identifier can only be left side of binary expression");
        var _e = this.startNodeAt(g, T);
        return _e.left = ee, _e.operator = j, _e.right = fe, this.finishNode(_e, de ? "LogicalExpression" : "BinaryExpression");
      }, ct.parseMaybeUnary = function(g, T, ee, fe) {
        var j = this.start, de = this.startLoc, _e;
        if (this.isContextual("await") && this.canAwait)
          _e = this.parseAwait(fe), T = !0;
        else if (this.type.prefix) {
          var Le = this.startNode(), et = this.type === w.incDec;
          Le.operator = this.value, Le.prefix = !0, this.next(), Le.argument = this.parseMaybeUnary(null, !0, et, fe), this.checkExpressionErrors(g, !0), et ? this.checkLValSimple(Le.argument) : this.strict && Le.operator === "delete" && ir(Le.argument) ? this.raiseRecoverable(Le.start, "Deleting local variable in strict mode") : Le.operator === "delete" && xr(Le.argument) ? this.raiseRecoverable(Le.start, "Private fields can not be deleted") : T = !0, _e = this.finishNode(Le, et ? "UpdateExpression" : "UnaryExpression");
        } else if (!T && this.type === w.privateId)
          (fe || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), _e = this.parsePrivateIdent(), this.type !== w._in && this.unexpected();
        else {
          if (_e = this.parseExprSubscripts(g, fe), this.checkExpressionErrors(g))
            return _e;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var vt = this.startNodeAt(j, de);
            vt.operator = this.value, vt.prefix = !1, vt.argument = _e, this.checkLValSimple(_e), this.next(), _e = this.finishNode(vt, "UpdateExpression");
          }
        }
        if (!ee && this.eat(w.starstar))
          if (T)
            this.unexpected(this.lastTokStart);
          else
            return this.buildBinary(j, de, _e, this.parseMaybeUnary(null, !1, !1, fe), "**", !1);
        else
          return _e;
      };
      function ir(g) {
        return g.type === "Identifier" || g.type === "ParenthesizedExpression" && ir(g.expression);
      }
      function xr(g) {
        return g.type === "MemberExpression" && g.property.type === "PrivateIdentifier" || g.type === "ChainExpression" && xr(g.expression) || g.type === "ParenthesizedExpression" && xr(g.expression);
      }
      ct.parseExprSubscripts = function(g, T) {
        var ee = this.start, fe = this.startLoc, j = this.parseExprAtom(g, T);
        if (j.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return j;
        var de = this.parseSubscripts(j, ee, fe, !1, T);
        return g && de.type === "MemberExpression" && (g.parenthesizedAssign >= de.start && (g.parenthesizedAssign = -1), g.parenthesizedBind >= de.start && (g.parenthesizedBind = -1), g.trailingComma >= de.start && (g.trailingComma = -1)), de;
      }, ct.parseSubscripts = function(g, T, ee, fe, j) {
        for (var de = this.options.ecmaVersion >= 8 && g.type === "Identifier" && g.name === "async" && this.lastTokEnd === g.end && !this.canInsertSemicolon() && g.end - g.start === 5 && this.potentialArrowAt === g.start, _e = !1; ; ) {
          var Le = this.parseSubscript(g, T, ee, fe, de, _e, j);
          if (Le.optional && (_e = !0), Le === g || Le.type === "ArrowFunctionExpression") {
            if (_e) {
              var et = this.startNodeAt(T, ee);
              et.expression = Le, Le = this.finishNode(et, "ChainExpression");
            }
            return Le;
          }
          g = Le;
        }
      }, ct.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(w.arrow);
      }, ct.parseSubscriptAsyncArrow = function(g, T, ee, fe) {
        return this.parseArrowExpression(this.startNodeAt(g, T), ee, !0, fe);
      }, ct.parseSubscript = function(g, T, ee, fe, j, de, _e) {
        var Le = this.options.ecmaVersion >= 11, et = Le && this.eat(w.questionDot);
        fe && et && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var vt = this.eat(w.bracketL);
        if (vt || et && this.type !== w.parenL && this.type !== w.backQuote || this.eat(w.dot)) {
          var Wt = this.startNodeAt(T, ee);
          Wt.object = g, vt ? (Wt.property = this.parseExpression(), this.expect(w.bracketR)) : this.type === w.privateId && g.type !== "Super" ? Wt.property = this.parsePrivateIdent() : Wt.property = this.parseIdent(this.options.allowReserved !== "never"), Wt.computed = !!vt, Le && (Wt.optional = et), g = this.finishNode(Wt, "MemberExpression");
        } else if (!fe && this.eat(w.parenL)) {
          var en = new xt(), pi = this.yieldPos, it = this.awaitPos, Tt = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var rr = this.parseExprList(w.parenR, this.options.ecmaVersion >= 8, !1, en);
          if (j && !et && this.shouldParseAsyncArrow())
            return this.checkPatternErrors(en, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = pi, this.awaitPos = it, this.awaitIdentPos = Tt, this.parseSubscriptAsyncArrow(T, ee, rr, _e);
          this.checkExpressionErrors(en, !0), this.yieldPos = pi || this.yieldPos, this.awaitPos = it || this.awaitPos, this.awaitIdentPos = Tt || this.awaitIdentPos;
          var Xt = this.startNodeAt(T, ee);
          Xt.callee = g, Xt.arguments = rr, Le && (Xt.optional = et), g = this.finishNode(Xt, "CallExpression");
        } else if (this.type === w.backQuote) {
          (et || de) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var Dt = this.startNodeAt(T, ee);
          Dt.tag = g, Dt.quasi = this.parseTemplate({ isTagged: !0 }), g = this.finishNode(Dt, "TaggedTemplateExpression");
        }
        return g;
      }, ct.parseExprAtom = function(g, T, ee) {
        this.type === w.slash && this.readRegexp();
        var fe, j = this.potentialArrowAt === this.start;
        switch (this.type) {
          case w._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), fe = this.startNode(), this.next(), this.type === w.parenL && !this.allowDirectSuper && this.raise(fe.start, "super() call outside constructor of a subclass"), this.type !== w.dot && this.type !== w.bracketL && this.type !== w.parenL && this.unexpected(), this.finishNode(fe, "Super");
          case w._this:
            return fe = this.startNode(), this.next(), this.finishNode(fe, "ThisExpression");
          case w.name:
            var de = this.start, _e = this.startLoc, Le = this.containsEsc, et = this.parseIdent(!1);
            if (this.options.ecmaVersion >= 8 && !Le && et.name === "async" && !this.canInsertSemicolon() && this.eat(w._function))
              return this.overrideContext(Ct.f_expr), this.parseFunction(this.startNodeAt(de, _e), 0, !1, !0, T);
            if (j && !this.canInsertSemicolon()) {
              if (this.eat(w.arrow))
                return this.parseArrowExpression(this.startNodeAt(de, _e), [et], !1, T);
              if (this.options.ecmaVersion >= 8 && et.name === "async" && this.type === w.name && !Le && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                return et = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(w.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(de, _e), [et], !0, T);
            }
            return et;
          case w.regexp:
            var vt = this.value;
            return fe = this.parseLiteral(vt.value), fe.regex = { pattern: vt.pattern, flags: vt.flags }, fe;
          case w.num:
          case w.string:
            return this.parseLiteral(this.value);
          case w._null:
          case w._true:
          case w._false:
            return fe = this.startNode(), fe.value = this.type === w._null ? null : this.type === w._true, fe.raw = this.type.keyword, this.next(), this.finishNode(fe, "Literal");
          case w.parenL:
            var Wt = this.start, en = this.parseParenAndDistinguishExpression(j, T);
            return g && (g.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(en) && (g.parenthesizedAssign = Wt), g.parenthesizedBind < 0 && (g.parenthesizedBind = Wt)), en;
          case w.bracketL:
            return fe = this.startNode(), this.next(), fe.elements = this.parseExprList(w.bracketR, !0, !0, g), this.finishNode(fe, "ArrayExpression");
          case w.braceL:
            return this.overrideContext(Ct.b_expr), this.parseObj(!1, g);
          case w._function:
            return fe = this.startNode(), this.next(), this.parseFunction(fe, 0);
          case w._class:
            return this.parseClass(this.startNode(), !1);
          case w._new:
            return this.parseNew();
          case w.backQuote:
            return this.parseTemplate();
          case w._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(ee) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }, ct.parseExprAtomDefault = function() {
        this.unexpected();
      }, ct.parseExprImport = function(g) {
        var T = this.startNode();
        if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === w.parenL && !g)
          return this.parseDynamicImport(T);
        if (this.type === w.dot) {
          var ee = this.startNodeAt(T.start, T.loc && T.loc.start);
          return ee.name = "import", T.meta = this.finishNode(ee, "Identifier"), this.parseImportMeta(T);
        } else
          this.unexpected();
      }, ct.parseDynamicImport = function(g) {
        if (this.next(), g.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
          this.eat(w.parenR) ? g.options = null : (this.expect(w.comma), this.afterTrailingComma(w.parenR) ? g.options = null : (g.options = this.parseMaybeAssign(), this.eat(w.parenR) || (this.expect(w.comma), this.afterTrailingComma(w.parenR) || this.unexpected())));
        else if (!this.eat(w.parenR)) {
          var T = this.start;
          this.eat(w.comma) && this.eat(w.parenR) ? this.raiseRecoverable(T, "Trailing comma is not allowed in import()") : this.unexpected(T);
        }
        return this.finishNode(g, "ImportExpression");
      }, ct.parseImportMeta = function(g) {
        this.next();
        var T = this.containsEsc;
        return g.property = this.parseIdent(!0), g.property.name !== "meta" && this.raiseRecoverable(g.property.start, "The only valid meta property for import is 'import.meta'"), T && this.raiseRecoverable(g.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(g.start, "Cannot use 'import.meta' outside a module"), this.finishNode(g, "MetaProperty");
      }, ct.parseLiteral = function(g) {
        var T = this.startNode();
        return T.value = g, T.raw = this.input.slice(this.start, this.end), T.raw.charCodeAt(T.raw.length - 1) === 110 && (T.bigint = T.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(T, "Literal");
      }, ct.parseParenExpression = function() {
        this.expect(w.parenL);
        var g = this.parseExpression();
        return this.expect(w.parenR), g;
      }, ct.shouldParseArrow = function(g) {
        return !this.canInsertSemicolon();
      }, ct.parseParenAndDistinguishExpression = function(g, T) {
        var ee = this.start, fe = this.startLoc, j, de = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var _e = this.start, Le = this.startLoc, et = [], vt = !0, Wt = !1, en = new xt(), pi = this.yieldPos, it = this.awaitPos, Tt;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== w.parenR; )
            if (vt ? vt = !1 : this.expect(w.comma), de && this.afterTrailingComma(w.parenR, !0)) {
              Wt = !0;
              break;
            } else if (this.type === w.ellipsis) {
              Tt = this.start, et.push(this.parseParenItem(this.parseRestBinding())), this.type === w.comma && this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
              break;
            } else
              et.push(this.parseMaybeAssign(!1, en, this.parseParenItem));
          var rr = this.lastTokEnd, Xt = this.lastTokEndLoc;
          if (this.expect(w.parenR), g && this.shouldParseArrow(et) && this.eat(w.arrow))
            return this.checkPatternErrors(en, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = pi, this.awaitPos = it, this.parseParenArrowList(ee, fe, et, T);
          (!et.length || Wt) && this.unexpected(this.lastTokStart), Tt && this.unexpected(Tt), this.checkExpressionErrors(en, !0), this.yieldPos = pi || this.yieldPos, this.awaitPos = it || this.awaitPos, et.length > 1 ? (j = this.startNodeAt(_e, Le), j.expressions = et, this.finishNodeAt(j, "SequenceExpression", rr, Xt)) : j = et[0];
        } else
          j = this.parseParenExpression();
        if (this.options.preserveParens) {
          var Dt = this.startNodeAt(ee, fe);
          return Dt.expression = j, this.finishNode(Dt, "ParenthesizedExpression");
        } else
          return j;
      }, ct.parseParenItem = function(g) {
        return g;
      }, ct.parseParenArrowList = function(g, T, ee, fe) {
        return this.parseArrowExpression(this.startNodeAt(g, T), ee, !1, fe);
      };
      var Rr = [];
      ct.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var g = this.startNode();
        if (this.next(), this.options.ecmaVersion >= 6 && this.type === w.dot) {
          var T = this.startNodeAt(g.start, g.loc && g.loc.start);
          T.name = "new", g.meta = this.finishNode(T, "Identifier"), this.next();
          var ee = this.containsEsc;
          return g.property = this.parseIdent(!0), g.property.name !== "target" && this.raiseRecoverable(g.property.start, "The only valid meta property for new is 'new.target'"), ee && this.raiseRecoverable(g.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(g.start, "'new.target' can only be used in functions and class static block"), this.finishNode(g, "MetaProperty");
        }
        var fe = this.start, j = this.startLoc;
        return g.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), fe, j, !0, !1), this.eat(w.parenL) ? g.arguments = this.parseExprList(w.parenR, this.options.ecmaVersion >= 8, !1) : g.arguments = Rr, this.finishNode(g, "NewExpression");
      }, ct.parseTemplateElement = function(g) {
        var T = g.isTagged, ee = this.startNode();
        return this.type === w.invalidTemplate ? (T || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), ee.value = {
          raw: this.value.replace(/\r\n?/g, `
`),
          cooked: null
        }) : ee.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), ee.tail = this.type === w.backQuote, this.finishNode(ee, "TemplateElement");
      }, ct.parseTemplate = function(g) {
        g === void 0 && (g = {});
        var T = g.isTagged;
        T === void 0 && (T = !1);
        var ee = this.startNode();
        this.next(), ee.expressions = [];
        var fe = this.parseTemplateElement({ isTagged: T });
        for (ee.quasis = [fe]; !fe.tail; )
          this.type === w.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(w.dollarBraceL), ee.expressions.push(this.parseExpression()), this.expect(w.braceR), ee.quasis.push(fe = this.parseTemplateElement({ isTagged: T }));
        return this.next(), this.finishNode(ee, "TemplateLiteral");
      }, ct.isAsyncProp = function(g) {
        return !g.computed && g.key.type === "Identifier" && g.key.name === "async" && (this.type === w.name || this.type === w.num || this.type === w.string || this.type === w.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === w.star) && !C.test(this.input.slice(this.lastTokEnd, this.start));
      }, ct.parseObj = function(g, T) {
        var ee = this.startNode(), fe = !0, j = {};
        for (ee.properties = [], this.next(); !this.eat(w.braceR); ) {
          if (fe)
            fe = !1;
          else if (this.expect(w.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(w.braceR))
            break;
          var de = this.parseProperty(g, T);
          g || this.checkPropClash(de, j, T), ee.properties.push(de);
        }
        return this.finishNode(ee, g ? "ObjectPattern" : "ObjectExpression");
      }, ct.parseProperty = function(g, T) {
        var ee = this.startNode(), fe, j, de, _e;
        if (this.options.ecmaVersion >= 9 && this.eat(w.ellipsis))
          return g ? (ee.argument = this.parseIdent(!1), this.type === w.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(ee, "RestElement")) : (ee.argument = this.parseMaybeAssign(!1, T), this.type === w.comma && T && T.trailingComma < 0 && (T.trailingComma = this.start), this.finishNode(ee, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (ee.method = !1, ee.shorthand = !1, (g || T) && (de = this.start, _e = this.startLoc), g || (fe = this.eat(w.star)));
        var Le = this.containsEsc;
        return this.parsePropertyName(ee), !g && !Le && this.options.ecmaVersion >= 8 && !fe && this.isAsyncProp(ee) ? (j = !0, fe = this.options.ecmaVersion >= 9 && this.eat(w.star), this.parsePropertyName(ee)) : j = !1, this.parsePropertyValue(ee, g, fe, j, de, _e, T, Le), this.finishNode(ee, "Property");
      }, ct.parseGetterSetter = function(g) {
        g.kind = g.key.name, this.parsePropertyName(g), g.value = this.parseMethod(!1);
        var T = g.kind === "get" ? 0 : 1;
        if (g.value.params.length !== T) {
          var ee = g.value.start;
          g.kind === "get" ? this.raiseRecoverable(ee, "getter should have no params") : this.raiseRecoverable(ee, "setter should have exactly one param");
        } else
          g.kind === "set" && g.value.params[0].type === "RestElement" && this.raiseRecoverable(g.value.params[0].start, "Setter cannot use rest params");
      }, ct.parsePropertyValue = function(g, T, ee, fe, j, de, _e, Le) {
        (ee || fe) && this.type === w.colon && this.unexpected(), this.eat(w.colon) ? (g.value = T ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, _e), g.kind = "init") : this.options.ecmaVersion >= 6 && this.type === w.parenL ? (T && this.unexpected(), g.kind = "init", g.method = !0, g.value = this.parseMethod(ee, fe)) : !T && !Le && this.options.ecmaVersion >= 5 && !g.computed && g.key.type === "Identifier" && (g.key.name === "get" || g.key.name === "set") && this.type !== w.comma && this.type !== w.braceR && this.type !== w.eq ? ((ee || fe) && this.unexpected(), this.parseGetterSetter(g)) : this.options.ecmaVersion >= 6 && !g.computed && g.key.type === "Identifier" ? ((ee || fe) && this.unexpected(), this.checkUnreserved(g.key), g.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = j), g.kind = "init", T ? g.value = this.parseMaybeDefault(j, de, this.copyNode(g.key)) : this.type === w.eq && _e ? (_e.shorthandAssign < 0 && (_e.shorthandAssign = this.start), g.value = this.parseMaybeDefault(j, de, this.copyNode(g.key))) : g.value = this.copyNode(g.key), g.shorthand = !0) : this.unexpected();
      }, ct.parsePropertyName = function(g) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(w.bracketL))
            return g.computed = !0, g.key = this.parseMaybeAssign(), this.expect(w.bracketR), g.key;
          g.computed = !1;
        }
        return g.key = this.type === w.num || this.type === w.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, ct.initFunction = function(g) {
        g.id = null, this.options.ecmaVersion >= 6 && (g.generator = g.expression = !1), this.options.ecmaVersion >= 8 && (g.async = !1);
      }, ct.parseMethod = function(g, T, ee) {
        var fe = this.startNode(), j = this.yieldPos, de = this.awaitPos, _e = this.awaitIdentPos;
        return this.initFunction(fe), this.options.ecmaVersion >= 6 && (fe.generator = g), this.options.ecmaVersion >= 8 && (fe.async = !!T), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(H(T, fe.generator) | Pe | (ee ? z : 0)), this.expect(w.parenL), fe.params = this.parseBindingList(w.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(fe, !1, !0, !1), this.yieldPos = j, this.awaitPos = de, this.awaitIdentPos = _e, this.finishNode(fe, "FunctionExpression");
      }, ct.parseArrowExpression = function(g, T, ee, fe) {
        var j = this.yieldPos, de = this.awaitPos, _e = this.awaitIdentPos;
        return this.enterScope(H(ee, !1) | Te), this.initFunction(g), this.options.ecmaVersion >= 8 && (g.async = !!ee), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, g.params = this.toAssignableList(T, !0), this.parseFunctionBody(g, !0, !1, fe), this.yieldPos = j, this.awaitPos = de, this.awaitIdentPos = _e, this.finishNode(g, "ArrowFunctionExpression");
      }, ct.parseFunctionBody = function(g, T, ee, fe) {
        var j = T && this.type !== w.braceL, de = this.strict, _e = !1;
        if (j)
          g.body = this.parseMaybeAssign(fe), g.expression = !0, this.checkParams(g, !1);
        else {
          var Le = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(g.params);
          (!de || Le) && (_e = this.strictDirective(this.end), _e && Le && this.raiseRecoverable(g.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var et = this.labels;
          this.labels = [], _e && (this.strict = !0), this.checkParams(g, !de && !_e && !T && !ee && this.isSimpleParamList(g.params)), this.strict && g.id && this.checkLValSimple(g.id, we), g.body = this.parseBlock(!1, void 0, _e && !de), g.expression = !1, this.adaptDirectivePrologue(g.body.body), this.labels = et;
        }
        this.exitScope();
      }, ct.isSimpleParamList = function(g) {
        for (var T = 0, ee = g; T < ee.length; T += 1) {
          var fe = ee[T];
          if (fe.type !== "Identifier")
            return !1;
        }
        return !0;
      }, ct.checkParams = function(g, T) {
        for (var ee = /* @__PURE__ */ Object.create(null), fe = 0, j = g.params; fe < j.length; fe += 1) {
          var de = j[fe];
          this.checkLValInnerPattern(de, me, T ? null : ee);
        }
      }, ct.parseExprList = function(g, T, ee, fe) {
        for (var j = [], de = !0; !this.eat(g); ) {
          if (de)
            de = !1;
          else if (this.expect(w.comma), T && this.afterTrailingComma(g))
            break;
          var _e = void 0;
          ee && this.type === w.comma ? _e = null : this.type === w.ellipsis ? (_e = this.parseSpread(fe), fe && this.type === w.comma && fe.trailingComma < 0 && (fe.trailingComma = this.start)) : _e = this.parseMaybeAssign(!1, fe), j.push(_e);
        }
        return j;
      }, ct.checkUnreserved = function(g) {
        var T = g.start, ee = g.end, fe = g.name;
        if (this.inGenerator && fe === "yield" && this.raiseRecoverable(T, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && fe === "await" && this.raiseRecoverable(T, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && fe === "arguments" && this.raiseRecoverable(T, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (fe === "arguments" || fe === "await") && this.raise(T, "Cannot use " + fe + " in class static initialization block"), this.keywords.test(fe) && this.raise(T, "Unexpected keyword '" + fe + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(T, ee).indexOf("\\") !== -1)) {
          var j = this.strict ? this.reservedWordsStrict : this.reservedWords;
          j.test(fe) && (!this.inAsync && fe === "await" && this.raiseRecoverable(T, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(T, "The keyword '" + fe + "' is reserved"));
        }
      }, ct.parseIdent = function(g) {
        var T = this.parseIdentNode();
        return this.next(!!g), this.finishNode(T, "Identifier"), g || (this.checkUnreserved(T), T.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = T.start)), T;
      }, ct.parseIdentNode = function() {
        var g = this.startNode();
        return this.type === w.name ? g.name = this.value : this.type.keyword ? (g.name = this.type.keyword, (g.name === "class" || g.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = w.name) : this.unexpected(), g;
      }, ct.parsePrivateIdent = function() {
        var g = this.startNode();
        return this.type === w.privateId ? g.name = this.value : this.unexpected(), this.next(), this.finishNode(g, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(g.start, "Private field '#" + g.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(g)), g;
      }, ct.parseYield = function(g) {
        this.yieldPos || (this.yieldPos = this.start);
        var T = this.startNode();
        return this.next(), this.type === w.semi || this.canInsertSemicolon() || this.type !== w.star && !this.type.startsExpr ? (T.delegate = !1, T.argument = null) : (T.delegate = this.eat(w.star), T.argument = this.parseMaybeAssign(g)), this.finishNode(T, "YieldExpression");
      }, ct.parseAwait = function(g) {
        this.awaitPos || (this.awaitPos = this.start);
        var T = this.startNode();
        return this.next(), T.argument = this.parseMaybeUnary(null, !0, !1, g), this.finishNode(T, "AwaitExpression");
      };
      var Nt = te.prototype;
      Nt.raise = function(g, T) {
        var ee = he(this.input, g);
        T += " (" + ee.line + ":" + ee.column + ")";
        var fe = new SyntaxError(T);
        throw fe.pos = g, fe.loc = ee, fe.raisedAt = this.pos, fe;
      }, Nt.raiseRecoverable = Nt.raise, Nt.curPosition = function() {
        if (this.options.locations)
          return new G(this.curLine, this.pos - this.lineStart);
      };
      var dr = te.prototype, $e = function(T) {
        this.flags = T, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
      };
      dr.enterScope = function(g) {
        this.scopeStack.push(new $e(g));
      }, dr.exitScope = function() {
        this.scopeStack.pop();
      }, dr.treatFunctionsAsVarInScope = function(g) {
        return g.flags & ce || !this.inModule && g.flags & ge;
      }, dr.declareName = function(g, T, ee) {
        var fe = !1;
        if (T === Ce) {
          var j = this.currentScope();
          fe = j.lexical.indexOf(g) > -1 || j.functions.indexOf(g) > -1 || j.var.indexOf(g) > -1, j.lexical.push(g), this.inModule && j.flags & ge && delete this.undefinedExports[g];
        } else if (T === xe) {
          var de = this.currentScope();
          de.lexical.push(g);
        } else if (T === We) {
          var _e = this.currentScope();
          this.treatFunctionsAsVar ? fe = _e.lexical.indexOf(g) > -1 : fe = _e.lexical.indexOf(g) > -1 || _e.var.indexOf(g) > -1, _e.functions.push(g);
        } else
          for (var Le = this.scopeStack.length - 1; Le >= 0; --Le) {
            var et = this.scopeStack[Le];
            if (et.lexical.indexOf(g) > -1 && !(et.flags & V && et.lexical[0] === g) || !this.treatFunctionsAsVarInScope(et) && et.functions.indexOf(g) > -1) {
              fe = !0;
              break;
            }
            if (et.var.push(g), this.inModule && et.flags & ge && delete this.undefinedExports[g], et.flags & R)
              break;
          }
        fe && this.raiseRecoverable(ee, "Identifier '" + g + "' has already been declared");
      }, dr.checkLocalExport = function(g) {
        this.scopeStack[0].lexical.indexOf(g.name) === -1 && this.scopeStack[0].var.indexOf(g.name) === -1 && (this.undefinedExports[g.name] = g);
      }, dr.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, dr.currentVarScope = function() {
        for (var g = this.scopeStack.length - 1; ; g--) {
          var T = this.scopeStack[g];
          if (T.flags & R)
            return T;
        }
      }, dr.currentThisScope = function() {
        for (var g = this.scopeStack.length - 1; ; g--) {
          var T = this.scopeStack[g];
          if (T.flags & R && !(T.flags & Te))
            return T;
        }
      };
      var at = function(T, ee, fe) {
        this.type = "", this.start = ee, this.end = 0, T.options.locations && (this.loc = new P(T, fe)), T.options.directSourceFile && (this.sourceFile = T.options.directSourceFile), T.options.ranges && (this.range = [ee, 0]);
      }, Rt = te.prototype;
      Rt.startNode = function() {
        return new at(this, this.start, this.startLoc);
      }, Rt.startNodeAt = function(g, T) {
        return new at(this, g, T);
      };
      function sr(g, T, ee, fe) {
        return g.type = T, g.end = ee, this.options.locations && (g.loc.end = fe), this.options.ranges && (g.range[1] = ee), g;
      }
      Rt.finishNode = function(g, T) {
        return sr.call(this, g, T, this.lastTokEnd, this.lastTokEndLoc);
      }, Rt.finishNodeAt = function(g, T, ee, fe) {
        return sr.call(this, g, T, ee, fe);
      }, Rt.copyNode = function(g) {
        var T = new at(this, g.start, this.startLoc);
        for (var ee in g)
          T[ee] = g[ee];
        return T;
      };
      var bt = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", Ur = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", or = Ur + " Extended_Pictographic", Ae = or, Ve = Ae + " EBase EComp EMod EPres ExtPict", Ge = Ve, lr = Ge, br = {
        9: Ur,
        10: or,
        11: Ae,
        12: Ve,
        13: Ge,
        14: lr
      }, Ut = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", cn = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: Ut
      }, Re = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", J = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", He = J + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", fr = He + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Mr = fr + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", ut = Mr + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", qn = ut + " " + bt, En = {
        9: J,
        10: He,
        11: fr,
        12: Mr,
        13: ut,
        14: qn
      }, yi = {};
      function Yi(g) {
        var T = yi[g] = {
          binary: le(br[g] + " " + Re),
          binaryOfStrings: le(cn[g]),
          nonBinary: {
            General_Category: le(Re),
            Script: le(En[g])
          }
        };
        T.nonBinary.Script_Extensions = T.nonBinary.Script, T.nonBinary.gc = T.nonBinary.General_Category, T.nonBinary.sc = T.nonBinary.Script, T.nonBinary.scx = T.nonBinary.Script_Extensions;
      }
      for (var Xi = 0, mn = [9, 10, 11, 12, 13, 14]; Xi < mn.length; Xi += 1) {
        var Ri = mn[Xi];
        Yi(Ri);
      }
      var Ht = te.prototype, jt = function(T, ee) {
        this.parent = T, this.base = ee || this;
      };
      jt.prototype.separatedFrom = function(T) {
        for (var ee = this; ee; ee = ee.parent)
          for (var fe = T; fe; fe = fe.parent)
            if (ee.base === fe.base && ee !== fe)
              return !0;
        return !1;
      }, jt.prototype.sibling = function() {
        return new jt(this.parent, this.base);
      };
      var jn = function(T) {
        this.parser = T, this.validFlags = "gim" + (T.options.ecmaVersion >= 6 ? "uy" : "") + (T.options.ecmaVersion >= 9 ? "s" : "") + (T.options.ecmaVersion >= 13 ? "d" : "") + (T.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = yi[T.options.ecmaVersion >= 14 ? 14 : T.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
      };
      jn.prototype.reset = function(T, ee, fe) {
        var j = fe.indexOf("v") !== -1, de = fe.indexOf("u") !== -1;
        this.start = T | 0, this.source = ee + "", this.flags = fe, j && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = de && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = de && this.parser.options.ecmaVersion >= 9);
      }, jn.prototype.raise = function(T) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + T);
      }, jn.prototype.at = function(T, ee) {
        ee === void 0 && (ee = !1);
        var fe = this.source, j = fe.length;
        if (T >= j)
          return -1;
        var de = fe.charCodeAt(T);
        if (!(ee || this.switchU) || de <= 55295 || de >= 57344 || T + 1 >= j)
          return de;
        var _e = fe.charCodeAt(T + 1);
        return _e >= 56320 && _e <= 57343 ? (de << 10) + _e - 56613888 : de;
      }, jn.prototype.nextIndex = function(T, ee) {
        ee === void 0 && (ee = !1);
        var fe = this.source, j = fe.length;
        if (T >= j)
          return j;
        var de = fe.charCodeAt(T), _e;
        return !(ee || this.switchU) || de <= 55295 || de >= 57344 || T + 1 >= j || (_e = fe.charCodeAt(T + 1)) < 56320 || _e > 57343 ? T + 1 : T + 2;
      }, jn.prototype.current = function(T) {
        return T === void 0 && (T = !1), this.at(this.pos, T);
      }, jn.prototype.lookahead = function(T) {
        return T === void 0 && (T = !1), this.at(this.nextIndex(this.pos, T), T);
      }, jn.prototype.advance = function(T) {
        T === void 0 && (T = !1), this.pos = this.nextIndex(this.pos, T);
      }, jn.prototype.eat = function(T, ee) {
        return ee === void 0 && (ee = !1), this.current(ee) === T ? (this.advance(ee), !0) : !1;
      }, jn.prototype.eatChars = function(T, ee) {
        ee === void 0 && (ee = !1);
        for (var fe = this.pos, j = 0, de = T; j < de.length; j += 1) {
          var _e = de[j], Le = this.at(fe, ee);
          if (Le === -1 || Le !== _e)
            return !1;
          fe = this.nextIndex(fe, ee);
        }
        return this.pos = fe, !0;
      }, Ht.validateRegExpFlags = function(g) {
        for (var T = g.validFlags, ee = g.flags, fe = !1, j = !1, de = 0; de < ee.length; de++) {
          var _e = ee.charAt(de);
          T.indexOf(_e) === -1 && this.raise(g.start, "Invalid regular expression flag"), ee.indexOf(_e, de + 1) > -1 && this.raise(g.start, "Duplicate regular expression flag"), _e === "u" && (fe = !0), _e === "v" && (j = !0);
        }
        this.options.ecmaVersion >= 15 && fe && j && this.raise(g.start, "Invalid regular expression flag");
      };
      function Ii(g) {
        for (var T in g)
          return !0;
        return !1;
      }
      Ht.validateRegExpPattern = function(g) {
        this.regexp_pattern(g), !g.switchN && this.options.ecmaVersion >= 9 && Ii(g.groupNames) && (g.switchN = !0, this.regexp_pattern(g));
      }, Ht.regexp_pattern = function(g) {
        g.pos = 0, g.lastIntValue = 0, g.lastStringValue = "", g.lastAssertionIsQuantifiable = !1, g.numCapturingParens = 0, g.maxBackReference = 0, g.groupNames = /* @__PURE__ */ Object.create(null), g.backReferenceNames.length = 0, g.branchID = null, this.regexp_disjunction(g), g.pos !== g.source.length && (g.eat(
          41
          /* ) */
        ) && g.raise("Unmatched ')'"), (g.eat(
          93
          /* ] */
        ) || g.eat(
          125
          /* } */
        )) && g.raise("Lone quantifier brackets")), g.maxBackReference > g.numCapturingParens && g.raise("Invalid escape");
        for (var T = 0, ee = g.backReferenceNames; T < ee.length; T += 1) {
          var fe = ee[T];
          g.groupNames[fe] || g.raise("Invalid named capture referenced");
        }
      }, Ht.regexp_disjunction = function(g) {
        var T = this.options.ecmaVersion >= 16;
        for (T && (g.branchID = new jt(g.branchID, null)), this.regexp_alternative(g); g.eat(
          124
          /* | */
        ); )
          T && (g.branchID = g.branchID.sibling()), this.regexp_alternative(g);
        T && (g.branchID = g.branchID.parent), this.regexp_eatQuantifier(g, !0) && g.raise("Nothing to repeat"), g.eat(
          123
          /* { */
        ) && g.raise("Lone quantifier brackets");
      }, Ht.regexp_alternative = function(g) {
        for (; g.pos < g.source.length && this.regexp_eatTerm(g); )
          ;
      }, Ht.regexp_eatTerm = function(g) {
        return this.regexp_eatAssertion(g) ? (g.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(g) && g.switchU && g.raise("Invalid quantifier"), !0) : (g.switchU ? this.regexp_eatAtom(g) : this.regexp_eatExtendedAtom(g)) ? (this.regexp_eatQuantifier(g), !0) : !1;
      }, Ht.regexp_eatAssertion = function(g) {
        var T = g.pos;
        if (g.lastAssertionIsQuantifiable = !1, g.eat(
          94
          /* ^ */
        ) || g.eat(
          36
          /* $ */
        ))
          return !0;
        if (g.eat(
          92
          /* \ */
        )) {
          if (g.eat(
            66
            /* B */
          ) || g.eat(
            98
            /* b */
          ))
            return !0;
          g.pos = T;
        }
        if (g.eat(
          40
          /* ( */
        ) && g.eat(
          63
          /* ? */
        )) {
          var ee = !1;
          if (this.options.ecmaVersion >= 9 && (ee = g.eat(
            60
            /* < */
          )), g.eat(
            61
            /* = */
          ) || g.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(g), g.eat(
              41
              /* ) */
            ) || g.raise("Unterminated group"), g.lastAssertionIsQuantifiable = !ee, !0;
        }
        return g.pos = T, !1;
      }, Ht.regexp_eatQuantifier = function(g, T) {
        return T === void 0 && (T = !1), this.regexp_eatQuantifierPrefix(g, T) ? (g.eat(
          63
          /* ? */
        ), !0) : !1;
      }, Ht.regexp_eatQuantifierPrefix = function(g, T) {
        return g.eat(
          42
          /* * */
        ) || g.eat(
          43
          /* + */
        ) || g.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(g, T);
      }, Ht.regexp_eatBracedQuantifier = function(g, T) {
        var ee = g.pos;
        if (g.eat(
          123
          /* { */
        )) {
          var fe = 0, j = -1;
          if (this.regexp_eatDecimalDigits(g) && (fe = g.lastIntValue, g.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(g) && (j = g.lastIntValue), g.eat(
            125
            /* } */
          )))
            return j !== -1 && j < fe && !T && g.raise("numbers out of order in {} quantifier"), !0;
          g.switchU && !T && g.raise("Incomplete quantifier"), g.pos = ee;
        }
        return !1;
      }, Ht.regexp_eatAtom = function(g) {
        return this.regexp_eatPatternCharacters(g) || g.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(g) || this.regexp_eatCharacterClass(g) || this.regexp_eatUncapturingGroup(g) || this.regexp_eatCapturingGroup(g);
      }, Ht.regexp_eatReverseSolidusAtomEscape = function(g) {
        var T = g.pos;
        if (g.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(g))
            return !0;
          g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatUncapturingGroup = function(g) {
        var T = g.pos;
        if (g.eat(
          40
          /* ( */
        )) {
          if (g.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var ee = this.regexp_eatModifiers(g), fe = g.eat(
                45
                /* - */
              );
              if (ee || fe) {
                for (var j = 0; j < ee.length; j++) {
                  var de = ee.charAt(j);
                  ee.indexOf(de, j + 1) > -1 && g.raise("Duplicate regular expression modifiers");
                }
                if (fe) {
                  var _e = this.regexp_eatModifiers(g);
                  !ee && !_e && g.current() === 58 && g.raise("Invalid regular expression modifiers");
                  for (var Le = 0; Le < _e.length; Le++) {
                    var et = _e.charAt(Le);
                    (_e.indexOf(et, Le + 1) > -1 || ee.indexOf(et) > -1) && g.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
            if (g.eat(
              58
              /* : */
            )) {
              if (this.regexp_disjunction(g), g.eat(
                41
                /* ) */
              ))
                return !0;
              g.raise("Unterminated group");
            }
          }
          g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatCapturingGroup = function(g) {
        if (g.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(g) : g.current() === 63 && g.raise("Invalid group"), this.regexp_disjunction(g), g.eat(
            41
            /* ) */
          ))
            return g.numCapturingParens += 1, !0;
          g.raise("Unterminated group");
        }
        return !1;
      }, Ht.regexp_eatModifiers = function(g) {
        for (var T = "", ee = 0; (ee = g.current()) !== -1 && ti(ee); )
          T += W(ee), g.advance();
        return T;
      };
      function ti(g) {
        return g === 105 || g === 109 || g === 115;
      }
      Ht.regexp_eatExtendedAtom = function(g) {
        return g.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(g) || this.regexp_eatCharacterClass(g) || this.regexp_eatUncapturingGroup(g) || this.regexp_eatCapturingGroup(g) || this.regexp_eatInvalidBracedQuantifier(g) || this.regexp_eatExtendedPatternCharacter(g);
      }, Ht.regexp_eatInvalidBracedQuantifier = function(g) {
        return this.regexp_eatBracedQuantifier(g, !0) && g.raise("Nothing to repeat"), !1;
      }, Ht.regexp_eatSyntaxCharacter = function(g) {
        var T = g.current();
        return Dn(T) ? (g.lastIntValue = T, g.advance(), !0) : !1;
      };
      function Dn(g) {
        return g === 36 || g >= 40 && g <= 43 || g === 46 || g === 63 || g >= 91 && g <= 94 || g >= 123 && g <= 125;
      }
      Ht.regexp_eatPatternCharacters = function(g) {
        for (var T = g.pos, ee = 0; (ee = g.current()) !== -1 && !Dn(ee); )
          g.advance();
        return g.pos !== T;
      }, Ht.regexp_eatExtendedPatternCharacter = function(g) {
        var T = g.current();
        return T !== -1 && T !== 36 && !(T >= 40 && T <= 43) && T !== 46 && T !== 63 && T !== 91 && T !== 94 && T !== 124 ? (g.advance(), !0) : !1;
      }, Ht.regexp_groupSpecifier = function(g) {
        if (g.eat(
          63
          /* ? */
        )) {
          this.regexp_eatGroupName(g) || g.raise("Invalid group");
          var T = this.options.ecmaVersion >= 16, ee = g.groupNames[g.lastStringValue];
          if (ee)
            if (T)
              for (var fe = 0, j = ee; fe < j.length; fe += 1) {
                var de = j[fe];
                de.separatedFrom(g.branchID) || g.raise("Duplicate capture group name");
              }
            else
              g.raise("Duplicate capture group name");
          T ? (ee || (g.groupNames[g.lastStringValue] = [])).push(g.branchID) : g.groupNames[g.lastStringValue] = !0;
        }
      }, Ht.regexp_eatGroupName = function(g) {
        if (g.lastStringValue = "", g.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(g) && g.eat(
            62
            /* > */
          ))
            return !0;
          g.raise("Invalid capture group name");
        }
        return !1;
      }, Ht.regexp_eatRegExpIdentifierName = function(g) {
        if (g.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(g)) {
          for (g.lastStringValue += W(g.lastIntValue); this.regexp_eatRegExpIdentifierPart(g); )
            g.lastStringValue += W(g.lastIntValue);
          return !0;
        }
        return !1;
      }, Ht.regexp_eatRegExpIdentifierStart = function(g) {
        var T = g.pos, ee = this.options.ecmaVersion >= 11, fe = g.current(ee);
        return g.advance(ee), fe === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(g, ee) && (fe = g.lastIntValue), ue(fe) ? (g.lastIntValue = fe, !0) : (g.pos = T, !1);
      };
      function ue(g) {
        return h(g, !0) || g === 36 || g === 95;
      }
      Ht.regexp_eatRegExpIdentifierPart = function(g) {
        var T = g.pos, ee = this.options.ecmaVersion >= 11, fe = g.current(ee);
        return g.advance(ee), fe === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(g, ee) && (fe = g.lastIntValue), Ue(fe) ? (g.lastIntValue = fe, !0) : (g.pos = T, !1);
      };
      function Ue(g) {
        return m(g, !0) || g === 36 || g === 95 || g === 8204 || g === 8205;
      }
      Ht.regexp_eatAtomEscape = function(g) {
        return this.regexp_eatBackReference(g) || this.regexp_eatCharacterClassEscape(g) || this.regexp_eatCharacterEscape(g) || g.switchN && this.regexp_eatKGroupName(g) ? !0 : (g.switchU && (g.current() === 99 && g.raise("Invalid unicode escape"), g.raise("Invalid escape")), !1);
      }, Ht.regexp_eatBackReference = function(g) {
        var T = g.pos;
        if (this.regexp_eatDecimalEscape(g)) {
          var ee = g.lastIntValue;
          if (g.switchU)
            return ee > g.maxBackReference && (g.maxBackReference = ee), !0;
          if (ee <= g.numCapturingParens)
            return !0;
          g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatKGroupName = function(g) {
        if (g.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(g))
            return g.backReferenceNames.push(g.lastStringValue), !0;
          g.raise("Invalid named reference");
        }
        return !1;
      }, Ht.regexp_eatCharacterEscape = function(g) {
        return this.regexp_eatControlEscape(g) || this.regexp_eatCControlLetter(g) || this.regexp_eatZero(g) || this.regexp_eatHexEscapeSequence(g) || this.regexp_eatRegExpUnicodeEscapeSequence(g, !1) || !g.switchU && this.regexp_eatLegacyOctalEscapeSequence(g) || this.regexp_eatIdentityEscape(g);
      }, Ht.regexp_eatCControlLetter = function(g) {
        var T = g.pos;
        if (g.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(g))
            return !0;
          g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatZero = function(g) {
        return g.current() === 48 && !On(g.lookahead()) ? (g.lastIntValue = 0, g.advance(), !0) : !1;
      }, Ht.regexp_eatControlEscape = function(g) {
        var T = g.current();
        return T === 116 ? (g.lastIntValue = 9, g.advance(), !0) : T === 110 ? (g.lastIntValue = 10, g.advance(), !0) : T === 118 ? (g.lastIntValue = 11, g.advance(), !0) : T === 102 ? (g.lastIntValue = 12, g.advance(), !0) : T === 114 ? (g.lastIntValue = 13, g.advance(), !0) : !1;
      }, Ht.regexp_eatControlLetter = function(g) {
        var T = g.current();
        return ze(T) ? (g.lastIntValue = T % 32, g.advance(), !0) : !1;
      };
      function ze(g) {
        return g >= 65 && g <= 90 || g >= 97 && g <= 122;
      }
      Ht.regexp_eatRegExpUnicodeEscapeSequence = function(g, T) {
        T === void 0 && (T = !1);
        var ee = g.pos, fe = T || g.switchU;
        if (g.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(g, 4)) {
            var j = g.lastIntValue;
            if (fe && j >= 55296 && j <= 56319) {
              var de = g.pos;
              if (g.eat(
                92
                /* \ */
              ) && g.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(g, 4)) {
                var _e = g.lastIntValue;
                if (_e >= 56320 && _e <= 57343)
                  return g.lastIntValue = (j - 55296) * 1024 + (_e - 56320) + 65536, !0;
              }
              g.pos = de, g.lastIntValue = j;
            }
            return !0;
          }
          if (fe && g.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(g) && g.eat(
            125
            /* } */
          ) && At(g.lastIntValue))
            return !0;
          fe && g.raise("Invalid unicode escape"), g.pos = ee;
        }
        return !1;
      };
      function At(g) {
        return g >= 0 && g <= 1114111;
      }
      Ht.regexp_eatIdentityEscape = function(g) {
        if (g.switchU)
          return this.regexp_eatSyntaxCharacter(g) ? !0 : g.eat(
            47
            /* / */
          ) ? (g.lastIntValue = 47, !0) : !1;
        var T = g.current();
        return T !== 99 && (!g.switchN || T !== 107) ? (g.lastIntValue = T, g.advance(), !0) : !1;
      }, Ht.regexp_eatDecimalEscape = function(g) {
        g.lastIntValue = 0;
        var T = g.current();
        if (T >= 49 && T <= 57) {
          do
            g.lastIntValue = 10 * g.lastIntValue + (T - 48), g.advance();
          while ((T = g.current()) >= 48 && T <= 57);
          return !0;
        }
        return !1;
      };
      var yt = 0, wt = 1, Se = 2;
      Ht.regexp_eatCharacterClassEscape = function(g) {
        var T = g.current();
        if (qe(T))
          return g.lastIntValue = -1, g.advance(), wt;
        var ee = !1;
        if (g.switchU && this.options.ecmaVersion >= 9 && ((ee = T === 80) || T === 112)) {
          g.lastIntValue = -1, g.advance();
          var fe;
          if (g.eat(
            123
            /* { */
          ) && (fe = this.regexp_eatUnicodePropertyValueExpression(g)) && g.eat(
            125
            /* } */
          ))
            return ee && fe === Se && g.raise("Invalid property name"), fe;
          g.raise("Invalid property name");
        }
        return yt;
      };
      function qe(g) {
        return g === 100 || g === 68 || g === 115 || g === 83 || g === 119 || g === 87;
      }
      Ht.regexp_eatUnicodePropertyValueExpression = function(g) {
        var T = g.pos;
        if (this.regexp_eatUnicodePropertyName(g) && g.eat(
          61
          /* = */
        )) {
          var ee = g.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(g)) {
            var fe = g.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(g, ee, fe), wt;
          }
        }
        if (g.pos = T, this.regexp_eatLoneUnicodePropertyNameOrValue(g)) {
          var j = g.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(g, j);
        }
        return yt;
      }, Ht.regexp_validateUnicodePropertyNameAndValue = function(g, T, ee) {
        ae(g.unicodeProperties.nonBinary, T) || g.raise("Invalid property name"), g.unicodeProperties.nonBinary[T].test(ee) || g.raise("Invalid property value");
      }, Ht.regexp_validateUnicodePropertyNameOrValue = function(g, T) {
        if (g.unicodeProperties.binary.test(T))
          return wt;
        if (g.switchV && g.unicodeProperties.binaryOfStrings.test(T))
          return Se;
        g.raise("Invalid property name");
      }, Ht.regexp_eatUnicodePropertyName = function(g) {
        var T = 0;
        for (g.lastStringValue = ""; lt(T = g.current()); )
          g.lastStringValue += W(T), g.advance();
        return g.lastStringValue !== "";
      };
      function lt(g) {
        return ze(g) || g === 95;
      }
      Ht.regexp_eatUnicodePropertyValue = function(g) {
        var T = 0;
        for (g.lastStringValue = ""; St(T = g.current()); )
          g.lastStringValue += W(T), g.advance();
        return g.lastStringValue !== "";
      };
      function St(g) {
        return lt(g) || On(g);
      }
      Ht.regexp_eatLoneUnicodePropertyNameOrValue = function(g) {
        return this.regexp_eatUnicodePropertyValue(g);
      }, Ht.regexp_eatCharacterClass = function(g) {
        if (g.eat(
          91
          /* [ */
        )) {
          var T = g.eat(
            94
            /* ^ */
          ), ee = this.regexp_classContents(g);
          return g.eat(
            93
            /* ] */
          ) || g.raise("Unterminated character class"), T && ee === Se && g.raise("Negated character class may contain strings"), !0;
        }
        return !1;
      }, Ht.regexp_classContents = function(g) {
        return g.current() === 93 ? wt : g.switchV ? this.regexp_classSetExpression(g) : (this.regexp_nonEmptyClassRanges(g), wt);
      }, Ht.regexp_nonEmptyClassRanges = function(g) {
        for (; this.regexp_eatClassAtom(g); ) {
          var T = g.lastIntValue;
          if (g.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(g)) {
            var ee = g.lastIntValue;
            g.switchU && (T === -1 || ee === -1) && g.raise("Invalid character class"), T !== -1 && ee !== -1 && T > ee && g.raise("Range out of order in character class");
          }
        }
      }, Ht.regexp_eatClassAtom = function(g) {
        var T = g.pos;
        if (g.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(g))
            return !0;
          if (g.switchU) {
            var ee = g.current();
            (ee === 99 || _i(ee)) && g.raise("Invalid class escape"), g.raise("Invalid escape");
          }
          g.pos = T;
        }
        var fe = g.current();
        return fe !== 93 ? (g.lastIntValue = fe, g.advance(), !0) : !1;
      }, Ht.regexp_eatClassEscape = function(g) {
        var T = g.pos;
        if (g.eat(
          98
          /* b */
        ))
          return g.lastIntValue = 8, !0;
        if (g.switchU && g.eat(
          45
          /* - */
        ))
          return g.lastIntValue = 45, !0;
        if (!g.switchU && g.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(g))
            return !0;
          g.pos = T;
        }
        return this.regexp_eatCharacterClassEscape(g) || this.regexp_eatCharacterEscape(g);
      }, Ht.regexp_classSetExpression = function(g) {
        var T = wt, ee;
        if (!this.regexp_eatClassSetRange(g)) if (ee = this.regexp_eatClassSetOperand(g)) {
          ee === Se && (T = Se);
          for (var fe = g.pos; g.eatChars(
            [38, 38]
            /* && */
          ); ) {
            if (g.current() !== 38 && (ee = this.regexp_eatClassSetOperand(g))) {
              ee !== Se && (T = wt);
              continue;
            }
            g.raise("Invalid character in character class");
          }
          if (fe !== g.pos)
            return T;
          for (; g.eatChars(
            [45, 45]
            /* -- */
          ); )
            this.regexp_eatClassSetOperand(g) || g.raise("Invalid character in character class");
          if (fe !== g.pos)
            return T;
        } else
          g.raise("Invalid character in character class");
        for (; ; )
          if (!this.regexp_eatClassSetRange(g)) {
            if (ee = this.regexp_eatClassSetOperand(g), !ee)
              return T;
            ee === Se && (T = Se);
          }
      }, Ht.regexp_eatClassSetRange = function(g) {
        var T = g.pos;
        if (this.regexp_eatClassSetCharacter(g)) {
          var ee = g.lastIntValue;
          if (g.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(g)) {
            var fe = g.lastIntValue;
            return ee !== -1 && fe !== -1 && ee > fe && g.raise("Range out of order in character class"), !0;
          }
          g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatClassSetOperand = function(g) {
        return this.regexp_eatClassSetCharacter(g) ? wt : this.regexp_eatClassStringDisjunction(g) || this.regexp_eatNestedClass(g);
      }, Ht.regexp_eatNestedClass = function(g) {
        var T = g.pos;
        if (g.eat(
          91
          /* [ */
        )) {
          var ee = g.eat(
            94
            /* ^ */
          ), fe = this.regexp_classContents(g);
          if (g.eat(
            93
            /* ] */
          ))
            return ee && fe === Se && g.raise("Negated character class may contain strings"), fe;
          g.pos = T;
        }
        if (g.eat(
          92
          /* \ */
        )) {
          var j = this.regexp_eatCharacterClassEscape(g);
          if (j)
            return j;
          g.pos = T;
        }
        return null;
      }, Ht.regexp_eatClassStringDisjunction = function(g) {
        var T = g.pos;
        if (g.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (g.eat(
            123
            /* { */
          )) {
            var ee = this.regexp_classStringDisjunctionContents(g);
            if (g.eat(
              125
              /* } */
            ))
              return ee;
          } else
            g.raise("Invalid escape");
          g.pos = T;
        }
        return null;
      }, Ht.regexp_classStringDisjunctionContents = function(g) {
        for (var T = this.regexp_classString(g); g.eat(
          124
          /* | */
        ); )
          this.regexp_classString(g) === Se && (T = Se);
        return T;
      }, Ht.regexp_classString = function(g) {
        for (var T = 0; this.regexp_eatClassSetCharacter(g); )
          T++;
        return T === 1 ? wt : Se;
      }, Ht.regexp_eatClassSetCharacter = function(g) {
        var T = g.pos;
        if (g.eat(
          92
          /* \ */
        ))
          return this.regexp_eatCharacterEscape(g) || this.regexp_eatClassSetReservedPunctuator(g) ? !0 : g.eat(
            98
            /* b */
          ) ? (g.lastIntValue = 8, !0) : (g.pos = T, !1);
        var ee = g.current();
        return ee < 0 || ee === g.lookahead() && Yt(ee) || Vr(ee) ? !1 : (g.advance(), g.lastIntValue = ee, !0);
      };
      function Yt(g) {
        return g === 33 || g >= 35 && g <= 38 || g >= 42 && g <= 44 || g === 46 || g >= 58 && g <= 64 || g === 94 || g === 96 || g === 126;
      }
      function Vr(g) {
        return g === 40 || g === 41 || g === 45 || g === 47 || g >= 91 && g <= 93 || g >= 123 && g <= 125;
      }
      Ht.regexp_eatClassSetReservedPunctuator = function(g) {
        var T = g.current();
        return gn(T) ? (g.lastIntValue = T, g.advance(), !0) : !1;
      };
      function gn(g) {
        return g === 33 || g === 35 || g === 37 || g === 38 || g === 44 || g === 45 || g >= 58 && g <= 62 || g === 64 || g === 96 || g === 126;
      }
      Ht.regexp_eatClassControlLetter = function(g) {
        var T = g.current();
        return On(T) || T === 95 ? (g.lastIntValue = T % 32, g.advance(), !0) : !1;
      }, Ht.regexp_eatHexEscapeSequence = function(g) {
        var T = g.pos;
        if (g.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(g, 2))
            return !0;
          g.switchU && g.raise("Invalid escape"), g.pos = T;
        }
        return !1;
      }, Ht.regexp_eatDecimalDigits = function(g) {
        var T = g.pos, ee = 0;
        for (g.lastIntValue = 0; On(ee = g.current()); )
          g.lastIntValue = 10 * g.lastIntValue + (ee - 48), g.advance();
        return g.pos !== T;
      };
      function On(g) {
        return g >= 48 && g <= 57;
      }
      Ht.regexp_eatHexDigits = function(g) {
        var T = g.pos, ee = 0;
        for (g.lastIntValue = 0; bs(ee = g.current()); )
          g.lastIntValue = 16 * g.lastIntValue + ys(ee), g.advance();
        return g.pos !== T;
      };
      function bs(g) {
        return g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102;
      }
      function ys(g) {
        return g >= 65 && g <= 70 ? 10 + (g - 65) : g >= 97 && g <= 102 ? 10 + (g - 97) : g - 48;
      }
      Ht.regexp_eatLegacyOctalEscapeSequence = function(g) {
        if (this.regexp_eatOctalDigit(g)) {
          var T = g.lastIntValue;
          if (this.regexp_eatOctalDigit(g)) {
            var ee = g.lastIntValue;
            T <= 3 && this.regexp_eatOctalDigit(g) ? g.lastIntValue = T * 64 + ee * 8 + g.lastIntValue : g.lastIntValue = T * 8 + ee;
          } else
            g.lastIntValue = T;
          return !0;
        }
        return !1;
      }, Ht.regexp_eatOctalDigit = function(g) {
        var T = g.current();
        return _i(T) ? (g.lastIntValue = T - 48, g.advance(), !0) : (g.lastIntValue = 0, !1);
      };
      function _i(g) {
        return g >= 48 && g <= 55;
      }
      Ht.regexp_eatFixedHexDigits = function(g, T) {
        var ee = g.pos;
        g.lastIntValue = 0;
        for (var fe = 0; fe < T; ++fe) {
          var j = g.current();
          if (!bs(j))
            return g.pos = ee, !1;
          g.lastIntValue = 16 * g.lastIntValue + ys(j), g.advance();
        }
        return !0;
      };
      var ri = function(T) {
        this.type = T.type, this.value = T.value, this.start = T.start, this.end = T.end, T.options.locations && (this.loc = new P(T, T.startLoc, T.endLoc)), T.options.ranges && (this.range = [T.start, T.end]);
      }, Ir = te.prototype;
      Ir.next = function(g) {
        !g && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ri(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, Ir.getToken = function() {
        return this.next(), new ri(this);
      }, typeof Symbol < "u" && (Ir[Symbol.iterator] = function() {
        var g = this;
        return {
          next: function() {
            var T = g.getToken();
            return {
              done: T.type === w.eof,
              value: T
            };
          }
        };
      }), Ir.nextToken = function() {
        var g = this.curContext();
        if ((!g || !g.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(w.eof);
        if (g.override)
          return g.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, Ir.readToken = function(g) {
        return h(g, this.options.ecmaVersion >= 6) || g === 92 ? this.readWord() : this.getTokenFromCode(g);
      }, Ir.fullCharCodeAtPos = function() {
        var g = this.input.charCodeAt(this.pos);
        if (g <= 55295 || g >= 56320)
          return g;
        var T = this.input.charCodeAt(this.pos + 1);
        return T <= 56319 || T >= 57344 ? g : (g << 10) + T - 56613888;
      }, Ir.skipBlockComment = function() {
        var g = this.options.onComment && this.curPosition(), T = this.pos, ee = this.input.indexOf("*/", this.pos += 2);
        if (ee === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = ee + 2, this.options.locations)
          for (var fe = void 0, j = T; (fe = B(this.input, j, this.pos)) > -1; )
            ++this.curLine, j = this.lineStart = fe;
        this.options.onComment && this.options.onComment(
          !0,
          this.input.slice(T + 2, ee),
          T,
          this.pos,
          g,
          this.curPosition()
        );
      }, Ir.skipLineComment = function(g) {
        for (var T = this.pos, ee = this.options.onComment && this.curPosition(), fe = this.input.charCodeAt(this.pos += g); this.pos < this.input.length && !S(fe); )
          fe = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          !1,
          this.input.slice(T + g, this.pos),
          T,
          this.pos,
          ee,
          this.curPosition()
        );
      }, Ir.skipSpace = function() {
        e: for (; this.pos < this.input.length; ) {
          var g = this.input.charCodeAt(this.pos);
          switch (g) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (g > 8 && g < 14 || g >= 5760 && U.test(String.fromCharCode(g)))
                ++this.pos;
              else
                break e;
          }
        }
      }, Ir.finishToken = function(g, T) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var ee = this.type;
        this.type = g, this.value = T, this.updateContext(ee);
      }, Ir.readToken_dot = function() {
        var g = this.input.charCodeAt(this.pos + 1);
        if (g >= 48 && g <= 57)
          return this.readNumber(!0);
        var T = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && g === 46 && T === 46 ? (this.pos += 3, this.finishToken(w.ellipsis)) : (++this.pos, this.finishToken(w.dot));
      }, Ir.readToken_slash = function() {
        var g = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : g === 61 ? this.finishOp(w.assign, 2) : this.finishOp(w.slash, 1);
      }, Ir.readToken_mult_modulo_exp = function(g) {
        var T = this.input.charCodeAt(this.pos + 1), ee = 1, fe = g === 42 ? w.star : w.modulo;
        return this.options.ecmaVersion >= 7 && g === 42 && T === 42 && (++ee, fe = w.starstar, T = this.input.charCodeAt(this.pos + 2)), T === 61 ? this.finishOp(w.assign, ee + 1) : this.finishOp(fe, ee);
      }, Ir.readToken_pipe_amp = function(g) {
        var T = this.input.charCodeAt(this.pos + 1);
        if (T === g) {
          if (this.options.ecmaVersion >= 12) {
            var ee = this.input.charCodeAt(this.pos + 2);
            if (ee === 61)
              return this.finishOp(w.assign, 3);
          }
          return this.finishOp(g === 124 ? w.logicalOR : w.logicalAND, 2);
        }
        return T === 61 ? this.finishOp(w.assign, 2) : this.finishOp(g === 124 ? w.bitwiseOR : w.bitwiseAND, 1);
      }, Ir.readToken_caret = function() {
        var g = this.input.charCodeAt(this.pos + 1);
        return g === 61 ? this.finishOp(w.assign, 2) : this.finishOp(w.bitwiseXOR, 1);
      }, Ir.readToken_plus_min = function(g) {
        var T = this.input.charCodeAt(this.pos + 1);
        return T === g ? T === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || C.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(w.incDec, 2) : T === 61 ? this.finishOp(w.assign, 2) : this.finishOp(w.plusMin, 1);
      }, Ir.readToken_lt_gt = function(g) {
        var T = this.input.charCodeAt(this.pos + 1), ee = 1;
        return T === g ? (ee = g === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + ee) === 61 ? this.finishOp(w.assign, ee + 1) : this.finishOp(w.bitShift, ee)) : T === 33 && g === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (T === 61 && (ee = 2), this.finishOp(w.relational, ee));
      }, Ir.readToken_eq_excl = function(g) {
        var T = this.input.charCodeAt(this.pos + 1);
        return T === 61 ? this.finishOp(w.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : g === 61 && T === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(w.arrow)) : this.finishOp(g === 61 ? w.eq : w.prefix, 1);
      }, Ir.readToken_question = function() {
        var g = this.options.ecmaVersion;
        if (g >= 11) {
          var T = this.input.charCodeAt(this.pos + 1);
          if (T === 46) {
            var ee = this.input.charCodeAt(this.pos + 2);
            if (ee < 48 || ee > 57)
              return this.finishOp(w.questionDot, 2);
          }
          if (T === 63) {
            if (g >= 12) {
              var fe = this.input.charCodeAt(this.pos + 2);
              if (fe === 61)
                return this.finishOp(w.assign, 3);
            }
            return this.finishOp(w.coalesce, 2);
          }
        }
        return this.finishOp(w.question, 1);
      }, Ir.readToken_numberSign = function() {
        var g = this.options.ecmaVersion, T = 35;
        if (g >= 13 && (++this.pos, T = this.fullCharCodeAtPos(), h(T, !0) || T === 92))
          return this.finishToken(w.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + W(T) + "'");
      }, Ir.getTokenFromCode = function(g) {
        switch (g) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            return ++this.pos, this.finishToken(w.parenL);
          case 41:
            return ++this.pos, this.finishToken(w.parenR);
          case 59:
            return ++this.pos, this.finishToken(w.semi);
          case 44:
            return ++this.pos, this.finishToken(w.comma);
          case 91:
            return ++this.pos, this.finishToken(w.bracketL);
          case 93:
            return ++this.pos, this.finishToken(w.bracketR);
          case 123:
            return ++this.pos, this.finishToken(w.braceL);
          case 125:
            return ++this.pos, this.finishToken(w.braceR);
          case 58:
            return ++this.pos, this.finishToken(w.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(w.backQuote);
          case 48:
            var T = this.input.charCodeAt(this.pos + 1);
            if (T === 120 || T === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (T === 111 || T === 79)
                return this.readRadixNumber(8);
              if (T === 98 || T === 66)
                return this.readRadixNumber(2);
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(g);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(g);
          case 124:
          case 38:
            return this.readToken_pipe_amp(g);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(g);
          case 60:
          case 62:
            return this.readToken_lt_gt(g);
          case 61:
          case 33:
            return this.readToken_eq_excl(g);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(w.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + W(g) + "'");
      }, Ir.finishOp = function(g, T) {
        var ee = this.input.slice(this.pos, this.pos + T);
        return this.pos += T, this.finishToken(g, ee);
      }, Ir.readRegexp = function() {
        for (var g, T, ee = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(ee, "Unterminated regular expression");
          var fe = this.input.charAt(this.pos);
          if (C.test(fe) && this.raise(ee, "Unterminated regular expression"), g)
            g = !1;
          else {
            if (fe === "[")
              T = !0;
            else if (fe === "]" && T)
              T = !1;
            else if (fe === "/" && !T)
              break;
            g = fe === "\\";
          }
          ++this.pos;
        }
        var j = this.input.slice(ee, this.pos);
        ++this.pos;
        var de = this.pos, _e = this.readWord1();
        this.containsEsc && this.unexpected(de);
        var Le = this.regexpState || (this.regexpState = new jn(this));
        Le.reset(ee, j, _e), this.validateRegExpFlags(Le), this.validateRegExpPattern(Le);
        var et = null;
        try {
          et = new RegExp(j, _e);
        } catch {
        }
        return this.finishToken(w.regexp, { pattern: j, flags: _e, value: et });
      }, Ir.readInt = function(g, T, ee) {
        for (var fe = this.options.ecmaVersion >= 12 && T === void 0, j = ee && this.input.charCodeAt(this.pos) === 48, de = this.pos, _e = 0, Le = 0, et = 0, vt = T ?? 1 / 0; et < vt; ++et, ++this.pos) {
          var Wt = this.input.charCodeAt(this.pos), en = void 0;
          if (fe && Wt === 95) {
            j && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), Le === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), et === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), Le = Wt;
            continue;
          }
          if (Wt >= 97 ? en = Wt - 97 + 10 : Wt >= 65 ? en = Wt - 65 + 10 : Wt >= 48 && Wt <= 57 ? en = Wt - 48 : en = 1 / 0, en >= g)
            break;
          Le = Wt, _e = _e * g + en;
        }
        return fe && Le === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === de || T != null && this.pos - de !== T ? null : _e;
      };
      function dt(g, T) {
        return T ? parseInt(g, 8) : parseFloat(g.replace(/_/g, ""));
      }
      function Sn(g) {
        return typeof BigInt != "function" ? null : BigInt(g.replace(/_/g, ""));
      }
      Ir.readRadixNumber = function(g) {
        var T = this.pos;
        this.pos += 2;
        var ee = this.readInt(g);
        return ee == null && this.raise(this.start + 2, "Expected number in radix " + g), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (ee = Sn(this.input.slice(T, this.pos)), ++this.pos) : h(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(w.num, ee);
      }, Ir.readNumber = function(g) {
        var T = this.pos;
        !g && this.readInt(10, void 0, !0) === null && this.raise(T, "Invalid number");
        var ee = this.pos - T >= 2 && this.input.charCodeAt(T) === 48;
        ee && this.strict && this.raise(T, "Invalid number");
        var fe = this.input.charCodeAt(this.pos);
        if (!ee && !g && this.options.ecmaVersion >= 11 && fe === 110) {
          var j = Sn(this.input.slice(T, this.pos));
          return ++this.pos, h(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(w.num, j);
        }
        ee && /[89]/.test(this.input.slice(T, this.pos)) && (ee = !1), fe === 46 && !ee && (++this.pos, this.readInt(10), fe = this.input.charCodeAt(this.pos)), (fe === 69 || fe === 101) && !ee && (fe = this.input.charCodeAt(++this.pos), (fe === 43 || fe === 45) && ++this.pos, this.readInt(10) === null && this.raise(T, "Invalid number")), h(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var de = dt(this.input.slice(T, this.pos), ee);
        return this.finishToken(w.num, de);
      }, Ir.readCodePoint = function() {
        var g = this.input.charCodeAt(this.pos), T;
        if (g === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var ee = ++this.pos;
          T = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, T > 1114111 && this.invalidStringToken(ee, "Code point out of bounds");
        } else
          T = this.readHexChar(4);
        return T;
      }, Ir.readString = function(g) {
        for (var T = "", ee = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var fe = this.input.charCodeAt(this.pos);
          if (fe === g)
            break;
          fe === 92 ? (T += this.input.slice(ee, this.pos), T += this.readEscapedChar(!1), ee = this.pos) : fe === 8232 || fe === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (S(fe) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return T += this.input.slice(ee, this.pos++), this.finishToken(w.string, T);
      };
      var Mi = {};
      Ir.tryReadTemplateToken = function() {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (g) {
          if (g === Mi)
            this.readInvalidTemplateToken();
          else
            throw g;
        }
        this.inTemplateElement = !1;
      }, Ir.invalidStringToken = function(g, T) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw Mi;
        this.raise(g, T);
      }, Ir.readTmplToken = function() {
        for (var g = "", T = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var ee = this.input.charCodeAt(this.pos);
          if (ee === 96 || ee === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === w.template || this.type === w.invalidTemplate) ? ee === 36 ? (this.pos += 2, this.finishToken(w.dollarBraceL)) : (++this.pos, this.finishToken(w.backQuote)) : (g += this.input.slice(T, this.pos), this.finishToken(w.template, g));
          if (ee === 92)
            g += this.input.slice(T, this.pos), g += this.readEscapedChar(!0), T = this.pos;
          else if (S(ee)) {
            switch (g += this.input.slice(T, this.pos), ++this.pos, ee) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                g += `
`;
                break;
              default:
                g += String.fromCharCode(ee);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), T = this.pos;
          } else
            ++this.pos;
        }
      }, Ir.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            // fall through
            case "`":
              return this.finishToken(w.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              this.input[this.pos + 1] === `
` && ++this.pos;
            // fall through
            case `
`:
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
              break;
          }
        this.raise(this.start, "Unterminated template");
      }, Ir.readEscapedChar = function(g) {
        var T = this.input.charCodeAt(++this.pos);
        switch (++this.pos, T) {
          case 110:
            return `
`;
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return W(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          // '\r\n'
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (this.strict && this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            ), g) {
              var ee = this.pos - 1;
              this.invalidStringToken(
                ee,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (T >= 48 && T <= 55) {
              var fe = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], j = parseInt(fe, 8);
              return j > 255 && (fe = fe.slice(0, -1), j = parseInt(fe, 8)), this.pos += fe.length - 1, T = this.input.charCodeAt(this.pos), (fe !== "0" || T === 56 || T === 57) && (this.strict || g) && this.invalidStringToken(
                this.pos - 1 - fe.length,
                g ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(j);
            }
            return S(T) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(T);
        }
      }, Ir.readHexChar = function(g) {
        var T = this.pos, ee = this.readInt(16, g);
        return ee === null && this.invalidStringToken(T, "Bad character escape sequence"), ee;
      }, Ir.readWord1 = function() {
        this.containsEsc = !1;
        for (var g = "", T = !0, ee = this.pos, fe = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var j = this.fullCharCodeAtPos();
          if (m(j, fe))
            this.pos += j <= 65535 ? 1 : 2;
          else if (j === 92) {
            this.containsEsc = !0, g += this.input.slice(ee, this.pos);
            var de = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var _e = this.readCodePoint();
            (T ? h : m)(_e, fe) || this.invalidStringToken(de, "Invalid Unicode escape"), g += W(_e), ee = this.pos;
          } else
            break;
          T = !1;
        }
        return g + this.input.slice(ee, this.pos);
      }, Ir.readWord = function() {
        var g = this.readWord1(), T = w.name;
        return this.keywords.test(g) && (T = _[g]), this.finishToken(T, g);
      };
      var vs = "8.14.0";
      te.acorn = {
        Parser: te,
        version: vs,
        defaultOptions: ye,
        Position: G,
        SourceLocation: P,
        getLineInfo: he,
        Node: at,
        TokenType: y,
        tokTypes: w,
        keywordTypes: _,
        TokContext: tt,
        tokContexts: Ct,
        isIdentifierChar: m,
        isIdentifierStart: h,
        Token: ri,
        isNewLine: S,
        lineBreak: C,
        lineBreakG: k,
        nonASCIIwhitespace: U
      };
      function Zi(g, T) {
        return te.parse(g, T);
      }
      function ws(g, T, ee) {
        return te.parseExpressionAt(g, T, ee);
      }
      function pa(g, T) {
        return te.tokenizer(g, T);
      }
      r.Node = at, r.Parser = te, r.Position = G, r.SourceLocation = P, r.TokContext = tt, r.Token = ri, r.TokenType = y, r.defaultOptions = ye, r.getLineInfo = he, r.isIdentifierChar = m, r.isIdentifierStart = h, r.isNewLine = S, r.keywordTypes = _, r.lineBreak = C, r.lineBreakG = k, r.nonASCIIwhitespace = U, r.parse = Zi, r.parseExpressionAt = ws, r.tokContexts = Ct, r.tokTypes = w, r.tokenizer = pa, r.version = vs;
    });
  }(Uf, Uf.exports)), Uf.exports;
}
var Z7;
function cLe() {
  return Z7 || (Z7 = 1, function(e) {
    const t = lLe(), r = /^[\da-fA-F]+$/, n = /^\d+$/, a = /* @__PURE__ */ new WeakMap();
    function s(l) {
      l = l.Parser.acorn || l;
      let u = a.get(l);
      if (!u) {
        const c = l.tokTypes, d = l.TokContext, p = l.TokenType, f = new d("<tag", !1), h = new d("</tag", !1), m = new d("<tag>...</tag>", !0, !0), y = {
          tc_oTag: f,
          tc_cTag: h,
          tc_expr: m
        }, b = {
          jsxName: new p("jsxName"),
          jsxText: new p("jsxText", { beforeExpr: !0 }),
          jsxTagStart: new p("jsxTagStart", { startsExpr: !0 }),
          jsxTagEnd: new p("jsxTagEnd")
        };
        b.jsxTagStart.updateContext = function() {
          this.context.push(m), this.context.push(f), this.exprAllowed = !1;
        }, b.jsxTagEnd.updateContext = function(v) {
          let x = this.context.pop();
          x === f && v === c.slash || x === h ? (this.context.pop(), this.exprAllowed = this.curContext() === m) : this.exprAllowed = !0;
        }, u = { tokContexts: y, tokTypes: b }, a.set(l, u);
      }
      return u;
    }
    function i(l) {
      if (!l)
        return l;
      if (l.type === "JSXIdentifier")
        return l.name;
      if (l.type === "JSXNamespacedName")
        return l.namespace.name + ":" + l.name.name;
      if (l.type === "JSXMemberExpression")
        return i(l.object) + "." + i(l.property);
    }
    e.exports = function(l) {
      return l = l || {}, function(u) {
        return o({
          allowNamespaces: l.allowNamespaces !== !1,
          allowNamespacedObjects: !!l.allowNamespacedObjects
        }, u);
      };
    }, Object.defineProperty(e.exports, "tokTypes", {
      get: function() {
        return s(X7()).tokTypes;
      },
      configurable: !0,
      enumerable: !0
    });
    function o(l, u) {
      const c = u.acorn || X7(), d = s(c), p = c.tokTypes, f = d.tokTypes, h = c.tokContexts, m = d.tokContexts.tc_oTag, y = d.tokContexts.tc_cTag, b = d.tokContexts.tc_expr, v = c.isNewLine, x = c.isIdentifierStart, _ = c.isIdentifierChar;
      return class extends u {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return d;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let E = "", w = this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
            let C = this.input.charCodeAt(this.pos);
            switch (C) {
              case 60:
              // '<'
              case 123:
                return this.pos === this.start ? C === 60 && this.exprAllowed ? (++this.pos, this.finishToken(f.jsxTagStart)) : this.getTokenFromCode(C) : (E += this.input.slice(w, this.pos), this.finishToken(f.jsxText, E));
              case 38:
                E += this.input.slice(w, this.pos), E += this.jsx_readEntity(), w = this.pos;
                break;
              case 62:
              // '>'
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (C === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                v(C) ? (E += this.input.slice(w, this.pos), E += this.jsx_readNewLine(!0), w = this.pos) : ++this.pos;
            }
          }
        }
        jsx_readNewLine(E) {
          let w = this.input.charCodeAt(this.pos), C;
          return ++this.pos, w === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, C = E ? `
` : `\r
`) : C = String.fromCharCode(w), this.options.locations && (++this.curLine, this.lineStart = this.pos), C;
        }
        jsx_readString(E) {
          let w = "", C = ++this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            let k = this.input.charCodeAt(this.pos);
            if (k === E) break;
            k === 38 ? (w += this.input.slice(C, this.pos), w += this.jsx_readEntity(), C = this.pos) : v(k) ? (w += this.input.slice(C, this.pos), w += this.jsx_readNewLine(!1), C = this.pos) : ++this.pos;
          }
          return w += this.input.slice(C, this.pos++), this.finishToken(p.string, w);
        }
        jsx_readEntity() {
          let E = "", w = 0, C, k = this.input[this.pos];
          k !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
          let S = ++this.pos;
          for (; this.pos < this.input.length && w++ < 10; ) {
            if (k = this.input[this.pos++], k === ";") {
              E[0] === "#" ? E[1] === "x" ? (E = E.substr(2), r.test(E) && (C = String.fromCharCode(parseInt(E, 16)))) : (E = E.substr(1), n.test(E) && (C = String.fromCharCode(parseInt(E, 10)))) : C = t[E];
              break;
            }
            E += k;
          }
          return C || (this.pos = S, "&");
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let E, w = this.pos;
          do
            E = this.input.charCodeAt(++this.pos);
          while (_(E) || E === 45);
          return this.finishToken(f.jsxName, this.input.slice(w, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let E = this.startNode();
          return this.type === f.jsxName ? E.name = this.value : this.type.keyword ? E.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(E, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let E = this.start, w = this.startLoc, C = this.jsx_parseIdentifier();
          if (!l.allowNamespaces || !this.eat(p.colon)) return C;
          var k = this.startNodeAt(E, w);
          return k.namespace = C, k.name = this.jsx_parseIdentifier(), this.finishNode(k, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === f.jsxTagEnd) return "";
          let E = this.start, w = this.startLoc, C = this.jsx_parseNamespacedName();
          for (this.type === p.dot && C.type === "JSXNamespacedName" && !l.allowNamespacedObjects && this.unexpected(); this.eat(p.dot); ) {
            let k = this.startNodeAt(E, w);
            k.object = C, k.property = this.jsx_parseIdentifier(), C = this.finishNode(k, "JSXMemberExpression");
          }
          return C;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case p.braceL:
              let E = this.jsx_parseExpressionContainer();
              return E.expression.type === "JSXEmptyExpression" && this.raise(E.start, "JSX attributes must only be assigned a non-empty expression"), E;
            case f.jsxTagStart:
            case p.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let E = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(E, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let E = this.startNode();
          return this.next(), E.expression = this.type === p.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(p.braceR), this.finishNode(E, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let E = this.startNode();
          return this.eat(p.braceL) ? (this.expect(p.ellipsis), E.argument = this.parseMaybeAssign(), this.expect(p.braceR), this.finishNode(E, "JSXSpreadAttribute")) : (E.name = this.jsx_parseNamespacedName(), E.value = this.eat(p.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(E, "JSXAttribute"));
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(E, w) {
          let C = this.startNodeAt(E, w);
          C.attributes = [];
          let k = this.jsx_parseElementName();
          for (k && (C.name = k); this.type !== p.slash && this.type !== f.jsxTagEnd; )
            C.attributes.push(this.jsx_parseAttribute());
          return C.selfClosing = this.eat(p.slash), this.expect(f.jsxTagEnd), this.finishNode(C, k ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(E, w) {
          let C = this.startNodeAt(E, w), k = this.jsx_parseElementName();
          return k && (C.name = k), this.expect(f.jsxTagEnd), this.finishNode(C, k ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(E, w) {
          let C = this.startNodeAt(E, w), k = [], S = this.jsx_parseOpeningElementAt(E, w), B = null;
          if (!S.selfClosing) {
            e: for (; ; )
              switch (this.type) {
                case f.jsxTagStart:
                  if (E = this.start, w = this.startLoc, this.next(), this.eat(p.slash)) {
                    B = this.jsx_parseClosingElementAt(E, w);
                    break e;
                  }
                  k.push(this.jsx_parseElementAt(E, w));
                  break;
                case f.jsxText:
                  k.push(this.parseExprAtom());
                  break;
                case p.braceL:
                  k.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            i(B.name) !== i(S.name) && this.raise(
              B.start,
              "Expected corresponding JSX closing tag for <" + i(S.name) + ">"
            );
          }
          let U = S.name ? "Element" : "Fragment";
          return C["opening" + U] = S, C["closing" + U] = B, C.children = k, this.type === p.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(C, "JSX" + U);
        }
        // Parse JSX text
        jsx_parseText() {
          let E = this.parseLiteral(this.value);
          return E.type = "JSXText", E;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let E = this.start, w = this.startLoc;
          return this.next(), this.jsx_parseElementAt(E, w);
        }
        parseExprAtom(E) {
          return this.type === f.jsxText ? this.jsx_parseText() : this.type === f.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(E);
        }
        readToken(E) {
          let w = this.curContext();
          if (w === b) return this.jsx_readToken();
          if (w === m || w === y) {
            if (x(E)) return this.jsx_readWord();
            if (E == 62)
              return ++this.pos, this.finishToken(f.jsxTagEnd);
            if ((E === 34 || E === 39) && w == m)
              return this.jsx_readString(E);
          }
          return E === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(f.jsxTagStart)) : super.readToken(E);
        }
        updateContext(E) {
          if (this.type == p.braceL) {
            var w = this.curContext();
            w == m ? this.context.push(h.b_expr) : w == b ? this.context.push(h.b_tmpl) : super.updateContext(E), this.exprAllowed = !0;
          } else if (this.type === p.slash && E === f.jsxTagStart)
            this.context.length -= 2, this.context.push(y), this.exprAllowed = !1;
          else
            return super.updateContext(E);
        }
      };
    }
  }(VA)), VA.exports;
}
var dLe = cLe();
const GW = /* @__PURE__ */ da(dLe), { stringify: fLe } = JSON;
if (!String.prototype.repeat)
  throw new Error(
    "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
  );
if (!String.prototype.endsWith)
  throw new Error(
    "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
  );
const Vm = {
  "||": 2,
  "??": 3,
  "&&": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
}, Is = 17, pLe = {
  // Definitions
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  // Operations
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  // Other definitions
  ArrowFunctionExpression: Is,
  ClassExpression: Is,
  FunctionExpression: Is,
  ObjectExpression: Is,
  // Other operations
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function yc(e, t) {
  const { generator: r } = e;
  if (e.write("("), t != null && t.length > 0) {
    r[t[0].type](t[0], e);
    const { length: n } = t;
    for (let a = 1; a < n; a++) {
      const s = t[a];
      e.write(", "), r[s.type](s, e);
    }
  }
  e.write(")");
}
function WW(e, t, r, n) {
  const a = e.expressionsPrecedence[t.type];
  if (a === Is)
    return !0;
  const s = e.expressionsPrecedence[r.type];
  return a !== s ? !n && a === 15 && s === 14 && r.operator === "**" || a < s : a !== 13 && a !== 14 ? !1 : t.operator === "**" && r.operator === "**" ? !n : a === 13 && s === 13 && (t.operator === "??" || r.operator === "??") ? !0 : n ? Vm[t.operator] <= Vm[r.operator] : Vm[t.operator] < Vm[r.operator];
}
function Gm(e, t, r, n) {
  const { generator: a } = e;
  WW(e, t, r, n) ? (e.write("("), a[t.type](t, e), e.write(")")) : a[t.type](t, e);
}
function hLe(e, t, r, n) {
  const a = t.split(`
`), s = a.length - 1;
  if (e.write(a[0].trim()), s > 0) {
    e.write(n);
    for (let i = 1; i < s; i++)
      e.write(r + a[i].trim() + n);
    e.write(r + a[s].trim());
  }
}
function ta(e, t, r, n) {
  const { length: a } = t;
  for (let s = 0; s < a; s++) {
    const i = t[s];
    e.write(r), i.type[0] === "L" ? e.write("// " + i.value.trim() + `
`, i) : (e.write("/*"), hLe(e, i.value, r, n), e.write("*/" + n));
  }
}
function mLe(e) {
  let t = e;
  for (; t != null; ) {
    const { type: r } = t;
    if (r[0] === "C" && r[1] === "a")
      return !0;
    if (r[0] === "M" && r[1] === "e" && r[2] === "m")
      t = t.object;
    else
      return !1;
  }
}
function WA(e, t) {
  const { generator: r } = e, { declarations: n } = t;
  e.write(t.kind + " ");
  const { length: a } = n;
  if (a > 0) {
    r.VariableDeclarator(n[0], e);
    for (let s = 1; s < a; s++)
      e.write(", "), r.VariableDeclarator(n[s], e);
  }
}
let J7, Q7, e9, t9, r9, n9;
const KW = {
  /*
  Default generator.
  */
  Program(e, t) {
    const r = t.indent.repeat(t.indentLevel), { lineEnd: n, writeComments: a } = t;
    a && e.comments != null && ta(t, e.comments, r, n);
    const s = e.body, { length: i } = s;
    for (let o = 0; o < i; o++) {
      const l = s[o];
      a && l.comments != null && ta(t, l.comments, r, n), t.write(r), this[l.type](l, t), t.write(n);
    }
    a && e.trailingComments != null && ta(t, e.trailingComments, r, n);
  },
  BlockStatement: n9 = function(e, t) {
    const r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: a } = t, s = r + t.indent;
    t.write("{");
    const i = e.body;
    if (i != null && i.length > 0) {
      t.write(n), a && e.comments != null && ta(t, e.comments, s, n);
      const { length: o } = i;
      for (let l = 0; l < o; l++) {
        const u = i[l];
        a && u.comments != null && ta(t, u.comments, s, n), t.write(s), this[u.type](u, t), t.write(n);
      }
      t.write(r);
    } else
      a && e.comments != null && (t.write(n), ta(t, e.comments, s, n), t.write(r));
    a && e.trailingComments != null && ta(t, e.trailingComments, s, n), t.write("}"), t.indentLevel--;
  },
  ClassBody: n9,
  StaticBlock(e, t) {
    t.write("static "), this.BlockStatement(e, t);
  },
  EmptyStatement(e, t) {
    t.write(";");
  },
  ExpressionStatement(e, t) {
    const r = t.expressionsPrecedence[e.expression.type];
    r === Is || r === 3 && e.expression.left.type[0] === "O" ? (t.write("("), this[e.expression.type](e.expression, t), t.write(")")) : this[e.expression.type](e.expression, t), t.write(";");
  },
  IfStatement(e, t) {
    t.write("if ("), this[e.test.type](e.test, t), t.write(") "), this[e.consequent.type](e.consequent, t), e.alternate != null && (t.write(" else "), this[e.alternate.type](e.alternate, t));
  },
  LabeledStatement(e, t) {
    this[e.label.type](e.label, t), t.write(": "), this[e.body.type](e.body, t);
  },
  BreakStatement(e, t) {
    t.write("break"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
  },
  ContinueStatement(e, t) {
    t.write("continue"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
  },
  WithStatement(e, t) {
    t.write("with ("), this[e.object.type](e.object, t), t.write(") "), this[e.body.type](e.body, t);
  },
  SwitchStatement(e, t) {
    const r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: a } = t;
    t.indentLevel++;
    const s = r + t.indent, i = s + t.indent;
    t.write("switch ("), this[e.discriminant.type](e.discriminant, t), t.write(") {" + n);
    const { cases: o } = e, { length: l } = o;
    for (let u = 0; u < l; u++) {
      const c = o[u];
      a && c.comments != null && ta(t, c.comments, s, n), c.test ? (t.write(s + "case "), this[c.test.type](c.test, t), t.write(":" + n)) : t.write(s + "default:" + n);
      const { consequent: d } = c, { length: p } = d;
      for (let f = 0; f < p; f++) {
        const h = d[f];
        a && h.comments != null && ta(t, h.comments, i, n), t.write(i), this[h.type](h, t), t.write(n);
      }
    }
    t.indentLevel -= 2, t.write(r + "}");
  },
  ReturnStatement(e, t) {
    t.write("return"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t)), t.write(";");
  },
  ThrowStatement(e, t) {
    t.write("throw "), this[e.argument.type](e.argument, t), t.write(";");
  },
  TryStatement(e, t) {
    if (t.write("try "), this[e.block.type](e.block, t), e.handler) {
      const { handler: r } = e;
      r.param == null ? t.write(" catch ") : (t.write(" catch ("), this[r.param.type](r.param, t), t.write(") ")), this[r.body.type](r.body, t);
    }
    e.finalizer && (t.write(" finally "), this[e.finalizer.type](e.finalizer, t));
  },
  WhileStatement(e, t) {
    t.write("while ("), this[e.test.type](e.test, t), t.write(") "), this[e.body.type](e.body, t);
  },
  DoWhileStatement(e, t) {
    t.write("do "), this[e.body.type](e.body, t), t.write(" while ("), this[e.test.type](e.test, t), t.write(");");
  },
  ForStatement(e, t) {
    if (t.write("for ("), e.init != null) {
      const { init: r } = e;
      r.type[0] === "V" ? WA(t, r) : this[r.type](r, t);
    }
    t.write("; "), e.test && this[e.test.type](e.test, t), t.write("; "), e.update && this[e.update.type](e.update, t), t.write(") "), this[e.body.type](e.body, t);
  },
  ForInStatement: J7 = function(e, t) {
    t.write(`for ${e.await ? "await " : ""}(`);
    const { left: r } = e;
    r.type[0] === "V" ? WA(t, r) : this[r.type](r, t), t.write(e.type[3] === "I" ? " in " : " of "), this[e.right.type](e.right, t), t.write(") "), this[e.body.type](e.body, t);
  },
  ForOfStatement: J7,
  DebuggerStatement(e, t) {
    t.write("debugger;", e);
  },
  FunctionDeclaration: Q7 = function(e, t) {
    t.write(
      (e.async ? "async " : "") + (e.generator ? "function* " : "function ") + (e.id ? e.id.name : ""),
      e
    ), yc(t, e.params), t.write(" "), this[e.body.type](e.body, t);
  },
  FunctionExpression: Q7,
  VariableDeclaration(e, t) {
    WA(t, e), t.write(";");
  },
  VariableDeclarator(e, t) {
    this[e.id.type](e.id, t), e.init != null && (t.write(" = "), this[e.init.type](e.init, t));
  },
  ClassDeclaration(e, t) {
    if (t.write("class " + (e.id ? `${e.id.name} ` : ""), e), e.superClass) {
      t.write("extends ");
      const { superClass: r } = e, { type: n } = r, a = t.expressionsPrecedence[n];
      (n[0] !== "C" || n[1] !== "l" || n[5] !== "E") && (a === Is || a < t.expressionsPrecedence.ClassExpression) ? (t.write("("), this[e.superClass.type](r, t), t.write(")")) : this[r.type](r, t), t.write(" ");
    }
    this.ClassBody(e.body, t);
  },
  ImportDeclaration(e, t) {
    t.write("import ");
    const { specifiers: r, attributes: n } = e, { length: a } = r;
    let s = 0;
    if (a > 0) {
      for (; s < a; ) {
        s > 0 && t.write(", ");
        const i = r[s], o = i.type[6];
        if (o === "D")
          t.write(i.local.name, i), s++;
        else if (o === "N")
          t.write("* as " + i.local.name, i), s++;
        else
          break;
      }
      if (s < a) {
        for (t.write("{"); ; ) {
          const i = r[s], { name: o } = i.imported;
          if (t.write(o, i), o !== i.local.name && t.write(" as " + i.local.name), ++s < a)
            t.write(", ");
          else
            break;
        }
        t.write("}");
      }
      t.write(" from ");
    }
    if (this.Literal(e.source, t), n && n.length > 0) {
      t.write(" with { ");
      for (let i = 0; i < n.length; i++)
        this.ImportAttribute(n[i], t), i < n.length - 1 && t.write(", ");
      t.write(" }");
    }
    t.write(";");
  },
  ImportAttribute(e, t) {
    this.Identifier(e.key, t), t.write(": "), this.Literal(e.value, t);
  },
  ImportExpression(e, t) {
    t.write("import("), this[e.source.type](e.source, t), t.write(")");
  },
  ExportDefaultDeclaration(e, t) {
    t.write("export default "), this[e.declaration.type](e.declaration, t), t.expressionsPrecedence[e.declaration.type] != null && e.declaration.type[0] !== "F" && t.write(";");
  },
  ExportNamedDeclaration(e, t) {
    if (t.write("export "), e.declaration)
      this[e.declaration.type](e.declaration, t);
    else {
      t.write("{");
      const { specifiers: r } = e, { length: n } = r;
      if (n > 0)
        for (let a = 0; ; ) {
          const s = r[a], { name: i } = s.local;
          if (t.write(i, s), i !== s.exported.name && t.write(" as " + s.exported.name), ++a < n)
            t.write(", ");
          else
            break;
        }
      if (t.write("}"), e.source && (t.write(" from "), this.Literal(e.source, t)), e.attributes && e.attributes.length > 0) {
        t.write(" with { ");
        for (let a = 0; a < e.attributes.length; a++)
          this.ImportAttribute(e.attributes[a], t), a < e.attributes.length - 1 && t.write(", ");
        t.write(" }");
      }
      t.write(";");
    }
  },
  ExportAllDeclaration(e, t) {
    if (e.exported != null ? t.write("export * as " + e.exported.name + " from ") : t.write("export * from "), this.Literal(e.source, t), e.attributes && e.attributes.length > 0) {
      t.write(" with { ");
      for (let r = 0; r < e.attributes.length; r++)
        this.ImportAttribute(e.attributes[r], t), r < e.attributes.length - 1 && t.write(", ");
      t.write(" }");
    }
    t.write(";");
  },
  MethodDefinition(e, t) {
    e.static && t.write("static ");
    const r = e.kind[0];
    (r === "g" || r === "s") && t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), yc(t, e.value.params), t.write(" "), this[e.value.body.type](e.value.body, t);
  },
  ClassExpression(e, t) {
    this.ClassDeclaration(e, t);
  },
  ArrowFunctionExpression(e, t) {
    t.write(e.async ? "async " : "", e);
    const { params: r } = e;
    r != null && (r.length === 1 && r[0].type[0] === "I" ? t.write(r[0].name, r[0]) : yc(t, e.params)), t.write(" => "), e.body.type[0] === "O" ? (t.write("("), this.ObjectExpression(e.body, t), t.write(")")) : this[e.body.type](e.body, t);
  },
  ThisExpression(e, t) {
    t.write("this", e);
  },
  Super(e, t) {
    t.write("super", e);
  },
  RestElement: e9 = function(e, t) {
    t.write("..."), this[e.argument.type](e.argument, t);
  },
  SpreadElement: e9,
  YieldExpression(e, t) {
    t.write(e.delegate ? "yield*" : "yield"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t));
  },
  AwaitExpression(e, t) {
    t.write("await ", e), Gm(t, e.argument, e);
  },
  TemplateLiteral(e, t) {
    const { quasis: r, expressions: n } = e;
    t.write("`");
    const { length: a } = n;
    for (let i = 0; i < a; i++) {
      const o = n[i], l = r[i];
      t.write(l.value.raw, l), t.write("${"), this[o.type](o, t), t.write("}");
    }
    const s = r[r.length - 1];
    t.write(s.value.raw, s), t.write("`");
  },
  TemplateElement(e, t) {
    t.write(e.value.raw, e);
  },
  TaggedTemplateExpression(e, t) {
    Gm(t, e.tag, e), this[e.quasi.type](e.quasi, t);
  },
  ArrayExpression: r9 = function(e, t) {
    if (t.write("["), e.elements.length > 0) {
      const { elements: r } = e, { length: n } = r;
      for (let a = 0; ; ) {
        const s = r[a];
        if (s != null && this[s.type](s, t), ++a < n)
          t.write(", ");
        else {
          s == null && t.write(", ");
          break;
        }
      }
    }
    t.write("]");
  },
  ArrayPattern: r9,
  ObjectExpression(e, t) {
    const r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: a } = t, s = r + t.indent;
    if (t.write("{"), e.properties.length > 0) {
      t.write(n), a && e.comments != null && ta(t, e.comments, s, n);
      const i = "," + n, { properties: o } = e, { length: l } = o;
      for (let u = 0; ; ) {
        const c = o[u];
        if (a && c.comments != null && ta(t, c.comments, s, n), t.write(s), this[c.type](c, t), ++u < l)
          t.write(i);
        else
          break;
      }
      t.write(n), a && e.trailingComments != null && ta(t, e.trailingComments, s, n), t.write(r + "}");
    } else a ? e.comments != null ? (t.write(n), ta(t, e.comments, s, n), e.trailingComments != null && ta(t, e.trailingComments, s, n), t.write(r + "}")) : e.trailingComments != null ? (t.write(n), ta(t, e.trailingComments, s, n), t.write(r + "}")) : t.write("}") : t.write("}");
    t.indentLevel--;
  },
  Property(e, t) {
    e.method || e.kind[0] !== "i" ? this.MethodDefinition(e, t) : (e.shorthand || (e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), t.write(": ")), this[e.value.type](e.value, t));
  },
  PropertyDefinition(e, t) {
    if (e.static && t.write("static "), e.computed && t.write("["), this[e.key.type](e.key, t), e.computed && t.write("]"), e.value == null) {
      e.key.type[0] !== "F" && t.write(";");
      return;
    }
    t.write(" = "), this[e.value.type](e.value, t), t.write(";");
  },
  ObjectPattern(e, t) {
    if (t.write("{"), e.properties.length > 0) {
      const { properties: r } = e, { length: n } = r;
      for (let a = 0; this[r[a].type](r[a], t), ++a < n; )
        t.write(", ");
    }
    t.write("}");
  },
  SequenceExpression(e, t) {
    yc(t, e.expressions);
  },
  UnaryExpression(e, t) {
    if (e.prefix) {
      const {
        operator: r,
        argument: n,
        argument: { type: a }
      } = e;
      t.write(r);
      const s = WW(t, n, e);
      !s && (r.length > 1 || a[0] === "U" && (a[1] === "n" || a[1] === "p") && n.prefix && n.operator[0] === r && (r === "+" || r === "-")) && t.write(" "), s ? (t.write(r.length > 1 ? " (" : "("), this[a](n, t), t.write(")")) : this[a](n, t);
    } else
      this[e.argument.type](e.argument, t), t.write(e.operator);
  },
  UpdateExpression(e, t) {
    e.prefix ? (t.write(e.operator), this[e.argument.type](e.argument, t)) : (this[e.argument.type](e.argument, t), t.write(e.operator));
  },
  AssignmentExpression(e, t) {
    this[e.left.type](e.left, t), t.write(" " + e.operator + " "), this[e.right.type](e.right, t);
  },
  AssignmentPattern(e, t) {
    this[e.left.type](e.left, t), t.write(" = "), this[e.right.type](e.right, t);
  },
  BinaryExpression: t9 = function(e, t) {
    const r = e.operator === "in";
    r && t.write("("), Gm(t, e.left, e, !1), t.write(" " + e.operator + " "), Gm(t, e.right, e, !0), r && t.write(")");
  },
  LogicalExpression: t9,
  ConditionalExpression(e, t) {
    const { test: r } = e, n = t.expressionsPrecedence[r.type];
    n === Is || n <= t.expressionsPrecedence.ConditionalExpression ? (t.write("("), this[r.type](r, t), t.write(")")) : this[r.type](r, t), t.write(" ? "), this[e.consequent.type](e.consequent, t), t.write(" : "), this[e.alternate.type](e.alternate, t);
  },
  NewExpression(e, t) {
    t.write("new ");
    const r = t.expressionsPrecedence[e.callee.type];
    r === Is || r < t.expressionsPrecedence.CallExpression || mLe(e.callee) ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), yc(t, e.arguments);
  },
  CallExpression(e, t) {
    const r = t.expressionsPrecedence[e.callee.type];
    r === Is || r < t.expressionsPrecedence.CallExpression ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), e.optional && t.write("?."), yc(t, e.arguments);
  },
  ChainExpression(e, t) {
    this[e.expression.type](e.expression, t);
  },
  MemberExpression(e, t) {
    const r = t.expressionsPrecedence[e.object.type];
    r === Is || r < t.expressionsPrecedence.MemberExpression ? (t.write("("), this[e.object.type](e.object, t), t.write(")")) : this[e.object.type](e.object, t), e.computed ? (e.optional && t.write("?."), t.write("["), this[e.property.type](e.property, t), t.write("]")) : (e.optional ? t.write("?.") : t.write("."), this[e.property.type](e.property, t));
  },
  MetaProperty(e, t) {
    t.write(e.meta.name + "." + e.property.name, e);
  },
  Identifier(e, t) {
    t.write(e.name, e);
  },
  PrivateIdentifier(e, t) {
    t.write(`#${e.name}`, e);
  },
  Literal(e, t) {
    e.raw != null ? t.write(e.raw, e) : e.regex != null ? this.RegExpLiteral(e, t) : e.bigint != null ? t.write(e.bigint + "n", e) : t.write(fLe(e.value), e);
  },
  RegExpLiteral(e, t) {
    const { regex: r } = e;
    t.write(`/${r.pattern}/${r.flags}`, e);
  }
}, gLe = {};
class bLe {
  constructor(t) {
    const r = t ?? gLe;
    this.output = "", r.output != null ? (this.output = r.output, this.write = this.writeToStream) : this.output = "", this.generator = r.generator != null ? r.generator : KW, this.expressionsPrecedence = r.expressionsPrecedence != null ? r.expressionsPrecedence : pLe, this.indent = r.indent != null ? r.indent : "  ", this.lineEnd = r.lineEnd != null ? r.lineEnd : `
`, this.indentLevel = r.startingIndentLevel != null ? r.startingIndentLevel : 0, this.writeComments = r.comments ? r.comments : !1, r.sourceMap != null && (this.write = r.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = r.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = {
      original: null,
      // Uses the entire state to avoid generating ephemeral objects
      generated: this,
      name: void 0,
      source: r.sourceMap.file || r.sourceMap._file
    });
  }
  write(t) {
    this.output += t;
  }
  writeToStream(t) {
    this.output.write(t);
  }
  writeAndMap(t, r) {
    this.output += t, this.map(t, r);
  }
  writeToStreamAndMap(t, r) {
    this.output.write(t), this.map(t, r);
  }
  map(t, r) {
    if (r != null) {
      const { type: s } = r;
      if (s[0] === "L" && s[2] === "n") {
        this.column = 0, this.line++;
        return;
      }
      if (r.loc != null) {
        const { mapping: i } = this;
        i.original = r.loc.start, i.name = r.name, this.sourceMap.addMapping(i);
      }
      if (s[0] === "T" && s[8] === "E" || s[0] === "L" && s[1] === "i" && typeof r.value == "string") {
        const { length: i } = t;
        let { column: o, line: l } = this;
        for (let u = 0; u < i; u++)
          t[u] === `
` ? (o = 0, l++) : o++;
        this.column = o, this.line = l;
        return;
      }
    }
    const { length: n } = t, { lineEnd: a } = this;
    n > 0 && (this.lineEndSize > 0 && (a.length === 1 ? t[n - 1] === a : t.endsWith(a)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += n);
  }
  toString() {
    return this.output;
  }
}
function yLe(e, t) {
  const r = new bLe(t);
  return r.generator[e.type](e, r), r.output;
}
function vLe(e, t) {
  const { SourceMapGenerator: r, filePath: n, handlers: a } = t, s = r ? new r({ file: n || "<unknown>.js" }) : void 0, i = yLe(
    e,
    // @ts-expect-error: `sourceMap` can be undefined, `astring` types are buggy.
    {
      comments: !0,
      generator: { ...KW, ...a },
      sourceMap: s || void 0
    }
  ), o = s ? s.toJSON() : void 0;
  return { value: i, map: o };
}
const wLe = {
  JSXAttribute: xLe,
  JSXClosingElement: ELe,
  JSXClosingFragment: SLe,
  JSXElement: _Le,
  JSXEmptyExpression: kLe,
  JSXExpressionContainer: CLe,
  JSXFragment: ALe,
  JSXIdentifier: TLe,
  JSXMemberExpression: RLe,
  JSXNamespacedName: ILe,
  JSXOpeningElement: NLe,
  JSXOpeningFragment: DLe,
  JSXSpreadAttribute: OLe,
  JSXText: PLe
};
function xLe(e, t) {
  this[e.name.type](e.name, t), e.value !== null && e.value !== void 0 && (t.write("="), e.value.type === "Literal" ? t.write(
    '"' + YW(String(e.value.value)).replace(/"/g, "&quot;") + '"',
    e
  ) : this[e.value.type](e.value, t));
}
function ELe(e, t) {
  t.write("</"), this[e.name.type](e.name, t), t.write(">");
}
function SLe(e, t) {
  t.write("</>", e);
}
function _Le(e, t) {
  let r = -1;
  if (this[e.openingElement.type](e.openingElement, t), e.children)
    for (; ++r < e.children.length; ) {
      const n = e.children[r];
      if (n.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[n.type](n, t);
    }
  e.closingElement && this[e.closingElement.type](e.closingElement, t);
}
function kLe() {
}
function CLe(e, t) {
  t.write("{"), this[e.expression.type](e.expression, t), t.write("}");
}
function ALe(e, t) {
  let r = -1;
  if (this[e.openingFragment.type](e.openingFragment, t), e.children)
    for (; ++r < e.children.length; ) {
      const n = e.children[r];
      if (n.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[n.type](n, t);
    }
  this[e.closingFragment.type](e.closingFragment, t);
}
function TLe(e, t) {
  t.write(e.name, e);
}
function RLe(e, t) {
  this[e.object.type](e.object, t), t.write("."), this[e.property.type](e.property, t);
}
function ILe(e, t) {
  this[e.namespace.type](e.namespace, t), t.write(":"), this[e.name.type](e.name, t);
}
function NLe(e, t) {
  let r = -1;
  if (t.write("<"), this[e.name.type](e.name, t), e.attributes)
    for (; ++r < e.attributes.length; )
      t.write(" "), this[e.attributes[r].type](e.attributes[r], t);
  t.write(e.selfClosing ? " />" : ">");
}
function DLe(e, t) {
  t.write("<>", e);
}
function OLe(e, t) {
  t.write("{"), this.SpreadElement(e, t), t.write("}");
}
function PLe(e, t) {
  t.write(YW(e.value).replace(/[<>{}]/g, LLe), e);
}
function YW(e) {
  return e.replace(/&(?=[#a-z])/gi, "&amp;");
}
function LLe(e) {
  return e === "<" ? "&lt;" : e === ">" ? "&gt;" : e === "{" ? "&#123;" : "&#125;";
}
function MLe() {
  const e = this.data(), t = e.settings || (e.settings = {}), r = t.handlers || (t.handlers = {});
  (t.plugins || (t.plugins = [])).push(GW()), Object.assign(r, wLe);
}
function FLe(e) {
  const t = this;
  this.compiler = r;
  function r(n, a) {
    const s = { ...t.data("settings"), ...e }, i = vLe(n, {
      SourceMapGenerator: s.SourceMapGenerator,
      filePath: a.path || "unknown.js",
      handlers: s.handlers
    });
    return a.map = i.map, i.value;
  }
}
function $Le(e, t) {
  const r = { type: "Block", value: e.value };
  t.inherit(e, r), t.comments.push(r);
  const n = {
    type: "JSXEmptyExpression",
    // @ts-expect-error: `comments` is custom.
    comments: [Object.assign({}, r, { leading: !1, trailing: !0 })]
  };
  t.patch(e, n);
  const a = { type: "JSXExpressionContainer", expression: n };
  return t.patch(e, a), a;
}
var Sf = {}, KA, i9;
function BLe() {
  if (i9) return KA;
  i9 = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, r = /^\s*/, n = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, i = /^[;\s]*/, o = /^\s+|\s+$/g, l = `
`, u = "/", c = "*", d = "", p = "comment", f = "declaration";
  KA = function(m, y) {
    if (typeof m != "string")
      throw new TypeError("First argument must be a string");
    if (!m) return [];
    y = y || {};
    var b = 1, v = 1;
    function x(O) {
      var I = O.match(t);
      I && (b += I.length);
      var q = O.lastIndexOf(l);
      v = ~q ? O.length - q : v + O.length;
    }
    function _() {
      var O = { line: b, column: v };
      return function(I) {
        return I.position = new E(O), k(), I;
      };
    }
    function E(O) {
      this.start = O, this.end = { line: b, column: v }, this.source = y.source;
    }
    E.prototype.content = m;
    function w(O) {
      var I = new Error(
        y.source + ":" + b + ":" + v + ": " + O
      );
      if (I.reason = O, I.filename = y.source, I.line = b, I.column = v, I.source = m, !y.silent) throw I;
    }
    function C(O) {
      var I = O.exec(m);
      if (I) {
        var q = I[0];
        return x(q), m = m.slice(q.length), I;
      }
    }
    function k() {
      C(r);
    }
    function S(O) {
      var I;
      for (O = O || []; I = B(); )
        I !== !1 && O.push(I);
      return O;
    }
    function B() {
      var O = _();
      if (!(u != m.charAt(0) || c != m.charAt(1))) {
        for (var I = 2; d != m.charAt(I) && (c != m.charAt(I) || u != m.charAt(I + 1)); )
          ++I;
        if (I += 2, d === m.charAt(I - 1))
          return w("End of comment missing");
        var q = m.slice(2, I - 2);
        return v += 2, x(q), m = m.slice(I), v += 2, O({
          type: p,
          comment: q
        });
      }
    }
    function U() {
      var O = _(), I = C(n);
      if (I) {
        if (B(), !C(a)) return w("property missing ':'");
        var q = C(s), ae = O({
          type: f,
          property: h(I[0].replace(e, d)),
          value: q ? h(q[0].replace(e, d)) : d
        });
        return C(i), ae;
      }
    }
    function N() {
      var O = [];
      S(O);
      for (var I; I = U(); )
        I !== !1 && (O.push(I), S(O));
      return O;
    }
    return k(), N();
  };
  function h(m) {
    return m ? m.replace(o, d) : d;
  }
  return KA;
}
var a9;
function ULe() {
  if (a9) return Sf;
  a9 = 1;
  var e = Sf.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(Sf, "__esModule", { value: !0 }), Sf.default = r;
  var t = e(BLe());
  function r(n, a) {
    var s = null;
    if (!n || typeof n != "string")
      return s;
    var i = (0, t.default)(n), o = typeof a == "function";
    return i.forEach(function(l) {
      if (l.type === "declaration") {
        var u = l.property, c = l.value;
        o ? a(u, c, l) : c && (s = s || {}, s[u] = c);
      }
    }), s;
  }
  return Sf;
}
var zLe = ULe();
const s9 = /* @__PURE__ */ da(zLe), qLe = s9.default || s9, VR = {}.hasOwnProperty, jLe = /[A-Z]/g, HLe = /-([a-z])/g, VLe = /* @__PURE__ */ new Set(["td", "th"]);
function GLe(e, t) {
  const r = t.schema;
  let n = r;
  const a = e.properties || {};
  r.space === "html" && e.tagName.toLowerCase() === "svg" && (n = Eh, t.schema = n);
  const s = t.all(e), i = [];
  let o, l, u;
  for (o in a)
    if (VR.call(a, o)) {
      let d = a[o];
      const p = DH(n, o);
      let f;
      if (d == null || d === !1 || typeof d == "number" && Number.isNaN(d) || !d && p.boolean)
        continue;
      if (o = t.elementAttributeNameCase === "react" && p.space ? fge[p.property] || p.property : p.attribute, Array.isArray(d) && (d = p.commaSeparated ? $H(d) : BH(d)), o === "style") {
        let h = typeof d == "object" ? d : WLe(String(d), e.tagName);
        t.stylePropertyNameCase === "css" && (h = KLe(h));
        const m = [];
        let y;
        for (y in h)
          VR.call(h, y) && m.push({
            type: "Property",
            method: !1,
            shorthand: !1,
            computed: !1,
            key: so(y) ? { type: "Identifier", name: y } : { type: "Literal", value: y },
            value: { type: "Literal", value: String(h[y]) },
            kind: "init"
          });
        u = m, f = {
          type: "JSXExpressionContainer",
          expression: { type: "ObjectExpression", properties: m }
        };
      } else if (d === !0)
        f = null;
      else if (t.tableCellAlignToStyle && VLe.has(e.tagName) && o === "align") {
        l = String(d);
        continue;
      } else
        f = { type: "Literal", value: String(d) };
      so(o, { jsx: !0 }) ? i.push({
        type: "JSXAttribute",
        name: { type: "JSXIdentifier", name: o },
        value: f
      }) : i.push({
        type: "JSXSpreadAttribute",
        argument: {
          type: "ObjectExpression",
          properties: [
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              key: { type: "Literal", value: String(o) },
              // @ts-expect-error No need to worry about `style` (which has a
              // `JSXExpressionContainer` value) because that’s a valid identifier.
              value: f || { type: "Literal", value: !0 },
              kind: "init"
            }
          ]
        }
      });
    }
  if (l !== void 0) {
    u || (u = [], i.push({
      type: "JSXAttribute",
      name: { type: "JSXIdentifier", name: "style" },
      value: {
        type: "JSXExpressionContainer",
        expression: { type: "ObjectExpression", properties: u }
      }
    }));
    const d = t.stylePropertyNameCase === "css" ? XW("textAlign") : "textAlign";
    u.push({
      type: "Property",
      method: !1,
      shorthand: !1,
      computed: !1,
      key: so(d) ? { type: "Identifier", name: d } : { type: "Literal", value: d },
      value: { type: "Literal", value: l },
      kind: "init"
    });
  }
  t.schema = r;
  const c = {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: i,
      name: t.createJsxElementName(e.tagName),
      selfClosing: s.length === 0
    },
    closingElement: s.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.tagName)
    } : null,
    children: s
  };
  return t.inherit(e, c), c;
}
function WLe(e, t) {
  const r = {};
  try {
    qLe(e, n);
  } catch (a) {
    const s = (
      /** @type {Error} */
      a
    );
    throw new Error(
      "Could not parse `style` attribute on `" + t + "`",
      { cause: s }
    );
  }
  return r;
  function n(a, s) {
    let i = a;
    i.slice(0, 2) !== "--" && (i.slice(0, 4) === "-ms-" && (i = "ms-" + i.slice(4)), i = i.replace(HLe, YLe)), r[i] = s;
  }
}
function KLe(e) {
  const t = {};
  let r;
  for (r in e)
    VR.call(e, r) && (t[XW(r)] = e[r]);
  return t;
}
function XW(e) {
  let t = e.replace(jLe, XLe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function YLe(e, t) {
  return t.toUpperCase();
}
function XLe(e) {
  return "-" + e.toLowerCase();
}
const ZLe = {}.hasOwnProperty, JLe = [];
function ib(e, t) {
  const r = t ? [...t].sort(SD) : JLe;
  r.length > 0 && ZW(e, { comments: r, index: 0 });
}
function ZW(e, t) {
  if (t.index === t.comments.length)
    return;
  const r = [], n = [];
  let a;
  for (a in e)
    if (ZLe.call(e, a)) {
      const i = e[a];
      if (i && typeof i == "object" && a !== "comments")
        if (Array.isArray(i)) {
          let o = -1;
          for (; ++o < i.length; )
            i[o] && typeof i[o].type == "string" && r.push(i[o]);
        } else typeof i.type == "string" && r.push(i);
    }
  r.sort(SD), n.push(...o9(t, e, !1, { leading: !0, trailing: !1 }));
  let s = -1;
  for (; ++s < r.length; )
    ZW(r[s], t);
  n.push(
    ...o9(t, e, !0, {
      leading: !1,
      trailing: r.length > 0
    })
  ), n.length > 0 && (e.comments = n);
}
function o9(e, t, r, n) {
  const a = [];
  for (; e.comments[e.index] && SD(e.comments[e.index], t, r) < 1; )
    a.push(Object.assign({}, e.comments[e.index++], n));
  return a;
}
function SD(e, t, r) {
  const n = r ? "end" : "start";
  return e.range && t.range ? e.range[0] - t.range[r ? 1 : 0] : e.loc && e.loc.start && t.loc && t.loc[n] ? e.loc.start.line - t.loc[n].line || e.loc.start.column - t.loc[n].column : "start" in e && n in t ? e.start - t[n] : Number.NaN;
}
function l9(e, t) {
  const r = e.data && e.data.estree, n = r && r.comments || [];
  let a;
  r && (t.comments.push(...n), ib(r, r.comments), a = r.body[0] && r.body[0].type === "ExpressionStatement" && r.body[0].expression || void 0), a || (a = { type: "JSXEmptyExpression" }, t.patch(e, a));
  const s = { type: "JSXExpressionContainer", expression: a };
  return t.inherit(e, s), s;
}
function u9(e, t) {
  const r = t.schema;
  let n = r;
  const a = e.attributes || [];
  let s = -1;
  e.name && r.space === "html" && e.name.toLowerCase() === "svg" && (n = Eh, t.schema = n);
  const i = t.all(e), o = [];
  for (; ++s < a.length; ) {
    const u = a[s], c = u.value;
    let d;
    if (u.type === "mdxJsxAttribute") {
      if (c == null)
        d = null;
      else if (typeof c == "object") {
        const f = c.data && c.data.estree, h = f && f.comments || [];
        let m;
        f && (t.comments.push(...h), ib(f, f.comments), m = f.body[0] && f.body[0].type === "ExpressionStatement" && f.body[0].expression || void 0), d = {
          type: "JSXExpressionContainer",
          expression: m || { type: "JSXEmptyExpression" }
        }, t.inherit(c, d);
      } else
        d = { type: "Literal", value: String(c) };
      const p = {
        type: "JSXAttribute",
        name: t.createJsxAttributeName(u.name),
        value: d
      };
      t.inherit(u, p), o.push(p);
    } else {
      const p = u.data && u.data.estree, f = p && p.comments || [];
      let h;
      p && (t.comments.push(...f), ib(p, p.comments), h = p.body[0] && p.body[0].type === "ExpressionStatement" && p.body[0].expression && p.body[0].expression.type === "ObjectExpression" && p.body[0].expression.properties && p.body[0].expression.properties[0] && p.body[0].expression.properties[0].type === "SpreadElement" && p.body[0].expression.properties[0].argument || void 0);
      const m = {
        type: "JSXSpreadAttribute",
        argument: h || { type: "ObjectExpression", properties: [] }
      };
      t.inherit(u, m), o.push(m);
    }
  }
  t.schema = r;
  const l = e.name ? {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: o,
      name: t.createJsxElementName(e.name),
      selfClosing: i.length === 0
    },
    closingElement: i.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.name)
    } : null,
    children: i
  } : {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: i
  };
  return t.inherit(e, l), l;
}
function QLe(e, t) {
  const r = e.data && e.data.estree, n = r && r.comments || [];
  r && (t.comments.push(...n), ib(r, n), t.esm.push(...r.body));
}
function eMe(e, t) {
  const r = t.all(e), n = [];
  let a = -1, s;
  for (; ++a < r.length; ) {
    const o = r[a];
    o.type === "JSXExpressionContainer" && o.expression.type === "Literal" && ty(String(o.expression.value)) ? s && s.push(o) : (s && n.push(...s), n.push(o), s = []);
  }
  const i = {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: n
  };
  return t.inherit(e, i), i;
}
function tMe(e, t) {
  const r = String(e.value || "");
  if (r) {
    const n = { type: "Literal", value: r };
    t.inherit(e, n);
    const a = { type: "JSXExpressionContainer", expression: n };
    return t.patch(e, a), a;
  }
}
const rMe = {
  comment: $Le,
  doctype: nMe,
  element: GLe,
  mdxFlowExpression: l9,
  mdxJsxFlowElement: u9,
  mdxJsxTextElement: u9,
  mdxTextExpression: l9,
  mdxjsEsm: QLe,
  root: eMe,
  text: tMe
};
function nMe() {
}
const iMe = {}.hasOwnProperty, aMe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
function sMe(e) {
  const t = PH("type", {
    invalid: oMe,
    unknown: lMe,
    handlers: { ...rMe, ...e.handlers }
  });
  return {
    // Current space.
    elementAttributeNameCase: e.elementAttributeNameCase || "react",
    schema: e.space === "svg" ? Eh : OH,
    stylePropertyNameCase: e.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: e.tableCellAlignToStyle !== !1,
    // Results.
    comments: [],
    esm: [],
    // Useful functions.
    all: uMe,
    createJsxAttributeName: dMe,
    createJsxElementName: fMe,
    handle: r,
    inherit: cMe,
    patch: JW
  };
  function r(n) {
    return t(n, this);
  }
}
function oMe(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function lMe(e) {
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function uMe(e) {
  const t = e.children || [];
  let r = -1;
  const n = [], a = this.schema.space === "html" && e.type === "element" && aMe.has(e.tagName.toLowerCase());
  for (; ++r < t.length; ) {
    const s = t[r];
    if (a && s.type === "text" && s.value === `
`)
      continue;
    const i = this.handle(s);
    Array.isArray(i) ? n.push(...i) : i && n.push(i);
  }
  return n;
}
function cMe(e, t) {
  const r = (
    /** @type {Record<string, unknown> | undefined} */
    e.data
  );
  let n, a;
  if (JW(e, t), r) {
    for (a in r)
      iMe.call(r, a) && a !== "estree" && (n || (n = {}), n[a] = r[a]);
    n && (t.data = n);
  }
}
function JW(e, t) {
  const r = hW(e);
  r && r.start.offset !== void 0 && r.end.offset !== void 0 && (t.start = r.start.offset, t.end = r.end.offset, t.loc = {
    start: { line: r.start.line, column: r.start.column - 1 },
    end: { line: r.end.line, column: r.end.column - 1 }
  }, t.range = [r.start.offset, r.end.offset]);
}
function dMe(e) {
  const t = QW(e);
  if (t.type === "JSXMemberExpression")
    throw new Error("Member expressions in attribute names are not supported");
  return t;
}
function fMe(e) {
  return QW(e);
}
function QW(e) {
  if (e.includes(".")) {
    const t = e.split(".");
    let r = t.shift(), n = { type: "JSXIdentifier", name: r };
    for (; r = t.shift(); )
      n = {
        type: "JSXMemberExpression",
        object: n,
        property: { type: "JSXIdentifier", name: r }
      };
    return n;
  }
  if (e.includes(":")) {
    const t = e.split(":");
    return {
      type: "JSXNamespacedName",
      namespace: { type: "JSXIdentifier", name: t[0] },
      name: { type: "JSXIdentifier", name: t[1] }
    };
  }
  return { type: "JSXIdentifier", name: e };
}
function pMe(e, t) {
  const r = sMe(t || {});
  let n = r.handle(e);
  const a = r.esm;
  if (n) {
    n.type !== "JSXFragment" && n.type !== "JSXElement" && (n = {
      type: "JSXFragment",
      openingFragment: { type: "JSXOpeningFragment" },
      closingFragment: { type: "JSXClosingFragment" },
      children: [n]
    }, r.patch(e, n));
    const i = { type: "ExpressionStatement", expression: n };
    r.patch(e, i), a.push(i);
  }
  const s = {
    type: "Program",
    body: a,
    sourceType: "module",
    comments: r.comments
  };
  return r.patch(e, s), s;
}
function hMe(e) {
  return function(t) {
    return pMe(t, e);
  };
}
function mMe() {
  return {
    enter: {
      mdxFlowExpression: bMe,
      mdxTextExpression: yMe
    },
    exit: {
      mdxFlowExpression: c9,
      mdxFlowExpressionChunk: d9,
      mdxTextExpression: c9,
      mdxTextExpressionChunk: d9
    }
  };
}
function gMe() {
  return {
    handlers: {
      mdxFlowExpression: f9,
      mdxTextExpression: f9
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" }
    ]
  };
}
function bMe(e) {
  this.enter({ type: "mdxFlowExpression", value: "" }, e), this.buffer();
}
function yMe(e) {
  this.enter({ type: "mdxTextExpression", value: "" }, e), this.buffer();
}
function c9(e) {
  const t = this.resume(), r = e.estree, n = this.stack[this.stack.length - 1];
  n.type === "mdxFlowExpression" || n.type, this.exit(e), n.value = t, r && (n.data = { estree: r });
}
function d9(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function f9(e, t, r) {
  const n = e.value || "";
  return "{" + r.indentLines(n, function(s, i, o) {
    return (i === 0 || o ? "" : "  ") + s;
  }) + "}";
}
const p9 = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function eK(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function vMe(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
function wMe(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function h9(e) {
  return wMe(e) || eK(e);
}
const xMe = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function EMe(e, t) {
  const r = t, n = typeof r.additional == "string" ? r.additional.charCodeAt(0) : r.additional, a = [];
  let s = 0, i = -1, o = "", l, u;
  r.position && ("start" in r.position || "indent" in r.position ? (u = r.position.indent, l = r.position.start) : l = r.position);
  let c = (l ? l.line : 0) || 1, d = (l ? l.column : 0) || 1, p = h(), f;
  for (s--; ++s <= e.length; )
    if (f === 10 && (d = (u ? u[i] : 0) || 1), f = e.charCodeAt(s), f === 38) {
      const b = e.charCodeAt(s + 1);
      if (b === 9 || b === 10 || b === 12 || b === 32 || b === 38 || b === 60 || Number.isNaN(b) || n && b === n) {
        o += String.fromCharCode(f), d++;
        continue;
      }
      const v = s + 1;
      let x = v, _ = v, E;
      if (b === 35) {
        _ = ++x;
        const O = e.charCodeAt(_);
        O === 88 || O === 120 ? (E = "hexadecimal", _ = ++x) : E = "decimal";
      } else
        E = "named";
      let w = "", C = "", k = "";
      const S = E === "named" ? h9 : E === "decimal" ? eK : vMe;
      for (_--; ++_ <= e.length; ) {
        const O = e.charCodeAt(_);
        if (!S(O))
          break;
        k += String.fromCharCode(O), E === "named" && MH.includes(k) && (w = k, C = Hp(k));
      }
      let B = e.charCodeAt(_) === 59;
      if (B) {
        _++;
        const O = E === "named" ? Hp(k) : !1;
        O && (w = k, C = O);
      }
      let U = 1 + _ - v, N = "";
      if (!(!B && r.nonTerminated === !1)) if (!k)
        E !== "named" && m(4, U);
      else if (E === "named") {
        if (B && !C)
          m(5, 1);
        else if (w !== k && (_ = x + w.length, U = 1 + _ - x, B = !1), !B) {
          const O = w ? 1 : 3;
          if (r.attribute) {
            const I = e.charCodeAt(_);
            I === 61 ? (m(O, U), C = "") : h9(I) ? C = "" : m(O, U);
          } else
            m(O, U);
        }
        N = C;
      } else {
        B || m(2, U);
        let O = Number.parseInt(
          k,
          E === "hexadecimal" ? 16 : 10
        );
        if (SMe(O))
          m(7, U), N = "�";
        else if (O in p9)
          m(6, U), N = p9[O];
        else {
          let I = "";
          _Me(O) && m(6, U), O > 65535 && (O -= 65536, I += String.fromCharCode(
            O >>> 10 | 55296
          ), O = 56320 | O & 1023), N = I + String.fromCharCode(O);
        }
      }
      if (N) {
        y(), p = h(), s = _ - 1, d += _ - v + 1, a.push(N);
        const O = h();
        O.offset++, r.reference && r.reference.call(
          r.referenceContext || void 0,
          N,
          { start: p, end: O },
          e.slice(v - 1, _)
        ), p = O;
      } else
        k = e.slice(v - 1, _), o += k, d += k.length, s = _ - 1;
    } else
      f === 10 && (c++, i++, d = 0), Number.isNaN(f) ? y() : (o += String.fromCharCode(f), d++);
  return a.join("");
  function h() {
    return {
      line: c,
      column: d,
      offset: s + ((l ? l.offset : 0) || 0)
    };
  }
  function m(b, v) {
    let x;
    r.warning && (x = h(), x.column += v, x.offset += v, r.warning.call(
      r.warningContext || void 0,
      xMe[b],
      x,
      b
    ));
  }
  function y() {
    o && (a.push(o), r.text && r.text.call(r.textContext || void 0, o, {
      start: p,
      end: h()
    }), o = "");
  }
}
function SMe(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function _Me(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534;
}
const tK = "  ";
function kMe() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: n,
      mdxJsxFlowTagClosingMarker: a,
      mdxJsxFlowTagAttribute: d,
      mdxJsxFlowTagExpressionAttribute: p,
      mdxJsxFlowTagAttributeValueLiteral: e,
      mdxJsxFlowTagAttributeValueExpression: e,
      mdxJsxFlowTagSelfClosingMarker: i,
      mdxJsxTextTag: n,
      mdxJsxTextTagClosingMarker: a,
      mdxJsxTextTagAttribute: d,
      mdxJsxTextTagExpressionAttribute: p,
      mdxJsxTextTagAttributeValueLiteral: e,
      mdxJsxTextTagAttributeValueExpression: e,
      mdxJsxTextTagSelfClosingMarker: i
    },
    exit: {
      mdxJsxFlowTagClosingMarker: o,
      mdxJsxFlowTagNamePrimary: l,
      mdxJsxFlowTagNameMember: u,
      mdxJsxFlowTagNameLocal: c,
      mdxJsxFlowTagExpressionAttribute: f,
      mdxJsxFlowTagExpressionAttributeValue: r,
      mdxJsxFlowTagAttributeNamePrimary: h,
      mdxJsxFlowTagAttributeNameLocal: m,
      mdxJsxFlowTagAttributeValueLiteral: y,
      mdxJsxFlowTagAttributeValueLiteralValue: r,
      mdxJsxFlowTagAttributeValueExpression: b,
      mdxJsxFlowTagAttributeValueExpressionValue: r,
      mdxJsxFlowTagSelfClosingMarker: v,
      mdxJsxFlowTag: x,
      mdxJsxTextTagClosingMarker: o,
      mdxJsxTextTagNamePrimary: l,
      mdxJsxTextTagNameMember: u,
      mdxJsxTextTagNameLocal: c,
      mdxJsxTextTagExpressionAttribute: f,
      mdxJsxTextTagExpressionAttributeValue: r,
      mdxJsxTextTagAttributeNamePrimary: h,
      mdxJsxTextTagAttributeNameLocal: m,
      mdxJsxTextTagAttributeValueLiteral: y,
      mdxJsxTextTagAttributeValueLiteralValue: r,
      mdxJsxTextTagAttributeValueExpression: b,
      mdxJsxTextTagAttributeValueExpressionValue: r,
      mdxJsxTextTagSelfClosingMarker: v,
      mdxJsxTextTag: x
    }
  };
  function e() {
    this.buffer();
  }
  function t(C) {
    return { line: C.line, column: C.column, offset: C.offset };
  }
  function r(C) {
    this.config.enter.data.call(this, C), this.config.exit.data.call(this, C);
  }
  function n(C) {
    const k = {
      name: void 0,
      attributes: [],
      close: !1,
      selfClosing: !1,
      start: C.start,
      end: C.end
    };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = k, this.buffer();
  }
  function a(C) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new Rn(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: C.start, end: C.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function s(C) {
    if (this.data.mdxJsxTag.close)
      throw new Rn(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: C.start, end: C.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function i(C) {
    if (this.data.mdxJsxTag.close)
      throw new Rn(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: C.start, end: C.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function o() {
    const C = this.data.mdxJsxTag;
    C.close = !0;
  }
  function l(C) {
    const k = this.data.mdxJsxTag;
    k.name = this.sliceSerialize(C);
  }
  function u(C) {
    const k = this.data.mdxJsxTag;
    k.name += "." + this.sliceSerialize(C);
  }
  function c(C) {
    const k = this.data.mdxJsxTag;
    k.name += ":" + this.sliceSerialize(C);
  }
  function d(C) {
    const k = this.data.mdxJsxTag;
    s.call(this, C), k.attributes.push({
      type: "mdxJsxAttribute",
      name: "",
      value: null,
      position: {
        start: t(C.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    });
  }
  function p(C) {
    const k = this.data.mdxJsxTag;
    s.call(this, C), k.attributes.push({
      type: "mdxJsxExpressionAttribute",
      value: "",
      position: {
        start: t(C.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    }), this.buffer();
  }
  function f(C) {
    const k = this.data.mdxJsxTag, S = k.attributes[k.attributes.length - 1];
    S.type;
    const B = C.estree;
    S.value = this.resume(), S.position, S.position.end = t(C.end), B && (S.data = { estree: B });
  }
  function h(C) {
    const k = this.data.mdxJsxTag, S = k.attributes[k.attributes.length - 1];
    S.type, S.name = this.sliceSerialize(C), S.position, S.position.end = t(C.end);
  }
  function m(C) {
    const k = this.data.mdxJsxTag, S = k.attributes[k.attributes.length - 1];
    S.type, S.name += ":" + this.sliceSerialize(C), S.position, S.position.end = t(C.end);
  }
  function y(C) {
    const k = this.data.mdxJsxTag, S = k.attributes[k.attributes.length - 1];
    S.value = EMe(this.resume(), { nonTerminated: !1 }), S.position, S.position.end = t(C.end);
  }
  function b(C) {
    const k = this.data.mdxJsxTag, S = k.attributes[k.attributes.length - 1];
    S.type;
    const B = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, U = C.estree;
    U && (B.data = { estree: U }), S.value = B, S.position, S.position.end = t(C.end);
  }
  function v() {
    const C = this.data.mdxJsxTag;
    C.selfClosing = !0;
  }
  function x(C) {
    const k = this.data.mdxJsxTag, S = this.data.mdxJsxTagStack, B = S[S.length - 1];
    if (k.close && B.name !== k.name)
      throw new Rn(
        "Unexpected closing tag `" + w(k) + "`, expected corresponding closing tag for `" + w(B) + "` (" + ss(B) + ")",
        { start: C.start, end: C.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(), k.close ? S.pop() : this.enter(
      {
        type: C.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
        name: k.name || null,
        attributes: k.attributes,
        children: []
      },
      C,
      _
    ), k.selfClosing || k.close ? this.exit(C, E) : S.push(k);
  }
  function _(C, k) {
    const S = this.data.mdxJsxTagStack, B = S[S.length - 1], U = C ? " before the end of `" + C.type + "`" : "", N = C ? { start: C.start, end: C.end } : void 0;
    throw new Rn(
      "Expected a closing tag for `" + w(B) + "` (" + ss({ start: k.start, end: k.end }) + ")" + U,
      N,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function E(C, k) {
    const S = this.data.mdxJsxTag;
    throw new Rn(
      "Expected the closing tag `" + w(S) + "` either after the end of `" + k.type + "` (" + ss(k.end) + ") or another opening tag after the start of `" + k.type + "` (" + ss(k.start) + ")",
      { start: C.start, end: C.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function w(C) {
    return "<" + (C.close ? "/" : "") + (C.name || "") + ">";
  }
}
function CMe(e) {
  const t = e, r = t.quote || '"', n = t.quoteSmart || !1, a = t.tightSelfClosing || !1, s = t.printWidth || Number.POSITIVE_INFINITY, i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error(
      "Cannot serialize attribute values with `" + r + "` for `options.quote`, expected `\"`, or `'`"
    );
  return o.peek = TMe, {
    handlers: {
      mdxJsxFlowElement: o,
      mdxJsxTextElement: o
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: !0,
    // Always generate links with resources (never autolinks).
    resourceLink: !0
  };
  function o(l, u, c, d) {
    const p = l.type === "mdxJsxFlowElement", f = l.name ? !l.children || l.children.length === 0 : !1, h = rK(c), m = nK(h), y = c.createTracker(d), b = c.createTracker(d), v = [], x = (p ? m : "") + "<" + (l.name || ""), _ = c.enter(l.type);
    if (y.move(x), b.move(x), l.attributes && l.attributes.length > 0) {
      if (!l.name)
        throw new Error("Cannot serialize fragment w/ attributes");
      let S = -1;
      for (; ++S < l.attributes.length; ) {
        const B = l.attributes[S];
        let U;
        if (B.type === "mdxJsxExpressionAttribute")
          U = "{" + (B.value || "") + "}";
        else {
          if (!B.name)
            throw new Error("Cannot serialize attribute w/o name");
          const N = B.value, O = B.name;
          let I = "";
          if (N != null) if (typeof N == "object")
            I = "{" + (N.value || "") + "}";
          else {
            const q = n && od(N, r) > od(N, i) ? i : r;
            I = q + Tge(N, { subset: [q] }) + q;
          }
          U = O + (I ? "=" : "") + I;
        }
        v.push(U);
      }
    }
    let E = !1;
    const w = v.join(" ");
    // Block:
    p && // Including a line ending (expressions).
    (/\r?\n|\r/.test(w) || // Current position (including `<tag`).
    y.current().now.column + // -1 because columns, +1 for ` ` before attributes.
    // Attributes joined by spaces.
    w.length + // ` />`.
    (f ? a ? 2 : 3 : 1) > s) && (E = !0);
    let C = y, k = x;
    if (E) {
      C = b;
      let S = -1;
      for (; ++S < v.length; )
        v[S] = m + tK + v[S];
      k += C.move(
        `
` + v.join(`
`) + `
` + m
      );
    } else w && (k += C.move(" " + w));
    return f && (k += C.move(
      (a || E ? "" : " ") + "/"
    )), k += C.move(">"), l.children && l.children.length > 0 && (l.type === "mdxJsxTextElement" ? k += C.move(
      c.containerPhrasing(l, {
        ...C.current(),
        before: ">",
        after: "<"
      })
    ) : (C.shift(2), k += C.move(`
`), k += C.move(AMe(l, c, C.current())), k += C.move(`
`))), f || (k += C.move(
      (p ? m : "") + "</" + (l.name || "") + ">"
    )), _(), k;
  }
}
function AMe(e, t, r) {
  const n = t.indexStack, a = e.children, s = t.createTracker(r), i = nK(rK(t)), o = [];
  let l = -1;
  for (n.push(-1); ++l < a.length; ) {
    const u = a[l];
    n[n.length - 1] = l;
    const c = { before: `
`, after: `
`, ...s.current() }, d = t.handle(u, e, t, c), p = u.type === "mdxJsxFlowElement" ? d : t.indentLines(d, function(f, h, m) {
      return (m ? "" : i) + f;
    });
    o.push(s.move(p)), u.type !== "list" && (t.bulletLastUsed = void 0), l < a.length - 1 && o.push(s.move(`

`));
  }
  return n.pop(), o.join("");
}
function rK(e) {
  let t = 0, r = e.stack.length;
  for (; --r > -1; ) {
    const n = e.stack[r];
    if (n === "blockquote" || n === "listItem") break;
    n === "mdxJsxFlowElement" && t++;
  }
  return t;
}
function nK(e) {
  return tK.repeat(e);
}
function TMe() {
  return "<";
}
function RMe() {
  return {
    enter: { mdxjsEsm: NMe },
    exit: { mdxjsEsm: DMe, mdxjsEsmData: OMe }
  };
}
function IMe() {
  return { handlers: { mdxjsEsm: PMe } };
}
function NMe(e) {
  this.enter({ type: "mdxjsEsm", value: "" }, e), this.buffer();
}
function DMe(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, this.exit(e);
  const n = e.estree;
  r.value = t, n && (r.data = { estree: n });
}
function OMe(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function PMe(e) {
  return e.value || "";
}
function LMe() {
  return [
    mMe(),
    kMe(),
    RMe()
  ];
}
function MMe(e) {
  return {
    extensions: [
      gMe(),
      CMe(e),
      IMe()
    ]
  };
}
var FMe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], iK = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], $Me = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", aK = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", YA = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, XA = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", BMe = {
  5: XA,
  "5module": XA + " export import",
  6: XA + " const class extends export import super"
}, UMe = /^in(stanceof)?$/, zMe = new RegExp("[" + aK + "]"), qMe = new RegExp("[" + aK + $Me + "]");
function GR(e, t) {
  for (var r = 65536, n = 0; n < t.length; n += 2) {
    if (r += t[n], r > e)
      return !1;
    if (r += t[n + 1], r >= e)
      return !0;
  }
  return !1;
}
function Vo(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && zMe.test(String.fromCharCode(e)) : t === !1 ? !1 : GR(e, iK);
}
function bd(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && qMe.test(String.fromCharCode(e)) : t === !1 ? !1 : GR(e, iK) || GR(e, FMe);
}
var vn = function(t, r) {
  r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function Za(e, t) {
  return new vn(e, { beforeExpr: !0, binop: t });
}
var Ja = { beforeExpr: !0 }, ya = { startsExpr: !0 }, _D = {};
function dn(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, _D[e] = new vn(e, t);
}
var ke = {
  num: new vn("num", ya),
  regexp: new vn("regexp", ya),
  string: new vn("string", ya),
  name: new vn("name", ya),
  privateId: new vn("privateId", ya),
  eof: new vn("eof"),
  // Punctuation token types.
  bracketL: new vn("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new vn("]"),
  braceL: new vn("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new vn("}"),
  parenL: new vn("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new vn(")"),
  comma: new vn(",", Ja),
  semi: new vn(";", Ja),
  colon: new vn(":", Ja),
  dot: new vn("."),
  question: new vn("?", Ja),
  questionDot: new vn("?."),
  arrow: new vn("=>", Ja),
  template: new vn("template"),
  invalidTemplate: new vn("invalidTemplate"),
  ellipsis: new vn("...", Ja),
  backQuote: new vn("`", ya),
  dollarBraceL: new vn("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new vn("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new vn("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new vn("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new vn("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: Za("||", 1),
  logicalAND: Za("&&", 2),
  bitwiseOR: Za("|", 3),
  bitwiseXOR: Za("^", 4),
  bitwiseAND: Za("&", 5),
  equality: Za("==/!=/===/!==", 6),
  relational: Za("</>/<=/>=", 7),
  bitShift: Za("<</>>/>>>", 8),
  plusMin: new vn("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: Za("%", 10),
  star: Za("*", 10),
  slash: Za("/", 10),
  starstar: new vn("**", { beforeExpr: !0 }),
  coalesce: Za("??", 1),
  // Keyword token types.
  _break: dn("break"),
  _case: dn("case", Ja),
  _catch: dn("catch"),
  _continue: dn("continue"),
  _debugger: dn("debugger"),
  _default: dn("default", Ja),
  _do: dn("do", { isLoop: !0, beforeExpr: !0 }),
  _else: dn("else", Ja),
  _finally: dn("finally"),
  _for: dn("for", { isLoop: !0 }),
  _function: dn("function", ya),
  _if: dn("if"),
  _return: dn("return", Ja),
  _switch: dn("switch"),
  _throw: dn("throw", Ja),
  _try: dn("try"),
  _var: dn("var"),
  _const: dn("const"),
  _while: dn("while", { isLoop: !0 }),
  _with: dn("with"),
  _new: dn("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: dn("this", ya),
  _super: dn("super", ya),
  _class: dn("class", ya),
  _extends: dn("extends", Ja),
  _export: dn("export"),
  _import: dn("import", ya),
  _null: dn("null", ya),
  _true: dn("true", ya),
  _false: dn("false", ya),
  _in: dn("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: dn("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: dn("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: dn("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: dn("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, ms = /\r\n?|\n|\u2028|\u2029/, jMe = new RegExp(ms.source, "g");
function Pd(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function sK(e, t, r) {
  r === void 0 && (r = e.length);
  for (var n = t; n < r; n++) {
    var a = e.charCodeAt(n);
    if (Pd(a))
      return n < r - 1 && a === 13 && e.charCodeAt(n + 1) === 10 ? n + 2 : n + 1;
  }
  return -1;
}
var oK = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, ts = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, lK = Object.prototype, HMe = lK.hasOwnProperty, VMe = lK.toString, Ld = Object.hasOwn || function(e, t) {
  return HMe.call(e, t);
}, m9 = Array.isArray || function(e) {
  return VMe.call(e) === "[object Array]";
}, g9 = /* @__PURE__ */ Object.create(null);
function Nl(e) {
  return g9[e] || (g9[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function Go(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
var GMe = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Gp = function(t, r) {
  this.line = t, this.column = r;
};
Gp.prototype.offset = function(t) {
  return new Gp(this.line, this.column + t);
};
var Ey = function(t, r, n) {
  this.start = r, this.end = n, t.sourceFile !== null && (this.source = t.sourceFile);
};
function uK(e, t) {
  for (var r = 1, n = 0; ; ) {
    var a = sK(e, n, t);
    if (a < 0)
      return new Gp(r, t - n);
    ++r, n = a;
  }
}
var WR = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, b9 = !1;
function WMe(e) {
  var t = {};
  for (var r in WR)
    t[r] = e && Ld(e, r) ? e[r] : WR[r];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!b9 && typeof console == "object" && console.warn && (b9 = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14), m9(t.onToken)) {
    var n = t.onToken;
    t.onToken = function(a) {
      return n.push(a);
    };
  }
  return m9(t.onComment) && (t.onComment = KMe(t, t.onComment)), t;
}
function KMe(e, t) {
  return function(r, n, a, s, i, o) {
    var l = {
      type: r ? "Block" : "Line",
      value: n,
      start: a,
      end: s
    };
    e.locations && (l.loc = new Ey(this, i, o)), e.ranges && (l.range = [a, s]), t.push(l);
  };
}
var Wp = 1, Md = 2, kD = 4, cK = 8, dK = 16, fK = 32, CD = 64, pK = 128, Rh = 256, AD = Wp | Md | Rh;
function TD(e, t) {
  return Md | (e ? kD : 0) | (t ? cK : 0);
}
var ab = 0, RD = 1, el = 2, hK = 3, mK = 4, gK = 5, Ei = function(t, r, n) {
  this.options = t = WMe(t), this.sourceFile = t.sourceFile, this.keywords = Nl(BMe[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var a = "";
  t.allowReserved !== !0 && (a = YA[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (a += " await")), this.reservedWords = Nl(a);
  var s = (a ? a + " " : "") + YA.strict;
  this.reservedWordsStrict = Nl(s), this.reservedWordsStrictBind = Nl(s + " " + YA.strictBind), this.input = String(r), this.containsEsc = !1, n ? (this.pos = n, this.lineStart = this.input.lastIndexOf(`
`, n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(ms).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = ke.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Wp), this.regexpState = null, this.privateNameStack = [];
}, yo = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
Ei.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
yo.inFunction.get = function() {
  return (this.currentVarScope().flags & Md) > 0;
};
yo.inGenerator.get = function() {
  return (this.currentVarScope().flags & cK) > 0 && !this.currentVarScope().inClassFieldInit;
};
yo.inAsync.get = function() {
  return (this.currentVarScope().flags & kD) > 0 && !this.currentVarScope().inClassFieldInit;
};
yo.canAwait.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e];
    if (t.inClassFieldInit || t.flags & Rh)
      return !1;
    if (t.flags & Md)
      return (t.flags & kD) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
yo.allowSuper.get = function() {
  var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit;
  return (t & CD) > 0 || r || this.options.allowSuperOutsideMethod;
};
yo.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & pK) > 0;
};
yo.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
yo.allowNewDotTarget.get = function() {
  var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit;
  return (t & (Md | Rh)) > 0 || r;
};
yo.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & Rh) > 0;
};
Ei.extend = function() {
  for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
  for (var n = this, a = 0; a < t.length; a++)
    n = t[a](n);
  return n;
};
Ei.parse = function(t, r) {
  return new this(r, t).parse();
};
Ei.parseExpressionAt = function(t, r, n) {
  var a = new this(n, t, r);
  return a.nextToken(), a.parseExpression();
};
Ei.tokenizer = function(t, r) {
  return new this(r, t);
};
Object.defineProperties(Ei.prototype, yo);
var fa = Ei.prototype, YMe = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
fa.strictDirective = function(e) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    ts.lastIndex = e, e += ts.exec(this.input)[0].length;
    var t = YMe.exec(this.input.slice(e));
    if (!t)
      return !1;
    if ((t[1] || t[2]) === "use strict") {
      ts.lastIndex = e + t[0].length;
      var r = ts.exec(this.input), n = r.index + r[0].length, a = this.input.charAt(n);
      return a === ";" || a === "}" || ms.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(a) || a === "!" && this.input.charAt(n + 1) === "=");
    }
    e += t[0].length, ts.lastIndex = e, e += ts.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
fa.eat = function(e) {
  return this.type === e ? (this.next(), !0) : !1;
};
fa.isContextual = function(e) {
  return this.type === ke.name && this.value === e && !this.containsEsc;
};
fa.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), !0) : !1;
};
fa.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
fa.canInsertSemicolon = function() {
  return this.type === ke.eof || this.type === ke.braceR || ms.test(this.input.slice(this.lastTokEnd, this.start));
};
fa.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
fa.semicolon = function() {
  !this.eat(ke.semi) && !this.insertSemicolon() && this.unexpected();
};
fa.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
};
fa.expect = function(e) {
  this.eat(e) || this.unexpected();
};
fa.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
var Sy = function() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
fa.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, t ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
fa.checkExpressionErrors = function(e, t) {
  if (!e)
    return !1;
  var r = e.shorthandAssign, n = e.doubleProto;
  if (!t)
    return r >= 0 || n >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), n >= 0 && this.raiseRecoverable(n, "Redefinition of __proto__ property");
};
fa.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
fa.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var Tr = Ei.prototype;
Tr.parseTopLevel = function(e) {
  var t = /* @__PURE__ */ Object.create(null);
  for (e.body || (e.body = []); this.type !== ke.eof; ) {
    var r = this.parseStatement(null, !0, t);
    e.body.push(r);
  }
  if (this.inModule)
    for (var n = 0, a = Object.keys(this.undefinedExports); n < a.length; n += 1) {
      var s = a[n];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var ID = { kind: "loop" }, XMe = { kind: "switch" };
Tr.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  ts.lastIndex = this.pos;
  var t = ts.exec(this.input), r = this.pos + t[0].length, n = this.input.charCodeAt(r);
  if (n === 91 || n === 92)
    return !0;
  if (e)
    return !1;
  if (n === 123 || n > 55295 && n < 56320)
    return !0;
  if (Vo(n, !0)) {
    for (var a = r + 1; bd(n = this.input.charCodeAt(a), !0); )
      ++a;
    if (n === 92 || n > 55295 && n < 56320)
      return !0;
    var s = this.input.slice(r, a);
    if (!UMe.test(s))
      return !0;
  }
  return !1;
};
Tr.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  ts.lastIndex = this.pos;
  var e = ts.exec(this.input), t = this.pos + e[0].length, r;
  return !ms.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(bd(r = this.input.charCodeAt(t + 8)) || r > 55295 && r < 56320));
};
Tr.parseStatement = function(e, t, r) {
  var n = this.type, a = this.startNode(), s;
  switch (this.isLet(e) && (n = ke._var, s = "let"), n) {
    case ke._break:
    case ke._continue:
      return this.parseBreakContinueStatement(a, n.keyword);
    case ke._debugger:
      return this.parseDebuggerStatement(a);
    case ke._do:
      return this.parseDoStatement(a);
    case ke._for:
      return this.parseForStatement(a);
    case ke._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(a, !1, !e);
    case ke._class:
      return e && this.unexpected(), this.parseClass(a, !0);
    case ke._if:
      return this.parseIfStatement(a);
    case ke._return:
      return this.parseReturnStatement(a);
    case ke._switch:
      return this.parseSwitchStatement(a);
    case ke._throw:
      return this.parseThrowStatement(a);
    case ke._try:
      return this.parseTryStatement(a);
    case ke._const:
    case ke._var:
      return s = s || this.value, e && s !== "var" && this.unexpected(), this.parseVarStatement(a, s);
    case ke._while:
      return this.parseWhileStatement(a);
    case ke._with:
      return this.parseWithStatement(a);
    case ke.braceL:
      return this.parseBlock(!0, a);
    case ke.semi:
      return this.parseEmptyStatement(a);
    case ke._export:
    case ke._import:
      if (this.options.ecmaVersion > 10 && n === ke._import) {
        ts.lastIndex = this.pos;
        var i = ts.exec(this.input), o = this.pos + i[0].length, l = this.input.charCodeAt(o);
        if (l === 40 || l === 46)
          return this.parseExpressionStatement(a, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), n === ke._import ? this.parseImport(a) : this.parseExport(a, r);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(a, !0, !e);
      var u = this.value, c = this.parseExpression();
      return n === ke.name && c.type === "Identifier" && this.eat(ke.colon) ? this.parseLabeledStatement(a, u, c, e) : this.parseExpressionStatement(a, c);
  }
};
Tr.parseBreakContinueStatement = function(e, t) {
  var r = t === "break";
  this.next(), this.eat(ke.semi) || this.insertSemicolon() ? e.label = null : this.type !== ke.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var n = 0; n < this.labels.length; ++n) {
    var a = this.labels[n];
    if ((e.label == null || a.name === e.label.name) && (a.kind != null && (r || a.kind === "loop") || e.label && r))
      break;
  }
  return n === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
};
Tr.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
Tr.parseDoStatement = function(e) {
  return this.next(), this.labels.push(ID), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(ke._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(ke.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
Tr.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(ID), this.enterScope(0), this.expect(ke.parenL), this.type === ke.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var r = this.isLet();
  if (this.type === ke._var || this.type === ke._const || r) {
    var n = this.startNode(), a = r ? "let" : this.value;
    return this.next(), this.parseVar(n, !0, a), this.finishNode(n, "VariableDeclaration"), (this.type === ke._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && n.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === ke._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, n)) : (t > -1 && this.unexpected(t), this.parseFor(e, n));
  }
  var s = this.isContextual("let"), i = !1, o = this.containsEsc, l = new Sy(), u = this.start, c = t > -1 ? this.parseExprSubscripts(l, "await") : this.parseExpression(!0, l);
  return this.type === ke._in || (i = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === ke._in && this.unexpected(t), e.await = !0) : i && this.options.ecmaVersion >= 8 && (c.start === u && !o && c.type === "Identifier" && c.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (e.await = !1)), s && i && this.raise(c.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(c, !1, l), this.checkLValPattern(c), this.parseForIn(e, c)) : (this.checkExpressionErrors(l, !0), t > -1 && this.unexpected(t), this.parseFor(e, c));
};
Tr.parseFunctionStatement = function(e, t, r) {
  return this.next(), this.parseFunction(e, np | (r ? 0 : KR), !1, t);
};
Tr.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(ke._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
Tr.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(ke.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
Tr.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(ke.braceL), this.labels.push(XMe), this.enterScope(0);
  for (var t, r = !1; this.type !== ke.braceR; )
    if (this.type === ke._case || this.type === ke._default) {
      var n = this.type === ke._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), n ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, t.test = null), this.expect(ke.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
Tr.parseThrowStatement = function(e) {
  return this.next(), ms.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var ZMe = [];
Tr.parseCatchClauseParam = function() {
  var e = this.parseBindingAtom(), t = e.type === "Identifier";
  return this.enterScope(t ? fK : 0), this.checkLValPattern(e, t ? mK : el), this.expect(ke.parenR), e;
};
Tr.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === ke._catch) {
    var t = this.startNode();
    this.next(), this.eat(ke.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(ke._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
Tr.parseVarStatement = function(e, t, r) {
  return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
Tr.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(ID), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
Tr.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
Tr.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
Tr.parseLabeledStatement = function(e, t, r, n) {
  for (var a = 0, s = this.labels; a < s.length; a += 1) {
    var i = s[a];
    i.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === ke._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var u = this.labels[l];
    if (u.statementStart === e.start)
      u.statementStart = this.start, u.kind = o;
    else
      break;
  }
  return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(n ? n.indexOf("label") === -1 ? n + "label" : n : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
};
Tr.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
Tr.parseBlock = function(e, t, r) {
  for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(ke.braceL), e && this.enterScope(0); this.type !== ke.braceR; ) {
    var n = this.parseStatement(null);
    t.body.push(n);
  }
  return r && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
Tr.parseFor = function(e, t) {
  return e.init = t, this.expect(ke.semi), e.test = this.type === ke.semi ? null : this.parseExpression(), this.expect(ke.semi), e.update = this.type === ke.parenR ? null : this.parseExpression(), this.expect(ke.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
Tr.parseForIn = function(e, t) {
  var r = this.type === ke._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
    t.start,
    (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(ke.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
};
Tr.parseVar = function(e, t, r, n) {
  for (e.declarations = [], e.kind = r; ; ) {
    var a = this.startNode();
    if (this.parseVarId(a, r), this.eat(ke.eq) ? a.init = this.parseMaybeAssign(t) : !n && r === "const" && !(this.type === ke._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !n && a.id.type !== "Identifier" && !(t && (this.type === ke._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : a.init = null, e.declarations.push(this.finishNode(a, "VariableDeclarator")), !this.eat(ke.comma))
      break;
  }
  return e;
};
Tr.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? RD : el, !1);
};
var np = 1, KR = 2, bK = 4;
Tr.parseFunction = function(e, t, r, n, a) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !n) && (this.type === ke.star && t & KR && this.unexpected(), e.generator = this.eat(ke.star)), this.options.ecmaVersion >= 8 && (e.async = !!n), t & np && (e.id = t & bK && this.type !== ke.name ? null : this.parseIdent(), e.id && !(t & KR) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? RD : el : hK));
  var s = this.yieldPos, i = this.awaitPos, o = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(TD(e.async, e.generator)), t & np || (e.id = this.type === ke.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, !1, a), this.yieldPos = s, this.awaitPos = i, this.awaitIdentPos = o, this.finishNode(e, t & np ? "FunctionDeclaration" : "FunctionExpression");
};
Tr.parseFunctionParams = function(e) {
  this.expect(ke.parenL), e.params = this.parseBindingList(ke.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
Tr.parseClass = function(e, t) {
  this.next();
  var r = this.strict;
  this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
  var n = this.enterClassBody(), a = this.startNode(), s = !1;
  for (a.body = [], this.expect(ke.braceL); this.type !== ke.braceR; ) {
    var i = this.parseClassElement(e.superClass !== null);
    i && (a.body.push(i), i.type === "MethodDefinition" && i.kind === "constructor" ? (s && this.raiseRecoverable(i.start, "Duplicate constructor in the same class"), s = !0) : i.key && i.key.type === "PrivateIdentifier" && JMe(n, i) && this.raiseRecoverable(i.key.start, "Identifier '#" + i.key.name + "' has already been declared"));
  }
  return this.strict = r, this.next(), e.body = this.finishNode(a, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
Tr.parseClassElement = function(e) {
  if (this.eat(ke.semi))
    return null;
  var t = this.options.ecmaVersion, r = this.startNode(), n = "", a = !1, s = !1, i = "method", o = !1;
  if (this.eatContextual("static")) {
    if (t >= 13 && this.eat(ke.braceL))
      return this.parseClassStaticBlock(r), r;
    this.isClassElementNameStart() || this.type === ke.star ? o = !0 : n = "static";
  }
  if (r.static = o, !n && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === ke.star) && !this.canInsertSemicolon() ? s = !0 : n = "async"), !n && (t >= 9 || !s) && this.eat(ke.star) && (a = !0), !n && !s && !a) {
    var l = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? i = l : n = l);
  }
  if (n ? (r.computed = !1, r.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r.key.name = n, this.finishNode(r.key, "Identifier")) : this.parseClassElementName(r), t < 13 || this.type === ke.parenL || i !== "method" || a || s) {
    var u = !r.static && sb(r, "constructor"), c = u && e;
    u && i !== "method" && this.raise(r.key.start, "Constructor can't have get/set modifier"), r.kind = u ? "constructor" : i, this.parseClassMethod(r, a, s, c);
  } else
    this.parseClassField(r);
  return r;
};
Tr.isClassElementNameStart = function() {
  return this.type === ke.name || this.type === ke.privateId || this.type === ke.num || this.type === ke.string || this.type === ke.bracketL || this.type.keyword;
};
Tr.parseClassElementName = function(e) {
  this.type === ke.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
};
Tr.parseClassMethod = function(e, t, r, n) {
  var a = e.key;
  e.kind === "constructor" ? (t && this.raise(a.start, "Constructor can't be a generator"), r && this.raise(a.start, "Constructor can't be an async method")) : e.static && sb(e, "prototype") && this.raise(a.start, "Classes may not have a static property named prototype");
  var s = e.value = this.parseMethod(t, r, n);
  return e.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"), e.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"), e.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
};
Tr.parseClassField = function(e) {
  if (sb(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && sb(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(ke.eq)) {
    var t = this.currentThisScope(), r = t.inClassFieldInit;
    t.inClassFieldInit = !0, e.value = this.parseMaybeAssign(), t.inClassFieldInit = r;
  } else
    e.value = null;
  return this.semicolon(), this.finishNode(e, "PropertyDefinition");
};
Tr.parseClassStaticBlock = function(e) {
  e.body = [];
  var t = this.labels;
  for (this.labels = [], this.enterScope(Rh | CD); this.type !== ke.braceR; ) {
    var r = this.parseStatement(null);
    e.body.push(r);
  }
  return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
};
Tr.parseClassId = function(e, t) {
  this.type === ke.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, el, !1)) : (t === !0 && this.unexpected(), e.id = null);
};
Tr.parseClassSuper = function(e) {
  e.superClass = this.eat(ke._extends) ? this.parseExprSubscripts(null, !1) : null;
};
Tr.enterClassBody = function() {
  var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(e), e.declared;
};
Tr.exitClassBody = function() {
  var e = this.privateNameStack.pop(), t = e.declared, r = e.used;
  if (this.options.checkPrivateFields)
    for (var n = this.privateNameStack.length, a = n === 0 ? null : this.privateNameStack[n - 1], s = 0; s < r.length; ++s) {
      var i = r[s];
      Ld(t, i.name) || (a ? a.used.push(i) : this.raiseRecoverable(i.start, "Private field '#" + i.name + "' must be declared in an enclosing class"));
    }
};
function JMe(e, t) {
  var r = t.key.name, n = e[r], a = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (a = (t.static ? "s" : "i") + t.kind), n === "iget" && a === "iset" || n === "iset" && a === "iget" || n === "sget" && a === "sset" || n === "sset" && a === "sget" ? (e[r] = "true", !1) : n ? !0 : (e[r] = a, !1);
}
function sb(e, t) {
  var r = e.computed, n = e.key;
  return !r && (n.type === "Identifier" && n.name === t || n.type === "Literal" && n.value === t);
}
Tr.parseExportAllDeclaration = function(e, t) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== ke.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
};
Tr.parseExport = function(e, t) {
  if (this.next(), this.eat(ke.star))
    return this.parseExportAllDeclaration(e, t);
  if (this.eat(ke._default))
    return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== ke.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    else {
      for (var r = 0, n = e.specifiers; r < n.length; r += 1) {
        var a = n[r];
        this.checkUnreserved(a.local), this.checkLocalExport(a.local), a.local.type === "Literal" && this.raise(a.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
Tr.parseExportDeclaration = function(e) {
  return this.parseStatement(null);
};
Tr.parseExportDefaultDeclaration = function() {
  var e;
  if (this.type === ke._function || (e = this.isAsyncFunction())) {
    var t = this.startNode();
    return this.next(), e && this.next(), this.parseFunction(t, np | bK, !1, e);
  } else if (this.type === ke._class) {
    var r = this.startNode();
    return this.parseClass(r, "nullableID");
  } else {
    var n = this.parseMaybeAssign();
    return this.semicolon(), n;
  }
};
Tr.checkExport = function(e, t, r) {
  e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Ld(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"), e[t] = !0);
};
Tr.checkPatternExport = function(e, t) {
  var r = t.type;
  if (r === "Identifier")
    this.checkExport(e, t, t.start);
  else if (r === "ObjectPattern")
    for (var n = 0, a = t.properties; n < a.length; n += 1) {
      var s = a[n];
      this.checkPatternExport(e, s);
    }
  else if (r === "ArrayPattern")
    for (var i = 0, o = t.elements; i < o.length; i += 1) {
      var l = o[i];
      l && this.checkPatternExport(e, l);
    }
  else r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "RestElement" && this.checkPatternExport(e, t.argument);
};
Tr.checkVariableExport = function(e, t) {
  if (e)
    for (var r = 0, n = t; r < n.length; r += 1) {
      var a = n[r];
      this.checkPatternExport(e, a.id);
    }
};
Tr.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
Tr.parseExportSpecifier = function(e) {
  var t = this.startNode();
  return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
    e,
    t.exported,
    t.exported.start
  ), this.finishNode(t, "ExportSpecifier");
};
Tr.parseExportSpecifiers = function(e) {
  var t = [], r = !0;
  for (this.expect(ke.braceL); !this.eat(ke.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(ke.comma), this.afterTrailingComma(ke.braceR))
      break;
    t.push(this.parseExportSpecifier(e));
  }
  return t;
};
Tr.parseImport = function(e) {
  return this.next(), this.type === ke.string ? (e.specifiers = ZMe, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === ke.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
Tr.parseImportSpecifier = function() {
  var e = this.startNode();
  return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, el), this.finishNode(e, "ImportSpecifier");
};
Tr.parseImportDefaultSpecifier = function() {
  var e = this.startNode();
  return e.local = this.parseIdent(), this.checkLValSimple(e.local, el), this.finishNode(e, "ImportDefaultSpecifier");
};
Tr.parseImportNamespaceSpecifier = function() {
  var e = this.startNode();
  return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, el), this.finishNode(e, "ImportNamespaceSpecifier");
};
Tr.parseImportSpecifiers = function() {
  var e = [], t = !0;
  if (this.type === ke.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(ke.comma)))
    return e;
  if (this.type === ke.star)
    return e.push(this.parseImportNamespaceSpecifier()), e;
  for (this.expect(ke.braceL); !this.eat(ke.braceR); ) {
    if (t)
      t = !1;
    else if (this.expect(ke.comma), this.afterTrailingComma(ke.braceR))
      break;
    e.push(this.parseImportSpecifier());
  }
  return e;
};
Tr.parseWithClause = function() {
  var e = [];
  if (!this.eat(ke._with))
    return e;
  this.expect(ke.braceL);
  for (var t = {}, r = !0; !this.eat(ke.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(ke.comma), this.afterTrailingComma(ke.braceR))
      break;
    var n = this.parseImportAttribute(), a = n.key.type === "Identifier" ? n.key.name : n.key.value;
    Ld(t, a) && this.raiseRecoverable(n.key.start, "Duplicate attribute key '" + a + "'"), t[a] = !0, e.push(n);
  }
  return e;
};
Tr.parseImportAttribute = function() {
  var e = this.startNode();
  return e.key = this.type === ke.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(ke.colon), this.type !== ke.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
};
Tr.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === ke.string) {
    var e = this.parseLiteral(this.value);
    return GMe.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
  }
  return this.parseIdent(!0);
};
Tr.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
Tr.isDirectiveCandidate = function(e) {
  return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var gs = Ei.prototype;
gs.toAssignable = function(e, t, r) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
        for (var n = 0, a = e.properties; n < a.length; n += 1) {
          var s = a[n];
          this.toAssignable(s, t), s.type === "RestElement" && (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") && this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, r);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else r && this.checkPatternErrors(r, !0);
  return e;
};
gs.toAssignableList = function(e, t) {
  for (var r = e.length, n = 0; n < r; n++) {
    var a = e[n];
    a && this.toAssignable(a, t);
  }
  if (r) {
    var s = e[r - 1];
    this.options.ecmaVersion === 6 && t && s && s.type === "RestElement" && s.argument.type !== "Identifier" && this.unexpected(s.argument.start);
  }
  return e;
};
gs.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
};
gs.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== ke.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
gs.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case ke.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(ke.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
      case ke.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
gs.parseBindingList = function(e, t, r, n) {
  for (var a = [], s = !0; !this.eat(e); )
    if (s ? s = !1 : this.expect(ke.comma), t && this.type === ke.comma)
      a.push(null);
    else {
      if (r && this.afterTrailingComma(e))
        break;
      if (this.type === ke.ellipsis) {
        var i = this.parseRestBinding();
        this.parseBindingListItem(i), a.push(i), this.type === ke.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else
        a.push(this.parseAssignableListItem(n));
    }
  return a;
};
gs.parseAssignableListItem = function(e) {
  var t = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(t), t;
};
gs.parseBindingListItem = function(e) {
  return e;
};
gs.parseMaybeDefault = function(e, t, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(ke.eq))
    return r;
  var n = this.startNodeAt(e, t);
  return n.left = r, n.right = this.parseMaybeAssign(), this.finishNode(n, "AssignmentPattern");
};
gs.checkLValSimple = function(e, t, r) {
  t === void 0 && (t = ab);
  var n = t !== ab;
  switch (e.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (n ? "Binding " : "Assigning to ") + e.name + " in strict mode"), n && (t === el && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), r && (Ld(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = !0), t !== gK && this.declareName(e.name, t, e.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      n && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return n && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, r);
    default:
      this.raise(e.start, (n ? "Binding" : "Assigning to") + " rvalue");
  }
};
gs.checkLValPattern = function(e, t, r) {
  switch (t === void 0 && (t = ab), e.type) {
    case "ObjectPattern":
      for (var n = 0, a = e.properties; n < a.length; n += 1) {
        var s = a[n];
        this.checkLValInnerPattern(s, t, r);
      }
      break;
    case "ArrayPattern":
      for (var i = 0, o = e.elements; i < o.length; i += 1) {
        var l = o[i];
        l && this.checkLValInnerPattern(l, t, r);
      }
      break;
    default:
      this.checkLValSimple(e, t, r);
  }
};
gs.checkLValInnerPattern = function(e, t, r) {
  switch (t === void 0 && (t = ab), e.type) {
    case "Property":
      this.checkLValInnerPattern(e.value, t, r);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(e.left, t, r);
      break;
    case "RestElement":
      this.checkLValPattern(e.argument, t, r);
      break;
    default:
      this.checkLValPattern(e, t, r);
  }
};
var As = function(t, r, n, a, s) {
  this.token = t, this.isExpr = !!r, this.preserveSpace = !!n, this.override = a, this.generator = !!s;
}, ei = {
  b_stat: new As("{", !1),
  b_expr: new As("{", !0),
  b_tmpl: new As("${", !1),
  p_stat: new As("(", !1),
  p_expr: new As("(", !0),
  q_tmpl: new As("`", !0, !0, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new As("function", !1),
  f_expr: new As("function", !0),
  f_expr_gen: new As("function", !0, !1, null, !0),
  f_gen: new As("function", !1, !1, null, !0)
}, Fd = Ei.prototype;
Fd.initialContext = function() {
  return [ei.b_stat];
};
Fd.curContext = function() {
  return this.context[this.context.length - 1];
};
Fd.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === ei.f_expr || t === ei.f_stat ? !0 : e === ke.colon && (t === ei.b_stat || t === ei.b_expr) ? !t.isExpr : e === ke._return || e === ke.name && this.exprAllowed ? ms.test(this.input.slice(this.lastTokEnd, this.start)) : e === ke._else || e === ke.semi || e === ke.eof || e === ke.parenR || e === ke.arrow ? !0 : e === ke.braceL ? t === ei.b_stat : e === ke._var || e === ke._const || e === ke.name ? !1 : !this.exprAllowed;
};
Fd.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return !1;
};
Fd.updateContext = function(e) {
  var t, r = this.type;
  r.keyword && e === ke.dot ? this.exprAllowed = !1 : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
};
Fd.overrideContext = function(e) {
  this.curContext() !== e && (this.context[this.context.length - 1] = e);
};
ke.parenR.updateContext = ke.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var e = this.context.pop();
  e === ei.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
ke.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? ei.b_stat : ei.b_expr), this.exprAllowed = !0;
};
ke.dollarBraceL.updateContext = function() {
  this.context.push(ei.b_tmpl), this.exprAllowed = !0;
};
ke.parenL.updateContext = function(e) {
  var t = e === ke._if || e === ke._for || e === ke._with || e === ke._while;
  this.context.push(t ? ei.p_stat : ei.p_expr), this.exprAllowed = !0;
};
ke.incDec.updateContext = function() {
};
ke._function.updateContext = ke._class.updateContext = function(e) {
  e.beforeExpr && e !== ke._else && !(e === ke.semi && this.curContext() !== ei.p_stat) && !(e === ke._return && ms.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === ke.colon || e === ke.braceL) && this.curContext() === ei.b_stat) ? this.context.push(ei.f_expr) : this.context.push(ei.f_stat), this.exprAllowed = !1;
};
ke.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
ke.backQuote.updateContext = function() {
  this.curContext() === ei.q_tmpl ? this.context.pop() : this.context.push(ei.q_tmpl), this.exprAllowed = !1;
};
ke.star.updateContext = function(e) {
  if (e === ke._function) {
    var t = this.context.length - 1;
    this.context[t] === ei.f_expr ? this.context[t] = ei.f_expr_gen : this.context[t] = ei.f_gen;
  }
  this.exprAllowed = !0;
};
ke.name.updateContext = function(e) {
  var t = !1;
  this.options.ecmaVersion >= 6 && e !== ke.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
};
var jr = Ei.prototype;
jr.checkPropClash = function(e, t, r) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var n = e.key, a;
    switch (n.type) {
      case "Identifier":
        a = n.name;
        break;
      case "Literal":
        a = String(n.value);
        break;
      default:
        return;
    }
    var s = e.kind;
    if (this.options.ecmaVersion >= 6) {
      a === "__proto__" && s === "init" && (t.proto && (r ? r.doubleProto < 0 && (r.doubleProto = n.start) : this.raiseRecoverable(n.start, "Redefinition of __proto__ property")), t.proto = !0);
      return;
    }
    a = "$" + a;
    var i = t[a];
    if (i) {
      var o;
      s === "init" ? o = this.strict && i.init || i.get || i.set : o = i.init || i[s], o && this.raiseRecoverable(n.start, "Redefinition of property");
    } else
      i = t[a] = {
        init: !1,
        get: !1,
        set: !1
      };
    i[s] = !0;
  }
};
jr.parseExpression = function(e, t) {
  var r = this.start, n = this.startLoc, a = this.parseMaybeAssign(e, t);
  if (this.type === ke.comma) {
    var s = this.startNodeAt(r, n);
    for (s.expressions = [a]; this.eat(ke.comma); )
      s.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(s, "SequenceExpression");
  }
  return a;
};
jr.parseMaybeAssign = function(e, t, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = !1;
  }
  var n = !1, a = -1, s = -1, i = -1;
  t ? (a = t.parenthesizedAssign, s = t.trailingComma, i = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Sy(), n = !0);
  var o = this.start, l = this.startLoc;
  (this.type === ke.parenL || this.type === ke.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
  var u = this.parseMaybeConditional(e, t);
  if (r && (u = r.call(this, u, o, l)), this.type.isAssign) {
    var c = this.startNodeAt(o, l);
    return c.operator = this.value, this.type === ke.eq && (u = this.toAssignable(u, !1, t)), n || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= u.start && (t.shorthandAssign = -1), this.type === ke.eq ? this.checkLValPattern(u) : this.checkLValSimple(u), c.left = u, this.next(), c.right = this.parseMaybeAssign(e), i > -1 && (t.doubleProto = i), this.finishNode(c, "AssignmentExpression");
  } else
    n && this.checkExpressionErrors(t, !0);
  return a > -1 && (t.parenthesizedAssign = a), s > -1 && (t.trailingComma = s), u;
};
jr.parseMaybeConditional = function(e, t) {
  var r = this.start, n = this.startLoc, a = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return a;
  if (this.eat(ke.question)) {
    var s = this.startNodeAt(r, n);
    return s.test = a, s.consequent = this.parseMaybeAssign(), this.expect(ke.colon), s.alternate = this.parseMaybeAssign(e), this.finishNode(s, "ConditionalExpression");
  }
  return a;
};
jr.parseExprOps = function(e, t) {
  var r = this.start, n = this.startLoc, a = this.parseMaybeUnary(t, !1, !1, e);
  return this.checkExpressionErrors(t) || a.start === r && a.type === "ArrowFunctionExpression" ? a : this.parseExprOp(a, r, n, -1, e);
};
jr.parseExprOp = function(e, t, r, n, a) {
  var s = this.type.binop;
  if (s != null && (!a || this.type !== ke._in) && s > n) {
    var i = this.type === ke.logicalOR || this.type === ke.logicalAND, o = this.type === ke.coalesce;
    o && (s = ke.logicalAND.binop);
    var l = this.value;
    this.next();
    var u = this.start, c = this.startLoc, d = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, a), u, c, s, a), p = this.buildBinary(t, r, e, d, l, i || o);
    return (i && this.type === ke.coalesce || o && (this.type === ke.logicalOR || this.type === ke.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, t, r, n, a);
  }
  return e;
};
jr.buildBinary = function(e, t, r, n, a, s) {
  n.type === "PrivateIdentifier" && this.raise(n.start, "Private identifier can only be left side of binary expression");
  var i = this.startNodeAt(e, t);
  return i.left = r, i.operator = a, i.right = n, this.finishNode(i, s ? "LogicalExpression" : "BinaryExpression");
};
jr.parseMaybeUnary = function(e, t, r, n) {
  var a = this.start, s = this.startLoc, i;
  if (this.isContextual("await") && this.canAwait)
    i = this.parseAwait(n), t = !0;
  else if (this.type.prefix) {
    var o = this.startNode(), l = this.type === ke.incDec;
    o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0, l, n), this.checkExpressionErrors(e, !0), l ? this.checkLValSimple(o.argument) : this.strict && o.operator === "delete" && yK(o.argument) ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : o.operator === "delete" && YR(o.argument) ? this.raiseRecoverable(o.start, "Private fields can not be deleted") : t = !0, i = this.finishNode(o, l ? "UpdateExpression" : "UnaryExpression");
  } else if (!t && this.type === ke.privateId)
    (n || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), i = this.parsePrivateIdent(), this.type !== ke._in && this.unexpected();
  else {
    if (i = this.parseExprSubscripts(e, n), this.checkExpressionErrors(e))
      return i;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var u = this.startNodeAt(a, s);
      u.operator = this.value, u.prefix = !1, u.argument = i, this.checkLValSimple(i), this.next(), i = this.finishNode(u, "UpdateExpression");
    }
  }
  if (!r && this.eat(ke.starstar))
    if (t)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(a, s, i, this.parseMaybeUnary(null, !1, !1, n), "**", !1);
  else
    return i;
};
function yK(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && yK(e.expression);
}
function YR(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && YR(e.expression) || e.type === "ParenthesizedExpression" && YR(e.expression);
}
jr.parseExprSubscripts = function(e, t) {
  var r = this.start, n = this.startLoc, a = this.parseExprAtom(e, t);
  if (a.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return a;
  var s = this.parseSubscripts(a, r, n, !1, t);
  return e && s.type === "MemberExpression" && (e.parenthesizedAssign >= s.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= s.start && (e.parenthesizedBind = -1), e.trailingComma >= s.start && (e.trailingComma = -1)), s;
};
jr.parseSubscripts = function(e, t, r, n, a) {
  for (var s = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, i = !1; ; ) {
    var o = this.parseSubscript(e, t, r, n, s, i, a);
    if (o.optional && (i = !0), o === e || o.type === "ArrowFunctionExpression") {
      if (i) {
        var l = this.startNodeAt(t, r);
        l.expression = o, o = this.finishNode(l, "ChainExpression");
      }
      return o;
    }
    e = o;
  }
};
jr.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(ke.arrow);
};
jr.parseSubscriptAsyncArrow = function(e, t, r, n) {
  return this.parseArrowExpression(this.startNodeAt(e, t), r, !0, n);
};
jr.parseSubscript = function(e, t, r, n, a, s, i) {
  var o = this.options.ecmaVersion >= 11, l = o && this.eat(ke.questionDot);
  n && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var u = this.eat(ke.bracketL);
  if (u || l && this.type !== ke.parenL && this.type !== ke.backQuote || this.eat(ke.dot)) {
    var c = this.startNodeAt(t, r);
    c.object = e, u ? (c.property = this.parseExpression(), this.expect(ke.bracketR)) : this.type === ke.privateId && e.type !== "Super" ? c.property = this.parsePrivateIdent() : c.property = this.parseIdent(this.options.allowReserved !== "never"), c.computed = !!u, o && (c.optional = l), e = this.finishNode(c, "MemberExpression");
  } else if (!n && this.eat(ke.parenL)) {
    var d = new Sy(), p = this.yieldPos, f = this.awaitPos, h = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var m = this.parseExprList(ke.parenR, this.options.ecmaVersion >= 8, !1, d);
    if (a && !l && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = f, this.awaitIdentPos = h, this.parseSubscriptAsyncArrow(t, r, m, i);
    this.checkExpressionErrors(d, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = f || this.awaitPos, this.awaitIdentPos = h || this.awaitIdentPos;
    var y = this.startNodeAt(t, r);
    y.callee = e, y.arguments = m, o && (y.optional = l), e = this.finishNode(y, "CallExpression");
  } else if (this.type === ke.backQuote) {
    (l || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var b = this.startNodeAt(t, r);
    b.tag = e, b.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(b, "TaggedTemplateExpression");
  }
  return e;
};
jr.parseExprAtom = function(e, t, r) {
  this.type === ke.slash && this.readRegexp();
  var n, a = this.potentialArrowAt === this.start;
  switch (this.type) {
    case ke._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), n = this.startNode(), this.next(), this.type === ke.parenL && !this.allowDirectSuper && this.raise(n.start, "super() call outside constructor of a subclass"), this.type !== ke.dot && this.type !== ke.bracketL && this.type !== ke.parenL && this.unexpected(), this.finishNode(n, "Super");
    case ke._this:
      return n = this.startNode(), this.next(), this.finishNode(n, "ThisExpression");
    case ke.name:
      var s = this.start, i = this.startLoc, o = this.containsEsc, l = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !o && l.name === "async" && !this.canInsertSemicolon() && this.eat(ke._function))
        return this.overrideContext(ei.f_expr), this.parseFunction(this.startNodeAt(s, i), 0, !1, !0, t);
      if (a && !this.canInsertSemicolon()) {
        if (this.eat(ke.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, i), [l], !1, t);
        if (this.options.ecmaVersion >= 8 && l.name === "async" && this.type === ke.name && !o && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return l = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(ke.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, i), [l], !0, t);
      }
      return l;
    case ke.regexp:
      var u = this.value;
      return n = this.parseLiteral(u.value), n.regex = { pattern: u.pattern, flags: u.flags }, n;
    case ke.num:
    case ke.string:
      return this.parseLiteral(this.value);
    case ke._null:
    case ke._true:
    case ke._false:
      return n = this.startNode(), n.value = this.type === ke._null ? null : this.type === ke._true, n.raw = this.type.keyword, this.next(), this.finishNode(n, "Literal");
    case ke.parenL:
      var c = this.start, d = this.parseParenAndDistinguishExpression(a, t);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(d) && (e.parenthesizedAssign = c), e.parenthesizedBind < 0 && (e.parenthesizedBind = c)), d;
    case ke.bracketL:
      return n = this.startNode(), this.next(), n.elements = this.parseExprList(ke.bracketR, !0, !0, e), this.finishNode(n, "ArrayExpression");
    case ke.braceL:
      return this.overrideContext(ei.b_expr), this.parseObj(!1, e);
    case ke._function:
      return n = this.startNode(), this.next(), this.parseFunction(n, 0);
    case ke._class:
      return this.parseClass(this.startNode(), !1);
    case ke._new:
      return this.parseNew();
    case ke.backQuote:
      return this.parseTemplate();
    case ke._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(r) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
jr.parseExprAtomDefault = function() {
  this.unexpected();
};
jr.parseExprImport = function(e) {
  var t = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === ke.parenL && !e)
    return this.parseDynamicImport(t);
  if (this.type === ke.dot) {
    var r = this.startNodeAt(t.start, t.loc && t.loc.start);
    return r.name = "import", t.meta = this.finishNode(r, "Identifier"), this.parseImportMeta(t);
  } else
    this.unexpected();
};
jr.parseDynamicImport = function(e) {
  if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
    this.eat(ke.parenR) ? e.options = null : (this.expect(ke.comma), this.afterTrailingComma(ke.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(ke.parenR) || (this.expect(ke.comma), this.afterTrailingComma(ke.parenR) || this.unexpected())));
  else if (!this.eat(ke.parenR)) {
    var t = this.start;
    this.eat(ke.comma) && this.eat(ke.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
  }
  return this.finishNode(e, "ImportExpression");
};
jr.parseImportMeta = function(e) {
  this.next();
  var t = this.containsEsc;
  return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
};
jr.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
};
jr.parseParenExpression = function() {
  this.expect(ke.parenL);
  var e = this.parseExpression();
  return this.expect(ke.parenR), e;
};
jr.shouldParseArrow = function(e) {
  return !this.canInsertSemicolon();
};
jr.parseParenAndDistinguishExpression = function(e, t) {
  var r = this.start, n = this.startLoc, a, s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var i = this.start, o = this.startLoc, l = [], u = !0, c = !1, d = new Sy(), p = this.yieldPos, f = this.awaitPos, h;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== ke.parenR; )
      if (u ? u = !1 : this.expect(ke.comma), s && this.afterTrailingComma(ke.parenR, !0)) {
        c = !0;
        break;
      } else if (this.type === ke.ellipsis) {
        h = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === ke.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        l.push(this.parseMaybeAssign(!1, d, this.parseParenItem));
    var m = this.lastTokEnd, y = this.lastTokEndLoc;
    if (this.expect(ke.parenR), e && this.shouldParseArrow(l) && this.eat(ke.arrow))
      return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = f, this.parseParenArrowList(r, n, l, t);
    (!l.length || c) && this.unexpected(this.lastTokStart), h && this.unexpected(h), this.checkExpressionErrors(d, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = f || this.awaitPos, l.length > 1 ? (a = this.startNodeAt(i, o), a.expressions = l, this.finishNodeAt(a, "SequenceExpression", m, y)) : a = l[0];
  } else
    a = this.parseParenExpression();
  if (this.options.preserveParens) {
    var b = this.startNodeAt(r, n);
    return b.expression = a, this.finishNode(b, "ParenthesizedExpression");
  } else
    return a;
};
jr.parseParenItem = function(e) {
  return e;
};
jr.parseParenArrowList = function(e, t, r, n) {
  return this.parseArrowExpression(this.startNodeAt(e, t), r, !1, n);
};
var QMe = [];
jr.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var e = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === ke.dot) {
    var t = this.startNodeAt(e.start, e.loc && e.loc.start);
    t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
    var r = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), r && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
  }
  var n = this.start, a = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), n, a, !0, !1), this.eat(ke.parenL) ? e.arguments = this.parseExprList(ke.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = QMe, this.finishNode(e, "NewExpression");
};
jr.parseTemplateElement = function(e) {
  var t = e.isTagged, r = this.startNode();
  return this.type === ke.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value.replace(/\r\n?/g, `
`),
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === ke.backQuote, this.finishNode(r, "TemplateElement");
};
jr.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = !1);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var n = this.parseTemplateElement({ isTagged: t });
  for (r.quasis = [n]; !n.tail; )
    this.type === ke.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(ke.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(ke.braceR), r.quasis.push(n = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
jr.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === ke.name || this.type === ke.num || this.type === ke.string || this.type === ke.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === ke.star) && !ms.test(this.input.slice(this.lastTokEnd, this.start));
};
jr.parseObj = function(e, t) {
  var r = this.startNode(), n = !0, a = {};
  for (r.properties = [], this.next(); !this.eat(ke.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(ke.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(ke.braceR))
      break;
    var s = this.parseProperty(e, t);
    e || this.checkPropClash(s, a, t), r.properties.push(s);
  }
  return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
};
jr.parseProperty = function(e, t) {
  var r = this.startNode(), n, a, s, i;
  if (this.options.ecmaVersion >= 9 && this.eat(ke.ellipsis))
    return e ? (r.argument = this.parseIdent(!1), this.type === ke.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (r.argument = this.parseMaybeAssign(!1, t), this.type === ke.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (e || t) && (s = this.start, i = this.startLoc), e || (n = this.eat(ke.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(r), !e && !o && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(r) ? (a = !0, n = this.options.ecmaVersion >= 9 && this.eat(ke.star), this.parsePropertyName(r)) : a = !1, this.parsePropertyValue(r, e, n, a, s, i, t, o), this.finishNode(r, "Property");
};
jr.parseGetterSetter = function(e) {
  e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1);
  var t = e.kind === "get" ? 0 : 1;
  if (e.value.params.length !== t) {
    var r = e.value.start;
    e.kind === "get" ? this.raiseRecoverable(r, "getter should have no params") : this.raiseRecoverable(r, "setter should have exactly one param");
  } else
    e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
};
jr.parsePropertyValue = function(e, t, r, n, a, s, i, o) {
  (r || n) && this.type === ke.colon && this.unexpected(), this.eat(ke.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, i), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === ke.parenL ? (t && this.unexpected(), e.kind = "init", e.method = !0, e.value = this.parseMethod(r, n)) : !t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== ke.comma && this.type !== ke.braceR && this.type !== ke.eq ? ((r || n) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r || n) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = a), e.kind = "init", t ? e.value = this.parseMaybeDefault(a, s, this.copyNode(e.key)) : this.type === ke.eq && i ? (i.shorthandAssign < 0 && (i.shorthandAssign = this.start), e.value = this.parseMaybeDefault(a, s, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = !0) : this.unexpected();
};
jr.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(ke.bracketL))
      return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(ke.bracketR), e.key;
    e.computed = !1;
  }
  return e.key = this.type === ke.num || this.type === ke.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
jr.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
};
jr.parseMethod = function(e, t, r) {
  var n = this.startNode(), a = this.yieldPos, s = this.awaitPos, i = this.awaitIdentPos;
  return this.initFunction(n), this.options.ecmaVersion >= 6 && (n.generator = e), this.options.ecmaVersion >= 8 && (n.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(TD(t, n.generator) | CD | (r ? pK : 0)), this.expect(ke.parenL), n.params = this.parseBindingList(ke.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(n, !1, !0, !1), this.yieldPos = a, this.awaitPos = s, this.awaitIdentPos = i, this.finishNode(n, "FunctionExpression");
};
jr.parseArrowExpression = function(e, t, r, n) {
  var a = this.yieldPos, s = this.awaitPos, i = this.awaitIdentPos;
  return this.enterScope(TD(r, !1) | dK), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, n), this.yieldPos = a, this.awaitPos = s, this.awaitIdentPos = i, this.finishNode(e, "ArrowFunctionExpression");
};
jr.parseFunctionBody = function(e, t, r, n) {
  var a = t && this.type !== ke.braceL, s = this.strict, i = !1;
  if (a)
    e.body = this.parseMaybeAssign(n), e.expression = !0, this.checkParams(e, !1);
  else {
    var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!s || o) && (i = this.strictDirective(this.end), i && o && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var l = this.labels;
    this.labels = [], i && (this.strict = !0), this.checkParams(e, !s && !i && !t && !r && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, gK), e.body = this.parseBlock(!1, void 0, i && !s), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = l;
  }
  this.exitScope();
};
jr.isSimpleParamList = function(e) {
  for (var t = 0, r = e; t < r.length; t += 1) {
    var n = r[t];
    if (n.type !== "Identifier")
      return !1;
  }
  return !0;
};
jr.checkParams = function(e, t) {
  for (var r = /* @__PURE__ */ Object.create(null), n = 0, a = e.params; n < a.length; n += 1) {
    var s = a[n];
    this.checkLValInnerPattern(s, RD, t ? null : r);
  }
};
jr.parseExprList = function(e, t, r, n) {
  for (var a = [], s = !0; !this.eat(e); ) {
    if (s)
      s = !1;
    else if (this.expect(ke.comma), t && this.afterTrailingComma(e))
      break;
    var i = void 0;
    r && this.type === ke.comma ? i = null : this.type === ke.ellipsis ? (i = this.parseSpread(n), n && this.type === ke.comma && n.trailingComma < 0 && (n.trailingComma = this.start)) : i = this.parseMaybeAssign(!1, n), a.push(i);
  }
  return a;
};
jr.checkUnreserved = function(e) {
  var t = e.start, r = e.end, n = e.name;
  if (this.inGenerator && n === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && n === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && n === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (n === "arguments" || n === "await") && this.raise(t, "Cannot use " + n + " in class static initialization block"), this.keywords.test(n) && this.raise(t, "Unexpected keyword '" + n + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
    var a = this.strict ? this.reservedWordsStrict : this.reservedWords;
    a.test(n) && (!this.inAsync && n === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + n + "' is reserved"));
  }
};
jr.parseIdent = function(e) {
  var t = this.parseIdentNode();
  return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t;
};
jr.parseIdentNode = function() {
  var e = this.startNode();
  return this.type === ke.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = ke.name) : this.unexpected(), e;
};
jr.parsePrivateIdent = function() {
  var e = this.startNode();
  return this.type === ke.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
};
jr.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === ke.semi || this.canInsertSemicolon() || this.type !== ke.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(ke.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
jr.parseAwait = function(e) {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
};
var ob = Ei.prototype;
ob.raise = function(e, t) {
  var r = uK(this.input, e);
  t += " (" + r.line + ":" + r.column + ")";
  var n = new SyntaxError(t);
  throw n.pos = e, n.loc = r, n.raisedAt = this.pos, n;
};
ob.raiseRecoverable = ob.raise;
ob.curPosition = function() {
  if (this.options.locations)
    return new Gp(this.curLine, this.pos - this.lineStart);
};
var Jl = Ei.prototype, e5e = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
Jl.enterScope = function(e) {
  this.scopeStack.push(new e5e(e));
};
Jl.exitScope = function() {
  this.scopeStack.pop();
};
Jl.treatFunctionsAsVarInScope = function(e) {
  return e.flags & Md || !this.inModule && e.flags & Wp;
};
Jl.declareName = function(e, t, r) {
  var n = !1;
  if (t === el) {
    var a = this.currentScope();
    n = a.lexical.indexOf(e) > -1 || a.functions.indexOf(e) > -1 || a.var.indexOf(e) > -1, a.lexical.push(e), this.inModule && a.flags & Wp && delete this.undefinedExports[e];
  } else if (t === mK) {
    var s = this.currentScope();
    s.lexical.push(e);
  } else if (t === hK) {
    var i = this.currentScope();
    this.treatFunctionsAsVar ? n = i.lexical.indexOf(e) > -1 : n = i.lexical.indexOf(e) > -1 || i.var.indexOf(e) > -1, i.functions.push(e);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var l = this.scopeStack[o];
      if (l.lexical.indexOf(e) > -1 && !(l.flags & fK && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(e) > -1) {
        n = !0;
        break;
      }
      if (l.var.push(e), this.inModule && l.flags & Wp && delete this.undefinedExports[e], l.flags & AD)
        break;
    }
  n && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
};
Jl.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Jl.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Jl.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & AD)
      return t;
  }
};
Jl.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & AD && !(t.flags & dK))
      return t;
  }
};
var _y = function(t, r, n) {
  this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new Ey(t, n)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
}, Ih = Ei.prototype;
Ih.startNode = function() {
  return new _y(this, this.start, this.startLoc);
};
Ih.startNodeAt = function(e, t) {
  return new _y(this, e, t);
};
function vK(e, t, r, n) {
  return e.type = t, e.end = r, this.options.locations && (e.loc.end = n), this.options.ranges && (e.range[1] = r), e;
}
Ih.finishNode = function(e, t) {
  return vK.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
Ih.finishNodeAt = function(e, t, r, n) {
  return vK.call(this, e, t, r, n);
};
Ih.copyNode = function(e) {
  var t = new _y(this, e.start, this.startLoc);
  for (var r in e)
    t[r] = e[r];
  return t;
};
var t5e = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", wK = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", xK = wK + " Extended_Pictographic", EK = xK, SK = EK + " EBase EComp EMod EPres ExtPict", _K = SK, r5e = _K, n5e = {
  9: wK,
  10: xK,
  11: EK,
  12: SK,
  13: _K,
  14: r5e
}, i5e = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", a5e = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: i5e
}, y9 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", kK = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", CK = kK + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", AK = CK + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", TK = AK + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", RK = TK + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", s5e = RK + " " + t5e, o5e = {
  9: kK,
  10: CK,
  11: AK,
  12: TK,
  13: RK,
  14: s5e
}, IK = {};
function l5e(e) {
  var t = IK[e] = {
    binary: Nl(n5e[e] + " " + y9),
    binaryOfStrings: Nl(a5e[e]),
    nonBinary: {
      General_Category: Nl(y9),
      Script: Nl(o5e[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
for (var ZA = 0, v9 = [9, 10, 11, 12, 13, 14]; ZA < v9.length; ZA += 1) {
  var u5e = v9[ZA];
  l5e(u5e);
}
var Er = Ei.prototype, lb = function(t, r) {
  this.parent = t, this.base = r || this;
};
lb.prototype.separatedFrom = function(t) {
  for (var r = this; r; r = r.parent)
    for (var n = t; n; n = n.parent)
      if (r.base === n.base && r !== n)
        return !0;
  return !1;
};
lb.prototype.sibling = function() {
  return new lb(this.parent, this.base);
};
var vo = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = IK[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
};
vo.prototype.reset = function(t, r, n) {
  var a = n.indexOf("v") !== -1, s = n.indexOf("u") !== -1;
  this.start = t | 0, this.source = r + "", this.flags = n, a && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
};
vo.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
vo.prototype.at = function(t, r) {
  r === void 0 && (r = !1);
  var n = this.source, a = n.length;
  if (t >= a)
    return -1;
  var s = n.charCodeAt(t);
  if (!(r || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= a)
    return s;
  var i = n.charCodeAt(t + 1);
  return i >= 56320 && i <= 57343 ? (s << 10) + i - 56613888 : s;
};
vo.prototype.nextIndex = function(t, r) {
  r === void 0 && (r = !1);
  var n = this.source, a = n.length;
  if (t >= a)
    return a;
  var s = n.charCodeAt(t), i;
  return !(r || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= a || (i = n.charCodeAt(t + 1)) < 56320 || i > 57343 ? t + 1 : t + 2;
};
vo.prototype.current = function(t) {
  return t === void 0 && (t = !1), this.at(this.pos, t);
};
vo.prototype.lookahead = function(t) {
  return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
};
vo.prototype.advance = function(t) {
  t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
};
vo.prototype.eat = function(t, r) {
  return r === void 0 && (r = !1), this.current(r) === t ? (this.advance(r), !0) : !1;
};
vo.prototype.eatChars = function(t, r) {
  r === void 0 && (r = !1);
  for (var n = this.pos, a = 0, s = t; a < s.length; a += 1) {
    var i = s[a], o = this.at(n, r);
    if (o === -1 || o !== i)
      return !1;
    n = this.nextIndex(n, r);
  }
  return this.pos = n, !0;
};
Er.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, r = e.flags, n = !1, a = !1, s = 0; s < r.length; s++) {
    var i = r.charAt(s);
    t.indexOf(i) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(i, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), i === "u" && (n = !0), i === "v" && (a = !0);
  }
  this.options.ecmaVersion >= 15 && n && a && this.raise(e.start, "Invalid regular expression flag");
};
function c5e(e) {
  for (var t in e)
    return !0;
  return !1;
}
Er.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && c5e(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
};
Er.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* ] */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
    var n = r[t];
    e.groupNames[n] || e.raise("Invalid named capture referenced");
  }
};
Er.regexp_disjunction = function(e) {
  var t = this.options.ecmaVersion >= 16;
  for (t && (e.branchID = new lb(e.branchID, null)), this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
  t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
Er.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
Er.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
};
Er.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = !1, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return !0;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return !0;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var r = !1;
    if (this.options.ecmaVersion >= 9 && (r = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, !0;
  }
  return e.pos = t, !1;
};
Er.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), !0) : !1;
};
Er.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
Er.regexp_eatBracedQuantifier = function(e, t) {
  var r = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var n = 0, a = -1;
    if (this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (a = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return a !== -1 && a < n && !t && e.raise("numbers out of order in {} quantifier"), !0;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
  }
  return !1;
};
Er.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
Er.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
Er.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var r = this.regexp_eatModifiers(e), n = e.eat(
          45
          /* - */
        );
        if (r || n) {
          for (var a = 0; a < r.length; a++) {
            var s = r.charAt(a);
            r.indexOf(s, a + 1) > -1 && e.raise("Duplicate regular expression modifiers");
          }
          if (n) {
            var i = this.regexp_eatModifiers(e);
            !r && !i && e.current() === 58 && e.raise("Invalid regular expression modifiers");
            for (var o = 0; o < i.length; o++) {
              var l = i.charAt(o);
              (i.indexOf(l, o + 1) > -1 || r.indexOf(l) > -1) && e.raise("Duplicate regular expression modifiers");
            }
          }
        }
      }
      if (e.eat(
        58
        /* : */
      )) {
        if (this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ))
          return !0;
        e.raise("Unterminated group");
      }
    }
    e.pos = t;
  }
  return !1;
};
Er.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, !0;
    e.raise("Unterminated group");
  }
  return !1;
};
Er.regexp_eatModifiers = function(e) {
  for (var t = "", r = 0; (r = e.current()) !== -1 && d5e(r); )
    t += Go(r), e.advance();
  return t;
};
function d5e(e) {
  return e === 105 || e === 109 || e === 115;
}
Er.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
Er.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
};
Er.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return NK(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function NK(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
Er.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !NK(r); )
    e.advance();
  return e.pos !== t;
};
Er.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
};
Er.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    this.regexp_eatGroupName(e) || e.raise("Invalid group");
    var t = this.options.ecmaVersion >= 16, r = e.groupNames[e.lastStringValue];
    if (r)
      if (t)
        for (var n = 0, a = r; n < a.length; n += 1) {
          var s = a[n];
          s.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
        }
      else
        e.raise("Duplicate capture group name");
    t ? (r || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
  }
};
Er.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return !0;
    e.raise("Invalid capture group name");
  }
  return !1;
};
Er.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += Go(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += Go(e.lastIntValue);
    return !0;
  }
  return !1;
};
Er.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, r = this.options.ecmaVersion >= 11, n = e.current(r);
  return e.advance(r), n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (n = e.lastIntValue), f5e(n) ? (e.lastIntValue = n, !0) : (e.pos = t, !1);
};
function f5e(e) {
  return Vo(e, !0) || e === 36 || e === 95;
}
Er.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, r = this.options.ecmaVersion >= 11, n = e.current(r);
  return e.advance(r), n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (n = e.lastIntValue), p5e(n) ? (e.lastIntValue = n, !0) : (e.pos = t, !1);
};
function p5e(e) {
  return bd(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
Er.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
};
Er.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var r = e.lastIntValue;
    if (e.switchU)
      return r > e.maxBackReference && (e.maxBackReference = r), !0;
    if (r <= e.numCapturingParens)
      return !0;
    e.pos = t;
  }
  return !1;
};
Er.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), !0;
    e.raise("Invalid named reference");
  }
  return !1;
};
Er.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
Er.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
Er.regexp_eatZero = function(e) {
  return e.current() === 48 && !ky(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
};
Er.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
};
Er.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return DK(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
function DK(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
Er.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
  t === void 0 && (t = !1);
  var r = e.pos, n = t || e.switchU;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var a = e.lastIntValue;
      if (n && a >= 55296 && a <= 56319) {
        var s = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var i = e.lastIntValue;
          if (i >= 56320 && i <= 57343)
            return e.lastIntValue = (a - 55296) * 1024 + (i - 56320) + 65536, !0;
        }
        e.pos = s, e.lastIntValue = a;
      }
      return !0;
    }
    if (n && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && h5e(e.lastIntValue))
      return !0;
    n && e.raise("Invalid unicode escape"), e.pos = r;
  }
  return !1;
};
function h5e(e) {
  return e >= 0 && e <= 1114111;
}
Er.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, !0) : !1;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
Er.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return !0;
  }
  return !1;
};
var OK = 0, Wo = 1, ns = 2;
Er.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (m5e(t))
    return e.lastIntValue = -1, e.advance(), Wo;
  var r = !1;
  if (e.switchU && this.options.ecmaVersion >= 9 && ((r = t === 80) || t === 112)) {
    e.lastIntValue = -1, e.advance();
    var n;
    if (e.eat(
      123
      /* { */
    ) && (n = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
      125
      /* } */
    ))
      return r && n === ns && e.raise("Invalid property name"), n;
    e.raise("Invalid property name");
  }
  return OK;
};
function m5e(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
Er.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var r = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var n = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, r, n), Wo;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var a = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, a);
  }
  return OK;
};
Er.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
  Ld(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid property value");
};
Er.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  if (e.unicodeProperties.binary.test(t))
    return Wo;
  if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
    return ns;
  e.raise("Invalid property name");
};
Er.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; PK(t = e.current()); )
    e.lastStringValue += Go(t), e.advance();
  return e.lastStringValue !== "";
};
function PK(e) {
  return DK(e) || e === 95;
}
Er.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; g5e(t = e.current()); )
    e.lastStringValue += Go(t), e.advance();
  return e.lastStringValue !== "";
};
function g5e(e) {
  return PK(e) || ky(e);
}
Er.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
Er.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    var t = e.eat(
      94
      /* ^ */
    ), r = this.regexp_classContents(e);
    return e.eat(
      93
      /* ] */
    ) || e.raise("Unterminated character class"), t && r === ns && e.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
Er.regexp_classContents = function(e) {
  return e.current() === 93 ? Wo : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Wo);
};
Er.regexp_nonEmptyClassRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var r = e.lastIntValue;
      e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of order in character class");
    }
  }
};
Er.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return !0;
    if (e.switchU) {
      var r = e.current();
      (r === 99 || FK(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var n = e.current();
  return n !== 93 ? (e.lastIntValue = n, e.advance(), !0) : !1;
};
Er.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, !0;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, !0;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return !0;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
Er.regexp_classSetExpression = function(e) {
  var t = Wo, r;
  if (!this.regexp_eatClassSetRange(e)) if (r = this.regexp_eatClassSetOperand(e)) {
    r === ns && (t = ns);
    for (var n = e.pos; e.eatChars(
      [38, 38]
      /* && */
    ); ) {
      if (e.current() !== 38 && (r = this.regexp_eatClassSetOperand(e))) {
        r !== ns && (t = Wo);
        continue;
      }
      e.raise("Invalid character in character class");
    }
    if (n !== e.pos)
      return t;
    for (; e.eatChars(
      [45, 45]
      /* -- */
    ); )
      this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
    if (n !== e.pos)
      return t;
  } else
    e.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(e)) {
      if (r = this.regexp_eatClassSetOperand(e), !r)
        return t;
      r === ns && (t = ns);
    }
};
Er.regexp_eatClassSetRange = function(e) {
  var t = e.pos;
  if (this.regexp_eatClassSetCharacter(e)) {
    var r = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(e)) {
      var n = e.lastIntValue;
      return r !== -1 && n !== -1 && r > n && e.raise("Range out of order in character class"), !0;
    }
    e.pos = t;
  }
  return !1;
};
Er.regexp_eatClassSetOperand = function(e) {
  return this.regexp_eatClassSetCharacter(e) ? Wo : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
};
Er.regexp_eatNestedClass = function(e) {
  var t = e.pos;
  if (e.eat(
    91
    /* [ */
  )) {
    var r = e.eat(
      94
      /* ^ */
    ), n = this.regexp_classContents(e);
    if (e.eat(
      93
      /* ] */
    ))
      return r && n === ns && e.raise("Negated character class may contain strings"), n;
    e.pos = t;
  }
  if (e.eat(
    92
    /* \ */
  )) {
    var a = this.regexp_eatCharacterClassEscape(e);
    if (a)
      return a;
    e.pos = t;
  }
  return null;
};
Er.regexp_eatClassStringDisjunction = function(e) {
  var t = e.pos;
  if (e.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (e.eat(
      123
      /* { */
    )) {
      var r = this.regexp_classStringDisjunctionContents(e);
      if (e.eat(
        125
        /* } */
      ))
        return r;
    } else
      e.raise("Invalid escape");
    e.pos = t;
  }
  return null;
};
Er.regexp_classStringDisjunctionContents = function(e) {
  for (var t = this.regexp_classString(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_classString(e) === ns && (t = ns);
  return t;
};
Er.regexp_classString = function(e) {
  for (var t = 0; this.regexp_eatClassSetCharacter(e); )
    t++;
  return t === 1 ? Wo : ns;
};
Er.regexp_eatClassSetCharacter = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
      98
      /* b */
    ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
  var r = e.current();
  return r < 0 || r === e.lookahead() && b5e(r) || y5e(r) ? !1 : (e.advance(), e.lastIntValue = r, !0);
};
function b5e(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function y5e(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
Er.regexp_eatClassSetReservedPunctuator = function(e) {
  var t = e.current();
  return v5e(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function v5e(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
Er.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return ky(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
Er.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return !0;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return !1;
};
Er.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; ky(r = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
  return e.pos !== t;
};
function ky(e) {
  return e >= 48 && e <= 57;
}
Er.regexp_eatHexDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; LK(r = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + MK(r), e.advance();
  return e.pos !== t;
};
function LK(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function MK(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
Er.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var r = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
    } else
      e.lastIntValue = t;
    return !0;
  }
  return !1;
};
Er.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return FK(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
};
function FK(e) {
  return e >= 48 && e <= 55;
}
Er.regexp_eatFixedHexDigits = function(e, t) {
  var r = e.pos;
  e.lastIntValue = 0;
  for (var n = 0; n < t; ++n) {
    var a = e.current();
    if (!LK(a))
      return e.pos = r, !1;
    e.lastIntValue = 16 * e.lastIntValue + MK(a), e.advance();
  }
  return !0;
};
var ND = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new Ey(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
}, un = Ei.prototype;
un.next = function(e) {
  !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ND(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
un.getToken = function() {
  return this.next(), new ND(this);
};
typeof Symbol < "u" && (un[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === ke.eof,
        value: t
      };
    }
  };
});
un.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(ke.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
un.readToken = function(e) {
  return Vo(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
un.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 56320)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
};
un.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations)
    for (var n = void 0, a = t; (n = sK(this.input, a, this.pos)) > -1; )
      ++this.curLine, a = this.lineStart = n;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(t + 2, r),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
un.skipLineComment = function(e) {
  for (var t = this.pos, r = this.options.onComment && this.curPosition(), n = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !Pd(n); )
    n = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    r,
    this.curPosition()
  );
};
un.skipSpace = function() {
  e: for (; this.pos < this.input.length; ) {
    var e = this.input.charCodeAt(this.pos);
    switch (e) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if (e > 8 && e < 14 || e >= 5760 && oK.test(String.fromCharCode(e)))
          ++this.pos;
        else
          break e;
    }
  }
};
un.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = e, this.value = t, this.updateContext(r);
};
un.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(!0);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(ke.ellipsis)) : (++this.pos, this.finishToken(ke.dot));
};
un.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(ke.assign, 2) : this.finishOp(ke.slash, 1);
};
un.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1, n = e === 42 ? ke.star : ke.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, n = ke.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(ke.assign, r + 1) : this.finishOp(n, r);
};
un.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t === e) {
    if (this.options.ecmaVersion >= 12) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r === 61)
        return this.finishOp(ke.assign, 3);
    }
    return this.finishOp(e === 124 ? ke.logicalOR : ke.logicalAND, 2);
  }
  return t === 61 ? this.finishOp(ke.assign, 2) : this.finishOp(e === 124 ? ke.bitwiseOR : ke.bitwiseAND, 1);
};
un.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(ke.assign, 2) : this.finishOp(ke.bitwiseXOR, 1);
};
un.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || ms.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(ke.incDec, 2) : t === 61 ? this.finishOp(ke.assign, 2) : this.finishOp(ke.plusMin, 1);
};
un.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1;
  return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(ke.assign, r + 1) : this.finishOp(ke.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2), this.finishOp(ke.relational, r));
};
un.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(ke.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(ke.arrow)) : this.finishOp(e === 61 ? ke.eq : ke.prefix, 1);
};
un.readToken_question = function() {
  var e = this.options.ecmaVersion;
  if (e >= 11) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === 46) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r < 48 || r > 57)
        return this.finishOp(ke.questionDot, 2);
    }
    if (t === 63) {
      if (e >= 12) {
        var n = this.input.charCodeAt(this.pos + 2);
        if (n === 61)
          return this.finishOp(ke.assign, 3);
      }
      return this.finishOp(ke.coalesce, 2);
    }
  }
  return this.finishOp(ke.question, 1);
};
un.readToken_numberSign = function() {
  var e = this.options.ecmaVersion, t = 35;
  if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), Vo(t, !0) || t === 92))
    return this.finishToken(ke.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + Go(t) + "'");
};
un.getTokenFromCode = function(e) {
  switch (e) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      return ++this.pos, this.finishToken(ke.parenL);
    case 41:
      return ++this.pos, this.finishToken(ke.parenR);
    case 59:
      return ++this.pos, this.finishToken(ke.semi);
    case 44:
      return ++this.pos, this.finishToken(ke.comma);
    case 91:
      return ++this.pos, this.finishToken(ke.bracketL);
    case 93:
      return ++this.pos, this.finishToken(ke.bracketR);
    case 123:
      return ++this.pos, this.finishToken(ke.braceL);
    case 125:
      return ++this.pos, this.finishToken(ke.braceR);
    case 58:
      return ++this.pos, this.finishToken(ke.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(ke.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(e);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(ke.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + Go(e) + "'");
};
un.finishOp = function(e, t) {
  var r = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, r);
};
un.readRegexp = function() {
  for (var e, t, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var n = this.input.charAt(this.pos);
    if (ms.test(n) && this.raise(r, "Unterminated regular expression"), e)
      e = !1;
    else {
      if (n === "[")
        t = !0;
      else if (n === "]" && t)
        t = !1;
      else if (n === "/" && !t)
        break;
      e = n === "\\";
    }
    ++this.pos;
  }
  var a = this.input.slice(r, this.pos);
  ++this.pos;
  var s = this.pos, i = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var o = this.regexpState || (this.regexpState = new vo(this));
  o.reset(r, a, i), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var l = null;
  try {
    l = new RegExp(a, i);
  } catch {
  }
  return this.finishToken(ke.regexp, { pattern: a, flags: i, value: l });
};
un.readInt = function(e, t, r) {
  for (var n = this.options.ecmaVersion >= 12 && t === void 0, a = r && this.input.charCodeAt(this.pos) === 48, s = this.pos, i = 0, o = 0, l = 0, u = t ?? 1 / 0; l < u; ++l, ++this.pos) {
    var c = this.input.charCodeAt(this.pos), d = void 0;
    if (n && c === 95) {
      a && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = c;
      continue;
    }
    if (c >= 97 ? d = c - 97 + 10 : c >= 65 ? d = c - 65 + 10 : c >= 48 && c <= 57 ? d = c - 48 : d = 1 / 0, d >= e)
      break;
    o = c, i = i * e + d;
  }
  return n && o === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === s || t != null && this.pos - s !== t ? null : i;
};
function w5e(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function $K(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
un.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var r = this.readInt(e);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = $K(this.input.slice(t, this.pos)), ++this.pos) : Vo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ke.num, r);
};
un.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
  var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  r && this.strict && this.raise(t, "Invalid number");
  var n = this.input.charCodeAt(this.pos);
  if (!r && !e && this.options.ecmaVersion >= 11 && n === 110) {
    var a = $K(this.input.slice(t, this.pos));
    return ++this.pos, Vo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ke.num, a);
  }
  r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1), n === 46 && !r && (++this.pos, this.readInt(10), n = this.input.charCodeAt(this.pos)), (n === 69 || n === 101) && !r && (n = this.input.charCodeAt(++this.pos), (n === 43 || n === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Vo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = w5e(this.input.slice(t, this.pos), r);
  return this.finishToken(ke.num, s);
};
un.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
un.readString = function(e) {
  for (var t = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var n = this.input.charCodeAt(this.pos);
    if (n === e)
      break;
    n === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(!1), r = this.pos) : n === 8232 || n === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Pd(n) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(r, this.pos++), this.finishToken(ke.string, t);
};
var BK = {};
un.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === BK)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = !1;
};
un.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw BK;
  this.raise(e, t);
};
un.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === ke.template || this.type === ke.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(ke.dollarBraceL)) : (++this.pos, this.finishToken(ke.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(ke.template, e));
    if (r === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
    else if (Pd(r)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
un.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      // fall through
      case "`":
        return this.finishToken(ke.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        this.input[this.pos + 1] === `
` && ++this.pos;
      // fall through
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine, this.lineStart = this.pos + 1;
        break;
    }
  this.raise(this.start, "Unterminated template");
};
un.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return Go(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    // '\r\n'
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), e) {
        var r = this.pos - 1;
        this.invalidStringToken(
          r,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (t >= 48 && t <= 55) {
        var n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], a = parseInt(n, 8);
        return a > 255 && (n = n.slice(0, -1), a = parseInt(n, 8)), this.pos += n.length - 1, t = this.input.charCodeAt(this.pos), (n !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - n.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(a);
      }
      return Pd(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
  }
};
un.readHexChar = function(e) {
  var t = this.pos, r = this.readInt(16, e);
  return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
};
un.readWord1 = function() {
  this.containsEsc = !1;
  for (var e = "", t = !0, r = this.pos, n = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var a = this.fullCharCodeAtPos();
    if (bd(a, n))
      this.pos += a <= 65535 ? 1 : 2;
    else if (a === 92) {
      this.containsEsc = !0, e += this.input.slice(r, this.pos);
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var i = this.readCodePoint();
      (t ? Vo : bd)(i, n) || this.invalidStringToken(s, "Invalid Unicode escape"), e += Go(i), r = this.pos;
    } else
      break;
    t = !1;
  }
  return e + this.input.slice(r, this.pos);
};
un.readWord = function() {
  var e = this.readWord1(), t = ke.name;
  return this.keywords.test(e) && (t = _D[e]), this.finishToken(t, e);
};
var x5e = "8.14.0";
Ei.acorn = {
  Parser: Ei,
  version: x5e,
  defaultOptions: WR,
  Position: Gp,
  SourceLocation: Ey,
  getLineInfo: uK,
  Node: _y,
  TokenType: vn,
  tokTypes: ke,
  keywordTypes: _D,
  TokContext: As,
  tokContexts: ei,
  isIdentifierChar: bd,
  isIdentifierStart: Vo,
  Token: ND,
  isNewLine: Pd,
  lineBreak: ms,
  lineBreakG: jMe,
  nonASCIIwhitespace: oK
};
const E5e = {}.hasOwnProperty, S5e = Symbol("continue"), JA = Symbol("exit"), _5e = Symbol("skip");
function k5e(e, t) {
  let r, n;
  typeof t == "function" ? r = t : typeof t == "object" && (t.enter && (r = t.enter), t.leave && (n = t.leave)), a(e, void 0, void 0, [])();
  function a(s, i, o, l) {
    return QA(s) && (u.displayName = "node (" + s.type + ")"), u;
    function u() {
      const c = r ? w9(r(s, i, o, l)) : [];
      if (c[0] === JA)
        return c;
      if (c[0] !== _5e) {
        let d;
        for (d in s)
          if (E5e.call(s, d) && s[d] && typeof s[d] == "object" && // @ts-expect-error: custom esast extension.
          d !== "data" && // @ts-expect-error: custom esast extension.
          d !== "position") {
            const p = l.concat(s), f = s[d];
            if (Array.isArray(f)) {
              const h = (
                /** @type {Array<unknown>} */
                f
              );
              let m = 0;
              for (; m > -1 && m < h.length; ) {
                const y = h[m];
                if (QA(y)) {
                  const b = a(
                    y,
                    d,
                    m,
                    p
                  )();
                  if (b[0] === JA) return b;
                  m = typeof b[1] == "number" ? b[1] : m + 1;
                } else
                  m++;
              }
            } else if (QA(f)) {
              const h = a(f, d, void 0, p)();
              if (h[0] === JA) return h;
            }
          }
      }
      return n ? w9(n(s, i, o, l)) : c;
    }
  }
}
function w9(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [S5e, e] : [e];
}
function QA(e) {
  return !!(e && typeof e == "object" && "type" in e && typeof e.type == "string" && e.type.length > 0);
}
function UK(e, t) {
  const r = t.prefix || "", n = t.suffix || "", a = Object.assign({}, t.acornOptions), s = [], i = [], o = a.onComment, l = a.onToken;
  let u = !1, c, d;
  const p = Object.assign({}, a, {
    onComment: s,
    preserveParens: !0
  });
  l && (p.onToken = i);
  const f = C5e(e, t.tokenTypes), h = f.value, m = r + h + n, y = t.expression && x9(h);
  if (y && !t.allowEmpty)
    throw new Rn("Unexpected empty expression", {
      place: v(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  try {
    c = t.expression && !y ? t.acorn.parseExpressionAt(m, 0, p) : t.acorn.parse(m, p);
  } catch (x) {
    const _ = (
      /** @type {AcornError} */
      x
    ), E = v(_.pos);
    _.message = String(_.message).replace(/ \(\d+:\d+\)$/, ""), _.pos = E.offset, _.loc = {
      line: E.line,
      column: E.column - 1
    }, d = _, u = _.raisedAt >= r.length + h.length || // Broken comments are raised at their start, not their end.
    _.message === "Unterminated comment";
  }
  if (c && t.expression && !y)
    if (x9(m.slice(c.end, m.length - n.length)))
      c = {
        type: "Program",
        start: 0,
        end: r.length + h.length,
        // @ts-expect-error: It’s good.
        body: [{
          type: "ExpressionStatement",
          expression: c,
          start: 0,
          end: r.length + h.length
        }],
        sourceType: "module",
        comments: []
      };
    else {
      const x = v(c.end), _ = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      _.pos = x.offset, _.loc = {
        line: x.line,
        column: x.column - 1
      }, d = _, c = void 0;
    }
  if (c) {
    if (c.comments = s, k5e(c, function(x, _, E, w) {
      let C = (
        /** @type {AcornNode | Array<AcornNode>} */
        w[w.length - 1]
      ), k = _;
      x.type === "ParenthesizedExpression" && C && k && (typeof E == "number" && (C = C[k], k = E), C[k] = x.expression), b(x);
    }), Array.isArray(o))
      o.push(...s);
    else if (typeof o == "function")
      for (const x of s)
        o(x.type === "Block", x.value, x.start, x.end, x.loc.start, x.loc.end);
    for (const x of i)
      x.end <= r.length || x.start - r.length >= h.length || (b(x), Array.isArray(l) ? l.push(x) : l(x));
  }
  return {
    estree: c,
    error: d,
    swallow: u
  };
  function b(x) {
    const _ = v(x.start), E = v(x.end);
    x.start = _.offset, x.end = E.offset, x.loc = {
      start: {
        line: _.line,
        column: _.column - 1,
        offset: _.offset
      },
      end: {
        line: E.line,
        column: E.column - 1,
        offset: E.offset
      }
    }, x.range = [x.start, x.end];
  }
  function v(x) {
    let _ = x - r.length;
    _ < 0 ? _ = 0 : _ > h.length && (_ = h.length);
    let E = A5e(f.stops, _);
    return E || (E = {
      line: t.start.line,
      column: t.start.column,
      offset: t.start.offset
    }), E;
  }
}
function x9(e) {
  return /^\s*$/.test(e.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function C5e(e, t) {
  const r = {
    value: "",
    stops: []
  };
  let n = -1;
  for (; ++n < e.length; ) {
    const a = e[n];
    if (a[0] === "enter") {
      const s = a[1].type;
      if (s === "lineEnding" || t.includes(s)) {
        const i = a[2].sliceStream(a[1]);
        for (; i.length > 0 && i[0] === -1; )
          i.shift();
        const o = T5e(i);
        r.stops.push([r.value.length, a[1].start]), r.value += o, r.stops.push([r.value.length, a[1].end]);
      }
    }
  }
  return r;
}
function A5e(e, t) {
  let r = 0;
  for (; r < e.length && e[r][0] <= t; )
    r += 1;
  if (r === 0)
    return;
  const [n, a] = e[r - 1], s = t - n;
  return {
    line: a.line,
    column: a.column + s,
    offset: a.offset + s
  };
}
function T5e(e) {
  let t = -1;
  const r = [];
  let n;
  for (; ++t < e.length; ) {
    const a = e[t];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = "	";
        break;
      }
      /* c8 ignore next 6 */
      case -1: {
        if (n) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    n = a === -2, r.push(s);
  }
  return r.join("");
}
function Fo(e) {
  const t = e || {}, r = t.loc || {}, n = t.range || [void 0, void 0], a = E9(r.start, n[0] || t.start), s = E9(r.end, n[1] || t.end);
  if (a && s)
    return { start: a, end: s };
}
function E9(e, t) {
  if (e && typeof e == "object") {
    const r = "line" in e ? eT(e.line) : void 0, n = "column" in e ? eT(e.column) : void 0;
    if (r && n !== void 0)
      return {
        line: r,
        column: n + 1,
        offset: eT(t)
      };
  }
}
function eT(e) {
  return typeof e == "number" && e > -1 ? e : void 0;
}
const R5e = 2, Fc = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", I5e = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", N5e = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed", S9 = "#unexpected-type-in-code-expected-an-object-spread-spread", D5e = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported", O5e = "#could-not-parse-expression-with-acorn";
function ub(e, t, r, n, a, s, i, o, l, u, c) {
  const d = this, p = this.events.length + 3;
  let f = 0, h, m;
  return y;
  function y(_) {
    return e.enter(r), e.enter(n), e.consume(_), e.exit(n), h = d.now(), b;
  }
  function b(_) {
    if (_ === null) {
      if (m) throw m;
      const E = new Rn("Unexpected end of file in expression, expected a corresponding closing brace for `{`", {
        place: d.now(),
        ruleId: "unexpected-eof",
        source: "micromark-extension-mdx-expression"
      });
      throw E.url = Fc + I5e, E;
    }
    if (_r(_))
      return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), x;
    if (_ === 125 && f === 0) {
      const E = s ? P5e.call(d, s, i, a, p, h, u || !1, l || !1) : {
        type: "ok",
        estree: void 0
      };
      if (E.type === "ok") {
        e.enter(n), e.consume(_), e.exit(n);
        const w = e.exit(r);
        return o && E.estree && Object.assign(w, {
          estree: E.estree
        }), t;
      }
      return m = E.message, e.enter(a), e.consume(_), v;
    }
    return e.enter(a), v(_);
  }
  function v(_) {
    return _ === 125 && f === 0 || _ === null || _r(_) ? (e.exit(a), b(_)) : (_ === 123 && !s ? f += 1 : _ === 125 && (f -= 1), e.consume(_), v);
  }
  function x(_) {
    const E = d.now();
    if (E.line !== h.line && !c && d.parser.lazy[E.line]) {
      const w = new Rn("Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", {
        place: d.now(),
        ruleId: "unexpected-lazy",
        source: "micromark-extension-mdx-expression"
      });
      throw w.url = Fc + N5e, w;
    }
    return Yr(_) ? on(e, b, "linePrefix", R5e + 1)(_) : b(_);
  }
}
function P5e(e, t, r, n, a, s, i) {
  const o = UK(this.events.slice(n), {
    acorn: e,
    tokenTypes: [r],
    acornOptions: t,
    start: a,
    expression: !0,
    allowEmpty: s,
    prefix: i ? "({" : "",
    suffix: i ? "})" : ""
  }), l = o.estree;
  if (i && l) {
    const u = l.body[0];
    if (u.type !== "ExpressionStatement" || u.expression.type !== "ObjectExpression") {
      const c = Fo(u), d = new Rn("Unexpected `" + u.type + "` in code: expected an object spread (`{...spread}`)", {
        place: c.start,
        ruleId: "non-spread",
        source: "micromark-extension-mdx-expression"
      });
      throw d.url = Fc + S9, d;
    }
    if (u.expression.properties[1]) {
      const c = Fo(u.expression.properties[1]), d = new Rn("Unexpected extra content in spread: only a single spread is supported", {
        place: c.start,
        ruleId: "spread-extra",
        source: "micromark-extension-mdx-expression"
      });
      throw d.url = Fc + D5e, d;
    }
    if (u.expression.properties[0] && u.expression.properties[0].type !== "SpreadElement") {
      const c = Fo(u.expression.properties[0]), d = new Rn("Unexpected `" + u.expression.properties[0].type + "` in code: only spread elements are supported", {
        place: c.start,
        ruleId: "non-spread",
        source: "micromark-extension-mdx-expression"
      });
      throw d.url = Fc + S9, d;
    }
  }
  if (o.error) {
    const u = new Rn("Could not parse expression with acorn", {
      cause: o.error,
      place: {
        line: o.error.loc.line,
        column: o.error.loc.column + 1,
        offset: o.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    return u.url = Fc + O5e, {
      type: "nok",
      message: u
    };
  }
  return {
    type: "ok",
    estree: l
  };
}
function L5e(e) {
  const t = e || {}, r = t.addResult, n = t.acorn, a = t.spread;
  let s = t.allowEmpty, i;
  if (s == null && (s = !0), n) {
    if (!n.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    i = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions);
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      123: {
        name: "mdxFlowExpression",
        tokenize: o,
        concrete: !0
      }
    },
    text: {
      123: {
        name: "mdxTextExpression",
        tokenize: l
      }
    }
  };
  function o(u, c, d) {
    const p = this;
    return f;
    function f(b) {
      return h(b);
    }
    function h(b) {
      return ub.call(p, u, m, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", n, i, r, a, s)(b);
    }
    function m(b) {
      return Yr(b) ? on(u, y, "whitespace")(b) : y(b);
    }
    function y(b) {
      const v = p.parser.constructs.flow[60], _ = (Array.isArray(v) ? v : (
        /* c8 ignore next 3 -- always a list when normalized. */
        v ? [v] : []
      )).find(function(E) {
        return E.name === "mdxJsxFlowTag";
      });
      return b === 60 && _ ? u.attempt(_, y, d)(b) : b === null || _r(b) ? c(b) : d(b);
    }
  }
  function l(u, c) {
    const d = this;
    return p;
    function p(f) {
      return ub.call(d, u, c, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", n, i, r, a, s, !0)(f);
    }
  }
}
const _9 = "https://github.com/micromark/micromark-extension-mdx-jsx";
function zK(e, t, r, n, a, s, i, o, l, u, c, d, p, f, h, m, y, b, v, x, _, E, w, C, k, S, B, U, N, O, I, q) {
  const ae = this;
  let Q, ne;
  return le;
  function le(Y) {
    return e.enter(o), e.enter(l), e.consume(Y), e.exit(l), W;
  }
  function W(Y) {
    return pn(Y) ? r(Y) : (Q = X, xe(Y));
  }
  function X(Y) {
    if (Y === 47)
      return e.enter(u), e.consume(Y), e.exit(u), Q = G, xe;
    if (Y === 62)
      return We(Y);
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(d), e.enter(p), e.consume(Y), P;
    Fe(Y, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (Y === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
  }
  function G(Y) {
    if (Y === 62)
      return We(Y);
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(d), e.enter(p), e.consume(Y), P;
    Fe(Y, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (Y === 42 || Y === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function P(Y) {
    if (Y !== null && Y >= 0 && Ef(Y, {
      jsx: !0
    }))
      return e.consume(Y), P;
    if (Y === 46 || Y === 47 || Y === 58 || Y === 62 || Y === 123 || pn(Y) || ia(Y))
      return e.exit(p), Q = he, xe(Y);
    Fe(Y, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (Y === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function he(Y) {
    if (Y === 46)
      return e.enter(f), e.consume(Y), e.exit(f), Q = ye, xe;
    if (Y === 58)
      return e.enter(m), e.consume(Y), e.exit(m), Q = F, xe;
    if (Y === 47 || Y === 62 || Y === 123 || Y !== null && Y >= 0 && Cs(Y))
      return e.exit(d), ie(Y);
    Fe(Y, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ye(Y) {
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(h), e.consume(Y), pe;
    Fe(Y, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function pe(Y) {
    if (Y !== null && Y >= 0 && Ef(Y, {
      jsx: !0
    }))
      return e.consume(Y), pe;
    if (Y === 46 || Y === 47 || Y === 62 || Y === 123 || pn(Y) || ia(Y))
      return e.exit(h), Q = $, xe(Y);
    Fe(Y, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (Y === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function $(Y) {
    if (Y === 46)
      return e.enter(f), e.consume(Y), e.exit(f), Q = ye, xe;
    if (Y === 47 || Y === 62 || Y === 123 || Y !== null && Y >= 0 && Cs(Y))
      return e.exit(d), ie(Y);
    Fe(Y, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function F(Y) {
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(y), e.consume(Y), ge;
    Fe(Y, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (Y === 43 || Y !== null && Y > 46 && Y < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function ge(Y) {
    if (Y !== null && Y >= 0 && Ef(Y, {
      jsx: !0
    }))
      return e.consume(Y), ge;
    if (Y === 47 || Y === 62 || Y === 123 || pn(Y) || ia(Y))
      return e.exit(y), Q = ce, xe(Y);
    Fe(Y, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ce(Y) {
    if (Y === 47 || Y === 62 || Y === 123 || Y !== null && Y >= 0 && Cs(Y))
      return e.exit(d), ie(Y);
    Fe(Y, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ie(Y) {
    if (Y === 47)
      return e.enter(c), e.consume(Y), e.exit(c), Q = Ce, xe;
    if (Y === 62)
      return We(Y);
    if (Y === 123)
      return ub.call(ae, e, re, b, v, x, n, a, s, !0, !1, i)(Y);
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(_), e.enter(E), e.enter(w), e.consume(Y), Te;
    Fe(Y, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function re(Y) {
    return Q = ie, xe(Y);
  }
  function Te(Y) {
    if (Y !== null && Y >= 0 && Ef(Y, {
      jsx: !0
    }))
      return e.consume(Y), Te;
    if (Y === 47 || Y === 58 || Y === 61 || Y === 62 || Y === 123 || pn(Y) || ia(Y))
      return e.exit(w), Q = V, xe(Y);
    Fe(Y, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function V(Y) {
    if (Y === 58)
      return e.enter(C), e.consume(Y), e.exit(C), Q = Pe, xe;
    if (Y === 61)
      return e.exit(E), e.enter(S), e.consume(Y), e.exit(S), Q = R, xe;
    if (Y === 47 || Y === 62 || Y === 123 || pn(Y) || ia(Y) || Y !== null && Y >= 0 && Cs(Y))
      return e.exit(E), e.exit(_), Q = ie, xe(Y);
    Fe(Y, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function Pe(Y) {
    if (Y !== null && Y >= 0 && Cs(Y))
      return e.enter(k), e.consume(Y), z;
    Fe(Y, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function z(Y) {
    if (Y !== null && Y >= 0 && Ef(Y, {
      jsx: !0
    }))
      return e.consume(Y), z;
    if (Y === 47 || Y === 61 || Y === 62 || Y === 123 || pn(Y) || ia(Y))
      return e.exit(k), e.exit(E), Q = A, xe(Y);
    Fe(Y, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function A(Y) {
    if (Y === 61)
      return e.enter(S), e.consume(Y), e.exit(S), Q = R, xe;
    if (Y === 47 || Y === 62 || Y === 123 || Y !== null && Y >= 0 && Cs(Y))
      return e.exit(_), ie(Y);
    Fe(Y, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function R(Y) {
    if (Y === 34 || Y === 39)
      return e.enter(B), e.enter(U), e.consume(Y), e.exit(U), ne = Y, be;
    if (Y === 123)
      return ub.call(ae, e, H, O, I, q, n, a, s, !1, !1, i)(Y);
    Fe(Y, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (Y === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
  }
  function H(Y) {
    return e.exit(_), Q = ie, xe(Y);
  }
  function be(Y) {
    return Y === null && Fe(Y, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(ne) + "`"), Y === ne ? (e.enter(U), e.consume(Y), e.exit(U), e.exit(B), e.exit(_), ne = void 0, Q = ie, xe) : _r(Y) ? (Q = be, xe(Y)) : (e.enter(N), me(Y));
  }
  function me(Y) {
    return Y === null || Y === ne || _r(Y) ? (e.exit(N), be(Y)) : (e.consume(Y), me);
  }
  function Ce(Y) {
    if (Y === 62)
      return We(Y);
    Fe(Y, "after self-closing slash", "`>` to end the tag" + (Y === 42 || Y === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function We(Y) {
    return e.enter(l), e.consume(Y), e.exit(l), e.exit(o), t;
  }
  function xe(Y) {
    return _r(Y) ? (e.enter("lineEnding"), e.consume(Y), e.exit("lineEnding"), te) : Yr(Y) || ia(Y) ? (e.enter("esWhitespace"), we(Y)) : Q(Y);
  }
  function we(Y) {
    return _r(Y) ? (e.exit("esWhitespace"), xe(Y)) : Yr(Y) || ia(Y) ? (e.consume(Y), we) : (e.exit("esWhitespace"), Q(Y));
  }
  function te(Y) {
    if (!i && ae.parser.lazy[ae.now().line]) {
      const Je = new Rn("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", ae.now(), "micromark-extension-mdx-jsx:unexpected-lazy");
      throw Je.url = _9 + "#unexpected-lazy-line-in-container-expected-line-to-be", Je;
    }
    return xe(Y);
  }
  function Fe(Y, Je, xt) {
    const Ze = new Rn("Unexpected " + (Y === null ? "end of file" : "character `" + (Y === 96 ? "` ` `" : String.fromCodePoint(Y)) + "` (" + M5e(Y) + ")") + " " + Je + ", expected " + xt, ae.now(), "micromark-extension-mdx-jsx:unexpected-" + (Y === null ? "eof" : "character"));
    throw Ze.url = _9 + (Y === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), Ze;
  }
}
function M5e(e) {
  return "U+" + e.toString(16).toUpperCase().padStart(4, "0");
}
function F5e(e, t) {
  return {
    name: "mdxJsxTextTag",
    tokenize: r
  };
  function r(n, a, s) {
    return zK.call(this, n, a, s, e, t.acornOptions, t.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
  }
}
function $5e(e, t) {
  return {
    name: "mdxJsxFlowTag",
    tokenize: r,
    concrete: !0
  };
  function r(n, a, s) {
    const i = this;
    return o;
    function o(d) {
      return l(d);
    }
    function l(d) {
      return zK.call(i, n, u, s, e, t.acornOptions, t.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(d);
    }
    function u(d) {
      return Yr(d) ? on(n, c, "whitespace")(d) : c(d);
    }
    function c(d) {
      const p = i.parser.constructs.flow[123], h = (Array.isArray(p) ? p : p ? [p] : []).find((m) => m.name === "mdxFlowExpression");
      return d === 60 ? (
        // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
        o(d)
      ) : d === 123 && h ? n.attempt(h, c, s)(d) : d === null || _r(d) ? a(d) : s(d);
    }
  }
}
function B5e(e) {
  const t = e || {}, r = t.acorn;
  let n;
  if (r) {
    if (!r.parse || !r.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    n = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions, {
      locations: !0
    });
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      60: $5e(r || void 0, {
        acornOptions: n,
        addResult: t.addResult || void 0
      })
    },
    text: {
      60: F5e(r || void 0, {
        acornOptions: n,
        addResult: t.addResult || void 0
      })
    }
  };
}
function U5e() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}
const z5e = {
  tokenize: H5e,
  partial: !0
}, k9 = "https://github.com/micromark/micromark-extension-mdxjs-esm", q5e = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
function j5e(e) {
  const t = {
    tokenize: a,
    concrete: !0
  };
  if (!e || !e.acorn || !e.acorn.parse)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  const r = e.acorn, n = Object.assign({
    ecmaVersion: 2024,
    sourceType: "module"
  }, e.acornOptions, {
    locations: !0
  });
  return {
    flow: {
      101: t,
      105: t
    }
  };
  function a(s, i, o) {
    const l = this, u = l.parser.definedModuleSpecifiers || (l.parser.definedModuleSpecifiers = []), c = this.events.length + 1;
    let d = "";
    return l.interrupt ? o : p;
    function p(v) {
      return l.now().column > 1 ? o(v) : (s.enter("mdxjsEsm"), s.enter("mdxjsEsmData"), s.consume(v), d += String.fromCharCode(v), f);
    }
    function f(v) {
      return Ui(v) ? (s.consume(v), d += String.fromCharCode(v), f) : (d === "import" || d === "export") && v === 32 ? (s.consume(v), h) : o(v);
    }
    function h(v) {
      return v === null || _r(v) ? (s.exit("mdxjsEsmData"), m(v)) : (s.consume(v), h);
    }
    function m(v) {
      return v === null ? b(v) : _r(v) ? s.check(z5e, b, y)(v) : (s.enter("mdxjsEsmData"), h(v));
    }
    function y(v) {
      return s.enter("lineEnding"), s.consume(v), s.exit("lineEnding"), m;
    }
    function b(v) {
      const x = UK(l.events.slice(c), {
        acorn: r,
        acornOptions: n,
        tokenTypes: ["mdxjsEsmData"],
        prefix: u.length > 0 ? "var " + u.join(",") + `
` : ""
      });
      if (x.error) {
        if (v !== null && x.swallow)
          return y(v);
        const E = new Rn("Could not parse import/exports with acorn", {
          cause: x.error,
          place: {
            line: x.error.loc.line,
            column: x.error.loc.column + 1,
            offset: x.error.pos
          },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm"
        });
        throw E.url = k9 + "#could-not-parse-importexports-with-acorn", E;
      }
      u.length > 0 && x.estree.body.shift();
      let _ = -1;
      for (; ++_ < x.estree.body.length; ) {
        const E = x.estree.body[_];
        if (!q5e.has(E.type)) {
          const w = new Rn("Unexpected `" + E.type + "` in code: only import/exports are supported", {
            place: Fo(E),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm"
          });
          throw w.url = k9 + "#unexpected-type-in-code-only-importexports-are-supported", w;
        }
        if (E.type === "ImportDeclaration" && !l.interrupt) {
          let w = -1;
          for (; ++w < E.specifiers.length; ) {
            const C = E.specifiers[w];
            u.push(C.local.name);
          }
        }
      }
      return Object.assign(s.exit("mdxjsEsm"), e.addResult ? {
        estree: x.estree
      } : void 0), i(v);
    }
  }
}
function H5e(e, t, r) {
  return n;
  function n(a) {
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), e.attempt(Id, t, r);
  }
}
function V5e(e) {
  const t = Object.assign(
    {
      acorn: Ei.extend(GW()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: !0
    },
    e
  );
  return TN([
    j5e(t),
    L5e(t),
    B5e(t),
    U5e()
  ]);
}
const G5e = {};
function W5e(e) {
  const t = this, r = e || G5e, n = t.data(), a = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []);
  a.push(V5e(r)), s.push(LMe()), i.push(MMe(r));
}
function kl(e, t) {
  const r = ["start", "end", "loc", "range"];
  let n = -1;
  for (; ++n < r.length; ) {
    const a = r[n];
    a in e && (t[a] = e[a]);
  }
}
function DD(e, t) {
  let r = -1;
  const n = [], a = [];
  let s;
  for (; ++r < e.length; ) {
    const i = e[r];
    i.type === "ImportNamespaceSpecifier" ? s = i : a.push(i);
  }
  if (s) {
    const i = {
      type: "VariableDeclarator",
      id: s.local,
      init: t
    };
    kl(s, i), n.push(i);
  }
  return n.push({
    type: "VariableDeclarator",
    id: {
      type: "ObjectPattern",
      properties: a.map(function(i) {
        let o = i.type === "ImportSpecifier" ? i.imported : i.type === "ExportSpecifier" ? i.exported : { type: "Identifier", name: "default" }, l = i.local;
        i.type === "ExportSpecifier" && (l = o, o = i.local), l.type;
        const u = {
          type: "Property",
          kind: "init",
          shorthand: o.type === "Identifier" && l.type === "Identifier" && o.name === l.name,
          method: !1,
          computed: !1,
          key: o,
          value: l
        };
        return kl(i, u), u;
      })
    },
    init: s ? { type: "Identifier", name: s.local.name } : t
  }), n;
}
function Pl(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    const n = e[t], a = typeof n == "string" && so(n) ? { type: "Identifier", name: n } : { type: "Literal", value: n };
    r = r ? {
      type: "MemberExpression",
      object: r,
      property: a,
      computed: a.type === "Literal",
      optional: !1
    } : a;
  }
  return r.type, r;
}
function C9(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    const n = e[t];
    typeof n == "string" && so(n, { jsx: !0 });
    const a = { type: "JSXIdentifier", name: n };
    r = r ? { type: "JSXMemberExpression", object: r, property: a } : a;
  }
  return r;
}
function K5e(e) {
  const { outputFormat: t } = e || {};
  return function(r) {
    if (r.comments && (r.comments = r.comments.filter(function(n) {
      return !n.data?._mdxIsPragmaComment;
    })), t === "function-body") {
      let n = 0;
      for (; n < r.body.length; ) {
        const s = r.body[n];
        if ("directive" in s && s.directive)
          n++;
        else
          break;
      }
      const a = r.body[n];
      a && a.type === "ImportDeclaration" && typeof a.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(a.source.value) && (r.body[n] = {
        type: "VariableDeclaration",
        kind: "const",
        declarations: DD(
          a.specifiers,
          Pl(["arguments", 0])
        )
      });
    }
  };
}
function qK() {
  const e = [{ block: !1, defined: [] }];
  return { enter: t, exit: r, scopes: e };
  function t(s) {
    if (s.type === "ArrowFunctionExpression") {
      e.push({ block: !1, defined: [] });
      for (const i of s.params)
        a(i, !1);
    } else if (s.type === "BlockStatement" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement")
      e.push({ block: !0, defined: [] });
    else if (s.type === "CatchClause")
      e.push({ block: !0, defined: [] }), s.param && a(s.param, !0);
    else if (s.type === "ClassDeclaration")
      n(s.id.name, !1);
    else if (s.type === "FunctionDeclaration") {
      n(s.id.name, !1), e.push({ block: !1, defined: [] });
      for (const i of s.params)
        a(i, !1);
    } else if (s.type === "FunctionExpression") {
      s.id && n(s.id.name, !1), e.push({ block: !1, defined: [] });
      for (const i of s.params)
        a(i, !1);
    } else if (s.type === "ImportDeclaration")
      for (const i of s.specifiers)
        n(i.local.name, !1);
    else if (s.type === "VariableDeclaration")
      for (const i of s.declarations)
        a(i.id, s.kind !== "var");
  }
  function r(s) {
    if (s.type === "ArrowFunctionExpression" || s.type === "FunctionDeclaration" || s.type === "FunctionExpression") {
      const i = e.pop();
      i.block;
    } else if (s.type === "BlockStatement" || s.type === "CatchClause" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement") {
      const i = e.pop();
      i.block;
    }
  }
  function n(s, i) {
    let o = e.length, l;
    for (; o-- && (l = e[o], !(i || !l.block)); )
      ;
    l.defined.push(s);
  }
  function a(s, i) {
    if (s.type === "ArrayPattern")
      for (const o of s.elements)
        o && a(o, i);
    else if (s.type === "AssignmentPattern")
      a(s.left, i);
    else if (s.type === "Identifier")
      n(s.name, i);
    else if (s.type === "ObjectPattern")
      for (const o of s.properties)
        o.type === "Property" ? a(o.value, i) : (o.type, a(o, i));
    else
      s.type, a(s.argument, i);
  }
}
class Y5e {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (t) => this.replacement = t
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(t, r, n, a) {
    t && r && (n != null ? t[r][n] = a : t[r] = a);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(t, r, n) {
    t && r && (n != null ? t[r].splice(n, 1) : delete t[r]);
  }
}
class X5e extends Y5e {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(t, r) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (n) => this.replacement = n
    }, this.enter = t, this.leave = r;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(t, r, n, a) {
    if (t) {
      if (this.enter) {
        const i = this.should_skip, o = this.should_remove, l = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, r, n, a), this.replacement && (t = this.replacement, this.replace(r, n, a, t)), this.should_remove && this.remove(r, n, a);
        const u = this.should_skip, c = this.should_remove;
        if (this.should_skip = i, this.should_remove = o, this.replacement = l, u) return t;
        if (c) return null;
      }
      let s;
      for (s in t) {
        const i = t[s];
        if (i && typeof i == "object")
          if (Array.isArray(i)) {
            const o = (
              /** @type {Array<unknown>} */
              i
            );
            for (let l = 0; l < o.length; l += 1) {
              const u = o[l];
              A9(u) && (this.visit(u, t, s, l) || l--);
            }
          } else A9(i) && this.visit(i, t, s, null);
      }
      if (this.leave) {
        const i = this.replacement, o = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, r, n, a), this.replacement && (t = this.replacement, this.replace(r, n, a, t)), this.should_remove && this.remove(r, n, a);
        const l = this.should_remove;
        if (this.replacement = i, this.should_remove = o, l) return null;
      }
    }
    return t;
  }
}
function A9(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function ip(e, { enter: t, leave: r }) {
  return new X5e(t, r).visit(e, null);
}
function Z5e(e) {
  return e.type === "FunctionDeclaration" ? { ...e, type: "FunctionExpression" } : (e.type, { ...e, type: "ClassExpression" });
}
function J5e(e) {
  return e.type === "FunctionDeclaration" || e.type === "ClassDeclaration" || e.type === "VariableDeclaration";
}
function Q5e(e) {
  const t = e.baseUrl || void 0, r = typeof t == "object" ? t.href : t, n = e.outputFormat || "program", a = e.pragma === void 0 ? "React.createElement" : e.pragma, s = e.pragmaFrag === void 0 ? "React.Fragment" : e.pragmaFrag, i = e.pragmaImportSource || "react", o = e.jsxImportSource || "react", l = e.jsxRuntime || "automatic";
  return function(c, d) {
    const p = [], f = [];
    let h = 0, m, y, b;
    if (l === "classic" && s && Wm(c, "@jsxFrag", s), l === "classic" && a && Wm(c, "@jsx", a), l === "automatic" && o && Wm(c, "@jsxImportSource", o), Wm(c, "@jsxRuntime", l), l === "classic" && i) {
      if (!a)
        throw new Error(
          "Missing `pragma` in classic runtime with `pragmaImportSource`"
        );
      E({
        type: "ImportDeclaration",
        specifiers: [
          {
            type: "ImportDefaultSpecifier",
            local: { type: "Identifier", name: a.split(".")[0] }
          }
        ],
        source: { type: "Literal", value: i }
      });
    }
    for (b of c.body)
      if (b.type === "ExportDefaultDeclaration")
        m && d.fail(
          "Unexpected duplicate layout, expected a single layout (previous: " + ss(Fo(m)) + ")",
          {
            ancestors: [c, b],
            place: Fo(b),
            ruleId: "duplicate-layout",
            source: "recma-document"
          }
        ), m = b, f.push({
          type: "VariableDeclaration",
          kind: "const",
          declarations: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "MDXLayout" },
              init: J5e(b.declaration) ? Z5e(b.declaration) : b.declaration
            }
          ]
        });
      else if (b.type === "ExportNamedDeclaration" && b.source) {
        const w = (
          /** @type {SimpleLiteral} */
          b.source
        );
        b.specifiers = b.specifiers.filter(function(C) {
          if (C.exported.type === "Identifier" && C.exported.name === "default") {
            m && d.fail(
              "Unexpected duplicate layout, expected a single layout (previous: " + ss(Fo(m)) + ")",
              {
                ancestors: [c, b, C],
                place: Fo(b),
                ruleId: "duplicate-layout",
                source: "recma-document"
              }
            ), m = C;
            const k = [];
            if (C.local.type === "Identifier" && C.local.name === "default")
              k.push({
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name: "MDXLayout" }
              });
            else {
              const U = {
                type: "ImportSpecifier",
                imported: C.local,
                local: { type: "Identifier", name: "MDXLayout" }
              };
              kl(C.local, U), k.push(U);
            }
            const S = { type: "Literal", value: w.value };
            kl(w, S);
            const B = {
              type: "ImportDeclaration",
              specifiers: k,
              source: S
            };
            return kl(C, B), E(B), !1;
          }
          return !0;
        }), b.specifiers.length > 0 && _(b);
      } else b.type === "ExportNamedDeclaration" || b.type === "ExportAllDeclaration" ? _(b) : b.type === "ImportDeclaration" ? E(b) : b.type === "ExpressionStatement" && (b.expression.type === "JSXElement" || b.expression.type === "JSXFragment") ? (y = !0, f.push(
        ...u(b.expression, n, !!m)
      )) : f.push(b);
    y || f.push(
      ...u(void 0, n, !!m)
    ), p.push(["MDXContent", "default"]), n === "function-body" && f.push({
      type: "ReturnStatement",
      argument: {
        type: "ObjectExpression",
        properties: [
          ...Array.from({ length: h }).map(
            /**
             * @param {undefined} _
             *   Nothing.
             * @param {number} index
             *   Index.
             * @returns {SpreadElement}
             *   Node.
             */
            function(w, C) {
              return {
                type: "SpreadElement",
                argument: {
                  type: "Identifier",
                  name: "_exportAll" + (C + 1)
                }
              };
            }
          ),
          ...p.map(function(w) {
            return {
              type: "Property",
              kind: "init",
              method: !1,
              computed: !1,
              shorthand: typeof w == "string",
              key: {
                type: "Identifier",
                name: typeof w == "string" ? w : w[1]
              },
              value: {
                type: "Identifier",
                name: typeof w == "string" ? w : w[0]
              }
            };
          })
        ]
      }
    }), c.body = f;
    let v = !1, x = !1;
    (r || n === "function-body") && ip(c, {
      enter(w) {
        if ((w.type === "ExportAllDeclaration" || w.type === "ExportNamedDeclaration" || w.type === "ImportDeclaration") && w.source) {
          let C = w.source.value;
          try {
            new URL(C);
          } catch {
            (C.startsWith("/") || C.startsWith("./") || C.startsWith("../")) && (C = new URL(C, r).href);
          }
          const k = { type: "Literal", value: C };
          kl(w.source, k), w.source = k;
          return;
        }
        if (w.type === "ImportExpression") {
          x = !0;
          const C = {
            type: "CallExpression",
            callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
            arguments: [w.source],
            optional: !1
          };
          w.source = C;
          return;
        }
        if (w.type === "MemberExpression" && "object" in w && w.object.type === "MetaProperty" && w.property.type === "Identifier" && w.object.meta.name === "import" && w.object.property.name === "meta" && w.property.name === "url") {
          v = !0;
          const C = { type: "Identifier", name: "_importMetaUrl" };
          kl(w, C), this.replace(C);
        }
      }
    }), x && (r || (v = !0), c.body.push(
      eFe(
        r ? { type: "Literal", value: r } : { type: "Identifier", name: "_importMetaUrl" }
      )
    )), v && c.body.unshift(...tFe());
    function _(w) {
      if (w.type === "ExportNamedDeclaration") {
        if (w.declaration) {
          const C = qK();
          ip(w, {
            enter(k) {
              C.enter(k), (k.type === "ArrowFunctionExpression" || k.type === "FunctionDeclaration" || k.type === "FunctionExpression") && (this.skip(), C.exit(k));
            },
            leave: C.exit
          }), p.push(...C.scopes[0].defined);
        }
        for (b of w.specifiers)
          b.exported.type === "Identifier" ? p.push(b.exported.name) : (b.exported.value, p.push(b.exported.value));
      }
      E(w);
    }
    function E(w) {
      let C, k;
      if (n === "function-body")
        if (
          // Always have a source:
          w.type === "ImportDeclaration" || w.type === "ExportAllDeclaration" || // Source optional:
          w.type === "ExportNamedDeclaration" && w.source
        ) {
          w.source;
          const S = { type: "ImportExpression", source: w.source };
          kl(w, S), k = { type: "AwaitExpression", argument: S }, (w.type === "ImportDeclaration" || w.type === "ExportNamedDeclaration") && w.specifiers.length === 0 ? C = { type: "ExpressionStatement", expression: k } : C = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: w.type === "ExportAllDeclaration" ? [
              {
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: "_exportAll" + ++h
                },
                init: k
              }
            ] : DD(w.specifiers, k)
          };
        } else if (w.declaration)
          C = w.declaration;
        else {
          const S = [];
          for (const B of w.specifiers)
            B.exported.type === "Identifier" && B.local.type === "Identifier" && B.local.name !== B.exported.name && S.push({
              type: "VariableDeclarator",
              id: B.exported,
              init: B.local
            });
          S.length > 0 && (C = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: S
          });
        }
      else
        C = w;
      C && f.push(C);
    }
  };
  function u(c, d, p) {
    let h = {
      type: "JSXElement",
      openingElement: {
        type: "JSXOpeningElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" },
        attributes: [
          {
            type: "JSXSpreadAttribute",
            argument: { type: "Identifier", name: "props" }
          }
        ],
        selfClosing: !1
      },
      closingElement: {
        type: "JSXClosingElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" }
      },
      children: [
        {
          type: "JSXElement",
          openingElement: {
            type: "JSXOpeningElement",
            name: { type: "JSXIdentifier", name: "_createMdxContent" },
            attributes: [
              {
                type: "JSXSpreadAttribute",
                argument: { type: "Identifier", name: "props" }
              }
            ],
            selfClosing: !0
          },
          closingElement: null,
          children: []
        }
      ]
    };
    p || (h = {
      type: "ConditionalExpression",
      test: { type: "Identifier", name: "MDXLayout" },
      consequent: h,
      alternate: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "_createMdxContent" },
        arguments: [{ type: "Identifier", name: "props" }],
        optional: !1
      }
    });
    let m = (
      // Cast because TS otherwise does not think `JSXFragment`s are expressions.
      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */
      c || { type: "Identifier", name: "undefined" }
    );
    m.type === "JSXFragment" && m.children.length === 1 && m.children[0].type === "JSXElement" && (m = m.children[0]);
    let y = !1;
    ip(m, {
      enter(v) {
        if (v.type === "ArrowFunctionExpression" || v.type === "FunctionDeclaration" || v.type === "FunctionExpression")
          return this.skip();
        (v.type === "AwaitExpression" || /* c8 ignore next 2 -- can only occur in a function (which then can
         * only be async, so skipped it) */
        v.type === "ForOfStatement" && v.await) && (y = !0);
      }
    });
    const b = {
      type: "FunctionDeclaration",
      id: { type: "Identifier", name: "MDXContent" },
      params: [
        {
          type: "AssignmentPattern",
          left: { type: "Identifier", name: "props" },
          right: { type: "ObjectExpression", properties: [] }
        }
      ],
      body: {
        type: "BlockStatement",
        body: [{ type: "ReturnStatement", argument: h }]
      }
    };
    return [
      {
        type: "FunctionDeclaration",
        async: y,
        id: { type: "Identifier", name: "_createMdxContent" },
        params: [{ type: "Identifier", name: "props" }],
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ReturnStatement",
              // Cast because TS doesn’t think `JSXFragment` is an expression.
              // eslint-disable-next-line object-shorthand
              argument: (
                /** @type {Expression} */
                m
              )
            }
          ]
        }
      },
      d === "program" ? { type: "ExportDefaultDeclaration", declaration: b } : b
    ];
  }
}
function Wm(e, t, r) {
  e.comments?.unshift({
    type: "Block",
    value: t + " " + r,
    data: { _mdxIsPragmaComment: !0 }
  });
}
function eFe(e) {
  return {
    type: "FunctionDeclaration",
    id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
    generator: !1,
    async: !1,
    params: [{ type: "Identifier", name: "d" }],
    body: {
      type: "BlockStatement",
      body: [
        {
          type: "IfStatement",
          test: {
            type: "BinaryExpression",
            left: {
              type: "UnaryExpression",
              operator: "typeof",
              prefix: !0,
              argument: { type: "Identifier", name: "d" }
            },
            operator: "!==",
            right: { type: "Literal", value: "string" }
          },
          consequent: {
            type: "ReturnStatement",
            argument: { type: "Identifier", name: "d" }
          },
          alternate: null
        },
        // To do: use `URL.canParse` when widely supported (see commented
        // out code below).
        {
          type: "TryStatement",
          block: {
            type: "BlockStatement",
            body: [
              {
                type: "ExpressionStatement",
                expression: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "URL" },
                  arguments: [{ type: "Identifier", name: "d" }]
                }
              },
              {
                type: "ReturnStatement",
                argument: { type: "Identifier", name: "d" }
              }
            ]
          },
          handler: {
            type: "CatchClause",
            param: null,
            body: { type: "BlockStatement", body: [] }
          },
          finalizer: null
        },
        // To do: use `URL.canParse` when widely supported.
        // {
        //   type: 'IfStatement',
        //   test: {
        //     type: 'CallExpression',
        //     callee: toIdOrMemberExpression(['URL', 'canParse']),
        //     arguments: [{type: 'Identifier', name: 'd'}],
        //     optional: false
        //   },
        //   consequent: {
        //     type: 'ReturnStatement',
        //     argument: {type: 'Identifier', name: 'd'}
        //   },
        //   alternate: null
        // },
        {
          type: "IfStatement",
          test: {
            type: "LogicalExpression",
            left: {
              type: "LogicalExpression",
              left: {
                type: "CallExpression",
                callee: Pl(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "/" }],
                optional: !1
              },
              operator: "||",
              right: {
                type: "CallExpression",
                callee: Pl(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "./" }],
                optional: !1
              }
            },
            operator: "||",
            right: {
              type: "CallExpression",
              callee: Pl(["d", "startsWith"]),
              arguments: [{ type: "Literal", value: "../" }],
              optional: !1
            }
          },
          consequent: {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "URL" },
                arguments: [{ type: "Identifier", name: "d" }, e]
              },
              property: { type: "Identifier", name: "href" },
              computed: !1,
              optional: !1
            }
          },
          alternate: null
        },
        {
          type: "ReturnStatement",
          argument: { type: "Identifier", name: "d" }
        }
      ]
    }
  };
}
function tFe() {
  return [
    {
      type: "VariableDeclaration",
      declarations: [
        {
          type: "VariableDeclarator",
          id: { type: "Identifier", name: "_importMetaUrl" },
          init: Pl(["arguments", 0, "baseUrl"])
        }
      ],
      kind: "const"
    },
    {
      type: "IfStatement",
      test: {
        type: "UnaryExpression",
        operator: "!",
        prefix: !0,
        argument: { type: "Identifier", name: "_importMetaUrl" }
      },
      consequent: {
        type: "ThrowStatement",
        argument: {
          type: "NewExpression",
          callee: { type: "Identifier", name: "Error" },
          arguments: [
            {
              type: "Literal",
              value: "Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`"
            }
          ]
        }
      },
      alternate: null
    }
  ];
}
function T9(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    const n = e[t];
    r = r ? { type: "BinaryExpression", left: r, operator: "+", right: n } : n;
  }
  return r;
}
function rFe(e) {
  const { development: t, outputFormat: r, providerImportSource: n } = e;
  return function(a, s) {
    const i = qK(), o = [];
    let l = !1, u = !1;
    if (ip(a, {
      enter(c) {
        i.enter(c), (c.type === "FunctionDeclaration" || c.type === "FunctionExpression" || c.type === "ArrowFunctionExpression") && (o.push({
          components: [],
          idToInvalidComponentName: /* @__PURE__ */ new Map(),
          node: c,
          objects: [],
          references: {},
          tags: []
        }), vc(c, "MDXContent") && !tT(i.scopes, "MDXLayout") && o[0].components.push("MDXLayout"));
        const d = o[0];
        if (!(!d || !vc(d.node, "_createMdxContent") && !n) && c.type === "JSXElement") {
          let p = c.openingElement.name;
          if (p.type === "JSXMemberExpression") {
            const f = [];
            for (; p.type === "JSXMemberExpression"; )
              f.unshift(p.property.name), p = p.object;
            f.unshift(p.name);
            const h = f.join("."), m = p.name, y = tT(i.scopes, m);
            !Object.hasOwn(d.references, h) && (!y || // If the parent scope is `_createMdxContent`, then this
            // references a component we can add a check statement for.
            o.length === 1 && o[0].node.type === "FunctionDeclaration" && vc(o[0].node, "_createMdxContent")) && (d.references[h] = { component: !0, node: c }), !d.objects.includes(m) && !y && d.objects.push(m);
          } else if (p.type !== "JSXNamespacedName") {
            if (so(p.name) && !/^[a-z]/.test(p.name)) {
              const f = p.name;
              tT(i.scopes, f) || (f !== "MDXLayout" && !Object.hasOwn(d.references, f) && (d.references[f] = { component: !0, node: c }), d.components.includes(f) || d.components.push(f));
            } else if (!(c.data && c.data._mdxExplicitJsx)) {
              const f = p.name;
              d.tags.includes(f) || d.tags.push(f);
              let h = ["_components", f];
              if (so(f) === !1) {
                let m = d.idToInvalidComponentName.get(f);
                m === void 0 && (m = `_component${d.idToInvalidComponentName.size}`, d.idToInvalidComponentName.set(
                  f,
                  m
                )), h = [m];
              }
              c.openingElement.name = C9(h), c.closingElement && (c.closingElement.name = C9(h));
            }
          }
        }
      },
      leave(c) {
        i.exit(c);
        const d = [], p = [], f = [], h = [];
        if (c.type === "FunctionDeclaration" || c.type === "FunctionExpression" || c.type === "ArrowFunctionExpression") {
          const m = o[o.length - 1];
          let y;
          for (y of m.tags.sort())
            d.push({
              type: "Property",
              kind: "init",
              key: so(y) ? { type: "Identifier", name: y } : { type: "Literal", value: y },
              value: { type: "Literal", value: y },
              method: !1,
              shorthand: !1,
              computed: !1
            });
          p.push(...m.components);
          for (y of m.objects)
            p.includes(y) || p.push(y);
          p.sort();
          const b = [];
          if (d.length > 0 || p.length > 0 || m.idToInvalidComponentName.size > 0) {
            if (n && (l = !0, f.push({
              type: "CallExpression",
              callee: { type: "Identifier", name: "_provideComponents" },
              arguments: [],
              optional: !1
            })), (vc(m.node, "MDXContent") || vc(m.node, "_createMdxContent")) && f.push(Pl(["props", "components"])), d.length > 0 || f.length > 1)
              for (const C of f)
                d.push({ type: "SpreadElement", argument: C });
            let E = d.length > 0 ? { type: "ObjectExpression", properties: d } : (
              // If we’re only getting components from `props.components`,
              // make sure it’s defined.
              {
                type: "LogicalExpression",
                operator: "||",
                left: f[0],
                right: { type: "ObjectExpression", properties: [] }
              }
            ), w;
            if (p.length > 0 && (w = {
              type: "ObjectPattern",
              properties: p.map(function(C) {
                return {
                  type: "Property",
                  kind: "init",
                  key: {
                    type: "Identifier",
                    name: C === "MDXLayout" ? "wrapper" : C
                  },
                  value: { type: "Identifier", name: C },
                  method: !1,
                  shorthand: C !== "MDXLayout",
                  computed: !1
                };
              })
            }), m.tags.length > 0 && (h.push({
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "_components" },
              init: E
            }), E = { type: "Identifier", name: "_components" }), vc(m.node, "_createMdxContent"))
              for (const [C, k] of [
                ...m.idToInvalidComponentName
              ].sort(function([S], [B]) {
                return S.localeCompare(B);
              }))
                h.push({
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name: k
                  },
                  init: {
                    type: "MemberExpression",
                    object: { type: "Identifier", name: "_components" },
                    property: { type: "Literal", value: C },
                    computed: !0,
                    optional: !1
                  }
                });
            w && h.push({
              type: "VariableDeclarator",
              id: w,
              init: E
            }), h.length > 0 && b.push({
              type: "VariableDeclaration",
              kind: "const",
              declarations: h
            });
          }
          let v;
          for (v in m.references)
            if (Object.hasOwn(m.references, v)) {
              const E = v.split(".");
              let w = 0;
              for (; ++w < E.length; ) {
                const C = E.slice(0, w).join(".");
                Object.hasOwn(m.references, C) || (m.references[C] = {
                  component: !1,
                  node: m.references[v].node
                });
              }
            }
          const x = Object.keys(m.references).sort();
          let _ = -1;
          for (; ++_ < x.length; ) {
            const E = x[_], w = m.references[E], C = ss(Fo(w.node)), k = [
              { type: "Literal", value: E },
              { type: "Literal", value: w.component }
            ];
            u = !0, t && C && k.push({ type: "Literal", value: C }), b.push({
              type: "IfStatement",
              test: {
                type: "UnaryExpression",
                operator: "!",
                prefix: !0,
                argument: Pl(E.split("."))
              },
              consequent: {
                type: "ExpressionStatement",
                expression: {
                  type: "CallExpression",
                  callee: { type: "Identifier", name: "_missingMdxReference" },
                  arguments: k,
                  optional: !1
                }
              },
              alternate: void 0
            });
          }
          b.length > 0 && (c.body.type !== "BlockStatement" && (c.body = {
            type: "BlockStatement",
            body: [{ type: "ReturnStatement", argument: c.body }]
          }), c.body.body.unshift(...b)), o.pop();
        }
      }
    }), l && n && a.body.unshift(
      nFe(n, r)
    ), u) {
      const c = [
        { type: "Literal", value: "Expected " },
        {
          type: "ConditionalExpression",
          test: { type: "Identifier", name: "component" },
          consequent: { type: "Literal", value: "component" },
          alternate: { type: "Literal", value: "object" }
        },
        { type: "Literal", value: " `" },
        { type: "Identifier", name: "id" },
        {
          type: "Literal",
          value: "` to be defined: you likely forgot to import, pass, or provide it."
        }
      ], d = [
        { type: "Identifier", name: "id" },
        { type: "Identifier", name: "component" }
      ];
      t && (c.push({
        type: "ConditionalExpression",
        test: { type: "Identifier", name: "place" },
        consequent: T9([
          { type: "Literal", value: "\nIt’s referenced in your code at `" },
          { type: "Identifier", name: "place" },
          {
            type: "Literal",
            value: (s.path ? "` in `" + s.path : "") + "`"
          }
        ]),
        alternate: { type: "Literal", value: "" }
      }), d.push({ type: "Identifier", name: "place" })), a.body.push({
        type: "FunctionDeclaration",
        id: { type: "Identifier", name: "_missingMdxReference" },
        generator: !1,
        async: !1,
        params: d,
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ThrowStatement",
              argument: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "Error" },
                arguments: [T9(c)]
              }
            }
          ]
        }
      });
    }
    r === "function-body" && a.body.unshift({
      type: "ExpressionStatement",
      expression: { type: "Literal", value: "use strict" },
      directive: "use strict"
    });
  };
}
function nFe(e, t) {
  const r = [
    {
      type: "ImportSpecifier",
      imported: { type: "Identifier", name: "useMDXComponents" },
      local: { type: "Identifier", name: "_provideComponents" }
    }
  ];
  return t === "function-body" ? {
    type: "VariableDeclaration",
    kind: "const",
    declarations: DD(
      r,
      Pl(["arguments", 0])
    )
  } : {
    type: "ImportDeclaration",
    specifiers: r,
    source: { type: "Literal", value: e }
  };
}
function vc(e, t) {
  return !!(e && "id" in e && e.id && e.id.name === t);
}
function tT(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r].defined.includes(t))
      return !0;
  return !1;
}
function iFe() {
  return function(e) {
    ay(e, "raw", function(t, r, n) {
      if (n && typeof r == "number")
        return n.children.splice(r, 1), r;
    });
  };
}
const aFe = /\s+/g, sFe = /[\t\n\v\f\r ]+/g;
function oFe(e, t) {
  t ? typeof t == "string" && (t = { style: t }) : t = {};
  const r = t.preserveLineEndings ? lFe : uFe;
  return String(e).replace(
    t.style === "html" ? sFe : aFe,
    t.trim ? cFe(r) : r
  );
}
function lFe(e) {
  const t = /\r?\n|\r/.exec(e);
  return t ? t[0] : " ";
}
function uFe() {
  return " ";
}
function cFe(e) {
  return t;
  function t(r, n, a) {
    return n === 0 || n + r.length === a.length ? "" : e(r);
  }
}
function dFe() {
  return function(e) {
    ay(e, function(t, r, n) {
      let a = -1, s = !0, i = !1;
      if (n && typeof r == "number" && t.type === "paragraph") {
        const o = t.children;
        for (; ++a < o.length; ) {
          const l = o[a];
          if (l.type === "mdxJsxTextElement" || l.type === "mdxTextExpression")
            i = !0;
          else if (!(l.type === "text" && oFe(l.value, { style: "html", trim: !0 }) === "")) {
            s = !1;
            break;
          }
        }
        if (s && i) {
          a = -1;
          const l = [];
          for (; ++a < o.length; ) {
            const u = o[a];
            u.type === "mdxJsxTextElement" && (u.type = "mdxJsxFlowElement"), u.type === "mdxTextExpression" && (u.type = "mdxFlowExpression"), u.type === "text" && /^[\t\r\n ]+$/.test(String(u.value)) || l.push(u);
          }
          return n.children.splice(r, 1, ...l), r;
        }
      }
      if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") {
        const o = t.data || (t.data = {});
        o._mdxExplicitJsx = !0;
      }
      (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression" || t.type === "mdxjsEsm") && t.data && t.data.estree && ip(t.data.estree, {
        enter(o) {
          if (o.type === "JSXElement") {
            const l = o.data || (o.data = {});
            l._mdxExplicitJsx = !0;
          }
        }
      });
    });
  };
}
const fFe = (
  /** @type {const} */
  [
    "mdxFlowExpression",
    "mdxJsxFlowElement",
    "mdxJsxTextElement",
    "mdxTextExpression",
    "mdxjsEsm"
  ]
);
let R9 = !1;
function pFe(e) {
  const t = e || {};
  t.format, (t.jsxRuntime === "classic" || t.pragma || t.pragmaFrag || t.pragmaImportSource) && !R9 && (R9 = !0, console.warn(
    "Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate"
  ));
  const r = oD().use(DN);
  t.format !== "md" && r.use(W5e);
  const n = t.remarkRehypeOptions || {};
  return r.use(dFe).use(t.remarkPlugins || []).use(yW, {
    ...n,
    allowDangerousHtml: !0,
    passThrough: [...n.passThrough || [], ...fFe]
  }).use(t.rehypePlugins || []), t.format === "md" && r.use(iFe), r.use(hMe, t).use(Q5e, t).use(rFe, t), t.jsx || r.use(oLe, t).use(K5e, t), r.use(MLe).use(FLe, t).use(t.recmaPlugins || []), r;
}
function hFe(e, t) {
  const { file: r, options: n } = YPe(e, t);
  return pFe(n).process(r);
}
const mFe = Object.getPrototypeOf(jK).constructor;
async function jK(e, t) {
  return new mFe(String(e))(t);
}
const HK = ({
  children: e,
  ...t
}) => {
  if (!e || typeof e != "object")
    return /* @__PURE__ */ K("code", { ...t, children: e });
  if (("type" in e ? e.type : "") !== "code")
    return /* @__PURE__ */ K("code", { ...t, children: e });
  const n = "props" in e ? e.props : {}, { className: a, children: s } = n, i = a?.replace("language-", "");
  return /* @__PURE__ */ K("div", { className: "text-sm", children: /* @__PURE__ */ K(BW, { language: i, style: PPe, children: String(s).replace(/\n$/, "") }) });
}, gFe = (e) => {
  const [t, r] = kt.useState(!0);
  return /* @__PURE__ */ $t(HPe, { open: t, onOpenChange: r, children: [
    /* @__PURE__ */ K(VPe, { children: /* @__PURE__ */ $t(ca, { variant: "light", size: "sm", children: [
      "Thoughts",
      /* @__PURE__ */ K(
        eq,
        {
          size: 14,
          className: ja(
            "transition-transform ml-2",
            t ? "rotate-180" : ""
          )
        }
      )
    ] }) }),
    /* @__PURE__ */ K(GPe, { className: "px-4 my-4 border-l-2 border-gray-200 morph-page-sm text-gray-400", children: e.children })
  ] });
}, XR = (e) => {
  const { source: t, sender: r } = e, { downloadMd: n, downloadHtml: a, downloadWordFromMd: s } = wW({});
  return /* @__PURE__ */ $t(kt.Suspense, { fallback: /* @__PURE__ */ K("div", { children: e.source }), children: [
    /* @__PURE__ */ $t("div", { className: "flex items-center gap-3 mb-1 w-full", children: [
      /* @__PURE__ */ K("div", { className: "font-bold text-sm", children: r }),
      /* @__PURE__ */ K("div", { className: "flex-1" }),
      /* @__PURE__ */ $t(wN, { children: [
        /* @__PURE__ */ K(xN, { children: /* @__PURE__ */ K(ca, { variant: "ghost", children: /* @__PURE__ */ K(tq, { size: 14 }) }) }),
        /* @__PURE__ */ $t(EN, { children: [
          /* @__PURE__ */ K(Jf, { onClick: () => a(e.source), children: "HTML" }),
          /* @__PURE__ */ K(Jf, { onClick: () => n(e.source), children: "Markdown" }),
          /* @__PURE__ */ K(Jf, { onClick: () => s(e.source), children: "Word" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ K(yFe, { value: t })
  ] });
};
function bFe(e) {
  return e = e.replace(/(?<!\n)(<think>)/g, `
$1`), e = e.replace(/(<think>)(?!\n)/g, `$1
`), e = e.replace(/(?<!\n)(<\/think>)/g, `
$1`), e = e.replace(/(<\/think>)(?!\n)/g, `$1
`), e = e.replace(/<think>/g, "<Think>"), e = e.replace(/<\/think>/g, "</Think>"), /<Think>/.test(e) && !/<\/Think>/.test(e) && (e += `
</Think>
`), e;
}
const yFe = (e) => {
  const [t, r] = kt.useState();
  return Qn(() => {
    hFe(bFe(e.value), {
      format: "mdx",
      outputFormat: "function-body",
      remarkPlugins: [NN]
    }).then((n) => {
      jK(n, YQ).then((a) => {
        const { default: s } = a;
        r(
          /* @__PURE__ */ K(
            s,
            {
              components: {
                Think: gFe,
                pre: HK
              }
            }
          )
        );
      });
    });
  }, [e.value]), /* @__PURE__ */ K("div", { className: "morph-page w-full max-w-ful", children: t });
}, vFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MdRenderer: XR,
  Pre: HK,
  default: XR
}, Symbol.toStringTag, { value: "Module" })), wFe = (e) => {
  const { source: t, contentType: r } = e, { downloadHtml: n } = wW({}), a = Or(() => {
    if (r === "HTML_TOP") {
      const s = new Blob([t], { type: "text/html" });
      return URL.createObjectURL(s);
    }
    if (r === "HTML_OTHER") {
      const s = new Blob(
        [
          `<html>
            <head></head>
            <body>${t}</body>
          </html>`
        ],
        { type: "text/html" }
      );
      return URL.createObjectURL(s);
    }
  }, [t, r]);
  return /* @__PURE__ */ $t("div", { className: "h-full w-full", children: [
    /* @__PURE__ */ $t("div", { className: "flex items-center gap-3 mb-1 w-full", children: [
      /* @__PURE__ */ K("div", { className: "flex-1" }),
      /* @__PURE__ */ $t(wN, { children: [
        /* @__PURE__ */ K(xN, { children: /* @__PURE__ */ K(ca, { variant: "ghost", children: /* @__PURE__ */ K(tq, { size: 14 }) }) }),
        /* @__PURE__ */ K(EN, { children: /* @__PURE__ */ K(Jf, { onClick: () => n(e.source), children: "HTML" }) })
      ] })
    ] }),
    /* @__PURE__ */ K(
      "iframe",
      {
        title: "MorphEmbed",
        width: "100%",
        height: "100%",
        src: a
      },
      a
    )
  ] });
}, {
  createElement: yd,
  createContext: xFe,
  createRef: Jze,
  forwardRef: VK,
  useCallback: xa,
  useContext: GK,
  useEffect: wu,
  useImperativeHandle: WK,
  useLayoutEffect: EFe,
  useMemo: SFe,
  useRef: Sa,
  useState: Zc
} = D, I9 = D[`useId${Math.random()}`.slice(0, 5)], _Fe = EFe, Cy = xFe(null);
Cy.displayName = "PanelGroupContext";
const xu = _Fe, kFe = typeof I9 == "function" ? I9 : () => null;
let CFe = 0;
function OD(e = null) {
  const t = kFe(), r = Sa(e || t || null);
  return r.current === null && (r.current = "" + CFe++), e ?? r.current;
}
function KK({
  children: e,
  className: t = "",
  collapsedSize: r,
  collapsible: n,
  defaultSize: a,
  forwardedRef: s,
  id: i,
  maxSize: o,
  minSize: l,
  onCollapse: u,
  onExpand: c,
  onResize: d,
  order: p,
  style: f,
  tagName: h = "div",
  ...m
}) {
  const y = GK(Cy);
  if (y === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: b,
    expandPanel: v,
    getPanelSize: x,
    getPanelStyle: _,
    groupId: E,
    isPanelCollapsed: w,
    reevaluatePanelConstraints: C,
    registerPanel: k,
    resizePanel: S,
    unregisterPanel: B
  } = y, U = OD(i), N = Sa({
    callbacks: {
      onCollapse: u,
      onExpand: c,
      onResize: d
    },
    constraints: {
      collapsedSize: r,
      collapsible: n,
      defaultSize: a,
      maxSize: o,
      minSize: l
    },
    id: U,
    idIsFromProps: i !== void 0,
    order: p
  });
  Sa({
    didLogMissingDefaultSizeWarning: !1
  }), xu(() => {
    const {
      callbacks: I,
      constraints: q
    } = N.current, ae = {
      ...q
    };
    N.current.id = U, N.current.idIsFromProps = i !== void 0, N.current.order = p, I.onCollapse = u, I.onExpand = c, I.onResize = d, q.collapsedSize = r, q.collapsible = n, q.defaultSize = a, q.maxSize = o, q.minSize = l, (ae.collapsedSize !== q.collapsedSize || ae.collapsible !== q.collapsible || ae.maxSize !== q.maxSize || ae.minSize !== q.minSize) && C(N.current, ae);
  }), xu(() => {
    const I = N.current;
    return k(I), () => {
      B(I);
    };
  }, [p, U, k, B]), WK(s, () => ({
    collapse: () => {
      b(N.current);
    },
    expand: (I) => {
      v(N.current, I);
    },
    getId() {
      return U;
    },
    getSize() {
      return x(N.current);
    },
    isCollapsed() {
      return w(N.current);
    },
    isExpanded() {
      return !w(N.current);
    },
    resize: (I) => {
      S(N.current, I);
    }
  }), [b, v, x, w, U, S]);
  const O = _(N.current, a);
  return yd(h, {
    ...m,
    children: e,
    className: t,
    id: i,
    style: {
      ...O,
      ...f
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": n || void 0,
    "data-panel-group-id": E,
    "data-panel-id": U,
    "data-panel-size": parseFloat("" + O.flexGrow).toFixed(1)
  });
}
const YK = VK((e, t) => yd(KK, {
  ...e,
  forwardedRef: t
}));
KK.displayName = "Panel";
YK.displayName = "forwardRef(Panel)";
let ZR = null, bu = null;
function AFe(e, t) {
  if (t) {
    const r = (t & eY) !== 0, n = (t & tY) !== 0, a = (t & rY) !== 0, s = (t & nY) !== 0;
    if (r)
      return a ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (n)
      return a ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (a)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function TFe() {
  bu !== null && (document.head.removeChild(bu), ZR = null, bu = null);
}
function rT(e, t) {
  const r = AFe(e, t);
  ZR !== r && (ZR = r, bu === null && (bu = document.createElement("style"), document.head.appendChild(bu)), bu.innerHTML = `*{cursor: ${r}!important;}`);
}
function XK(e) {
  return e.type === "keydown";
}
function ZK(e) {
  return e.type.startsWith("pointer");
}
function JK(e) {
  return e.type.startsWith("mouse");
}
function Ay(e) {
  if (ZK(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (JK(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function RFe() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function IFe(e, t, r) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function NFe(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const r = {
    a: O9(e),
    b: O9(t)
  };
  let n;
  for (; r.a.at(-1) === r.b.at(-1); )
    e = r.a.pop(), t = r.b.pop(), n = e;
  tn(n, "Stacking order can only be calculated for elements with a common ancestor");
  const a = {
    a: D9(N9(r.a)),
    b: D9(N9(r.b))
  };
  if (a.a === a.b) {
    const s = n.childNodes, i = {
      a: r.a.at(-1),
      b: r.b.at(-1)
    };
    let o = s.length;
    for (; o--; ) {
      const l = s[o];
      if (l === i.a) return 1;
      if (l === i.b) return -1;
    }
  }
  return Math.sign(a.a - a.b);
}
const DFe = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function OFe(e) {
  var t;
  const r = getComputedStyle((t = QK(e)) !== null && t !== void 0 ? t : e).display;
  return r === "flex" || r === "inline-flex";
}
function PFe(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || OFe(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || DFe.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function N9(e) {
  let t = e.length;
  for (; t--; ) {
    const r = e[t];
    if (tn(r, "Missing node"), PFe(r)) return r;
  }
  return null;
}
function D9(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function O9(e) {
  const t = [];
  for (; e; )
    t.push(e), e = QK(e);
  return t;
}
function QK(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const eY = 1, tY = 2, rY = 4, nY = 8, LFe = RFe() === "coarse";
let Fs = [], Jc = !1, Al = /* @__PURE__ */ new Map(), Ty = /* @__PURE__ */ new Map();
const Kp = /* @__PURE__ */ new Set();
function MFe(e, t, r, n, a) {
  var s;
  const {
    ownerDocument: i
  } = t, o = {
    direction: r,
    element: t,
    hitAreaMargins: n,
    setResizeHandlerState: a
  }, l = (s = Al.get(i)) !== null && s !== void 0 ? s : 0;
  return Al.set(i, l + 1), Kp.add(o), cb(), function() {
    var c;
    Ty.delete(e), Kp.delete(o);
    const d = (c = Al.get(i)) !== null && c !== void 0 ? c : 1;
    if (Al.set(i, d - 1), cb(), d === 1 && Al.delete(i), Fs.includes(o)) {
      const p = Fs.indexOf(o);
      p >= 0 && Fs.splice(p, 1), LD(), a("up", !0, null);
    }
  };
}
function P9(e) {
  const {
    target: t
  } = e, {
    x: r,
    y: n
  } = Ay(e);
  Jc = !0, PD({
    target: t,
    x: r,
    y: n
  }), cb(), Fs.length > 0 && (db("down", e), e.preventDefault(), e.stopPropagation());
}
function _f(e) {
  const {
    x: t,
    y: r
  } = Ay(e);
  if (Jc && e.buttons === 0 && (Jc = !1, db("up", e)), !Jc) {
    const {
      target: n
    } = e;
    PD({
      target: n,
      x: t,
      y: r
    });
  }
  db("move", e), LD(), Fs.length > 0 && e.preventDefault();
}
function wc(e) {
  const {
    target: t
  } = e, {
    x: r,
    y: n
  } = Ay(e);
  Ty.clear(), Jc = !1, Fs.length > 0 && e.preventDefault(), db("up", e), PD({
    target: t,
    x: r,
    y: n
  }), LD(), cb();
}
function PD({
  target: e,
  x: t,
  y: r
}) {
  Fs.splice(0);
  let n = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (n = e), Kp.forEach((a) => {
    const {
      element: s,
      hitAreaMargins: i
    } = a, o = s.getBoundingClientRect(), {
      bottom: l,
      left: u,
      right: c,
      top: d
    } = o, p = LFe ? i.coarse : i.fine;
    if (t >= u - p && t <= c + p && r >= d - p && r <= l + p) {
      if (n !== null && document.contains(n) && s !== n && !s.contains(n) && !n.contains(s) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      NFe(n, s) > 0) {
        let h = n, m = !1;
        for (; h && !h.contains(s); ) {
          if (IFe(h.getBoundingClientRect(), o)) {
            m = !0;
            break;
          }
          h = h.parentElement;
        }
        if (m)
          return;
      }
      Fs.push(a);
    }
  });
}
function nT(e, t) {
  Ty.set(e, t);
}
function LD() {
  let e = !1, t = !1;
  Fs.forEach((n) => {
    const {
      direction: a
    } = n;
    a === "horizontal" ? e = !0 : t = !0;
  });
  let r = 0;
  Ty.forEach((n) => {
    r |= n;
  }), e && t ? rT("intersection", r) : e ? rT("horizontal", r) : t ? rT("vertical", r) : TFe();
}
function cb() {
  Al.forEach((e, t) => {
    const {
      body: r
    } = t;
    r.removeEventListener("contextmenu", wc), r.removeEventListener("pointerdown", P9), r.removeEventListener("pointerleave", _f), r.removeEventListener("pointermove", _f);
  }), window.removeEventListener("pointerup", wc), window.removeEventListener("pointercancel", wc), Kp.size > 0 && (Jc ? (Fs.length > 0 && Al.forEach((e, t) => {
    const {
      body: r
    } = t;
    e > 0 && (r.addEventListener("contextmenu", wc), r.addEventListener("pointerleave", _f), r.addEventListener("pointermove", _f));
  }), window.addEventListener("pointerup", wc), window.addEventListener("pointercancel", wc)) : Al.forEach((e, t) => {
    const {
      body: r
    } = t;
    e > 0 && (r.addEventListener("pointerdown", P9, {
      capture: !0
    }), r.addEventListener("pointermove", _f));
  }));
}
function db(e, t) {
  Kp.forEach((r) => {
    const {
      setResizeHandlerState: n
    } = r, a = Fs.includes(r);
    n(e, a, t);
  });
}
function FFe() {
  const [e, t] = Zc(0);
  return xa(() => t((r) => r + 1), []);
}
function tn(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
const MD = 10;
function Ru(e, t, r = MD) {
  return e.toFixed(r) === t.toFixed(r) ? 0 : e > t ? 1 : -1;
}
function Oo(e, t, r = MD) {
  return Ru(e, t, r) === 0;
}
function La(e, t, r) {
  return Ru(e, t, r) === 0;
}
function $Fe(e, t, r) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++) {
    const a = e[n], s = t[n];
    if (!La(a, s, r))
      return !1;
  }
  return !0;
}
function $c({
  panelConstraints: e,
  panelIndex: t,
  size: r
}) {
  const n = e[t];
  tn(n != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: a = 0,
    collapsible: s,
    maxSize: i = 100,
    minSize: o = 0
  } = n;
  if (Ru(r, o) < 0)
    if (s) {
      const l = (a + o) / 2;
      Ru(r, l) < 0 ? r = a : r = o;
    } else
      r = o;
  return r = Math.min(i, r), r = parseFloat(r.toFixed(MD)), r;
}
function zf({
  delta: e,
  initialLayout: t,
  panelConstraints: r,
  pivotIndices: n,
  prevLayout: a,
  trigger: s
}) {
  if (La(e, 0))
    return t;
  const i = [...t], [o, l] = n;
  tn(o != null, "Invalid first pivot index"), tn(l != null, "Invalid second pivot index");
  let u = 0;
  if (s === "keyboard") {
    {
      const d = e < 0 ? l : o, p = r[d];
      tn(p, `Panel constraints not found for index ${d}`);
      const {
        collapsedSize: f = 0,
        collapsible: h,
        minSize: m = 0
      } = p;
      if (h) {
        const y = t[d];
        if (tn(y != null, `Previous layout not found for panel index ${d}`), La(y, f)) {
          const b = m - y;
          Ru(b, Math.abs(e)) > 0 && (e = e < 0 ? 0 - b : b);
        }
      }
    }
    {
      const d = e < 0 ? o : l, p = r[d];
      tn(p, `No panel constraints found for index ${d}`);
      const {
        collapsedSize: f = 0,
        collapsible: h,
        minSize: m = 0
      } = p;
      if (h) {
        const y = t[d];
        if (tn(y != null, `Previous layout not found for panel index ${d}`), La(y, m)) {
          const b = y - f;
          Ru(b, Math.abs(e)) > 0 && (e = e < 0 ? 0 - b : b);
        }
      }
    }
  }
  {
    const d = e < 0 ? 1 : -1;
    let p = e < 0 ? l : o, f = 0;
    for (; ; ) {
      const m = t[p];
      tn(m != null, `Previous layout not found for panel index ${p}`);
      const b = $c({
        panelConstraints: r,
        panelIndex: p,
        size: 100
      }) - m;
      if (f += b, p += d, p < 0 || p >= r.length)
        break;
    }
    const h = Math.min(Math.abs(e), Math.abs(f));
    e = e < 0 ? 0 - h : h;
  }
  {
    let p = e < 0 ? o : l;
    for (; p >= 0 && p < r.length; ) {
      const f = Math.abs(e) - Math.abs(u), h = t[p];
      tn(h != null, `Previous layout not found for panel index ${p}`);
      const m = h - f, y = $c({
        panelConstraints: r,
        panelIndex: p,
        size: m
      });
      if (!La(h, y) && (u += h - y, i[p] = y, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? p-- : p++;
    }
  }
  if ($Fe(a, i))
    return a;
  {
    const d = e < 0 ? l : o, p = t[d];
    tn(p != null, `Previous layout not found for panel index ${d}`);
    const f = p + u, h = $c({
      panelConstraints: r,
      panelIndex: d,
      size: f
    });
    if (i[d] = h, !La(h, f)) {
      let m = f - h, b = e < 0 ? l : o;
      for (; b >= 0 && b < r.length; ) {
        const v = i[b];
        tn(v != null, `Previous layout not found for panel index ${b}`);
        const x = v + m, _ = $c({
          panelConstraints: r,
          panelIndex: b,
          size: x
        });
        if (La(v, _) || (m -= _ - v, i[b] = _), La(m, 0))
          break;
        e > 0 ? b-- : b++;
      }
    }
  }
  const c = i.reduce((d, p) => p + d, 0);
  return La(c, 100) ? i : a;
}
function BFe({
  layout: e,
  panelsArray: t,
  pivotIndices: r
}) {
  let n = 0, a = 100, s = 0, i = 0;
  const o = r[0];
  tn(o != null, "No pivot index found"), t.forEach((d, p) => {
    const {
      constraints: f
    } = d, {
      maxSize: h = 100,
      minSize: m = 0
    } = f;
    p === o ? (n = m, a = h) : (s += m, i += h);
  });
  const l = Math.min(a, 100 - s), u = Math.max(n, 100 - i), c = e[o];
  return {
    valueMax: l,
    valueMin: u,
    valueNow: c
  };
}
function Yp(e, t = document) {
  return Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`));
}
function iY(e, t, r = document) {
  const a = Yp(e, r).findIndex((s) => s.getAttribute("data-panel-resize-handle-id") === t);
  return a ?? null;
}
function aY(e, t, r) {
  const n = iY(e, t, r);
  return n != null ? [n, n + 1] : [-1, -1];
}
function sY(e, t = document) {
  var r;
  if (t instanceof HTMLElement && (t == null || (r = t.dataset) === null || r === void 0 ? void 0 : r.panelGroupId) == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Ry(e, t = document) {
  const r = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return r || null;
}
function UFe(e, t, r, n = document) {
  var a, s, i, o;
  const l = Ry(t, n), u = Yp(e, n), c = l ? u.indexOf(l) : -1, d = (a = (s = r[c]) === null || s === void 0 ? void 0 : s.id) !== null && a !== void 0 ? a : null, p = (i = (o = r[c + 1]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null;
  return [d, p];
}
function zFe({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: r,
  layout: n,
  panelDataArray: a,
  panelGroupElement: s,
  setLayout: i
}) {
  Sa({
    didWarnAboutMissingResizeHandle: !1
  }), xu(() => {
    if (!s)
      return;
    const o = Yp(r, s);
    for (let l = 0; l < a.length - 1; l++) {
      const {
        valueMax: u,
        valueMin: c,
        valueNow: d
      } = BFe({
        layout: n,
        panelsArray: a,
        pivotIndices: [l, l + 1]
      }), p = o[l];
      if (p != null) {
        const f = a[l];
        tn(f, `No panel data found for index "${l}"`), p.setAttribute("aria-controls", f.id), p.setAttribute("aria-valuemax", "" + Math.round(u)), p.setAttribute("aria-valuemin", "" + Math.round(c)), p.setAttribute("aria-valuenow", d != null ? "" + Math.round(d) : "");
      }
    }
    return () => {
      o.forEach((l, u) => {
        l.removeAttribute("aria-controls"), l.removeAttribute("aria-valuemax"), l.removeAttribute("aria-valuemin"), l.removeAttribute("aria-valuenow");
      });
    };
  }, [r, n, a, s]), wu(() => {
    if (!s)
      return;
    const o = t.current;
    tn(o, "Eager values not found");
    const {
      panelDataArray: l
    } = o, u = sY(r, s);
    tn(u != null, `No group found for id "${r}"`);
    const c = Yp(r, s);
    tn(c, `No resize handles found for group id "${r}"`);
    const d = c.map((p) => {
      const f = p.getAttribute("data-panel-resize-handle-id");
      tn(f, "Resize handle element has no handle id attribute");
      const [h, m] = UFe(r, f, l, s);
      if (h == null || m == null)
        return () => {
        };
      const y = (b) => {
        if (!b.defaultPrevented)
          switch (b.key) {
            case "Enter": {
              b.preventDefault();
              const v = l.findIndex((x) => x.id === h);
              if (v >= 0) {
                const x = l[v];
                tn(x, `No panel data found for index ${v}`);
                const _ = n[v], {
                  collapsedSize: E = 0,
                  collapsible: w,
                  minSize: C = 0
                } = x.constraints;
                if (_ != null && w) {
                  const k = zf({
                    delta: La(_, E) ? C - E : E - _,
                    initialLayout: n,
                    panelConstraints: l.map((S) => S.constraints),
                    pivotIndices: aY(r, f, s),
                    prevLayout: n,
                    trigger: "keyboard"
                  });
                  n !== k && i(k);
                }
              }
              break;
            }
          }
      };
      return p.addEventListener("keydown", y), () => {
        p.removeEventListener("keydown", y);
      };
    });
    return () => {
      d.forEach((p) => p());
    };
  }, [s, e, t, r, n, a, i]);
}
function L9(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function oY(e, t) {
  const r = e === "horizontal", {
    x: n,
    y: a
  } = Ay(t);
  return r ? n : a;
}
function qFe(e, t, r, n, a) {
  const s = r === "horizontal", i = Ry(t, a);
  tn(i, `No resize handle element found for id "${t}"`);
  const o = i.getAttribute("data-panel-group-id");
  tn(o, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: l
  } = n;
  const u = oY(r, e), c = sY(o, a);
  tn(c, `No group element found for id "${o}"`);
  const d = c.getBoundingClientRect(), p = s ? d.width : d.height;
  return (u - l) / p * 100;
}
function jFe(e, t, r, n, a, s) {
  if (XK(e)) {
    const i = r === "horizontal";
    let o = 0;
    e.shiftKey ? o = 100 : a != null ? o = a : o = 10;
    let l = 0;
    switch (e.key) {
      case "ArrowDown":
        l = i ? 0 : o;
        break;
      case "ArrowLeft":
        l = i ? -o : 0;
        break;
      case "ArrowRight":
        l = i ? o : 0;
        break;
      case "ArrowUp":
        l = i ? 0 : -o;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return n == null ? 0 : qFe(e, t, r, n, s);
}
function HFe({
  panelDataArray: e
}) {
  const t = Array(e.length), r = e.map((s) => s.constraints);
  let n = 0, a = 100;
  for (let s = 0; s < e.length; s++) {
    const i = r[s];
    tn(i, `Panel constraints not found for index ${s}`);
    const {
      defaultSize: o
    } = i;
    o != null && (n++, t[s] = o, a -= o);
  }
  for (let s = 0; s < e.length; s++) {
    const i = r[s];
    tn(i, `Panel constraints not found for index ${s}`);
    const {
      defaultSize: o
    } = i;
    if (o != null)
      continue;
    const l = e.length - n, u = a / l;
    n++, t[s] = u, a -= u;
  }
  return t;
}
function xc(e, t, r) {
  t.forEach((n, a) => {
    const s = e[a];
    tn(s, `Panel data not found for index ${a}`);
    const {
      callbacks: i,
      constraints: o,
      id: l
    } = s, {
      collapsedSize: u = 0,
      collapsible: c
    } = o, d = r[l];
    if (d == null || n !== d) {
      r[l] = n;
      const {
        onCollapse: p,
        onExpand: f,
        onResize: h
      } = i;
      h && h(n, d), c && (p || f) && (f && (d == null || Oo(d, u)) && !Oo(n, u) && f(), p && (d == null || !Oo(d, u)) && Oo(n, u) && p());
    }
  });
}
function Km(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] != t[r])
      return !1;
  return !0;
}
function VFe({
  defaultSize: e,
  dragState: t,
  layout: r,
  panelData: n,
  panelIndex: a,
  precision: s = 3
}) {
  const i = r[a];
  let o;
  return i == null ? o = e != null ? e.toPrecision(s) : "1" : n.length === 1 ? o = "1" : o = i.toPrecision(s), {
    flexBasis: 0,
    flexGrow: o,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function GFe(e, t = 10) {
  let r = null;
  return (...a) => {
    r !== null && clearTimeout(r), r = setTimeout(() => {
      e(...a);
    }, t);
  };
}
function M9(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, r) => {
        localStorage.setItem(t, r);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function lY(e) {
  return `react-resizable-panels:${e}`;
}
function uY(e) {
  return e.map((t) => {
    const {
      constraints: r,
      id: n,
      idIsFromProps: a,
      order: s
    } = t;
    return a ? n : s ? `${s}:${JSON.stringify(r)}` : JSON.stringify(r);
  }).sort((t, r) => t.localeCompare(r)).join(",");
}
function cY(e, t) {
  try {
    const r = lY(e), n = t.getItem(r);
    if (n) {
      const a = JSON.parse(n);
      if (typeof a == "object" && a != null)
        return a;
    }
  } catch {
  }
  return null;
}
function WFe(e, t, r) {
  var n, a;
  const s = (n = cY(e, r)) !== null && n !== void 0 ? n : {}, i = uY(t);
  return (a = s[i]) !== null && a !== void 0 ? a : null;
}
function KFe(e, t, r, n, a) {
  var s;
  const i = lY(e), o = uY(t), l = (s = cY(e, a)) !== null && s !== void 0 ? s : {};
  l[o] = {
    expandToSizes: Object.fromEntries(r.entries()),
    layout: n
  };
  try {
    a.setItem(i, JSON.stringify(l));
  } catch (u) {
    console.error(u);
  }
}
function F9({
  layout: e,
  panelConstraints: t
}) {
  const r = [...e], n = r.reduce((s, i) => s + i, 0);
  if (r.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${r.map((s) => `${s}%`).join(", ")}`);
  if (!La(n, 100) && r.length > 0)
    for (let s = 0; s < t.length; s++) {
      const i = r[s];
      tn(i != null, `No layout data found for index ${s}`);
      const o = 100 / n * i;
      r[s] = o;
    }
  let a = 0;
  for (let s = 0; s < t.length; s++) {
    const i = r[s];
    tn(i != null, `No layout data found for index ${s}`);
    const o = $c({
      panelConstraints: t,
      panelIndex: s,
      size: i
    });
    i != o && (a += i - o, r[s] = o);
  }
  if (!La(a, 0))
    for (let s = 0; s < t.length; s++) {
      const i = r[s];
      tn(i != null, `No layout data found for index ${s}`);
      const o = i + a, l = $c({
        panelConstraints: t,
        panelIndex: s,
        size: o
      });
      if (i !== l && (a -= l - i, r[s] = l, La(a, 0)))
        break;
    }
  return r;
}
const YFe = 100, qf = {
  getItem: (e) => (M9(qf), qf.getItem(e)),
  setItem: (e, t) => {
    M9(qf), qf.setItem(e, t);
  }
}, $9 = {};
function dY({
  autoSaveId: e = null,
  children: t,
  className: r = "",
  direction: n,
  forwardedRef: a,
  id: s = null,
  onLayout: i = null,
  keyboardResizeBy: o = null,
  storage: l = qf,
  style: u,
  tagName: c = "div",
  ...d
}) {
  const p = OD(s), f = Sa(null), [h, m] = Zc(null), [y, b] = Zc([]), v = FFe(), x = Sa({}), _ = Sa(/* @__PURE__ */ new Map()), E = Sa(0), w = Sa({
    autoSaveId: e,
    direction: n,
    dragState: h,
    id: p,
    keyboardResizeBy: o,
    onLayout: i,
    storage: l
  }), C = Sa({
    layout: y,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  Sa({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), WK(a, () => ({
    getId: () => w.current.id,
    getLayout: () => {
      const {
        layout: P
      } = C.current;
      return P;
    },
    setLayout: (P) => {
      const {
        onLayout: he
      } = w.current, {
        layout: ye,
        panelDataArray: pe
      } = C.current, $ = F9({
        layout: P,
        panelConstraints: pe.map((F) => F.constraints)
      });
      L9(ye, $) || (b($), C.current.layout = $, he && he($), xc(pe, $, x.current));
    }
  }), []), xu(() => {
    w.current.autoSaveId = e, w.current.direction = n, w.current.dragState = h, w.current.id = p, w.current.onLayout = i, w.current.storage = l;
  }), zFe({
    committedValuesRef: w,
    eagerValuesRef: C,
    groupId: p,
    layout: y,
    panelDataArray: C.current.panelDataArray,
    setLayout: b,
    panelGroupElement: f.current
  }), wu(() => {
    const {
      panelDataArray: P
    } = C.current;
    if (e) {
      if (y.length === 0 || y.length !== P.length)
        return;
      let he = $9[e];
      he == null && (he = GFe(KFe, YFe), $9[e] = he);
      const ye = [...P], pe = new Map(_.current);
      he(e, ye, pe, y, l);
    }
  }, [e, y, l]), wu(() => {
  });
  const k = xa((P) => {
    const {
      onLayout: he
    } = w.current, {
      layout: ye,
      panelDataArray: pe
    } = C.current;
    if (P.constraints.collapsible) {
      const $ = pe.map((ie) => ie.constraints), {
        collapsedSize: F = 0,
        panelSize: ge,
        pivotIndices: ce
      } = fu(pe, P, ye);
      if (tn(ge != null, `Panel size not found for panel "${P.id}"`), !Oo(ge, F)) {
        _.current.set(P.id, ge);
        const re = Ic(pe, P) === pe.length - 1 ? ge - F : F - ge, Te = zf({
          delta: re,
          initialLayout: ye,
          panelConstraints: $,
          pivotIndices: ce,
          prevLayout: ye,
          trigger: "imperative-api"
        });
        Km(ye, Te) || (b(Te), C.current.layout = Te, he && he(Te), xc(pe, Te, x.current));
      }
    }
  }, []), S = xa((P, he) => {
    const {
      onLayout: ye
    } = w.current, {
      layout: pe,
      panelDataArray: $
    } = C.current;
    if (P.constraints.collapsible) {
      const F = $.map((V) => V.constraints), {
        collapsedSize: ge = 0,
        panelSize: ce = 0,
        minSize: ie = 0,
        pivotIndices: re
      } = fu($, P, pe), Te = he ?? ie;
      if (Oo(ce, ge)) {
        const V = _.current.get(P.id), Pe = V != null && V >= Te ? V : Te, A = Ic($, P) === $.length - 1 ? ce - Pe : Pe - ce, R = zf({
          delta: A,
          initialLayout: pe,
          panelConstraints: F,
          pivotIndices: re,
          prevLayout: pe,
          trigger: "imperative-api"
        });
        Km(pe, R) || (b(R), C.current.layout = R, ye && ye(R), xc($, R, x.current));
      }
    }
  }, []), B = xa((P) => {
    const {
      layout: he,
      panelDataArray: ye
    } = C.current, {
      panelSize: pe
    } = fu(ye, P, he);
    return tn(pe != null, `Panel size not found for panel "${P.id}"`), pe;
  }, []), U = xa((P, he) => {
    const {
      panelDataArray: ye
    } = C.current, pe = Ic(ye, P);
    return VFe({
      defaultSize: he,
      dragState: h,
      layout: y,
      panelData: ye,
      panelIndex: pe
    });
  }, [h, y]), N = xa((P) => {
    const {
      layout: he,
      panelDataArray: ye
    } = C.current, {
      collapsedSize: pe = 0,
      collapsible: $,
      panelSize: F
    } = fu(ye, P, he);
    return tn(F != null, `Panel size not found for panel "${P.id}"`), $ === !0 && Oo(F, pe);
  }, []), O = xa((P) => {
    const {
      layout: he,
      panelDataArray: ye
    } = C.current, {
      collapsedSize: pe = 0,
      collapsible: $,
      panelSize: F
    } = fu(ye, P, he);
    return tn(F != null, `Panel size not found for panel "${P.id}"`), !$ || Ru(F, pe) > 0;
  }, []), I = xa((P) => {
    const {
      panelDataArray: he
    } = C.current;
    he.push(P), he.sort((ye, pe) => {
      const $ = ye.order, F = pe.order;
      return $ == null && F == null ? 0 : $ == null ? -1 : F == null ? 1 : $ - F;
    }), C.current.panelDataArrayChanged = !0, v();
  }, [v]);
  xu(() => {
    if (C.current.panelDataArrayChanged) {
      C.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: P,
        onLayout: he,
        storage: ye
      } = w.current, {
        layout: pe,
        panelDataArray: $
      } = C.current;
      let F = null;
      if (P) {
        const ce = WFe(P, $, ye);
        ce && (_.current = new Map(Object.entries(ce.expandToSizes)), F = ce.layout);
      }
      F == null && (F = HFe({
        panelDataArray: $
      }));
      const ge = F9({
        layout: F,
        panelConstraints: $.map((ce) => ce.constraints)
      });
      L9(pe, ge) || (b(ge), C.current.layout = ge, he && he(ge), xc($, ge, x.current));
    }
  }), xu(() => {
    const P = C.current;
    return () => {
      P.layout = [];
    };
  }, []);
  const q = xa((P) => {
    let he = !1;
    const ye = f.current;
    return ye && window.getComputedStyle(ye, null).getPropertyValue("direction") === "rtl" && (he = !0), function($) {
      $.preventDefault();
      const F = f.current;
      if (!F)
        return () => null;
      const {
        direction: ge,
        dragState: ce,
        id: ie,
        keyboardResizeBy: re,
        onLayout: Te
      } = w.current, {
        layout: V,
        panelDataArray: Pe
      } = C.current, {
        initialLayout: z
      } = ce ?? {}, A = aY(ie, P, F);
      let R = jFe($, P, ge, ce, re, F);
      const H = ge === "horizontal";
      H && he && (R = -R);
      const be = Pe.map((We) => We.constraints), me = zf({
        delta: R,
        initialLayout: z ?? V,
        panelConstraints: be,
        pivotIndices: A,
        prevLayout: V,
        trigger: XK($) ? "keyboard" : "mouse-or-touch"
      }), Ce = !Km(V, me);
      (ZK($) || JK($)) && E.current != R && (E.current = R, !Ce && R !== 0 ? H ? nT(P, R < 0 ? eY : tY) : nT(P, R < 0 ? rY : nY) : nT(P, 0)), Ce && (b(me), C.current.layout = me, Te && Te(me), xc(Pe, me, x.current));
    };
  }, []), ae = xa((P, he) => {
    const {
      onLayout: ye
    } = w.current, {
      layout: pe,
      panelDataArray: $
    } = C.current, F = $.map((V) => V.constraints), {
      panelSize: ge,
      pivotIndices: ce
    } = fu($, P, pe);
    tn(ge != null, `Panel size not found for panel "${P.id}"`);
    const re = Ic($, P) === $.length - 1 ? ge - he : he - ge, Te = zf({
      delta: re,
      initialLayout: pe,
      panelConstraints: F,
      pivotIndices: ce,
      prevLayout: pe,
      trigger: "imperative-api"
    });
    Km(pe, Te) || (b(Te), C.current.layout = Te, ye && ye(Te), xc($, Te, x.current));
  }, []), Q = xa((P, he) => {
    const {
      layout: ye,
      panelDataArray: pe
    } = C.current, {
      collapsedSize: $ = 0,
      collapsible: F
    } = he, {
      collapsedSize: ge = 0,
      collapsible: ce,
      maxSize: ie = 100,
      minSize: re = 0
    } = P.constraints, {
      panelSize: Te
    } = fu(pe, P, ye);
    Te != null && (F && ce && Oo(Te, $) ? Oo($, ge) || ae(P, ge) : Te < re ? ae(P, re) : Te > ie && ae(P, ie));
  }, [ae]), ne = xa((P, he) => {
    const {
      direction: ye
    } = w.current, {
      layout: pe
    } = C.current;
    if (!f.current)
      return;
    const $ = Ry(P, f.current);
    tn($, `Drag handle element not found for id "${P}"`);
    const F = oY(ye, he);
    m({
      dragHandleId: P,
      dragHandleRect: $.getBoundingClientRect(),
      initialCursorPosition: F,
      initialLayout: pe
    });
  }, []), le = xa(() => {
    m(null);
  }, []), W = xa((P) => {
    const {
      panelDataArray: he
    } = C.current, ye = Ic(he, P);
    ye >= 0 && (he.splice(ye, 1), delete x.current[P.id], C.current.panelDataArrayChanged = !0, v());
  }, [v]), X = SFe(() => ({
    collapsePanel: k,
    direction: n,
    dragState: h,
    expandPanel: S,
    getPanelSize: B,
    getPanelStyle: U,
    groupId: p,
    isPanelCollapsed: N,
    isPanelExpanded: O,
    reevaluatePanelConstraints: Q,
    registerPanel: I,
    registerResizeHandle: q,
    resizePanel: ae,
    startDragging: ne,
    stopDragging: le,
    unregisterPanel: W,
    panelGroupElement: f.current
  }), [k, h, n, S, B, U, p, N, O, Q, I, q, ae, ne, le, W]), G = {
    display: "flex",
    flexDirection: n === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return yd(Cy.Provider, {
    value: X
  }, yd(c, {
    ...d,
    children: t,
    className: r,
    id: s,
    ref: f,
    style: {
      ...G,
      ...u
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": n,
    "data-panel-group-id": p
  }));
}
const fY = VK((e, t) => yd(dY, {
  ...e,
  forwardedRef: t
}));
dY.displayName = "PanelGroup";
fY.displayName = "forwardRef(PanelGroup)";
function Ic(e, t) {
  return e.findIndex((r) => r === t || r.id === t.id);
}
function fu(e, t, r) {
  const n = Ic(e, t), s = n === e.length - 1 ? [n - 1, n] : [n, n + 1], i = r[n];
  return {
    ...t.constraints,
    panelSize: i,
    pivotIndices: s
  };
}
function XFe({
  disabled: e,
  handleId: t,
  resizeHandler: r,
  panelGroupElement: n
}) {
  wu(() => {
    if (e || r == null || n == null)
      return;
    const a = Ry(t, n);
    if (a == null)
      return;
    const s = (i) => {
      if (!i.defaultPrevented)
        switch (i.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            i.preventDefault(), r(i);
            break;
          }
          case "F6": {
            i.preventDefault();
            const o = a.getAttribute("data-panel-group-id");
            tn(o, `No group element found for id "${o}"`);
            const l = Yp(o, n), u = iY(o, t, n);
            tn(u !== null, `No resize element found for id "${t}"`);
            const c = i.shiftKey ? u > 0 ? u - 1 : l.length - 1 : u + 1 < l.length ? u + 1 : 0;
            l[c].focus();
            break;
          }
        }
    };
    return a.addEventListener("keydown", s), () => {
      a.removeEventListener("keydown", s);
    };
  }, [n, e, t, r]);
}
function pY({
  children: e = null,
  className: t = "",
  disabled: r = !1,
  hitAreaMargins: n,
  id: a,
  onBlur: s,
  onDragging: i,
  onFocus: o,
  style: l = {},
  tabIndex: u = 0,
  tagName: c = "div",
  ...d
}) {
  var p, f;
  const h = Sa(null), m = Sa({
    onDragging: i
  });
  wu(() => {
    m.current.onDragging = i;
  });
  const y = GK(Cy);
  if (y === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: b,
    groupId: v,
    registerResizeHandle: x,
    startDragging: _,
    stopDragging: E,
    panelGroupElement: w
  } = y, C = OD(a), [k, S] = Zc("inactive"), [B, U] = Zc(!1), [N, O] = Zc(null), I = Sa({
    state: k
  });
  xu(() => {
    I.current.state = k;
  }), wu(() => {
    if (r)
      O(null);
    else {
      const ne = x(C);
      O(() => ne);
    }
  }, [r, C, x]);
  const q = (p = n?.coarse) !== null && p !== void 0 ? p : 15, ae = (f = n?.fine) !== null && f !== void 0 ? f : 5;
  return wu(() => {
    if (r || N == null)
      return;
    const ne = h.current;
    return tn(ne, "Element ref not attached"), MFe(C, ne, b, {
      coarse: q,
      fine: ae
    }, (W, X, G) => {
      if (X)
        switch (W) {
          case "down": {
            S("drag"), tn(G, 'Expected event to be defined for "down" action'), _(C, G);
            const {
              onDragging: P
            } = m.current;
            P && P(!0);
            break;
          }
          case "move": {
            const {
              state: P
            } = I.current;
            P !== "drag" && S("hover"), tn(G, 'Expected event to be defined for "move" action'), N(G);
            break;
          }
          case "up": {
            S("hover"), E();
            const {
              onDragging: P
            } = m.current;
            P && P(!1);
            break;
          }
        }
      else
        S("inactive");
    });
  }, [q, b, r, ae, x, C, N, _, E]), XFe({
    disabled: r,
    handleId: C,
    resizeHandler: N,
    panelGroupElement: w
  }), yd(c, {
    ...d,
    children: e,
    className: t,
    id: a,
    onBlur: () => {
      U(!1), s?.();
    },
    onFocus: () => {
      U(!0), o?.();
    },
    ref: h,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...l
    },
    tabIndex: u,
    // CSS selectors
    "data-panel-group-direction": b,
    "data-panel-group-id": v,
    "data-resize-handle": "",
    "data-resize-handle-active": k === "drag" ? "pointer" : B ? "keyboard" : void 0,
    "data-resize-handle-state": k,
    "data-panel-resize-handle-enabled": !r,
    "data-panel-resize-handle-id": C
  });
}
pY.displayName = "PanelResizeHandle";
const ZFe = ({
  className: e,
  ...t
}) => /* @__PURE__ */ K(
  fY,
  {
    className: ja(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      e
    ),
    ...t
  }
), B9 = YK, JFe = ({
  withHandle: e,
  className: t,
  ...r
}) => /* @__PURE__ */ K(
  pY,
  {
    className: ja(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      t
    ),
    ...r,
    children: e && /* @__PURE__ */ K("div", { className: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border", children: /* @__PURE__ */ K(due, { className: "h-2.5 w-2.5" }) })
  }
), QFe = (e) => {
  const { children: t, active: r, content: n } = e, a = Or(() => {
    if (console.log(n), !!n)
      return /^\s*(<!DOCTYPE html>)?\s*<html[\s>]/i.test(n) ? "HTML_TOP" : /^\s*<([a-zA-Z]+)[\s>]/.test(n) ? "HTML_OTHER" : /^\s*#\s|^\s*[*_-]{1,3}\s|^\s*\d+\.\s|^\s*>/.test(n) ? "MARKDOWN" : "UNKNOWN";
  }, [n]);
  return r ? /* @__PURE__ */ K(ln, { children: /* @__PURE__ */ $t(ZFe, { direction: "horizontal", children: [
    /* @__PURE__ */ K(B9, { className: "p-4", children: t }),
    /* @__PURE__ */ K(JFe, { withHandle: !0, className: "bg-transparent" }),
    /* @__PURE__ */ K(B9, { className: "p-2", children: /* @__PURE__ */ K(zu, { className: "h-full w-full shadow", children: /* @__PURE__ */ K("div", { className: "relative h-full w-full", children: a === "HTML_TOP" || a === "HTML_OTHER" ? /* @__PURE__ */ K(
      wFe,
      {
        source: n || "",
        contentType: a
      }
    ) : a === "MARKDOWN" ? /* @__PURE__ */ K("div", { className: "p-4", children: /* @__PURE__ */ K(XR, { source: n || "" }) }) : /* @__PURE__ */ K("div", { className: "p-4", children: n }) }) }) })
  ] }) }) : /* @__PURE__ */ K(ln, { children: t });
}, e6e = kt.memo((e) => {
  const {
    postData: t,
    postDataUrl: r = (E) => `/cli/run-stream/${E}`,
    variables: n = {},
    height: a,
    layout: s = "chat",
    inputType: i = "default",
    layoutOrder: o = "default",
    historyOrder: l = "default",
    submitLabel: u = "Submit"
  } = e, {
    handleInputChange: c,
    handleSubmit: d,
    startNewThread: p,
    messages: f,
    content: h,
    isLoading: m,
    error: y,
    input: b,
    commingMessage: v
  } = lfe({
    variables: n,
    postDataUrl: r,
    postData: t,
    layout: s
  }), x = kt.useRef(null), _ = kt.useCallback(
    (E) => {
      E.metaKey && E.key === "Enter" && x.current?.click();
    },
    []
  );
  return /* @__PURE__ */ K(QFe, { active: s === "side-by-side", content: h, children: /* @__PURE__ */ $t(
    "div",
    {
      className: `flex h-full ${o === "default" ? "flex-col" : "flex-col-reverse"} w-full`,
      style: { height: a },
      children: [
        y && /* @__PURE__ */ K(kd, { title: "Error", variant: "error", className: "my-4", children: y.message }),
        /* @__PURE__ */ K(
          dce,
          {
            messages: f,
            commingMessage: v,
            layout: s,
            historyOrder: l,
            height: a,
            isLoading: m,
            onStartNewThread: p
          }
        ),
        /* @__PURE__ */ K(
          pce,
          {
            layout: s,
            inputType: i,
            inputValue: b,
            onIpuntChange: c,
            onKeydown: _,
            onSubmit: d,
            submitButtonRef: x,
            submitLabel: u
          }
        )
      ]
    }
  ) });
});
e6e.displayName = "LLM";
const t6e = uh({
  base: [
    // base
    "relative block w-full appearance-none rounded-md border px-2.5 py-2 shadow-sm outline-none transition sm:text-sm",
    // border color
    "border-gray-300 dark:border-gray-800",
    // text color
    "text-gray-900 dark:text-gray-50",
    // placeholder color
    "placeholder-gray-400 dark:placeholder-gray-500",
    // background color
    "bg-white dark:bg-gray-950",
    // disabled
    "disabled:border-gray-300 disabled:bg-gray-100 disabled:text-gray-400",
    "disabled:dark:border-gray-700 disabled:dark:bg-gray-800 disabled:dark:text-gray-500",
    // file
    [
      "file:-my-2 file:-ml-2.5 file:cursor-pointer file:rounded-l-[5px] file:rounded-r-none file:border-0 file:px-3 file:py-2 file:outline-none focus:outline-none disabled:pointer-events-none file:disabled:pointer-events-none",
      "file:border-solid file:border-gray-300 file:bg-gray-50 file:text-gray-500 file:hover:bg-gray-100 file:dark:border-gray-800 file:dark:bg-gray-950 file:hover:dark:bg-gray-900/20 file:disabled:dark:border-gray-700",
      "file:[border-inline-end-width:1px] file:[margin-inline-end:0.75rem]",
      "file:disabled:bg-gray-100 file:disabled:text-gray-500 file:disabled:dark:bg-gray-800"
    ],
    // focus
    ch,
    // invalid (optional)
    // "aria-[invalid=true]:dark:ring-red-400/20 aria-[invalid=true]:ring-2 aria-[invalid=true]:ring-red-200 aria-[invalid=true]:border-red-500 invalid:ring-2 invalid:ring-red-200 invalid:border-red-500"
    // remove search cancel button (optional)
    "[&::-webkit-search-cancel-button]:hidden [&::-webkit-search-decoration]:hidden"
  ],
  variants: {
    hasError: {
      true: Fb
    },
    // number input
    enableStepper: {
      false: "[appearance:textfield] [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none"
    }
  }
}), FD = kt.forwardRef(
  ({
    className: e,
    inputClassName: t,
    hasError: r,
    enableStepper: n = !0,
    type: a,
    onChange: s,
    ...i
  }, o) => {
    const [l, u] = kt.useState(a), [c, d] = kt.useState(i.defaultValue || ""), p = a === "password", f = a === "search", h = (m) => {
      const y = m.target.value;
      d(y), s && s(m);
    };
    return /* @__PURE__ */ $t("div", { className: gr("relative w-full", e), "tremor-id": "tremor-raw", children: [
      /* @__PURE__ */ K(
        "input",
        {
          ref: o,
          type: p ? l : a,
          className: gr(
            t6e({ hasError: r, enableStepper: n }),
            {
              "pl-8": f,
              "pr-10": p
            },
            t
          ),
          value: c,
          onChange: h,
          ...i
        }
      ),
      f && /* @__PURE__ */ K(
        "div",
        {
          className: gr(
            // base
            "pointer-events-none absolute bottom-0 left-2 flex h-full items-center justify-center",
            // text color
            "text-gray-400 dark:text-gray-600"
          ),
          children: /* @__PURE__ */ K(
            xue,
            {
              className: "size-[1.125rem] shrink-0",
              "aria-hidden": "true"
            }
          )
        }
      ),
      p && /* @__PURE__ */ K(
        "div",
        {
          className: gr(
            "absolute bottom-0 right-0 flex h-full items-center justify-center px-3"
          ),
          children: /* @__PURE__ */ $t(
            "button",
            {
              "aria-label": "Change password visibility",
              className: gr(
                // base
                "h-fit w-fit rounded-sm outline-none transition-all",
                // text
                "text-gray-400 dark:text-gray-600",
                // hover
                "hover:text-gray-500 hover:dark:text-gray-500",
                dh
              ),
              type: "button",
              onClick: () => {
                u(l === "password" ? "text" : "password");
              },
              children: [
                /* @__PURE__ */ K("span", { className: "sr-only", children: l === "password" ? "Show password" : "Hide password" }),
                l === "password" ? /* @__PURE__ */ K(uue, { "aria-hidden": "true", className: "size-5 shrink-0" }) : /* @__PURE__ */ K(oue, { "aria-hidden": "true", className: "size-5 shrink-0" })
              ]
            }
          )
        }
      )
    ] });
  }
);
FD.displayName = "Input";
const r6e = Mu((e, t) => {
  const { state: r, debounce: n } = e, [a, s] = Wn(r.value);
  return Qn(() => {
    const i = setTimeout(() => {
      r.update(a);
    }, n);
    return () => {
      clearTimeout(i);
    };
  }, [a, n, r]), /* @__PURE__ */ K(
    FD,
    {
      ref: t,
      value: a,
      onChange: (i) => s(i.target.value),
      ...e
    }
  );
}), Qze = Mu((e, t) => {
  const { state: r, debounce: n } = e;
  return r ? /* @__PURE__ */ K(
    r6e,
    {
      ref: t,
      ...e,
      state: r,
      debounce: n || 300
    }
  ) : /* @__PURE__ */ K(FD, { ref: t, ...e });
});
function n6e(e) {
  const t = D.useRef({ value: e, previous: e });
  return D.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var i6e = "VisuallyHidden", hY = D.forwardRef(
  (e, t) => /* @__PURE__ */ K(
    Wr.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
hY.displayName = i6e;
var a6e = [" ", "Enter", "ArrowUp", "ArrowDown"], s6e = [" ", "Enter"], Nh = "Select", [Iy, Ny, o6e] = qb(Nh), [$d, eqe] = ds(Nh, [
  o6e,
  Wl
]), Dy = Wl(), [l6e, Ql] = $d(Nh), [u6e, c6e] = $d(Nh), mY = (e) => {
  const {
    __scopeSelect: t,
    children: r,
    open: n,
    defaultOpen: a,
    onOpenChange: s,
    value: i,
    defaultValue: o,
    onValueChange: l,
    dir: u,
    name: c,
    autoComplete: d,
    disabled: p,
    required: f,
    form: h
  } = e, m = Dy(t), [y, b] = D.useState(null), [v, x] = D.useState(null), [_, E] = D.useState(!1), w = hh(u), [C = !1, k] = Bs({
    prop: n,
    defaultProp: a,
    onChange: s
  }), [S, B] = Bs({
    prop: i,
    defaultProp: o,
    onChange: l
  }), U = D.useRef(null), N = y ? h || !!y.closest("form") : !0, [O, I] = D.useState(/* @__PURE__ */ new Set()), q = Array.from(O).map((ae) => ae.props.value).join(";");
  return /* @__PURE__ */ K(gh, { ...m, children: /* @__PURE__ */ $t(
    l6e,
    {
      required: f,
      scope: t,
      trigger: y,
      onTriggerChange: b,
      valueNode: v,
      onValueNodeChange: x,
      valueNodeHasChildren: _,
      onValueNodeHasChildrenChange: E,
      contentId: us(),
      value: S,
      onValueChange: B,
      open: C,
      onOpenChange: k,
      dir: w,
      triggerPointerDownPosRef: U,
      disabled: p,
      children: [
        /* @__PURE__ */ K(Iy.Provider, { scope: t, children: /* @__PURE__ */ K(
          u6e,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: D.useCallback((ae) => {
              I((Q) => new Set(Q).add(ae));
            }, []),
            onNativeOptionRemove: D.useCallback((ae) => {
              I((Q) => {
                const ne = new Set(Q);
                return ne.delete(ae), ne;
              });
            }, []),
            children: r
          }
        ) }),
        N ? /* @__PURE__ */ $t(
          zY,
          {
            "aria-hidden": !0,
            required: f,
            tabIndex: -1,
            name: c,
            autoComplete: d,
            value: S,
            onChange: (ae) => B(ae.target.value),
            disabled: p,
            form: h,
            children: [
              S === void 0 ? /* @__PURE__ */ K("option", { value: "" }) : null,
              Array.from(O)
            ]
          },
          q
        ) : null
      ]
    }
  ) });
};
mY.displayName = Nh;
var gY = "SelectTrigger", bY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, disabled: n = !1, ...a } = e, s = Dy(r), i = Ql(gY, r), o = i.disabled || n, l = sn(t, i.onTriggerChange), u = Ny(r), c = D.useRef("touch"), [d, p, f] = qY((m) => {
      const y = u().filter((x) => !x.disabled), b = y.find((x) => x.value === i.value), v = jY(y, m, b);
      v !== void 0 && i.onValueChange(v.value);
    }), h = (m) => {
      o || (i.onOpenChange(!0), f()), m && (i.triggerPointerDownPosRef.current = {
        x: Math.round(m.pageX),
        y: Math.round(m.pageY)
      });
    };
    return /* @__PURE__ */ K(bh, { asChild: !0, ...s, children: /* @__PURE__ */ K(
      Wr.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": i.contentId,
        "aria-expanded": i.open,
        "aria-required": i.required,
        "aria-autocomplete": "none",
        dir: i.dir,
        "data-state": i.open ? "open" : "closed",
        disabled: o,
        "data-disabled": o ? "" : void 0,
        "data-placeholder": UY(i.value) ? "" : void 0,
        ...a,
        ref: l,
        onClick: nr(a.onClick, (m) => {
          m.currentTarget.focus(), c.current !== "mouse" && h(m);
        }),
        onPointerDown: nr(a.onPointerDown, (m) => {
          c.current = m.pointerType;
          const y = m.target;
          y.hasPointerCapture(m.pointerId) && y.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && m.pointerType === "mouse" && (h(m), m.preventDefault());
        }),
        onKeyDown: nr(a.onKeyDown, (m) => {
          const y = d.current !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && p(m.key), !(y && m.key === " ") && a6e.includes(m.key) && (h(), m.preventDefault());
        })
      }
    ) });
  }
);
bY.displayName = gY;
var yY = "SelectValue", vY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, className: n, style: a, children: s, placeholder: i = "", ...o } = e, l = Ql(yY, r), { onValueNodeHasChildrenChange: u } = l, c = s !== void 0, d = sn(t, l.onValueNodeChange);
    return Ti(() => {
      u(c);
    }, [u, c]), /* @__PURE__ */ K(
      Wr.span,
      {
        ...o,
        ref: d,
        style: { pointerEvents: "none" },
        children: UY(l.value) ? /* @__PURE__ */ K(ln, { children: i }) : s
      }
    );
  }
);
vY.displayName = yY;
var d6e = "SelectIcon", wY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, children: n, ...a } = e;
    return /* @__PURE__ */ K(Wr.span, { "aria-hidden": !0, ...a, ref: t, children: n || "▼" });
  }
);
wY.displayName = d6e;
var f6e = "SelectPortal", xY = (e) => /* @__PURE__ */ K(Xb, { asChild: !0, ...e });
xY.displayName = f6e;
var Iu = "SelectContent", EY = D.forwardRef(
  (e, t) => {
    const r = Ql(Iu, e.__scopeSelect), [n, a] = D.useState();
    if (Ti(() => {
      a(new DocumentFragment());
    }, []), !r.open) {
      const s = n;
      return s ? _b.createPortal(
        /* @__PURE__ */ K(SY, { scope: e.__scopeSelect, children: /* @__PURE__ */ K(Iy.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ K("div", { children: e.children }) }) }),
        s
      ) : null;
    }
    return /* @__PURE__ */ K(_Y, { ...e, ref: t });
  }
);
EY.displayName = Iu;
var Ts = 10, [SY, eu] = $d(Iu), p6e = "SelectContentImpl", _Y = D.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: r,
      position: n = "item-aligned",
      onCloseAutoFocus: a,
      onEscapeKeyDown: s,
      onPointerDownOutside: i,
      //
      // PopperContent props
      side: o,
      sideOffset: l,
      align: u,
      alignOffset: c,
      arrowPadding: d,
      collisionBoundary: p,
      collisionPadding: f,
      sticky: h,
      hideWhenDetached: m,
      avoidCollisions: y,
      //
      ...b
    } = e, v = Ql(Iu, r), [x, _] = D.useState(null), [E, w] = D.useState(null), C = sn(t, ($) => _($)), [k, S] = D.useState(null), [B, U] = D.useState(
      null
    ), N = Ny(r), [O, I] = D.useState(!1), q = D.useRef(!1);
    D.useEffect(() => {
      if (x) return cN(x);
    }, [x]), eN();
    const ae = D.useCallback(
      ($) => {
        const [F, ...ge] = N().map((re) => re.ref.current), [ce] = ge.slice(-1), ie = document.activeElement;
        for (const re of $)
          if (re === ie || (re?.scrollIntoView({ block: "nearest" }), re === F && E && (E.scrollTop = 0), re === ce && E && (E.scrollTop = E.scrollHeight), re?.focus(), document.activeElement !== ie)) return;
      },
      [N, E]
    ), Q = D.useCallback(
      () => ae([k, x]),
      [ae, k, x]
    );
    D.useEffect(() => {
      O && Q();
    }, [O, Q]);
    const { onOpenChange: ne, triggerPointerDownPosRef: le } = v;
    D.useEffect(() => {
      if (x) {
        let $ = { x: 0, y: 0 };
        const F = (ce) => {
          $ = {
            x: Math.abs(Math.round(ce.pageX) - (le.current?.x ?? 0)),
            y: Math.abs(Math.round(ce.pageY) - (le.current?.y ?? 0))
          };
        }, ge = (ce) => {
          $.x <= 10 && $.y <= 10 ? ce.preventDefault() : x.contains(ce.target) || ne(!1), document.removeEventListener("pointermove", F), le.current = null;
        };
        return le.current !== null && (document.addEventListener("pointermove", F), document.addEventListener("pointerup", ge, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", F), document.removeEventListener("pointerup", ge, { capture: !0 });
        };
      }
    }, [x, ne, le]), D.useEffect(() => {
      const $ = () => ne(!1);
      return window.addEventListener("blur", $), window.addEventListener("resize", $), () => {
        window.removeEventListener("blur", $), window.removeEventListener("resize", $);
      };
    }, [ne]);
    const [W, X] = qY(($) => {
      const F = N().filter((ie) => !ie.disabled), ge = F.find((ie) => ie.ref.current === document.activeElement), ce = jY(F, $, ge);
      ce && setTimeout(() => ce.ref.current.focus());
    }), G = D.useCallback(
      ($, F, ge) => {
        const ce = !q.current && !ge;
        (v.value !== void 0 && v.value === F || ce) && (S($), ce && (q.current = !0));
      },
      [v.value]
    ), P = D.useCallback(() => x?.focus(), [x]), he = D.useCallback(
      ($, F, ge) => {
        const ce = !q.current && !ge;
        (v.value !== void 0 && v.value === F || ce) && U($);
      },
      [v.value]
    ), ye = n === "popper" ? JR : kY, pe = ye === JR ? {
      side: o,
      sideOffset: l,
      align: u,
      alignOffset: c,
      arrowPadding: d,
      collisionBoundary: p,
      collisionPadding: f,
      sticky: h,
      hideWhenDetached: m,
      avoidCollisions: y
    } : {};
    return /* @__PURE__ */ K(
      SY,
      {
        scope: r,
        content: x,
        viewport: E,
        onViewportChange: w,
        itemRefCallback: G,
        selectedItem: k,
        onItemLeave: P,
        itemTextRefCallback: he,
        focusSelectedItem: Q,
        selectedItemText: B,
        position: n,
        isPositioned: O,
        searchRef: W,
        children: /* @__PURE__ */ K(Qb, { as: zo, allowPinchZoom: !0, children: /* @__PURE__ */ K(
          Hb,
          {
            asChild: !0,
            trapped: v.open,
            onMountAutoFocus: ($) => {
              $.preventDefault();
            },
            onUnmountAutoFocus: nr(a, ($) => {
              v.trigger?.focus({ preventScroll: !0 }), $.preventDefault();
            }),
            children: /* @__PURE__ */ K(
              jb,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: s,
                onPointerDownOutside: i,
                onFocusOutside: ($) => $.preventDefault(),
                onDismiss: () => v.onOpenChange(!1),
                children: /* @__PURE__ */ K(
                  ye,
                  {
                    role: "listbox",
                    id: v.contentId,
                    "data-state": v.open ? "open" : "closed",
                    dir: v.dir,
                    onContextMenu: ($) => $.preventDefault(),
                    ...b,
                    ...pe,
                    onPlaced: () => I(!0),
                    ref: C,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...b.style
                    },
                    onKeyDown: nr(b.onKeyDown, ($) => {
                      const F = $.ctrlKey || $.altKey || $.metaKey;
                      if ($.key === "Tab" && $.preventDefault(), !F && $.key.length === 1 && X($.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes($.key)) {
                        let ce = N().filter((ie) => !ie.disabled).map((ie) => ie.ref.current);
                        if (["ArrowUp", "End"].includes($.key) && (ce = ce.slice().reverse()), ["ArrowUp", "ArrowDown"].includes($.key)) {
                          const ie = $.target, re = ce.indexOf(ie);
                          ce = ce.slice(re + 1);
                        }
                        setTimeout(() => ae(ce)), $.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
_Y.displayName = p6e;
var h6e = "SelectItemAlignedPosition", kY = D.forwardRef((e, t) => {
  const { __scopeSelect: r, onPlaced: n, ...a } = e, s = Ql(Iu, r), i = eu(Iu, r), [o, l] = D.useState(null), [u, c] = D.useState(null), d = sn(t, (C) => c(C)), p = Ny(r), f = D.useRef(!1), h = D.useRef(!0), { viewport: m, selectedItem: y, selectedItemText: b, focusSelectedItem: v } = i, x = D.useCallback(() => {
    if (s.trigger && s.valueNode && o && u && m && y && b) {
      const C = s.trigger.getBoundingClientRect(), k = u.getBoundingClientRect(), S = s.valueNode.getBoundingClientRect(), B = b.getBoundingClientRect();
      if (s.dir !== "rtl") {
        const ie = B.left - k.left, re = S.left - ie, Te = C.left - re, V = C.width + Te, Pe = Math.max(V, k.width), z = window.innerWidth - Ts, A = XT(re, [
          Ts,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Ts, z - Pe)
        ]);
        o.style.minWidth = V + "px", o.style.left = A + "px";
      } else {
        const ie = k.right - B.right, re = window.innerWidth - S.right - ie, Te = window.innerWidth - C.right - re, V = C.width + Te, Pe = Math.max(V, k.width), z = window.innerWidth - Ts, A = XT(re, [
          Ts,
          Math.max(Ts, z - Pe)
        ]);
        o.style.minWidth = V + "px", o.style.right = A + "px";
      }
      const U = p(), N = window.innerHeight - Ts * 2, O = m.scrollHeight, I = window.getComputedStyle(u), q = parseInt(I.borderTopWidth, 10), ae = parseInt(I.paddingTop, 10), Q = parseInt(I.borderBottomWidth, 10), ne = parseInt(I.paddingBottom, 10), le = q + ae + O + ne + Q, W = Math.min(y.offsetHeight * 5, le), X = window.getComputedStyle(m), G = parseInt(X.paddingTop, 10), P = parseInt(X.paddingBottom, 10), he = C.top + C.height / 2 - Ts, ye = N - he, pe = y.offsetHeight / 2, $ = y.offsetTop + pe, F = q + ae + $, ge = le - F;
      if (F <= he) {
        const ie = U.length > 0 && y === U[U.length - 1].ref.current;
        o.style.bottom = "0px";
        const re = u.clientHeight - m.offsetTop - m.offsetHeight, Te = Math.max(
          ye,
          pe + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (ie ? P : 0) + re + Q
        ), V = F + Te;
        o.style.height = V + "px";
      } else {
        const ie = U.length > 0 && y === U[0].ref.current;
        o.style.top = "0px";
        const Te = Math.max(
          he,
          q + m.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (ie ? G : 0) + pe
        ) + ge;
        o.style.height = Te + "px", m.scrollTop = F - he + m.offsetTop;
      }
      o.style.margin = `${Ts}px 0`, o.style.minHeight = W + "px", o.style.maxHeight = N + "px", n?.(), requestAnimationFrame(() => f.current = !0);
    }
  }, [
    p,
    s.trigger,
    s.valueNode,
    o,
    u,
    m,
    y,
    b,
    s.dir,
    n
  ]);
  Ti(() => x(), [x]);
  const [_, E] = D.useState();
  Ti(() => {
    u && E(window.getComputedStyle(u).zIndex);
  }, [u]);
  const w = D.useCallback(
    (C) => {
      C && h.current === !0 && (x(), v?.(), h.current = !1);
    },
    [x, v]
  );
  return /* @__PURE__ */ K(
    g6e,
    {
      scope: r,
      contentWrapper: o,
      shouldExpandOnScrollRef: f,
      onScrollButtonChange: w,
      children: /* @__PURE__ */ K(
        "div",
        {
          ref: l,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: _
          },
          children: /* @__PURE__ */ K(
            Wr.div,
            {
              ...a,
              ref: d,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...a.style
              }
            }
          )
        }
      )
    }
  );
});
kY.displayName = h6e;
var m6e = "SelectPopperPosition", JR = D.forwardRef((e, t) => {
  const {
    __scopeSelect: r,
    align: n = "start",
    collisionPadding: a = Ts,
    ...s
  } = e, i = Dy(r);
  return /* @__PURE__ */ K(
    Kb,
    {
      ...i,
      ...s,
      ref: t,
      align: n,
      collisionPadding: a,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
JR.displayName = m6e;
var [g6e, $D] = $d(Iu, {}), QR = "SelectViewport", CY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, nonce: n, ...a } = e, s = eu(QR, r), i = $D(QR, r), o = sn(t, s.onViewportChange), l = D.useRef(0);
    return /* @__PURE__ */ $t(ln, { children: [
      /* @__PURE__ */ K(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: n
        }
      ),
      /* @__PURE__ */ K(Iy.Slot, { scope: r, children: /* @__PURE__ */ K(
        Wr.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...a,
          ref: o,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...a.style
          },
          onScroll: nr(a.onScroll, (u) => {
            const c = u.currentTarget, { contentWrapper: d, shouldExpandOnScrollRef: p } = i;
            if (p?.current && d) {
              const f = Math.abs(l.current - c.scrollTop);
              if (f > 0) {
                const h = window.innerHeight - Ts * 2, m = parseFloat(d.style.minHeight), y = parseFloat(d.style.height), b = Math.max(m, y);
                if (b < h) {
                  const v = b + f, x = Math.min(h, v), _ = v - x;
                  d.style.height = x + "px", d.style.bottom === "0px" && (c.scrollTop = _ > 0 ? _ : 0, d.style.justifyContent = "flex-end");
                }
              }
            }
            l.current = c.scrollTop;
          })
        }
      ) })
    ] });
  }
);
CY.displayName = QR;
var AY = "SelectGroup", [b6e, y6e] = $d(AY), TY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, ...n } = e, a = us();
    return /* @__PURE__ */ K(b6e, { scope: r, id: a, children: /* @__PURE__ */ K(Wr.div, { role: "group", "aria-labelledby": a, ...n, ref: t }) });
  }
);
TY.displayName = AY;
var RY = "SelectLabel", IY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, ...n } = e, a = y6e(RY, r);
    return /* @__PURE__ */ K(Wr.div, { id: a.id, ...n, ref: t });
  }
);
IY.displayName = RY;
var fb = "SelectItem", [v6e, NY] = $d(fb), DY = D.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: r,
      value: n,
      disabled: a = !1,
      textValue: s,
      ...i
    } = e, o = Ql(fb, r), l = eu(fb, r), u = o.value === n, [c, d] = D.useState(s ?? ""), [p, f] = D.useState(!1), h = sn(
      t,
      (v) => l.itemRefCallback?.(v, n, a)
    ), m = us(), y = D.useRef("touch"), b = () => {
      a || (o.onValueChange(n), o.onOpenChange(!1));
    };
    if (n === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ K(
      v6e,
      {
        scope: r,
        value: n,
        disabled: a,
        textId: m,
        isSelected: u,
        onItemTextChange: D.useCallback((v) => {
          d((x) => x || (v?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ K(
          Iy.ItemSlot,
          {
            scope: r,
            value: n,
            disabled: a,
            textValue: c,
            children: /* @__PURE__ */ K(
              Wr.div,
              {
                role: "option",
                "aria-labelledby": m,
                "data-highlighted": p ? "" : void 0,
                "aria-selected": u && p,
                "data-state": u ? "checked" : "unchecked",
                "aria-disabled": a || void 0,
                "data-disabled": a ? "" : void 0,
                tabIndex: a ? void 0 : -1,
                ...i,
                ref: h,
                onFocus: nr(i.onFocus, () => f(!0)),
                onBlur: nr(i.onBlur, () => f(!1)),
                onClick: nr(i.onClick, () => {
                  y.current !== "mouse" && b();
                }),
                onPointerUp: nr(i.onPointerUp, () => {
                  y.current === "mouse" && b();
                }),
                onPointerDown: nr(i.onPointerDown, (v) => {
                  y.current = v.pointerType;
                }),
                onPointerMove: nr(i.onPointerMove, (v) => {
                  y.current = v.pointerType, a ? l.onItemLeave?.() : y.current === "mouse" && v.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: nr(i.onPointerLeave, (v) => {
                  v.currentTarget === document.activeElement && l.onItemLeave?.();
                }),
                onKeyDown: nr(i.onKeyDown, (v) => {
                  l.searchRef?.current !== "" && v.key === " " || (s6e.includes(v.key) && b(), v.key === " " && v.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
DY.displayName = fb;
var jf = "SelectItemText", OY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, className: n, style: a, ...s } = e, i = Ql(jf, r), o = eu(jf, r), l = NY(jf, r), u = c6e(jf, r), [c, d] = D.useState(null), p = sn(
      t,
      (b) => d(b),
      l.onItemTextChange,
      (b) => o.itemTextRefCallback?.(b, l.value, l.disabled)
    ), f = c?.textContent, h = D.useMemo(
      () => /* @__PURE__ */ K("option", { value: l.value, disabled: l.disabled, children: f }, l.value),
      [l.disabled, l.value, f]
    ), { onNativeOptionAdd: m, onNativeOptionRemove: y } = u;
    return Ti(() => (m(h), () => y(h)), [m, y, h]), /* @__PURE__ */ $t(ln, { children: [
      /* @__PURE__ */ K(Wr.span, { id: l.textId, ...s, ref: p }),
      l.isSelected && i.valueNode && !i.valueNodeHasChildren ? _b.createPortal(s.children, i.valueNode) : null
    ] });
  }
);
OY.displayName = jf;
var PY = "SelectItemIndicator", LY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, ...n } = e;
    return NY(PY, r).isSelected ? /* @__PURE__ */ K(Wr.span, { "aria-hidden": !0, ...n, ref: t }) : null;
  }
);
LY.displayName = PY;
var eI = "SelectScrollUpButton", MY = D.forwardRef((e, t) => {
  const r = eu(eI, e.__scopeSelect), n = $D(eI, e.__scopeSelect), [a, s] = D.useState(!1), i = sn(t, n.onScrollButtonChange);
  return Ti(() => {
    if (r.viewport && r.isPositioned) {
      let o = function() {
        const u = l.scrollTop > 0;
        s(u);
      };
      const l = r.viewport;
      return o(), l.addEventListener("scroll", o), () => l.removeEventListener("scroll", o);
    }
  }, [r.viewport, r.isPositioned]), a ? /* @__PURE__ */ K(
    $Y,
    {
      ...e,
      ref: i,
      onAutoScroll: () => {
        const { viewport: o, selectedItem: l } = r;
        o && l && (o.scrollTop = o.scrollTop - l.offsetHeight);
      }
    }
  ) : null;
});
MY.displayName = eI;
var tI = "SelectScrollDownButton", FY = D.forwardRef((e, t) => {
  const r = eu(tI, e.__scopeSelect), n = $D(tI, e.__scopeSelect), [a, s] = D.useState(!1), i = sn(t, n.onScrollButtonChange);
  return Ti(() => {
    if (r.viewport && r.isPositioned) {
      let o = function() {
        const u = l.scrollHeight - l.clientHeight, c = Math.ceil(l.scrollTop) < u;
        s(c);
      };
      const l = r.viewport;
      return o(), l.addEventListener("scroll", o), () => l.removeEventListener("scroll", o);
    }
  }, [r.viewport, r.isPositioned]), a ? /* @__PURE__ */ K(
    $Y,
    {
      ...e,
      ref: i,
      onAutoScroll: () => {
        const { viewport: o, selectedItem: l } = r;
        o && l && (o.scrollTop = o.scrollTop + l.offsetHeight);
      }
    }
  ) : null;
});
FY.displayName = tI;
var $Y = D.forwardRef((e, t) => {
  const { __scopeSelect: r, onAutoScroll: n, ...a } = e, s = eu("SelectScrollButton", r), i = D.useRef(null), o = Ny(r), l = D.useCallback(() => {
    i.current !== null && (window.clearInterval(i.current), i.current = null);
  }, []);
  return D.useEffect(() => () => l(), [l]), Ti(() => {
    o().find((c) => c.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [o]), /* @__PURE__ */ K(
    Wr.div,
    {
      "aria-hidden": !0,
      ...a,
      ref: t,
      style: { flexShrink: 0, ...a.style },
      onPointerDown: nr(a.onPointerDown, () => {
        i.current === null && (i.current = window.setInterval(n, 50));
      }),
      onPointerMove: nr(a.onPointerMove, () => {
        s.onItemLeave?.(), i.current === null && (i.current = window.setInterval(n, 50));
      }),
      onPointerLeave: nr(a.onPointerLeave, () => {
        l();
      })
    }
  );
}), w6e = "SelectSeparator", BY = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, ...n } = e;
    return /* @__PURE__ */ K(Wr.div, { "aria-hidden": !0, ...n, ref: t });
  }
);
BY.displayName = w6e;
var rI = "SelectArrow", x6e = D.forwardRef(
  (e, t) => {
    const { __scopeSelect: r, ...n } = e, a = Dy(r), s = Ql(rI, r), i = eu(rI, r);
    return s.open && i.position === "popper" ? /* @__PURE__ */ K(Yb, { ...a, ...n, ref: t }) : null;
  }
);
x6e.displayName = rI;
function UY(e) {
  return e === "" || e === void 0;
}
var zY = D.forwardRef(
  (e, t) => {
    const { value: r, ...n } = e, a = D.useRef(null), s = sn(t, a), i = n6e(r);
    return D.useEffect(() => {
      const o = a.current, l = window.HTMLSelectElement.prototype, c = Object.getOwnPropertyDescriptor(
        l,
        "value"
      ).set;
      if (i !== r && c) {
        const d = new Event("change", { bubbles: !0 });
        c.call(o, r), o.dispatchEvent(d);
      }
    }, [i, r]), /* @__PURE__ */ K(hY, { asChild: !0, children: /* @__PURE__ */ K("select", { ...n, ref: s, defaultValue: r }) });
  }
);
zY.displayName = "BubbleSelect";
function qY(e) {
  const t = si(e), r = D.useRef(""), n = D.useRef(0), a = D.useCallback(
    (i) => {
      const o = r.current + i;
      t(o), function l(u) {
        r.current = u, window.clearTimeout(n.current), u !== "" && (n.current = window.setTimeout(() => l(""), 1e3));
      }(o);
    },
    [t]
  ), s = D.useCallback(() => {
    r.current = "", window.clearTimeout(n.current);
  }, []);
  return D.useEffect(() => () => window.clearTimeout(n.current), []), [r, a, s];
}
function jY(e, t, r) {
  const a = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, s = r ? e.indexOf(r) : -1;
  let i = E6e(e, Math.max(s, 0));
  a.length === 1 && (i = i.filter((u) => u !== r));
  const l = i.find(
    (u) => u.textValue.toLowerCase().startsWith(a.toLowerCase())
  );
  return l !== r ? l : void 0;
}
function E6e(e, t) {
  return e.map((r, n) => e[(t + n) % e.length]);
}
var S6e = mY, _6e = bY, k6e = vY, C6e = wY, A6e = xY, T6e = EY, R6e = CY, I6e = TY, N6e = IY, D6e = DY, O6e = OY, P6e = LY, HY = MY, VY = FY, L6e = BY;
const BD = S6e;
BD.displayName = "Select";
const GY = I6e;
GY.displayName = "SelectGroup";
const UD = k6e;
UD.displayName = "SelectValue";
const M6e = [
  gr(
    // base
    "group/trigger flex w-full select-none items-center justify-between gap-2 truncate rounded-md border px-3 py-2 shadow-sm outline-none transition sm:text-sm",
    // border color
    "border-gray-300 dark:border-gray-800",
    // text color
    "text-gray-900 dark:text-gray-50",
    // placeholder
    "data-[placeholder]:text-gray-500 data-[placeholder]:dark:text-gray-500",
    // background color
    "bg-white dark:bg-gray-950",
    // hover
    "hover:bg-gray-50 hover:dark:bg-gray-950/50",
    // disabled
    "data-[disabled]:bg-gray-100 data-[disabled]:text-gray-400",
    "data-[disabled]:dark:border-gray-700 data-[disabled]:dark:bg-gray-800 data-[disabled]:dark:text-gray-500",
    ch
    // invalid (optional)
    // "aria-[invalid=true]:dark:ring-red-400/20 aria-[invalid=true]:ring-2 aria-[invalid=true]:ring-red-200 aria-[invalid=true]:border-red-500 invalid:ring-2 invalid:ring-red-200 invalid:border-red-500"
  )
], zD = kt.forwardRef(({ className: e, hasError: t, children: r, ...n }, a) => /* @__PURE__ */ $t(
  _6e,
  {
    ref: a,
    className: gr(
      M6e,
      t ? Fb : "",
      e
    ),
    "tremor-id": "tremor-raw",
    ...n,
    children: [
      /* @__PURE__ */ K("span", { className: "truncate", children: r }),
      /* @__PURE__ */ K(C6e, { asChild: !0, children: /* @__PURE__ */ K(
        iue,
        {
          className: gr(
            // base
            "size-4 shrink-0",
            // text color
            "text-gray-400 dark:text-gray-600",
            // disabled
            "group-data-[disabled]/trigger:text-gray-300 group-data-[disabled]/trigger:dark:text-gray-600"
          )
        }
      ) })
    ]
  }
));
zD.displayName = "SelectTrigger";
const WY = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  HY,
  {
    ref: r,
    className: gr(
      "flex cursor-default items-center justify-center py-1",
      e
    ),
    ...t,
    children: /* @__PURE__ */ K(Jle, { className: "size-3 shrink-0", "aria-hidden": "true" })
  }
));
WY.displayName = HY.displayName;
const KY = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  VY,
  {
    ref: r,
    className: gr(
      "flex cursor-default items-center justify-center py-1",
      e
    ),
    ...t,
    children: /* @__PURE__ */ K(eq, { className: "size-3 shrink-0", "aria-hidden": "true" })
  }
));
KY.displayName = VY.displayName;
const qD = kt.forwardRef(
  ({
    className: e,
    position: t = "popper",
    children: r,
    sideOffset: n = 8,
    collisionPadding: a = 10,
    ...s
  }, i) => /* @__PURE__ */ K(A6e, { children: /* @__PURE__ */ $t(
    T6e,
    {
      ref: i,
      className: gr(
        // base
        "relative z-50 overflow-hidden rounded-md border shadow-xl shadow-black/[2.5%]",
        // widths
        "min-w-[calc(var(--radix-select-trigger-width)-2px)] max-w-[95vw]",
        // heights
        "max-h-[--radix-select-content-available-height]",
        // background color
        "bg-white dark:bg-gray-950",
        // text color
        "text-gray-900 dark:text-gray-50",
        // border color
        "border-gray-200 dark:border-gray-800",
        // transition
        "will-change-[transform,opacity]",
        // "data-[state=open]:animate-slideDownAndFade",
        "data-[state=closed]:animate-hide",
        "data-[side=bottom]:animate-slideDownAndFade data-[side=left]:animate-slideLeftAndFade data-[side=right]:animate-slideRightAndFade data-[side=top]:animate-slideUpAndFade",
        e
      ),
      sideOffset: n,
      position: t,
      collisionPadding: a,
      ...s,
      children: [
        /* @__PURE__ */ K(WY, {}),
        /* @__PURE__ */ K(
          R6e,
          {
            className: gr(
              "p-1",
              t === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[calc(var(--radix-select-trigger-width))]"
            ),
            children: r
          }
        ),
        /* @__PURE__ */ K(KY, {})
      ]
    }
  ) })
);
qD.displayName = "SelectContent";
const YY = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  N6e,
  {
    ref: r,
    className: gr(
      // base
      "px-3 py-2 text-xs font-medium tracking-wide",
      // text color
      "text-gray-500 dark:text-gray-500",
      e
    ),
    ...t
  }
));
YY.displayName = "SelectGroupLabel";
const Oy = kt.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ $t(
  D6e,
  {
    ref: n,
    className: gr(
      // base
      "grid cursor-pointer grid-cols-[1fr_20px] gap-x-2 rounded px-3 py-2 outline-none transition-colors data-[state=checked]:font-semibold sm:text-sm",
      // text color
      "text-gray-900 dark:text-gray-50",
      // disabled
      "data-[disabled]:pointer-events-none data-[disabled]:text-gray-400 data-[disabled]:hover:bg-none dark:data-[disabled]:text-gray-600",
      // focus
      "focus-visible:bg-gray-100 focus-visible:dark:bg-gray-900",
      // hover
      "hover:bg-gray-100 hover:dark:bg-gray-900",
      e
    ),
    ...r,
    children: [
      /* @__PURE__ */ K(O6e, { className: "flex-1 truncate", children: t }),
      /* @__PURE__ */ K(P6e, { children: /* @__PURE__ */ K(
        Qz,
        {
          className: "size-5 shrink-0 text-gray-800 dark:text-gray-200",
          "aria-hidden": "true"
        }
      ) })
    ]
  }
));
Oy.displayName = "SelectItem";
const XY = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  L6e,
  {
    ref: r,
    className: gr(
      // base
      "-mx-1 my-1 h-px",
      // background color
      "bg-gray-300 dark:bg-gray-700",
      e
    ),
    ...t
  }
));
XY.displayName = "SelectSeparator";
const tqe = Mu((e) => {
  const { state: t } = e;
  return t ? /* @__PURE__ */ K(F6e, { ...e, state: t }) : /* @__PURE__ */ $t(BD, { ...e, children: [
    /* @__PURE__ */ K(zD, { children: /* @__PURE__ */ K(UD, {}) }),
    /* @__PURE__ */ K(qD, { children: e.children })
  ] });
}), F6e = Mu((e) => {
  const { state: t, children: r, ...n } = e;
  return /* @__PURE__ */ $t(
    BD,
    {
      ...n,
      value: t.value,
      onValueChange: (a) => {
        t.update(a);
      },
      children: [
        /* @__PURE__ */ K(zD, { children: /* @__PURE__ */ K(UD, {}) }),
        /* @__PURE__ */ K(qD, { children: r })
      ]
    }
  );
}), rqe = GY, nqe = YY, iqe = Oy, aqe = XY, sqe = (e) => {
  const {
    items: t,
    alias: r,
    loadData: n,
    valueKey: a = "value",
    labelKey: s = "label"
  } = e;
  return r || n ? /* @__PURE__ */ K($6e, { ...e }) : /* @__PURE__ */ K(ln, { children: t?.map((i, o) => /* @__PURE__ */ K(Oy, { value: String(i[a]), children: String(i[s]) }, o)) });
}, $6e = (e) => {
  const {
    alias: t,
    loadData: r,
    loadDataUrl: n = (u) => `${window.location.protocol}//${window.location.host}/cli/run/${u}/json`,
    variables: a = {},
    valueKey: s = "value",
    labelKey: i = "label"
  } = e, o = fh({ loadData: r, alias: t }), { items: l } = Ab({
    loadData: o,
    variables: a,
    loadDataUrl: n
  });
  return /* @__PURE__ */ K(ln, { children: l?.map((u, c) => /* @__PURE__ */ K(Oy, { value: String(u[s]), children: String(u[i]) }, c)) });
};
function iT(e, t) {
  return e - t * Math.floor(e / t);
}
const ZY = 1721426;
function Ym(e, t, r, n) {
  t = jD(e, t);
  let a = t - 1, s = -2;
  return r <= 2 ? s = 0 : bg(t) && (s = -1), ZY - 1 + 365 * a + Math.floor(a / 4) - Math.floor(a / 100) + Math.floor(a / 400) + Math.floor((367 * r - 362) / 12 + s + n);
}
function bg(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function jD(e, t) {
  return e === "BC" ? 1 - t : t;
}
function B6e(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const U6e = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class Hl {
  fromJulianDay(t) {
    let r = t, n = r - ZY, a = Math.floor(n / 146097), s = iT(n, 146097), i = Math.floor(s / 36524), o = iT(s, 36524), l = Math.floor(o / 1461), u = iT(o, 1461), c = Math.floor(u / 365), d = a * 400 + i * 100 + l * 4 + c + (i !== 4 && c !== 4 ? 1 : 0), [p, f] = B6e(d), h = r - Ym(p, f, 1, 1), m = 2;
    r < Ym(p, f, 3, 1) ? m = 0 : bg(f) && (m = 1);
    let y = Math.floor(((h + m) * 12 + 373) / 367), b = r - Ym(p, f, y, 1) + 1;
    return new wd(p, f, y, b);
  }
  toJulianDay(t) {
    return Ym(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return U6e[bg(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return bg(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
function JY(e) {
  return $o(Date.now(), e);
}
function z6e(e) {
  return iX(JY(e));
}
function QY(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function eX(e, t) {
  return U9(e) - U9(t);
}
function U9(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let aT = null;
function Py() {
  return aT == null && (aT = new Intl.DateTimeFormat().resolvedOptions().timeZone), aT;
}
function q6e(e) {
  return e.calendar.getMinimumMonthInYear ? e.calendar.getMinimumMonthInYear(e) : 1;
}
function j6e(e) {
  return e.calendar.getMinimumDayInMonth ? e.calendar.getMinimumDayInMonth(e) : 1;
}
function vd(e) {
  e = la(e, new Hl());
  let t = jD(e.era, e.year);
  return tX(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function tX(e, t, r, n, a, s, i) {
  let o = /* @__PURE__ */ new Date();
  return o.setUTCHours(n, a, s, i), o.setUTCFullYear(e, t - 1, r), o.getTime();
}
function nI(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === Py()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: a, hour: s, minute: i, second: o } = rX(e, t);
  return tX(r, n, a, s, i, o, 0) - Math.floor(e / 1e3) * 1e3;
}
const z9 = /* @__PURE__ */ new Map();
function rX(e, t) {
  let r = z9.get(t);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), z9.set(t, r));
  let n = r.formatToParts(new Date(e)), a = {};
  for (let s of n) s.type !== "literal" && (a[s.type] = s.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: a.era === "BC" || a.era === "B" ? -a.year + 1 : +a.year,
    month: +a.month,
    day: +a.day,
    hour: a.hour === "24" ? 0 : +a.hour,
    minute: +a.minute,
    second: +a.second
  };
}
const q9 = 864e5;
function H6e(e, t, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((s) => V6e(e, t, s));
}
function V6e(e, t, r) {
  let n = rX(r, t);
  return e.year === n.year && e.month === n.month && e.day === n.day && e.hour === n.hour && e.minute === n.minute && e.second === n.second;
}
function Po(e, t, r = "compatible") {
  let n = Vl(e);
  if (t === "UTC") return vd(n);
  if (t === Py() && r === "compatible") {
    n = la(n, new Hl());
    let l = /* @__PURE__ */ new Date(), u = jD(n.era, n.year);
    return l.setFullYear(u, n.month - 1, n.day), l.setHours(n.hour, n.minute, n.second, n.millisecond), l.getTime();
  }
  let a = vd(n), s = nI(a - q9, t), i = nI(a + q9, t), o = H6e(n, t, a - s, a - i);
  if (o.length === 1) return o[0];
  if (o.length > 1) switch (r) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return o[0];
    case "later":
      return o[o.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(a - s, a - i);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(a - s, a - i);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function nX(e, t, r = "compatible") {
  return new Date(Po(e, t, r));
}
function $o(e, t) {
  let r = nI(e, t), n = new Date(e + r), a = n.getUTCFullYear(), s = n.getUTCMonth() + 1, i = n.getUTCDate(), o = n.getUTCHours(), l = n.getUTCMinutes(), u = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new Zp(a < 1 ? "BC" : "AD", a < 1 ? -a + 1 : a, s, i, t, r, o, l, u, c);
}
function iX(e) {
  return new wd(e.calendar, e.era, e.year, e.month, e.day);
}
function Vl(e, t) {
  let r = 0, n = 0, a = 0, s = 0;
  if ("timeZone" in e) ({ hour: r, minute: n, second: a, millisecond: s } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: r, minute: n, second: a, millisecond: s } = t), new pb(e.calendar, e.era, e.year, e.month, e.day, r, n, a, s);
}
function j9(e) {
  return new Tn(e.hour, e.minute, e.second, e.millisecond);
}
function la(e, t) {
  if (e.calendar.identifier === t.identifier) return e;
  let r = t.fromJulianDay(e.calendar.toJulianDay(e)), n = e.copy();
  return n.calendar = t, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, Nu(n), n;
}
function aX(e, t, r) {
  if (e instanceof Zp)
    return e.timeZone === t ? e : W6e(e, t);
  let n = Po(e, t, r);
  return $o(n, t);
}
function G6e(e) {
  let t = vd(e) - e.offset;
  return new Date(t);
}
function W6e(e, t) {
  let r = vd(e) - e.offset;
  return la($o(r, t), e.calendar);
}
const kf = 36e5;
function Ly(e, t) {
  let r = e.copy(), n = "hour" in r ? uX(r, t) : 0;
  iI(r, t.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e), r.month += t.months || 0, aI(r), sX(r), r.day += (t.weeks || 0) * 7, r.day += t.days || 0, r.day += n, K6e(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let a = r.calendar.getYearsInEra(r);
  if (r.year > a) {
    var s, i;
    let l = (s = (i = r.calendar).isInverseEra) === null || s === void 0 ? void 0 : s.call(i, r);
    r.year = a, r.month = l ? 1 : r.calendar.getMonthsInYear(r), r.day = l ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let o = r.calendar.getMonthsInYear(r);
  return r.month > o && (r.month = o, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function iI(e, t) {
  var r, n;
  !((r = (n = e.calendar).isInverseEra) === null || r === void 0) && r.call(n, e) && (t = -t), e.year += t;
}
function aI(e) {
  for (; e.month < 1; )
    iI(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, iI(e, 1);
}
function K6e(e) {
  for (; e.day < 1; )
    e.month--, aI(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, aI(e);
}
function sX(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function Nu(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), sX(e);
}
function HD(e) {
  let t = {};
  for (let r in e) typeof e[r] == "number" && (t[r] = -e[r]);
  return t;
}
function oX(e, t) {
  return Ly(e, HD(t));
}
function VD(e, t) {
  let r = e.copy();
  return t.era != null && (r.era = t.era), t.year != null && (r.year = t.year), t.month != null && (r.month = t.month), t.day != null && (r.day = t.day), Nu(r), r;
}
function Xp(e, t) {
  let r = e.copy();
  return t.hour != null && (r.hour = t.hour), t.minute != null && (r.minute = t.minute), t.second != null && (r.second = t.second), t.millisecond != null && (r.millisecond = t.millisecond), lX(r), r;
}
function Y6e(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = Xm(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = Xm(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = Xm(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = Xm(e.hour, 24), t;
}
function lX(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function Xm(e, t) {
  let r = e % t;
  return r < 0 && (r += t), r;
}
function uX(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, Y6e(e);
}
function cX(e, t) {
  let r = e.copy();
  return uX(r, t), r;
}
function X6e(e, t) {
  return cX(e, HD(t));
}
function GD(e, t, r, n) {
  let a = e.copy();
  switch (t) {
    case "era": {
      let o = e.calendar.getEras(), l = o.indexOf(e.era);
      if (l < 0) throw new Error("Invalid era: " + e.era);
      l = Bo(l, r, 0, o.length - 1, n?.round), a.era = o[l], Nu(a);
      break;
    }
    case "year":
      var s, i;
      !((s = (i = a.calendar).isInverseEra) === null || s === void 0) && s.call(i, a) && (r = -r), a.year = Bo(e.year, r, -1 / 0, 9999, n?.round), a.year === -1 / 0 && (a.year = 1), a.calendar.balanceYearMonth && a.calendar.balanceYearMonth(a, e);
      break;
    case "month":
      a.month = Bo(e.month, r, 1, e.calendar.getMonthsInYear(e), n?.round);
      break;
    case "day":
      a.day = Bo(e.day, r, 1, e.calendar.getDaysInMonth(e), n?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(a), Nu(a), a;
}
function WD(e, t, r, n) {
  let a = e.copy();
  switch (t) {
    case "hour": {
      let s = e.hour, i = 0, o = 23;
      if (n?.hourCycle === 12) {
        let l = s >= 12;
        i = l ? 12 : 0, o = l ? 23 : 11;
      }
      a.hour = Bo(s, r, i, o, n?.round);
      break;
    }
    case "minute":
      a.minute = Bo(e.minute, r, 0, 59, n?.round);
      break;
    case "second":
      a.second = Bo(e.second, r, 0, 59, n?.round);
      break;
    case "millisecond":
      a.millisecond = Bo(e.millisecond, r, 0, 999, n?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return a;
}
function Bo(e, t, r, n, a = !1) {
  if (a) {
    e += Math.sign(t), e < r && (e = n);
    let s = Math.abs(t);
    t > 0 ? e = Math.ceil(e / s) * s : e = Math.floor(e / s) * s, e > n && (e = r);
  } else
    e += t, e < r ? e = n - (r - e - 1) : e > n && (e = r + (e - n - 1));
  return e;
}
function dX(e, t) {
  let r;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let a = Ly(Vl(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    r = Po(a, e.timeZone);
  } else
    r = vd(e) - e.offset;
  r += t.milliseconds || 0, r += (t.seconds || 0) * 1e3, r += (t.minutes || 0) * 6e4, r += (t.hours || 0) * 36e5;
  let n = $o(r, e.timeZone);
  return la(n, e.calendar);
}
function Z6e(e, t) {
  return dX(e, HD(t));
}
function J6e(e, t, r, n) {
  switch (t) {
    case "hour": {
      let a = 0, s = 23;
      if (n?.hourCycle === 12) {
        let h = e.hour >= 12;
        a = h ? 12 : 0, s = h ? 23 : 11;
      }
      let i = Vl(e), o = la(Xp(i, {
        hour: a
      }), new Hl()), l = [
        Po(o, e.timeZone, "earlier"),
        Po(o, e.timeZone, "later")
      ].filter((h) => $o(h, e.timeZone).day === o.day)[0], u = la(Xp(i, {
        hour: s
      }), new Hl()), c = [
        Po(u, e.timeZone, "earlier"),
        Po(u, e.timeZone, "later")
      ].filter((h) => $o(h, e.timeZone).day === u.day).pop(), d = vd(e) - e.offset, p = Math.floor(d / kf), f = d % kf;
      return d = Bo(p, r, Math.floor(l / kf), Math.floor(c / kf), n?.round) * kf + f, la($o(d, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return WD(e, t, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let a = GD(Vl(e), t, r, n), s = Po(a, e.timeZone);
      return la($o(s, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function Q6e(e, t, r) {
  let n = Vl(e), a = Xp(VD(n, t), t);
  if (a.compare(n) === 0) return e;
  let s = Po(a, e.timeZone, r);
  return la($o(s, e.timeZone), e.calendar);
}
function fX(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function pX(e) {
  let t = la(e, new Hl()), r;
  return t.era === "BC" ? r = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : r = String(t.year).padStart(4, "0"), `${r}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function hX(e) {
  return `${pX(e)}T${fX(e)}`;
}
function e$e(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let r = Math.floor(e / 36e5), n = e % 36e5 / 6e4;
  return `${t}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
}
function t$e(e) {
  return `${hX(e)}${e$e(e.offset)}[${e.timeZone}]`;
}
function r$e(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Dh(e, t, r) {
  r$e(e, t), t.set(e, r);
}
function KD(e) {
  let t = typeof e[0] == "object" ? e.shift() : new Hl(), r;
  if (typeof e[0] == "string") r = e.shift();
  else {
    let i = t.getEras();
    r = i[i.length - 1];
  }
  let n = e.shift(), a = e.shift(), s = e.shift();
  return [
    t,
    r,
    n,
    a,
    s
  ];
}
var n$e = /* @__PURE__ */ new WeakMap();
class wd {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new wd(this.calendar, this.era, this.year, this.month, this.day) : new wd(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return Ly(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return oX(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return VD(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return GD(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return nX(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return pX(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return QY(this, t);
  }
  constructor(...t) {
    Dh(this, n$e, {
      writable: !0,
      value: void 0
    });
    let [r, n, a, s, i] = KD(t);
    this.calendar = r, this.era = n, this.year = a, this.month = s, this.day = i, Nu(this);
  }
}
var i$e = /* @__PURE__ */ new WeakMap();
class Tn {
  /** Returns a copy of this time. */
  copy() {
    return new Tn(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(t) {
    return cX(this, t);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(t) {
    return X6e(this, t);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return Xp(this, t);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return WD(this, t, r, n);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return fX(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(t) {
    return eX(this, t);
  }
  constructor(t = 0, r = 0, n = 0, a = 0) {
    Dh(this, i$e, {
      writable: !0,
      value: void 0
    }), this.hour = t, this.minute = r, this.second = n, this.millisecond = a, lX(this);
  }
}
var a$e = /* @__PURE__ */ new WeakMap();
class pb {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new pb(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new pb(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return Ly(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return oX(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return VD(Xp(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return GD(this, t, r, n);
      default:
        return WD(this, t, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, r) {
    return nX(this, t, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return hX(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let r = QY(this, t);
    return r === 0 ? eX(this, Vl(t)) : r;
  }
  constructor(...t) {
    Dh(this, a$e, {
      writable: !0,
      value: void 0
    });
    let [r, n, a, s, i] = KD(t);
    this.calendar = r, this.era = n, this.year = a, this.month = s, this.day = i, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Nu(this);
  }
}
var s$e = /* @__PURE__ */ new WeakMap();
class Zp {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Zp(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Zp(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return dX(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Z6e(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, r) {
    return Q6e(this, t, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return J6e(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return G6e(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return t$e(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - aX(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    Dh(this, s$e, {
      writable: !0,
      value: void 0
    });
    let [r, n, a, s, i] = KD(t), o = t.shift(), l = t.shift();
    this.calendar = r, this.era = n, this.year = a, this.month = s, this.day = i, this.timeZone = o, this.offset = l, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Nu(this);
  }
}
let sT = /* @__PURE__ */ new Map();
class Bc {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)} – ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(t), a = this.formatter.formatToParts(r);
    return [
      ...n.map((s) => ({
        ...s,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...a.map((s) => ({
        ...s,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return u$e() && (this.resolvedHourCycle || (this.resolvedHourCycle = c$e(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, r = {}) {
    this.formatter = mX(t, r), this.options = r;
  }
}
const o$e = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function mX(e, t = {}) {
  if (typeof t.hour12 == "boolean" && l$e()) {
    t = {
      ...t
    };
    let a = o$e[String(t.hour12)][e.split("-")[0]], s = t.hour12 ? "h12" : "h23";
    t.hourCycle = a ?? s, delete t.hour12;
  }
  let r = e + (t ? Object.entries(t).sort((a, s) => a[0] < s[0] ? -1 : 1).join() : "");
  if (sT.has(r)) return sT.get(r);
  let n = new Intl.DateTimeFormat(e, t);
  return sT.set(r, n), n;
}
let oT = null;
function l$e() {
  return oT == null && (oT = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), oT;
}
let lT = null;
function u$e() {
  return lT == null && (lT = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), lT;
}
function c$e(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = mX(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((s) => s.type === "hour").value, 10), a = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((s) => s.type === "hour").value, 10);
  if (n === 0 && a === 23) return "h23";
  if (n === 24 && a === 23) return "h24";
  if (n === 0 && a === 11) return "h11";
  if (n === 12 && a === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
var YD = "Popover", [gX, oqe] = ds(YD, [
  Wl
]), Oh = Wl(), [d$e, tu] = gX(YD), bX = (e) => {
  const {
    __scopePopover: t,
    children: r,
    open: n,
    defaultOpen: a,
    onOpenChange: s,
    modal: i = !1
  } = e, o = Oh(t), l = D.useRef(null), [u, c] = D.useState(!1), [d = !1, p] = Bs({
    prop: n,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ K(gh, { ...o, children: /* @__PURE__ */ K(
    d$e,
    {
      scope: t,
      contentId: us(),
      triggerRef: l,
      open: d,
      onOpenChange: p,
      onOpenToggle: D.useCallback(() => p((f) => !f), [p]),
      hasCustomAnchor: u,
      onCustomAnchorAdd: D.useCallback(() => c(!0), []),
      onCustomAnchorRemove: D.useCallback(() => c(!1), []),
      modal: i,
      children: r
    }
  ) });
};
bX.displayName = YD;
var yX = "PopoverAnchor", f$e = D.forwardRef(
  (e, t) => {
    const { __scopePopover: r, ...n } = e, a = tu(yX, r), s = Oh(r), { onCustomAnchorAdd: i, onCustomAnchorRemove: o } = a;
    return D.useEffect(() => (i(), () => o()), [i, o]), /* @__PURE__ */ K(bh, { ...s, ...n, ref: t });
  }
);
f$e.displayName = yX;
var vX = "PopoverTrigger", wX = D.forwardRef(
  (e, t) => {
    const { __scopePopover: r, ...n } = e, a = tu(vX, r), s = Oh(r), i = sn(t, a.triggerRef), o = /* @__PURE__ */ K(
      Wr.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": kX(a.open),
        ...n,
        ref: i,
        onClick: nr(e.onClick, a.onOpenToggle)
      }
    );
    return a.hasCustomAnchor ? o : /* @__PURE__ */ K(bh, { asChild: !0, ...s, children: o });
  }
);
wX.displayName = vX;
var XD = "PopoverPortal", [p$e, h$e] = gX(XD, {
  forceMount: void 0
}), xX = (e) => {
  const { __scopePopover: t, forceMount: r, children: n, container: a } = e, s = tu(XD, t);
  return /* @__PURE__ */ K(p$e, { scope: t, forceMount: r, children: /* @__PURE__ */ K(Ra, { present: r || s.open, children: /* @__PURE__ */ K(Xb, { asChild: !0, container: a, children: n }) }) });
};
xX.displayName = XD;
var xd = "PopoverContent", EX = D.forwardRef(
  (e, t) => {
    const r = h$e(xd, e.__scopePopover), { forceMount: n = r.forceMount, ...a } = e, s = tu(xd, e.__scopePopover);
    return /* @__PURE__ */ K(Ra, { present: n || s.open, children: s.modal ? /* @__PURE__ */ K(m$e, { ...a, ref: t }) : /* @__PURE__ */ K(g$e, { ...a, ref: t }) });
  }
);
EX.displayName = xd;
var m$e = D.forwardRef(
  (e, t) => {
    const r = tu(xd, e.__scopePopover), n = D.useRef(null), a = sn(t, n), s = D.useRef(!1);
    return D.useEffect(() => {
      const i = n.current;
      if (i) return cN(i);
    }, []), /* @__PURE__ */ K(Qb, { as: zo, allowPinchZoom: !0, children: /* @__PURE__ */ K(
      SX,
      {
        ...e,
        ref: a,
        trapFocus: r.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: nr(e.onCloseAutoFocus, (i) => {
          i.preventDefault(), s.current || r.triggerRef.current?.focus();
        }),
        onPointerDownOutside: nr(
          e.onPointerDownOutside,
          (i) => {
            const o = i.detail.originalEvent, l = o.button === 0 && o.ctrlKey === !0, u = o.button === 2 || l;
            s.current = u;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: nr(
          e.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), g$e = D.forwardRef(
  (e, t) => {
    const r = tu(xd, e.__scopePopover), n = D.useRef(!1), a = D.useRef(!1);
    return /* @__PURE__ */ K(
      SX,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          e.onCloseAutoFocus?.(s), s.defaultPrevented || (n.current || r.triggerRef.current?.focus(), s.preventDefault()), n.current = !1, a.current = !1;
        },
        onInteractOutside: (s) => {
          e.onInteractOutside?.(s), s.defaultPrevented || (n.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const i = s.target;
          r.triggerRef.current?.contains(i) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
        }
      }
    );
  }
), SX = D.forwardRef(
  (e, t) => {
    const {
      __scopePopover: r,
      trapFocus: n,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: i,
      onEscapeKeyDown: o,
      onPointerDownOutside: l,
      onFocusOutside: u,
      onInteractOutside: c,
      ...d
    } = e, p = tu(xd, r), f = Oh(r);
    return eN(), /* @__PURE__ */ K(
      Hb,
      {
        asChild: !0,
        loop: !0,
        trapped: n,
        onMountAutoFocus: a,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ K(
          jb,
          {
            asChild: !0,
            disableOutsidePointerEvents: i,
            onInteractOutside: c,
            onEscapeKeyDown: o,
            onPointerDownOutside: l,
            onFocusOutside: u,
            onDismiss: () => p.onOpenChange(!1),
            children: /* @__PURE__ */ K(
              Kb,
              {
                "data-state": kX(p.open),
                role: "dialog",
                id: p.contentId,
                ...f,
                ...d,
                ref: t,
                style: {
                  ...d.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), _X = "PopoverClose", b$e = D.forwardRef(
  (e, t) => {
    const { __scopePopover: r, ...n } = e, a = tu(_X, r);
    return /* @__PURE__ */ K(
      Wr.button,
      {
        type: "button",
        ...n,
        ref: t,
        onClick: nr(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
b$e.displayName = _X;
var y$e = "PopoverArrow", v$e = D.forwardRef(
  (e, t) => {
    const { __scopePopover: r, ...n } = e, a = Oh(r);
    return /* @__PURE__ */ K(Yb, { ...a, ...n, ref: t });
  }
);
v$e.displayName = y$e;
function kX(e) {
  return e ? "open" : "closed";
}
var CX = bX, w$e = wX, x$e = xX, E$e = EX, AX = {};
AX = {
  calendar: "التقويم",
  day: "يوم",
  dayPeriod: "ص/م",
  endDate: "تاريخ الانتهاء",
  era: "العصر",
  hour: "الساعات",
  minute: "الدقائق",
  month: "الشهر",
  second: "الثواني",
  selectedDateDescription: (e) => `تاريخ محدد: ${e.date}`,
  selectedRangeDescription: (e) => `المدى الزمني المحدد: ${e.startDate} إلى ${e.endDate}`,
  selectedTimeDescription: (e) => `الوقت المحدد: ${e.time}`,
  startDate: "تاريخ البدء",
  timeZoneName: "التوقيت",
  weekday: "اليوم",
  year: "السنة"
};
var TX = {};
TX = {
  calendar: "Календар",
  day: "ден",
  dayPeriod: "пр.об./сл.об.",
  endDate: "Крайна дата",
  era: "ера",
  hour: "час",
  minute: "минута",
  month: "месец",
  second: "секунда",
  selectedDateDescription: (e) => `Избрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Избран диапазон: ${e.startDate} до ${e.endDate}`,
  selectedTimeDescription: (e) => `Избрано време: ${e.time}`,
  startDate: "Начална дата",
  timeZoneName: "часова зона",
  weekday: "ден от седмицата",
  year: "година"
};
var RX = {};
RX = {
  calendar: "Kalendář",
  day: "den",
  dayPeriod: "část dne",
  endDate: "Konečné datum",
  era: "letopočet",
  hour: "hodina",
  minute: "minuta",
  month: "měsíc",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybrané datum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybrané období: ${e.startDate} až ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybraný čas: ${e.time}`,
  startDate: "Počáteční datum",
  timeZoneName: "časové pásmo",
  weekday: "den v týdnu",
  year: "rok"
};
var IX = {};
IX = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "AM/PM",
  endDate: "Slutdato",
  era: "æra",
  hour: "time",
  minute: "minut",
  month: "måned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt interval: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tidspunkt: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidszone",
  weekday: "ugedag",
  year: "år"
};
var NX = {};
NX = {
  calendar: "Kalender",
  day: "Tag",
  dayPeriod: "Tageshälfte",
  endDate: "Enddatum",
  era: "Epoche",
  hour: "Stunde",
  minute: "Minute",
  month: "Monat",
  second: "Sekunde",
  selectedDateDescription: (e) => `Ausgewähltes Datum: ${e.date}`,
  selectedRangeDescription: (e) => `Ausgewählter Bereich: ${e.startDate} bis ${e.endDate}`,
  selectedTimeDescription: (e) => `Ausgewählte Zeit: ${e.time}`,
  startDate: "Anfangsdatum",
  timeZoneName: "Zeitzone",
  weekday: "Wochentag",
  year: "Jahr"
};
var DX = {};
DX = {
  calendar: "Ημερολόγιο",
  day: "ημέρα",
  dayPeriod: "π.μ./μ.μ.",
  endDate: "Ημερομηνία λήξης",
  era: "περίοδος",
  hour: "ώρα",
  minute: "λεπτό",
  month: "μήνας",
  second: "δευτερόλεπτο",
  selectedDateDescription: (e) => `Επιλεγμένη ημερομηνία: ${e.date}`,
  selectedRangeDescription: (e) => `Επιλεγμένο εύρος: ${e.startDate} έως ${e.endDate}`,
  selectedTimeDescription: (e) => `Επιλεγμένη ώρα: ${e.time}`,
  startDate: "Ημερομηνία έναρξης",
  timeZoneName: "ζώνη ώρας",
  weekday: "καθημερινή",
  year: "έτος"
};
var OX = {};
OX = {
  era: "era",
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  dayPeriod: "AM/PM",
  calendar: "Calendar",
  startDate: "Start Date",
  endDate: "End Date",
  weekday: "day of the week",
  timeZoneName: "time zone",
  selectedDateDescription: (e) => `Selected Date: ${e.date}`,
  selectedRangeDescription: (e) => `Selected Range: ${e.startDate} to ${e.endDate}`,
  selectedTimeDescription: (e) => `Selected Time: ${e.time}`
};
var PX = {};
PX = {
  calendar: "Calendario",
  day: "día",
  dayPeriod: "a. m./p. m.",
  endDate: "Fecha final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mes",
  second: "segundo",
  selectedDateDescription: (e) => `Fecha seleccionada: ${e.date}`,
  selectedRangeDescription: (e) => `Rango seleccionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora seleccionada: ${e.time}`,
  startDate: "Fecha de inicio",
  timeZoneName: "zona horaria",
  weekday: "día de la semana",
  year: "año"
};
var LX = {};
LX = {
  calendar: "Kalender",
  day: "päev",
  dayPeriod: "enne/pärast lõunat",
  endDate: "Lõppkuupäev",
  era: "ajastu",
  hour: "tund",
  minute: "minut",
  month: "kuu",
  second: "sekund",
  selectedDateDescription: (e) => `Valitud kuupäev: ${e.date}`,
  selectedRangeDescription: (e) => `Valitud vahemik: ${e.startDate} kuni ${e.endDate}`,
  selectedTimeDescription: (e) => `Valitud aeg: ${e.time}`,
  startDate: "Alguskuupäev",
  timeZoneName: "ajavöönd",
  weekday: "nädalapäev",
  year: "aasta"
};
var MX = {};
MX = {
  calendar: "Kalenteri",
  day: "päivä",
  dayPeriod: "vuorokaudenaika",
  endDate: "Päättymispäivä",
  era: "aikakausi",
  hour: "tunti",
  minute: "minuutti",
  month: "kuukausi",
  second: "sekunti",
  selectedDateDescription: (e) => `Valittu päivämäärä: ${e.date}`,
  selectedRangeDescription: (e) => `Valittu aikaväli: ${e.startDate} – ${e.endDate}`,
  selectedTimeDescription: (e) => `Valittu aika: ${e.time}`,
  startDate: "Alkamispäivä",
  timeZoneName: "aikavyöhyke",
  weekday: "viikonpäivä",
  year: "vuosi"
};
var FX = {};
FX = {
  calendar: "Calendrier",
  day: "jour",
  dayPeriod: "cadran",
  endDate: "Date de fin",
  era: "ère",
  hour: "heure",
  minute: "minute",
  month: "mois",
  second: "seconde",
  selectedDateDescription: (e) => `Date sélectionnée : ${e.date}`,
  selectedRangeDescription: (e) => `Plage sélectionnée : ${e.startDate} au ${e.endDate}`,
  selectedTimeDescription: (e) => `Heure choisie : ${e.time}`,
  startDate: "Date de début",
  timeZoneName: "fuseau horaire",
  weekday: "jour de la semaine",
  year: "année"
};
var $X = {};
$X = {
  calendar: "לוח שנה",
  day: "יום",
  dayPeriod: "לפנה״צ/אחה״צ",
  endDate: "תאריך סיום",
  era: "תקופה",
  hour: "שעה",
  minute: "דקה",
  month: "חודש",
  second: "שנייה",
  selectedDateDescription: (e) => `תאריך נבחר: ${e.date}`,
  selectedRangeDescription: (e) => `טווח נבחר: ${e.startDate} עד ${e.endDate}`,
  selectedTimeDescription: (e) => `זמן נבחר: ${e.time}`,
  startDate: "תאריך התחלה",
  timeZoneName: "אזור זמן",
  weekday: "יום בשבוע",
  year: "שנה"
};
var BX = {};
BX = {
  calendar: "Kalendar",
  day: "dan",
  dayPeriod: "AM/PM",
  endDate: "Datum završetka",
  era: "era",
  hour: "sat",
  minute: "minuta",
  month: "mjesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Odabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Odabrani raspon: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Odabrano vrijeme: ${e.time}`,
  startDate: "Datum početka",
  timeZoneName: "vremenska zona",
  weekday: "dan u tjednu",
  year: "godina"
};
var UX = {};
UX = {
  calendar: "Naptár",
  day: "nap",
  dayPeriod: "napszak",
  endDate: "Befejező dátum",
  era: "éra",
  hour: "óra",
  minute: "perc",
  month: "hónap",
  second: "másodperc",
  selectedDateDescription: (e) => `Kijelölt dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Kijelölt tartomány: ${e.startDate}–${e.endDate}`,
  selectedTimeDescription: (e) => `Kijelölt idő: ${e.time}`,
  startDate: "Kezdő dátum",
  timeZoneName: "időzóna",
  weekday: "hét napja",
  year: "év"
};
var zX = {};
zX = {
  calendar: "Calendario",
  day: "giorno",
  dayPeriod: "AM/PM",
  endDate: "Data finale",
  era: "era",
  hour: "ora",
  minute: "minuto",
  month: "mese",
  second: "secondo",
  selectedDateDescription: (e) => `Data selezionata: ${e.date}`,
  selectedRangeDescription: (e) => `Intervallo selezionato: da ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selezionata: ${e.time}`,
  startDate: "Data iniziale",
  timeZoneName: "fuso orario",
  weekday: "giorno della settimana",
  year: "anno"
};
var qX = {};
qX = {
  calendar: "カレンダー",
  day: "日",
  dayPeriod: "午前/午後",
  endDate: "終了日",
  era: "時代",
  hour: "時",
  minute: "分",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `選択した日付 : ${e.date}`,
  selectedRangeDescription: (e) => `選択範囲 : ${e.startDate} から ${e.endDate}`,
  selectedTimeDescription: (e) => `選択した時間 : ${e.time}`,
  startDate: "開始日",
  timeZoneName: "タイムゾーン",
  weekday: "曜日",
  year: "年"
};
var jX = {};
jX = {
  calendar: "달력",
  day: "일",
  dayPeriod: "오전/오후",
  endDate: "종료일",
  era: "연호",
  hour: "시",
  minute: "분",
  month: "월",
  second: "초",
  selectedDateDescription: (e) => `선택 일자: ${e.date}`,
  selectedRangeDescription: (e) => `선택 범위: ${e.startDate} ~ ${e.endDate}`,
  selectedTimeDescription: (e) => `선택 시간: ${e.time}`,
  startDate: "시작일",
  timeZoneName: "시간대",
  weekday: "요일",
  year: "년"
};
var HX = {};
HX = {
  calendar: "Kalendorius",
  day: "diena",
  dayPeriod: "iki pietų / po pietų",
  endDate: "Pabaigos data",
  era: "era",
  hour: "valanda",
  minute: "minutė",
  month: "mėnuo",
  second: "sekundė",
  selectedDateDescription: (e) => `Pasirinkta data: ${e.date}`,
  selectedRangeDescription: (e) => `Pasirinktas intervalas: nuo ${e.startDate} iki ${e.endDate}`,
  selectedTimeDescription: (e) => `Pasirinktas laikas: ${e.time}`,
  startDate: "Pradžios data",
  timeZoneName: "laiko juosta",
  weekday: "savaitės diena",
  year: "metai"
};
var VX = {};
VX = {
  calendar: "Kalendārs",
  day: "diena",
  dayPeriod: "priekšpusdienā/pēcpusdienā",
  endDate: "Beigu datums",
  era: "ēra",
  hour: "stundas",
  minute: "minūtes",
  month: "mēnesis",
  second: "sekundes",
  selectedDateDescription: (e) => `Atlasītais datums: ${e.date}`,
  selectedRangeDescription: (e) => `Atlasītais diapazons: no ${e.startDate} līdz ${e.endDate}`,
  selectedTimeDescription: (e) => `Atlasītais laiks: ${e.time}`,
  startDate: "Sākuma datums",
  timeZoneName: "laika josla",
  weekday: "nedēļas diena",
  year: "gads"
};
var GX = {};
GX = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Sluttdato",
  era: "tidsalder",
  hour: "time",
  minute: "minutt",
  month: "måned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt område: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tid: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidssone",
  weekday: "ukedag",
  year: "år"
};
var WX = {};
WX = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Einddatum",
  era: "tijdperk",
  hour: "uur",
  minute: "minuut",
  month: "maand",
  second: "seconde",
  selectedDateDescription: (e) => `Geselecteerde datum: ${e.date}`,
  selectedRangeDescription: (e) => `Geselecteerd bereik: ${e.startDate} tot ${e.endDate}`,
  selectedTimeDescription: (e) => `Geselecteerde tijd: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tijdzone",
  weekday: "dag van de week",
  year: "jaar"
};
var KX = {};
KX = {
  calendar: "Kalendarz",
  day: "dzień",
  dayPeriod: "rano / po południu / wieczorem",
  endDate: "Data końcowa",
  era: "era",
  hour: "godzina",
  minute: "minuta",
  month: "miesiąc",
  second: "sekunda",
  selectedDateDescription: (e) => `Wybrana data: ${e.date}`,
  selectedRangeDescription: (e) => `Wybrany zakres: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Wybrany czas: ${e.time}`,
  startDate: "Data początkowa",
  timeZoneName: "strefa czasowa",
  weekday: "dzień tygodnia",
  year: "rok"
};
var YX = {};
YX = {
  calendar: "Calendário",
  day: "dia",
  dayPeriod: "AM/PM",
  endDate: "Data final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mês",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data inicial",
  timeZoneName: "fuso horário",
  weekday: "dia da semana",
  year: "ano"
};
var XX = {};
XX = {
  calendar: "Calendário",
  day: "dia",
  dayPeriod: "am/pm",
  endDate: "Data de Término",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mês",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data de Início",
  timeZoneName: "fuso horário",
  weekday: "dia da semana",
  year: "ano"
};
var ZX = {};
ZX = {
  calendar: "Calendar",
  day: "zi",
  dayPeriod: "a.m/p.m.",
  endDate: "Dată final",
  era: "eră",
  hour: "oră",
  minute: "minut",
  month: "lună",
  second: "secundă",
  selectedDateDescription: (e) => `Dată selectată: ${e.date}`,
  selectedRangeDescription: (e) => `Interval selectat: de la ${e.startDate} până la ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selectată: ${e.time}`,
  startDate: "Dată început",
  timeZoneName: "fus orar",
  weekday: "ziua din săptămână",
  year: "an"
};
var JX = {};
JX = {
  calendar: "Календарь",
  day: "день",
  dayPeriod: "AM/PM",
  endDate: "Дата окончания",
  era: "эра",
  hour: "час",
  minute: "минута",
  month: "месяц",
  second: "секунда",
  selectedDateDescription: (e) => `Выбранная дата: ${e.date}`,
  selectedRangeDescription: (e) => `Выбранный диапазон: с ${e.startDate} по ${e.endDate}`,
  selectedTimeDescription: (e) => `Выбранное время: ${e.time}`,
  startDate: "Дата начала",
  timeZoneName: "часовой пояс",
  weekday: "день недели",
  year: "год"
};
var QX = {};
QX = {
  calendar: "Kalendár",
  day: "deň",
  dayPeriod: "AM/PM",
  endDate: "Dátum ukončenia",
  era: "letopočet",
  hour: "hodina",
  minute: "minúta",
  month: "mesiac",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybratý dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybratý rozsah: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybratý čas: ${e.time}`,
  startDate: "Dátum začatia",
  timeZoneName: "časové pásmo",
  weekday: "deň týždňa",
  year: "rok"
};
var eZ = {};
eZ = {
  calendar: "Koledar",
  day: "dan",
  dayPeriod: "dop/pop",
  endDate: "Datum konca",
  era: "doba",
  hour: "ura",
  minute: "minuta",
  month: "mesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Izbrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izbrano območje: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izbrani čas: ${e.time}`,
  startDate: "Datum začetka",
  timeZoneName: "časovni pas",
  weekday: "dan v tednu",
  year: "leto"
};
var tZ = {};
tZ = {
  calendar: "Kalendar",
  day: "дан",
  dayPeriod: "пре подне/по подне",
  endDate: "Datum završetka",
  era: "ера",
  hour: "сат",
  minute: "минут",
  month: "месец",
  second: "секунд",
  selectedDateDescription: (e) => `Izabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izabrani opseg: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izabrano vreme: ${e.time}`,
  startDate: "Datum početka",
  timeZoneName: "временска зона",
  weekday: "дан у недељи",
  year: "година"
};
var rZ = {};
rZ = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "fm/em",
  endDate: "Slutdatum",
  era: "era",
  hour: "timme",
  minute: "minut",
  month: "månad",
  second: "sekund",
  selectedDateDescription: (e) => `Valt datum: ${e.date}`,
  selectedRangeDescription: (e) => `Valt intervall: ${e.startDate} till ${e.endDate}`,
  selectedTimeDescription: (e) => `Vald tid: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tidszon",
  weekday: "veckodag",
  year: "år"
};
var nZ = {};
nZ = {
  calendar: "Takvim",
  day: "gün",
  dayPeriod: "ÖÖ/ÖS",
  endDate: "Bitiş Tarihi",
  era: "çağ",
  hour: "saat",
  minute: "dakika",
  month: "ay",
  second: "saniye",
  selectedDateDescription: (e) => `Seçilen Tarih: ${e.date}`,
  selectedRangeDescription: (e) => `Seçilen Aralık: ${e.startDate} - ${e.endDate}`,
  selectedTimeDescription: (e) => `Seçilen Zaman: ${e.time}`,
  startDate: "Başlangıç Tarihi",
  timeZoneName: "saat dilimi",
  weekday: "haftanın günü",
  year: "yıl"
};
var iZ = {};
iZ = {
  calendar: "Календар",
  day: "день",
  dayPeriod: "дп/пп",
  endDate: "Дата завершення",
  era: "ера",
  hour: "година",
  minute: "хвилина",
  month: "місяць",
  second: "секунда",
  selectedDateDescription: (e) => `Вибрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Вибраний діапазон: ${e.startDate} — ${e.endDate}`,
  selectedTimeDescription: (e) => `Вибраний час: ${e.time}`,
  startDate: "Дата початку",
  timeZoneName: "часовий пояс",
  weekday: "день тижня",
  year: "рік"
};
var aZ = {};
aZ = {
  calendar: "日历",
  day: "日",
  dayPeriod: "上午/下午",
  endDate: "结束日期",
  era: "纪元",
  hour: "小时",
  minute: "分钟",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `选定的日期：${e.date}`,
  selectedRangeDescription: (e) => `选定的范围：${e.startDate} 至 ${e.endDate}`,
  selectedTimeDescription: (e) => `选定的时间：${e.time}`,
  startDate: "开始日期",
  timeZoneName: "时区",
  weekday: "工作日",
  year: "年"
};
var sZ = {};
sZ = {
  calendar: "日曆",
  day: "日",
  dayPeriod: "上午/下午",
  endDate: "結束日期",
  era: "纪元",
  hour: "小时",
  minute: "分钟",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `選定的日期：${e.date}`,
  selectedRangeDescription: (e) => `選定的範圍：${e.startDate} 至 ${e.endDate}`,
  selectedTimeDescription: (e) => `選定的時間：${e.time}`,
  startDate: "開始日期",
  timeZoneName: "时区",
  weekday: "工作日",
  year: "年"
};
var ZD = {};
ZD = {
  "ar-AE": AX,
  "bg-BG": TX,
  "cs-CZ": RX,
  "da-DK": IX,
  "de-DE": NX,
  "el-GR": DX,
  "en-US": OX,
  "es-ES": PX,
  "et-EE": LX,
  "fi-FI": MX,
  "fr-FR": FX,
  "he-IL": $X,
  "hr-HR": BX,
  "hu-HU": UX,
  "it-IT": zX,
  "ja-JP": qX,
  "ko-KR": jX,
  "lt-LT": HX,
  "lv-LV": VX,
  "nb-NO": GX,
  "nl-NL": WX,
  "pl-PL": KX,
  "pt-BR": YX,
  "pt-PT": XX,
  "ro-RO": ZX,
  "ru-RU": JX,
  "sk-SK": QX,
  "sl-SI": eZ,
  "sr-SP": tZ,
  "sv-SE": rZ,
  "tr-TR": nZ,
  "uk-UA": iZ,
  "zh-CN": aZ,
  "zh-TW": sZ
};
const tl = typeof document < "u" ? kt.useLayoutEffect : () => {
};
function oa(e) {
  const t = Gr(null);
  return tl(() => {
    t.current = e;
  }, [
    e
  ]), ci((...r) => {
    const n = t.current;
    return n?.(...r);
  }, []);
}
function S$e(e) {
  let [t, r] = Wn(e), n = Gr(null), a = oa(() => {
    if (!n.current) return;
    let i = n.current.next();
    if (i.done) {
      n.current = null;
      return;
    }
    t === i.value ? a() : r(i.value);
  });
  tl(() => {
    n.current && a();
  });
  let s = oa((i) => {
    n.current = i(t), a();
  });
  return [
    t,
    s
  ];
}
const hb = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
}, oZ = /* @__PURE__ */ kt.createContext(hb), _$e = /* @__PURE__ */ kt.createContext(!1);
let k$e = !!(typeof window < "u" && window.document && window.document.createElement), uT = /* @__PURE__ */ new WeakMap();
function C$e(e = !1) {
  let t = Ta(oZ), r = Gr(null);
  if (r.current === null && !e) {
    var n, a;
    let s = (a = kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || a === void 0 || (n = a.ReactCurrentOwner) === null || n === void 0 ? void 0 : n.current;
    if (s) {
      let i = uT.get(s);
      i == null ? uT.set(s, {
        id: t.current,
        state: s.memoizedState
      }) : s.memoizedState !== i.state && (t.current = i.id, uT.delete(s));
    }
    r.current = ++t.current;
  }
  return r.current;
}
function A$e(e) {
  let t = Ta(oZ);
  t === hb && !k$e && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let r = C$e(!!e), n = t === hb && process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${t.prefix}`;
  return e || `${n}-${r}`;
}
function T$e(e) {
  let t = kt.useId(), [r] = Wn(lZ()), n = r || process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${hb.prefix}`;
  return e || `${n}-${t}`;
}
const R$e = typeof kt.useId == "function" ? T$e : A$e;
function I$e() {
  return !1;
}
function N$e() {
  return !0;
}
function D$e(e) {
  return () => {
  };
}
function lZ() {
  return typeof kt.useSyncExternalStore == "function" ? kt.useSyncExternalStore(D$e, I$e, N$e) : Ta(_$e);
}
let O$e = !!(typeof window < "u" && window.document && window.document.createElement), Cl = /* @__PURE__ */ new Map();
function Jp(e) {
  let [t, r] = Wn(e), n = Gr(null), a = R$e(t), s = ci((i) => {
    n.current = i;
  }, []);
  return O$e && (Cl.has(a) && !Cl.get(a).includes(s) ? Cl.set(a, [
    ...Cl.get(a),
    s
  ]) : Cl.set(a, [
    s
  ])), tl(() => {
    let i = a;
    return () => {
      Cl.delete(i);
    };
  }, [
    a
  ]), Qn(() => {
    let i = n.current;
    i && (n.current = null, r(i));
  }), a;
}
function P$e(e, t) {
  if (e === t) return e;
  let r = Cl.get(e);
  if (r)
    return r.forEach((a) => a(t)), t;
  let n = Cl.get(t);
  return n ? (n.forEach((a) => a(e)), e) : t;
}
function H9(e = []) {
  let t = Jp(), [r, n] = S$e(t), a = ci(() => {
    n(function* () {
      yield t, yield document.getElementById(t) ? t : void 0;
    });
  }, [
    t,
    n
  ]);
  return tl(a, [
    t,
    a,
    ...e
  ]), r;
}
function uZ(...e) {
  return (...t) => {
    for (let r of e) typeof r == "function" && r(...t);
  };
}
const ka = (e) => {
  var t;
  return (t = e?.ownerDocument) !== null && t !== void 0 ? t : document;
}, Du = (e) => e && "window" in e && e.window === e ? e : ka(e).defaultView || window;
function Ou(...e) {
  let t = {
    ...e[0]
  };
  for (let r = 1; r < e.length; r++) {
    let n = e[r];
    for (let a in n) {
      let s = t[a], i = n[a];
      typeof s == "function" && typeof i == "function" && // This is a lot faster than a regex.
      a[0] === "o" && a[1] === "n" && a.charCodeAt(2) >= /* 'A' */
      65 && a.charCodeAt(2) <= /* 'Z' */
      90 ? t[a] = uZ(s, i) : (a === "className" || a === "UNSAFE_className") && typeof s == "string" && typeof i == "string" ? t[a] = HI(s, i) : a === "id" && s && i ? t.id = P$e(s, i) : t[a] = i !== void 0 ? i : s;
    }
  }
  return t;
}
const L$e = /* @__PURE__ */ new Set([
  "id"
]), M$e = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]), F$e = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]), $$e = /^(data-.*)$/;
function B$e(e, t = {}) {
  let { labelable: r, isLink: n, propNames: a } = t, s = {};
  for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && (L$e.has(i) || r && M$e.has(i) || n && F$e.has(i) || a?.has(i) || $$e.test(i)) && (s[i] = e[i]);
  return s;
}
function yu(e) {
  if (U$e()) e.focus({
    preventScroll: !0
  });
  else {
    let t = z$e(e);
    e.focus(), q$e(t);
  }
}
let Zm = null;
function U$e() {
  if (Zm == null) {
    Zm = !1;
    try {
      document.createElement("div").focus({
        get preventScroll() {
          return Zm = !0, !0;
        }
      });
    } catch {
    }
  }
  return Zm;
}
function z$e(e) {
  let t = e.parentNode, r = [], n = document.scrollingElement || document.documentElement;
  for (; t instanceof HTMLElement && t !== n; )
    (t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && r.push({
      element: t,
      scrollTop: t.scrollTop,
      scrollLeft: t.scrollLeft
    }), t = t.parentNode;
  return n instanceof HTMLElement && r.push({
    element: n,
    scrollTop: n.scrollTop,
    scrollLeft: n.scrollLeft
  }), r;
}
function q$e(e) {
  for (let { element: t, scrollTop: r, scrollLeft: n } of e)
    t.scrollTop = r, t.scrollLeft = n;
}
function My(e) {
  var t;
  return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some((r) => e.test(r.brand))) || e.test(window.navigator.userAgent);
}
function JD(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function ru(e) {
  let t = null;
  return () => (t == null && (t = e()), t);
}
const Ed = ru(function() {
  return JD(/^Mac/i);
}), j$e = ru(function() {
  return JD(/^iPhone/i);
}), cZ = ru(function() {
  return JD(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  Ed() && navigator.maxTouchPoints > 1;
}), QD = ru(function() {
  return j$e() || cZ();
}), H$e = ru(function() {
  return My(/AppleWebKit/i) && !V$e();
}), V$e = ru(function() {
  return My(/Chrome/i);
}), dZ = ru(function() {
  return My(/Android/i);
}), G$e = ru(function() {
  return My(/Firefox/i);
});
function Qp(e, t, r = !0) {
  var n, a;
  let { metaKey: s, ctrlKey: i, altKey: o, shiftKey: l } = t;
  G$e() && (!((a = window.event) === null || a === void 0 || (n = a.type) === null || n === void 0) && n.startsWith("key")) && e.target === "_blank" && (Ed() ? s = !0 : i = !0);
  let u = H$e() && Ed() && !cZ() ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey: s,
    ctrlKey: i,
    altKey: o,
    shiftKey: l
  }) : new MouseEvent("click", {
    metaKey: s,
    ctrlKey: i,
    altKey: o,
    shiftKey: l,
    bubbles: !0,
    cancelable: !0
  });
  Qp.isOpening = r, yu(e), e.dispatchEvent(u), Qp.isOpening = !1;
}
Qp.isOpening = !1;
let Nc = /* @__PURE__ */ new Map(), sI = /* @__PURE__ */ new Set();
function V9() {
  if (typeof window > "u") return;
  function e(n) {
    return "propertyName" in n;
  }
  let t = (n) => {
    if (!e(n) || !n.target) return;
    let a = Nc.get(n.target);
    a || (a = /* @__PURE__ */ new Set(), Nc.set(n.target, a), n.target.addEventListener("transitioncancel", r, {
      once: !0
    })), a.add(n.propertyName);
  }, r = (n) => {
    if (!e(n) || !n.target) return;
    let a = Nc.get(n.target);
    if (a && (a.delete(n.propertyName), a.size === 0 && (n.target.removeEventListener("transitioncancel", r), Nc.delete(n.target)), Nc.size === 0)) {
      for (let s of sI) s();
      sI.clear();
    }
  };
  document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", r);
}
typeof document < "u" && (document.readyState !== "loading" ? V9() : document.addEventListener("DOMContentLoaded", V9));
function fZ(e) {
  requestAnimationFrame(() => {
    Nc.size === 0 ? e() : sI.add(e);
  });
}
function pZ() {
  let e = Gr(/* @__PURE__ */ new Map()), t = ci((a, s, i, o) => {
    let l = o?.once ? (...u) => {
      e.current.delete(i), i(...u);
    } : i;
    e.current.set(i, {
      type: s,
      eventTarget: a,
      fn: l,
      options: o
    }), a.addEventListener(s, l, o);
  }, []), r = ci((a, s, i, o) => {
    var l;
    let u = ((l = e.current.get(i)) === null || l === void 0 ? void 0 : l.fn) || i;
    a.removeEventListener(s, u, o), e.current.delete(i);
  }, []), n = ci(() => {
    e.current.forEach((a, s) => {
      r(a.eventTarget, a.type, s, a.options);
    });
  }, [
    r
  ]);
  return Qn(() => n, [
    n
  ]), {
    addGlobalListener: t,
    removeGlobalListener: r,
    removeAllGlobalListeners: n
  };
}
function hZ(e, t) {
  let { id: r, "aria-label": n, "aria-labelledby": a } = e;
  return r = Jp(r), a && n ? a = [
    .../* @__PURE__ */ new Set([
      r,
      ...a.trim().split(/\s+/)
    ])
  ].join(" ") : a && (a = a.trim().split(/\s+/).join(" ")), !n && !a && t && (n = t), {
    id: r,
    "aria-label": n,
    "aria-labelledby": a
  };
}
function W$e(e, t) {
  tl(() => {
    if (e && e.ref && t)
      return e.ref.current = t.current, () => {
        e.ref && (e.ref.current = null);
      };
  });
}
function oI(e, t) {
  if (!e) return !1;
  let r = window.getComputedStyle(e), n = /(auto|scroll)/.test(r.overflow + r.overflowX + r.overflowY);
  return n && t && (n = e.scrollHeight !== e.clientHeight || e.scrollWidth !== e.clientWidth), n;
}
function K$e(e, t) {
  let r = e;
  for (oI(r, t) && (r = r.parentElement); r && !oI(r, t); ) r = r.parentElement;
  return r || document.scrollingElement || document.documentElement;
}
function Y$e(e, t) {
  const r = [];
  for (; e && e !== document.documentElement; )
    oI(e, t) && r.push(e), e = e.parentElement;
  return r;
}
let X$e = 0;
const cT = /* @__PURE__ */ new Map();
function Z$e(e) {
  let [t, r] = Wn();
  return tl(() => {
    if (!e) return;
    let n = cT.get(e);
    if (n)
      r(n.element.id);
    else {
      let a = `react-aria-description-${X$e++}`;
      r(a);
      let s = document.createElement("div");
      s.id = a, s.style.display = "none", s.textContent = e, document.body.appendChild(s), n = {
        refCount: 0,
        element: s
      }, cT.set(e, n);
    }
    return n.refCount++, () => {
      n && --n.refCount === 0 && (n.element.remove(), cT.delete(e));
    };
  }, [
    e
  ]), {
    "aria-describedby": e ? t : void 0
  };
}
function dT(e, t, r, n) {
  let a = oa(r), s = r == null;
  Qn(() => {
    if (s || !e.current) return;
    let i = e.current;
    return i.addEventListener(t, a, n), () => {
      i.removeEventListener(t, a, n);
    };
  }, [
    e,
    t,
    n,
    s,
    a
  ]);
}
function J$e(e, t) {
  let r = G9(e, t, "left"), n = G9(e, t, "top"), a = t.offsetWidth, s = t.offsetHeight, i = e.scrollLeft, o = e.scrollTop, { borderTopWidth: l, borderLeftWidth: u, scrollPaddingTop: c, scrollPaddingRight: d, scrollPaddingBottom: p, scrollPaddingLeft: f } = getComputedStyle(e), h = i + parseInt(u, 10), m = o + parseInt(l, 10), y = h + e.clientWidth, b = m + e.clientHeight, v = parseInt(c, 10) || 0, x = parseInt(p, 10) || 0, _ = parseInt(d, 10) || 0, E = parseInt(f, 10) || 0;
  r <= i + E ? i = r - parseInt(u, 10) - E : r + a > y - _ && (i += r + a - y + _), n <= m + v ? o = n - parseInt(l, 10) - v : n + s > b - x && (o += n + s - b + x), e.scrollLeft = i, e.scrollTop = o;
}
function G9(e, t, r) {
  const n = r === "left" ? "offsetLeft" : "offsetTop";
  let a = 0;
  for (; t.offsetParent && (a += t[n], t.offsetParent !== e); ) {
    if (t.offsetParent.contains(e)) {
      a -= e[n];
      break;
    }
    t = t.offsetParent;
  }
  return a;
}
function Q$e(e, t) {
  if (e && document.contains(e)) {
    let i = document.scrollingElement || document.documentElement;
    if (window.getComputedStyle(i).overflow === "hidden") {
      let l = Y$e(e);
      for (let u of l) J$e(u, e);
    } else {
      var r;
      let { left: l, top: u } = e.getBoundingClientRect();
      e == null || (r = e.scrollIntoView) === null || r === void 0 || r.call(e, {
        block: "nearest"
      });
      let { left: c, top: d } = e.getBoundingClientRect();
      if (Math.abs(l - c) > 1 || Math.abs(u - d) > 1) {
        var n, a, s;
        t == null || (a = t.containingElement) === null || a === void 0 || (n = a.scrollIntoView) === null || n === void 0 || n.call(a, {
          block: "center",
          inline: "center"
        }), (s = e.scrollIntoView) === null || s === void 0 || s.call(e, {
          block: "nearest"
        });
      }
    }
  }
}
function lI(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : dZ() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function e8e(e) {
  return !dZ() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function t8e(e, t) {
  let r = Gr(null);
  return e && r.current && t(e, r.current) && (e = r.current), r.current = e, e;
}
function r8e(e, t, r) {
  let n = Gr(t), a = oa(() => {
    r && r(n.current);
  });
  Qn(() => {
    var s;
    let i = e == null || (s = e.current) === null || s === void 0 ? void 0 : s.form;
    return i?.addEventListener("reset", a), () => {
      i?.removeEventListener("reset", a);
    };
  }, [
    e,
    a
  ]);
}
function mZ(e, t, r) {
  let [n, a] = Wn(e || t), s = Gr(e !== void 0), i = e !== void 0;
  Qn(() => {
    let u = s.current;
    u !== i && console.warn(`WARN: A component changed from ${u ? "controlled" : "uncontrolled"} to ${i ? "controlled" : "uncontrolled"}.`), s.current = i;
  }, [
    i
  ]);
  let o = i ? e : n, l = ci((u, ...c) => {
    let d = (p, ...f) => {
      r && (Object.is(o, p) || r(p, ...f)), i || (o = p);
    };
    typeof u == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), a((f, ...h) => {
      let m = u(i ? o : f, ...h);
      return d(m, ...c), i ? f : m;
    })) : (i || a(u), d(u, ...c));
  }, [
    i,
    o,
    r
  ]);
  return [
    o,
    l
  ];
}
let Uc = "default", uI = "", yg = /* @__PURE__ */ new WeakMap();
function W9(e) {
  if (QD()) {
    if (Uc === "default") {
      const t = ka(e);
      uI = t.documentElement.style.webkitUserSelect, t.documentElement.style.webkitUserSelect = "none";
    }
    Uc = "disabled";
  } else (e instanceof HTMLElement || e instanceof SVGElement) && (yg.set(e, e.style.userSelect), e.style.userSelect = "none");
}
function Jm(e) {
  if (QD()) {
    if (Uc !== "disabled") return;
    Uc = "restoring", setTimeout(() => {
      fZ(() => {
        if (Uc === "restoring") {
          const t = ka(e);
          t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = uI || ""), uI = "", Uc = "default";
        }
      });
    }, 300);
  } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && yg.has(e)) {
    let t = yg.get(e);
    e.style.userSelect === "none" && (e.style.userSelect = t), e.getAttribute("style") === "" && e.removeAttribute("style"), yg.delete(e);
  }
}
const gZ = kt.createContext({
  register: () => {
  }
});
gZ.displayName = "PressResponderContext";
function n8e(e, t) {
  return t.get ? t.get.call(e) : t.value;
}
function bZ(e, t, r) {
  if (!t.has(e)) throw new TypeError("attempted to " + r + " private field on non-instance");
  return t.get(e);
}
function i8e(e, t) {
  var r = bZ(e, t, "get");
  return n8e(e, r);
}
function a8e(e, t, r) {
  if (t.set) t.set.call(e, r);
  else {
    if (!t.writable)
      throw new TypeError("attempted to set read only private field");
    t.value = r;
  }
}
function K9(e, t, r) {
  var n = bZ(e, t, "set");
  return a8e(e, n, r), r;
}
function s8e(e) {
  let t = Ta(gZ);
  if (t) {
    let { register: r, ...n } = t;
    e = Ou(n, e), r();
  }
  return W$e(t, e.ref), e;
}
var Qm = /* @__PURE__ */ new WeakMap();
class eg {
  continuePropagation() {
    K9(this, Qm, !1);
  }
  get shouldStopPropagation() {
    return i8e(this, Qm);
  }
  constructor(t, r, n, a) {
    Dh(this, Qm, {
      writable: !0,
      value: void 0
    }), K9(this, Qm, !0);
    var s;
    let i = (s = a?.target) !== null && s !== void 0 ? s : n.currentTarget;
    const o = i?.getBoundingClientRect();
    let l, u = 0, c, d = null;
    n.clientX != null && n.clientY != null && (c = n.clientX, d = n.clientY), o && (c != null && d != null ? (l = c - o.left, u = d - o.top) : (l = o.width / 2, u = o.height / 2)), this.type = t, this.pointerType = r, this.target = n.currentTarget, this.shiftKey = n.shiftKey, this.metaKey = n.metaKey, this.ctrlKey = n.ctrlKey, this.altKey = n.altKey, this.x = l, this.y = u;
  }
}
const Y9 = Symbol("linkClicked");
function o8e(e) {
  let {
    onPress: t,
    onPressChange: r,
    onPressStart: n,
    onPressEnd: a,
    onPressUp: s,
    isDisabled: i,
    isPressed: o,
    preventFocusOnPress: l,
    shouldCancelOnPointerExit: u,
    allowTextSelectionOnPress: c,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: d,
    ...p
  } = s8e(e), [f, h] = Wn(!1), m = Gr({
    isPressed: !1,
    ignoreEmulatedMouseEvents: !1,
    ignoreClickAfterPress: !1,
    didFirePressStart: !1,
    isTriggeringEvent: !1,
    activePointerId: null,
    target: null,
    isOverTarget: !1,
    pointerType: null
  }), { addGlobalListener: y, removeAllGlobalListeners: b } = pZ(), v = oa((k, S) => {
    let B = m.current;
    if (i || B.didFirePressStart) return !1;
    let U = !0;
    if (B.isTriggeringEvent = !0, n) {
      let N = new eg("pressstart", S, k);
      n(N), U = N.shouldStopPropagation;
    }
    return r && r(!0), B.isTriggeringEvent = !1, B.didFirePressStart = !0, h(!0), U;
  }), x = oa((k, S, B = !0) => {
    let U = m.current;
    if (!U.didFirePressStart) return !1;
    U.ignoreClickAfterPress = !0, U.didFirePressStart = !1, U.isTriggeringEvent = !0;
    let N = !0;
    if (a) {
      let O = new eg("pressend", S, k);
      a(O), N = O.shouldStopPropagation;
    }
    if (r && r(!1), h(!1), t && B && !i) {
      let O = new eg("press", S, k);
      t(O), N && (N = O.shouldStopPropagation);
    }
    return U.isTriggeringEvent = !1, N;
  }), _ = oa((k, S) => {
    let B = m.current;
    if (i) return !1;
    if (s) {
      B.isTriggeringEvent = !0;
      let U = new eg("pressup", S, k);
      return s(U), B.isTriggeringEvent = !1, U.shouldStopPropagation;
    }
    return !0;
  }), E = oa((k) => {
    let S = m.current;
    S.isPressed && S.target && (S.isOverTarget && S.pointerType != null && x(Co(S.target, k), S.pointerType, !1), S.isPressed = !1, S.isOverTarget = !1, S.activePointerId = null, S.pointerType = null, b(), c || Jm(S.target));
  }), w = oa((k) => {
    u && E(k);
  }), C = Or(() => {
    let k = m.current, S = {
      onKeyDown(U) {
        if (fT(U.nativeEvent, U.currentTarget) && U.currentTarget.contains(U.target)) {
          var N;
          Z9(U.target, U.key) && U.preventDefault();
          let O = !0;
          if (!k.isPressed && !U.repeat) {
            k.target = U.currentTarget, k.isPressed = !0, O = v(U, "keyboard");
            let I = U.currentTarget, q = (ae) => {
              fT(ae, I) && !ae.repeat && I.contains(ae.target) && k.target && _(Co(k.target, ae), "keyboard");
            };
            y(ka(U.currentTarget), "keyup", uZ(q, B), !0);
          }
          O && U.stopPropagation(), U.metaKey && Ed() && ((N = k.metaKeyEvents) === null || N === void 0 || N.set(U.key, U.nativeEvent));
        } else U.key === "Meta" && (k.metaKeyEvents = /* @__PURE__ */ new Map());
      },
      onClick(U) {
        if (!(U && !U.currentTarget.contains(U.target)) && U && U.button === 0 && !k.isTriggeringEvent && !Qp.isOpening) {
          let N = !0;
          if (i && U.preventDefault(), !k.ignoreClickAfterPress && !k.ignoreEmulatedMouseEvents && !k.isPressed && (k.pointerType === "virtual" || lI(U.nativeEvent))) {
            !i && !l && yu(U.currentTarget);
            let O = v(U, "virtual"), I = _(U, "virtual"), q = x(U, "virtual");
            N = O && I && q;
          }
          k.ignoreEmulatedMouseEvents = !1, k.ignoreClickAfterPress = !1, N && U.stopPropagation();
        }
      }
    }, B = (U) => {
      var N;
      if (k.isPressed && k.target && fT(U, k.target)) {
        var O;
        Z9(U.target, U.key) && U.preventDefault();
        let q = U.target;
        x(Co(k.target, U), "keyboard", k.target.contains(q)), b(), U.key !== "Enter" && e2(k.target) && k.target.contains(q) && !U[Y9] && (U[Y9] = !0, Qp(k.target, U, !1)), k.isPressed = !1, (O = k.metaKeyEvents) === null || O === void 0 || O.delete(U.key);
      } else if (U.key === "Meta" && (!((N = k.metaKeyEvents) === null || N === void 0) && N.size)) {
        var I;
        let q = k.metaKeyEvents;
        k.metaKeyEvents = void 0;
        for (let ae of q.values()) (I = k.target) === null || I === void 0 || I.dispatchEvent(new KeyboardEvent("keyup", ae));
      }
    };
    if (typeof PointerEvent < "u") {
      S.onPointerDown = (I) => {
        if (I.button !== 0 || !I.currentTarget.contains(I.target)) return;
        if (e8e(I.nativeEvent)) {
          k.pointerType = "virtual";
          return;
        }
        hT(I.currentTarget) && I.preventDefault(), k.pointerType = I.pointerType;
        let q = !0;
        if (!k.isPressed) {
          k.isPressed = !0, k.isOverTarget = !0, k.activePointerId = I.pointerId, k.target = I.currentTarget, !i && !l && yu(I.currentTarget), c || W9(k.target), q = v(I, k.pointerType);
          let ae = I.target;
          "releasePointerCapture" in ae && ae.releasePointerCapture(I.pointerId), y(ka(I.currentTarget), "pointerup", U, !1), y(ka(I.currentTarget), "pointercancel", O, !1);
        }
        q && I.stopPropagation();
      }, S.onMouseDown = (I) => {
        I.currentTarget.contains(I.target) && I.button === 0 && (hT(I.currentTarget) && I.preventDefault(), I.stopPropagation());
      }, S.onPointerUp = (I) => {
        !I.currentTarget.contains(I.target) || k.pointerType === "virtual" || I.button === 0 && _(I, k.pointerType || I.pointerType);
      }, S.onPointerEnter = (I) => {
        I.pointerId === k.activePointerId && k.target && !k.isOverTarget && k.pointerType != null && (k.isOverTarget = !0, v(Co(k.target, I), k.pointerType));
      }, S.onPointerLeave = (I) => {
        I.pointerId === k.activePointerId && k.target && k.isOverTarget && k.pointerType != null && (k.isOverTarget = !1, x(Co(k.target, I), k.pointerType, !1), w(I));
      };
      let U = (I) => {
        I.pointerId === k.activePointerId && k.isPressed && I.button === 0 && k.target && (k.target.contains(I.target) && k.pointerType != null ? x(Co(k.target, I), k.pointerType) : k.isOverTarget && k.pointerType != null && x(Co(k.target, I), k.pointerType, !1), k.isPressed = !1, k.isOverTarget = !1, k.activePointerId = null, k.pointerType = null, b(), c || Jm(k.target), "ontouchend" in k.target && I.pointerType !== "mouse" && y(k.target, "touchend", N, {
          once: !0
        }));
      }, N = (I) => {
        yZ(I.currentTarget) && I.preventDefault();
      }, O = (I) => {
        E(I);
      };
      S.onDragStart = (I) => {
        I.currentTarget.contains(I.target) && E(I);
      };
    } else {
      S.onMouseDown = (O) => {
        if (O.button !== 0 || !O.currentTarget.contains(O.target)) return;
        if (hT(O.currentTarget) && O.preventDefault(), k.ignoreEmulatedMouseEvents) {
          O.stopPropagation();
          return;
        }
        k.isPressed = !0, k.isOverTarget = !0, k.target = O.currentTarget, k.pointerType = lI(O.nativeEvent) ? "virtual" : "mouse", !i && !l && yu(O.currentTarget), v(O, k.pointerType) && O.stopPropagation(), y(ka(O.currentTarget), "mouseup", U, !1);
      }, S.onMouseEnter = (O) => {
        if (!O.currentTarget.contains(O.target)) return;
        let I = !0;
        k.isPressed && !k.ignoreEmulatedMouseEvents && k.pointerType != null && (k.isOverTarget = !0, I = v(O, k.pointerType)), I && O.stopPropagation();
      }, S.onMouseLeave = (O) => {
        if (!O.currentTarget.contains(O.target)) return;
        let I = !0;
        k.isPressed && !k.ignoreEmulatedMouseEvents && k.pointerType != null && (k.isOverTarget = !1, I = x(O, k.pointerType, !1), w(O)), I && O.stopPropagation();
      }, S.onMouseUp = (O) => {
        O.currentTarget.contains(O.target) && !k.ignoreEmulatedMouseEvents && O.button === 0 && _(O, k.pointerType || "mouse");
      };
      let U = (O) => {
        if (O.button === 0) {
          if (k.isPressed = !1, b(), k.ignoreEmulatedMouseEvents) {
            k.ignoreEmulatedMouseEvents = !1;
            return;
          }
          k.target && pT(O, k.target) && k.pointerType != null ? x(Co(k.target, O), k.pointerType) : k.target && k.isOverTarget && k.pointerType != null && x(Co(k.target, O), k.pointerType, !1), k.isOverTarget = !1;
        }
      };
      S.onTouchStart = (O) => {
        if (!O.currentTarget.contains(O.target)) return;
        let I = l8e(O.nativeEvent);
        if (!I) return;
        k.activePointerId = I.identifier, k.ignoreEmulatedMouseEvents = !0, k.isOverTarget = !0, k.isPressed = !0, k.target = O.currentTarget, k.pointerType = "touch", !i && !l && yu(O.currentTarget), c || W9(k.target), v(wl(k.target, O), k.pointerType) && O.stopPropagation(), y(Du(O.currentTarget), "scroll", N, !0);
      }, S.onTouchMove = (O) => {
        if (!O.currentTarget.contains(O.target)) return;
        if (!k.isPressed) {
          O.stopPropagation();
          return;
        }
        let I = X9(O.nativeEvent, k.activePointerId), q = !0;
        I && pT(I, O.currentTarget) ? !k.isOverTarget && k.pointerType != null && (k.isOverTarget = !0, q = v(wl(k.target, O), k.pointerType)) : k.isOverTarget && k.pointerType != null && (k.isOverTarget = !1, q = x(wl(k.target, O), k.pointerType, !1), w(wl(k.target, O))), q && O.stopPropagation();
      }, S.onTouchEnd = (O) => {
        if (!O.currentTarget.contains(O.target)) return;
        if (!k.isPressed) {
          O.stopPropagation();
          return;
        }
        let I = X9(O.nativeEvent, k.activePointerId), q = !0;
        I && pT(I, O.currentTarget) && k.pointerType != null ? (_(wl(k.target, O), k.pointerType), q = x(wl(k.target, O), k.pointerType)) : k.isOverTarget && k.pointerType != null && (q = x(wl(k.target, O), k.pointerType, !1)), q && O.stopPropagation(), k.isPressed = !1, k.activePointerId = null, k.isOverTarget = !1, k.ignoreEmulatedMouseEvents = !0, k.target && !c && Jm(k.target), b();
      }, S.onTouchCancel = (O) => {
        O.currentTarget.contains(O.target) && (O.stopPropagation(), k.isPressed && E(wl(k.target, O)));
      };
      let N = (O) => {
        k.isPressed && O.target.contains(k.target) && E({
          currentTarget: k.target,
          shiftKey: !1,
          ctrlKey: !1,
          metaKey: !1,
          altKey: !1
        });
      };
      S.onDragStart = (O) => {
        O.currentTarget.contains(O.target) && E(O);
      };
    }
    return S;
  }, [
    y,
    i,
    l,
    b,
    c,
    E,
    w,
    x,
    v,
    _
  ]);
  return Qn(() => () => {
    var k;
    c || Jm((k = m.current.target) !== null && k !== void 0 ? k : void 0);
  }, [
    c
  ]), {
    isPressed: o || f,
    pressProps: Ou(p, C)
  };
}
function e2(e) {
  return e.tagName === "A" && e.hasAttribute("href");
}
function fT(e, t) {
  const { key: r, code: n } = e, a = t, s = a.getAttribute("role");
  return (r === "Enter" || r === " " || r === "Spacebar" || n === "Space") && !(a instanceof Du(a).HTMLInputElement && !vZ(a, r) || a instanceof Du(a).HTMLTextAreaElement || a.isContentEditable) && // Links should only trigger with Enter key
  !((s === "link" || !s && e2(a)) && r !== "Enter");
}
function l8e(e) {
  const { targetTouches: t } = e;
  return t.length > 0 ? t[0] : null;
}
function X9(e, t) {
  const r = e.changedTouches;
  for (let n = 0; n < r.length; n++) {
    const a = r[n];
    if (a.identifier === t) return a;
  }
  return null;
}
function wl(e, t) {
  let r = 0, n = 0;
  return t.targetTouches && t.targetTouches.length === 1 && (r = t.targetTouches[0].clientX, n = t.targetTouches[0].clientY), {
    currentTarget: e,
    shiftKey: t.shiftKey,
    ctrlKey: t.ctrlKey,
    metaKey: t.metaKey,
    altKey: t.altKey,
    clientX: r,
    clientY: n
  };
}
function Co(e, t) {
  let r = t.clientX, n = t.clientY;
  return {
    currentTarget: e,
    shiftKey: t.shiftKey,
    ctrlKey: t.ctrlKey,
    metaKey: t.metaKey,
    altKey: t.altKey,
    clientX: r,
    clientY: n
  };
}
function u8e(e) {
  let t = 0, r = 0;
  return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX), e.height !== void 0 ? r = e.height / 2 : e.radiusY !== void 0 && (r = e.radiusY), {
    top: e.clientY - r,
    right: e.clientX + t,
    bottom: e.clientY + r,
    left: e.clientX - t
  };
}
function c8e(e, t) {
  return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom);
}
function pT(e, t) {
  let r = t.getBoundingClientRect(), n = u8e(e);
  return c8e(r, n);
}
function hT(e) {
  return !(e instanceof HTMLElement) || !e.hasAttribute("draggable");
}
function yZ(e) {
  return e instanceof HTMLInputElement ? !1 : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !e2(e);
}
function Z9(e, t) {
  return e instanceof HTMLInputElement ? !vZ(e, t) : yZ(e);
}
const d8e = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function vZ(e, t) {
  return e.type === "checkbox" || e.type === "radio" ? t === " " : d8e.has(e.type);
}
class f8e {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(t, r) {
    this.nativeEvent = r, this.target = r.target, this.currentTarget = r.currentTarget, this.relatedTarget = r.relatedTarget, this.bubbles = r.bubbles, this.cancelable = r.cancelable, this.defaultPrevented = r.defaultPrevented, this.eventPhase = r.eventPhase, this.isTrusted = r.isTrusted, this.timeStamp = r.timeStamp, this.type = t;
  }
}
function p8e(e) {
  let t = Gr({
    isFocused: !1,
    observer: null
  });
  tl(() => {
    const n = t.current;
    return () => {
      n.observer && (n.observer.disconnect(), n.observer = null);
    };
  }, []);
  let r = oa((n) => {
    e?.(n);
  });
  return ci((n) => {
    if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
      t.current.isFocused = !0;
      let a = n.target, s = (i) => {
        t.current.isFocused = !1, a.disabled && r(new f8e("blur", i)), t.current.observer && (t.current.observer.disconnect(), t.current.observer = null);
      };
      a.addEventListener("focusout", s, {
        once: !0
      }), t.current.observer = new MutationObserver(() => {
        if (t.current.isFocused && a.disabled) {
          var i;
          (i = t.current.observer) === null || i === void 0 || i.disconnect();
          let o = a === document.activeElement ? null : document.activeElement;
          a.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: o
          })), a.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: o
          }));
        }
      }), t.current.observer.observe(a, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    r
  ]);
}
let Bd = null, h8e = /* @__PURE__ */ new Set(), ap = /* @__PURE__ */ new Map(), Pu = !1, cI = !1;
function Fy(e, t) {
  for (let r of h8e) r(e, t);
}
function m8e(e) {
  return !(e.metaKey || !Ed() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function mb(e) {
  Pu = !0, m8e(e) && (Bd = "keyboard", Fy("keyboard", e));
}
function rs(e) {
  Bd = "pointer", (e.type === "mousedown" || e.type === "pointerdown") && (Pu = !0, Fy("pointer", e));
}
function wZ(e) {
  lI(e) && (Pu = !0, Bd = "virtual");
}
function xZ(e) {
  e.target === window || e.target === document || (!Pu && !cI && (Bd = "virtual", Fy("virtual", e)), Pu = !1, cI = !1);
}
function EZ() {
  Pu = !1, cI = !0;
}
function J9(e) {
  if (typeof window > "u" || ap.get(Du(e))) return;
  const t = Du(e), r = ka(e);
  let n = t.HTMLElement.prototype.focus;
  t.HTMLElement.prototype.focus = function() {
    Pu = !0, n.apply(this, arguments);
  }, r.addEventListener("keydown", mb, !0), r.addEventListener("keyup", mb, !0), r.addEventListener("click", wZ, !0), t.addEventListener("focus", xZ, !0), t.addEventListener("blur", EZ, !1), typeof PointerEvent < "u" ? (r.addEventListener("pointerdown", rs, !0), r.addEventListener("pointermove", rs, !0), r.addEventListener("pointerup", rs, !0)) : (r.addEventListener("mousedown", rs, !0), r.addEventListener("mousemove", rs, !0), r.addEventListener("mouseup", rs, !0)), t.addEventListener("beforeunload", () => {
    SZ(e);
  }, {
    once: !0
  }), ap.set(t, {
    focus: n
  });
}
const SZ = (e, t) => {
  const r = Du(e), n = ka(e);
  t && n.removeEventListener("DOMContentLoaded", t), ap.has(r) && (r.HTMLElement.prototype.focus = ap.get(r).focus, n.removeEventListener("keydown", mb, !0), n.removeEventListener("keyup", mb, !0), n.removeEventListener("click", wZ, !0), r.removeEventListener("focus", xZ, !0), r.removeEventListener("blur", EZ, !1), typeof PointerEvent < "u" ? (n.removeEventListener("pointerdown", rs, !0), n.removeEventListener("pointermove", rs, !0), n.removeEventListener("pointerup", rs, !0)) : (n.removeEventListener("mousedown", rs, !0), n.removeEventListener("mousemove", rs, !0), n.removeEventListener("mouseup", rs, !0)), ap.delete(r));
};
function g8e(e) {
  const t = ka(e);
  let r;
  return t.readyState !== "loading" ? J9(e) : (r = () => {
    J9(e);
  }, t.addEventListener("DOMContentLoaded", r)), () => SZ(e, r);
}
typeof document < "u" && g8e();
function b8e() {
  return Bd;
}
function y8e(e) {
  Bd = e, Fy(e, null);
}
function v8e(e) {
  let { isDisabled: t, onBlurWithin: r, onFocusWithin: n, onFocusWithinChange: a } = e, s = Gr({
    isFocusWithin: !1
  }), i = ci((u) => {
    s.current.isFocusWithin && !u.currentTarget.contains(u.relatedTarget) && (s.current.isFocusWithin = !1, r && r(u), a && a(!1));
  }, [
    r,
    a,
    s
  ]), o = p8e(i), l = ci((u) => {
    !s.current.isFocusWithin && document.activeElement === u.target && (n && n(u), a && a(!0), s.current.isFocusWithin = !0, o(u));
  }, [
    n,
    a,
    o
  ]);
  return t ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: l,
      onBlur: i
    }
  };
}
function w8e(e) {
  const t = ka(e);
  if (b8e() === "virtual") {
    let r = t.activeElement;
    fZ(() => {
      t.activeElement === r && e.isConnected && yu(e);
    });
  } else yu(e);
}
function x8e(e) {
  const t = Du(e);
  if (!(e instanceof t.HTMLElement) && !(e instanceof t.SVGElement)) return !1;
  let { display: r, visibility: n } = e.style, a = r !== "none" && n !== "hidden" && n !== "collapse";
  if (a) {
    const { getComputedStyle: s } = e.ownerDocument.defaultView;
    let { display: i, visibility: o } = s(e);
    a = i !== "none" && o !== "hidden" && o !== "collapse";
  }
  return a;
}
function E8e(e, t) {
  return !e.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !e.hasAttribute("data-react-aria-prevent-focus") && (e.nodeName === "DETAILS" && t && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0);
}
function _Z(e, t) {
  return e.nodeName !== "#comment" && x8e(e) && E8e(e, t) && (!e.parentElement || _Z(e.parentElement, e));
}
const t2 = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])'
], S8e = t2.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
t2.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const _8e = t2.join(':not([hidden]):not([tabindex="-1"]),');
function kZ(e, t) {
  return !e || !t ? !1 : t.some((r) => r.contains(e));
}
function Cf(e, t = !1) {
  if (e != null && !t) try {
    w8e(e);
  } catch {
  }
  else if (e != null) try {
    e.focus();
  } catch {
  }
}
function Hf(e, t, r) {
  let n = t?.tabbable ? _8e : S8e, a = ka(e).createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode(s) {
      var i;
      return !(t == null || (i = t.from) === null || i === void 0) && i.contains(s) ? NodeFilter.FILTER_REJECT : s.matches(n) && _Z(s) && (!r || kZ(s, r)) && (!t?.accept || t.accept(s)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  return t?.from && (a.currentNode = t.from), a;
}
function CZ(e, t = {}) {
  return {
    focusNext(r = {}) {
      let n = e.current;
      if (!n) return null;
      let { from: a, tabbable: s = t.tabbable, wrap: i = t.wrap, accept: o = t.accept } = r, l = a || ka(n).activeElement, u = Hf(n, {
        tabbable: s,
        accept: o
      });
      n.contains(l) && (u.currentNode = l);
      let c = u.nextNode();
      return !c && i && (u.currentNode = n, c = u.nextNode()), c && Cf(c, !0), c;
    },
    focusPrevious(r = t) {
      let n = e.current;
      if (!n) return null;
      let { from: a, tabbable: s = t.tabbable, wrap: i = t.wrap, accept: o = t.accept } = r, l = a || ka(n).activeElement, u = Hf(n, {
        tabbable: s,
        accept: o
      });
      if (n.contains(l)) u.currentNode = l;
      else {
        let d = mT(u);
        return d && Cf(d, !0), d ?? null;
      }
      let c = u.previousNode();
      if (!c && i) {
        u.currentNode = n;
        let d = mT(u);
        if (!d)
          return null;
        c = d;
      }
      return c && Cf(c, !0), c ?? null;
    },
    focusFirst(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: a = t.tabbable, accept: s = t.accept } = r, o = Hf(n, {
        tabbable: a,
        accept: s
      }).nextNode();
      return o && Cf(o, !0), o;
    },
    focusLast(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: a = t.tabbable, accept: s = t.accept } = r, i = Hf(n, {
        tabbable: a,
        accept: s
      }), o = mT(i);
      return o && Cf(o, !0), o ?? null;
    }
  };
}
function mT(e) {
  let t, r;
  do
    r = e.lastChild(), r && (t = r);
  while (r);
  return t;
}
class r2 {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(t) {
    return this.fastMap.get(t);
  }
  addTreeNode(t, r, n) {
    let a = this.fastMap.get(r ?? null);
    if (!a) return;
    let s = new Q9({
      scopeRef: t
    });
    a.addChild(s), s.parent = a, this.fastMap.set(t, s), n && (s.nodeToRestore = n);
  }
  addNode(t) {
    this.fastMap.set(t.scopeRef, t);
  }
  removeTreeNode(t) {
    if (t === null) return;
    let r = this.fastMap.get(t);
    if (!r) return;
    let n = r.parent;
    for (let s of this.traverse()) s !== r && r.nodeToRestore && s.nodeToRestore && r.scopeRef && r.scopeRef.current && kZ(s.nodeToRestore, r.scopeRef.current) && (s.nodeToRestore = r.nodeToRestore);
    let a = r.children;
    n && (n.removeChild(r), a.size > 0 && a.forEach((s) => n && n.addChild(s))), this.fastMap.delete(r.scopeRef);
  }
  // Pre Order Depth First
  *traverse(t = this.root) {
    if (t.scopeRef != null && (yield t), t.children.size > 0) for (let r of t.children) yield* this.traverse(r);
  }
  clone() {
    var t;
    let r = new r2();
    var n;
    for (let a of this.traverse()) r.addTreeNode(a.scopeRef, (n = (t = a.parent) === null || t === void 0 ? void 0 : t.scopeRef) !== null && n !== void 0 ? n : null, a.nodeToRestore);
    return r;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map(), this.root = new Q9({
      scopeRef: null
    }), this.fastMap.set(null, this.root);
  }
}
class Q9 {
  addChild(t) {
    this.children.add(t), t.parent = this;
  }
  removeChild(t) {
    this.children.delete(t), t.parent = void 0;
  }
  constructor(t) {
    this.children = /* @__PURE__ */ new Set(), this.contain = !1, this.scopeRef = t.scopeRef;
  }
}
new r2();
const k8e = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]), C8e = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function A8e(e) {
  if (Intl.Locale) {
    let r = new Intl.Locale(e).maximize(), n = typeof r.getTextInfo == "function" ? r.getTextInfo() : r.textInfo;
    if (n) return n.direction === "rtl";
    if (r.script) return k8e.has(r.script);
  }
  let t = e.split("-")[0];
  return C8e.has(t);
}
const T8e = Symbol.for("react-aria.i18n.locale");
function AZ() {
  let e = typeof window < "u" && window[T8e] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      e
    ]);
  } catch {
    e = "en-US";
  }
  return {
    locale: e,
    direction: A8e(e) ? "rtl" : "ltr"
  };
}
let dI = AZ(), Vf = /* @__PURE__ */ new Set();
function eU() {
  dI = AZ();
  for (let e of Vf) e(dI);
}
function R8e() {
  let e = lZ(), [t, r] = Wn(dI);
  return Qn(() => (Vf.size === 0 && window.addEventListener("languagechange", eU), Vf.add(r), () => {
    Vf.delete(r), Vf.size === 0 && window.removeEventListener("languagechange", eU);
  }), []), e ? {
    locale: "en-US",
    direction: "ltr"
  } : t;
}
const I8e = /* @__PURE__ */ kt.createContext(null);
function Ud() {
  let e = R8e();
  return Ta(I8e) || e;
}
const N8e = Symbol.for("react-aria.i18n.locale"), D8e = Symbol.for("react-aria.i18n.strings");
let Ec;
class Ku {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(t, r) {
    let a = this.getStringsForLocale(r)[t];
    if (!a) throw new Error(`Could not find intl message ${t} in ${r} locale`);
    return a;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(t) {
    let r = this.strings[t];
    return r || (r = O8e(t, this.strings, this.defaultLocale), this.strings[t] = r), r;
  }
  static getGlobalDictionaryForPackage(t) {
    if (typeof window > "u") return null;
    let r = window[N8e];
    if (Ec === void 0) {
      let a = window[D8e];
      if (!a) return null;
      Ec = {};
      for (let s in a) Ec[s] = new Ku({
        [r]: a[s]
      }, r);
    }
    let n = Ec?.[t];
    if (!n) throw new Error(`Strings for package "${t}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return n;
  }
  constructor(t, r = "en-US") {
    this.strings = Object.fromEntries(Object.entries(t).filter(([, n]) => n)), this.defaultLocale = r;
  }
}
function O8e(e, t, r = "en-US") {
  if (t[e]) return t[e];
  let n = P8e(e);
  if (t[n]) return t[n];
  for (let a in t)
    if (a.startsWith(n + "-")) return t[a];
  return t[r];
}
function P8e(e) {
  return Intl.Locale ? new Intl.Locale(e).language : e.split("-")[0];
}
const tU = /* @__PURE__ */ new Map(), rU = /* @__PURE__ */ new Map();
class TZ {
  /** Formats a localized string for the given key with the provided variables. */
  format(t, r) {
    let n = this.strings.getStringForLocale(t, this.locale);
    return typeof n == "function" ? n(r, this) : n;
  }
  plural(t, r, n = "cardinal") {
    let a = r["=" + t];
    if (a) return typeof a == "function" ? a() : a;
    let s = this.locale + ":" + n, i = tU.get(s);
    i || (i = new Intl.PluralRules(this.locale, {
      type: n
    }), tU.set(s, i));
    let o = i.select(t);
    return a = r[o] || r.other, typeof a == "function" ? a() : a;
  }
  number(t) {
    let r = rU.get(this.locale);
    return r || (r = new Intl.NumberFormat(this.locale), rU.set(this.locale, r)), r.format(t);
  }
  select(t, r) {
    let n = t[r] || t.other;
    return typeof n == "function" ? n() : n;
  }
  constructor(t, r) {
    this.locale = t, this.strings = r;
  }
}
const nU = /* @__PURE__ */ new WeakMap();
function L8e(e) {
  let t = nU.get(e);
  return t || (t = new Ku(e), nU.set(e, t)), t;
}
function RZ(e, t) {
  return t && Ku.getGlobalDictionaryForPackage(t) || L8e(e);
}
function IZ(e, t) {
  let { locale: r } = Ud(), n = RZ(e, t);
  return Or(() => new TZ(r, n), [
    r,
    n
  ]);
}
function tg(e) {
  e = t8e(e ?? {}, M8e);
  let { locale: t } = Ud();
  return Or(() => new Bc(t, e), [
    t,
    e
  ]);
}
function M8e(e, t) {
  if (e === t) return !0;
  let r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (let a of r)
    if (t[a] !== e[a]) return !1;
  return !0;
}
let gT = /* @__PURE__ */ new Map(), fI = !1;
try {
  fI = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let gb = !1;
try {
  gb = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const NZ = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class F8e {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let r = "";
    if (!fI && this.options.signDisplay != null ? r = B8e(this.numberFormatter, this.options.signDisplay, t) : r = this.numberFormatter.format(t), this.options.style === "unit" && !gb) {
      var n;
      let { unit: a, unitDisplay: s = "short", locale: i } = this.resolvedOptions();
      if (!a) return r;
      let o = (n = NZ[a]) === null || n === void 0 ? void 0 : n[s];
      r += o[i] || o.default;
    }
    return r;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, r) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)} – ${this.format(r)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.numberFormatter.formatToParts(t), a = this.numberFormatter.formatToParts(r);
    return [
      ...n.map((s) => ({
        ...s,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...a.map((s) => ({
        ...s,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !fI && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !gb && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, r = {}) {
    this.numberFormatter = $8e(t, r), this.options = r;
  }
}
function $8e(e, t = {}) {
  let { numberingSystem: r } = t;
  if (r && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${r}`), t.style === "unit" && !gb) {
    var n;
    let { unit: i, unitDisplay: o = "short" } = t;
    if (!i) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((n = NZ[i]) === null || n === void 0) && n[o])) throw new Error(`Unsupported unit ${i} with unitDisplay = ${o}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let a = e + (t ? Object.entries(t).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : "");
  if (gT.has(a)) return gT.get(a);
  let s = new Intl.NumberFormat(e, t);
  return gT.set(a, s), s;
}
function B8e(e, t, r) {
  if (t === "auto") return e.format(r);
  if (t === "never") return e.format(Math.abs(r));
  {
    let n = !1;
    if (t === "always" ? n = r > 0 || Object.is(r, 0) : t === "exceptZero" && (Object.is(r, -0) || Object.is(r, 0) ? r = Math.abs(r) : n = r > 0), n) {
      let a = e.format(-r), s = e.format(r), i = a.replace(s, "").replace(/\u200e|\u061C/, "");
      return [
        ...i
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), a.replace(s, "!!!").replace(i, "+").replace("!!!", s);
    } else return e.format(r);
  }
}
const U8e = new RegExp("^.*\\(.*\\).*$"), z8e = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
class DZ {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return bT(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, r, n) {
    return bT(this.locale, this.options, t).isValidPartialNumber(t, r, n);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return bT(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, r = {}) {
    this.locale = t, this.options = r;
  }
}
const iU = /* @__PURE__ */ new Map();
function bT(e, t, r) {
  let n = aU(e, t);
  if (!e.includes("-nu-") && !n.isValidPartialNumber(r)) {
    for (let a of z8e) if (a !== n.options.numberingSystem) {
      let s = aU(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + a, t);
      if (s.isValidPartialNumber(r)) return s;
    }
  }
  return n;
}
function aU(e, t) {
  let r = e + (t ? Object.entries(t).sort((a, s) => a[0] < s[0] ? -1 : 1).join() : ""), n = iU.get(r);
  return n || (n = new q8e(e, t), iU.set(r, n)), n;
}
class q8e {
  parse(t) {
    let r = this.sanitize(t);
    if (this.symbols.group && (r = rg(r, this.symbols.group, "")), this.symbols.decimal && (r = r.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (r = r.replace(this.symbols.minusSign, "-")), r = r.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let i = r.indexOf("-");
      r = r.replace("-", "");
      let o = r.indexOf(".");
      o === -1 && (o = r.length), r = r.replace(".", ""), o - 2 === 0 ? r = `0.${r}` : o - 2 === -1 ? r = `0.0${r}` : o - 2 === -2 ? r = "0.00" : r = `${r.slice(0, o - 2)}.${r.slice(o - 2)}`, i > -1 && (r = `-${r}`);
    }
    let n = r ? +r : NaN;
    if (isNaN(n)) return NaN;
    if (this.options.style === "percent") {
      var a, s;
      let i = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) + 2, 20),
        maximumFractionDigits: Math.min(((s = this.options.maximumFractionDigits) !== null && s !== void 0 ? s : 0) + 2, 20)
      };
      return new DZ(this.locale, i).parse(new F8e(this.locale, i).format(n));
    }
    return this.options.currencySign === "accounting" && U8e.test(t) && (n = -1 * n), n;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("،", this.symbols.decimal)), this.symbols.group && (t = rg(t, ".", this.symbols.group))), this.options.locale === "fr-FR" && (t = rg(t, ".", " ")), t;
  }
  isValidPartialNumber(t, r = -1 / 0, n = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && r < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && n > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = rg(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, r = {}) {
    this.locale = t, this.formatter = new Intl.NumberFormat(t, r), this.options = this.formatter.resolvedOptions(), this.symbols = H8e(t, this.formatter, this.options, r);
    var n, a;
    this.options.style === "percent" && (((n = this.options.minimumFractionDigits) !== null && n !== void 0 ? n : 0) > 18 || ((a = this.options.maximumFractionDigits) !== null && a !== void 0 ? a : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const sU = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), j8e = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function H8e(e, t, r, n) {
  var a, s, i, o;
  let l = new Intl.NumberFormat(e, {
    ...r,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), u = l.formatToParts(-10000.111), c = l.formatToParts(10000.111), d = j8e.map((B) => l.formatToParts(B));
  var p;
  let f = (p = (a = u.find((B) => B.type === "minusSign")) === null || a === void 0 ? void 0 : a.value) !== null && p !== void 0 ? p : "-", h = (s = c.find((B) => B.type === "plusSign")) === null || s === void 0 ? void 0 : s.value;
  !h && (n?.signDisplay === "exceptZero" || n?.signDisplay === "always") && (h = "+");
  let y = (i = new Intl.NumberFormat(e, {
    ...r,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((B) => B.type === "decimal")) === null || i === void 0 ? void 0 : i.value, b = (o = u.find((B) => B.type === "group")) === null || o === void 0 ? void 0 : o.value, v = u.filter((B) => !sU.has(B.type)).map((B) => oU(B.value)), x = d.flatMap((B) => B.filter((U) => !sU.has(U.type)).map((U) => oU(U.value))), _ = [
    .../* @__PURE__ */ new Set([
      ...v,
      ...x
    ])
  ].sort((B, U) => U.length - B.length), E = _.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${_.join("|")}|[\\p{White_Space}]`, "gu"), w = [
    ...new Intl.NumberFormat(r.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), C = new Map(w.map((B, U) => [
    B,
    U
  ])), k = new RegExp(`[${w.join("")}]`, "g");
  return {
    minusSign: f,
    plusSign: h,
    decimal: y,
    group: b,
    literals: E,
    numeral: k,
    index: (B) => String(C.get(B))
  };
}
function rg(e, t, r) {
  return e.replaceAll ? e.replaceAll(t, r) : e.split(t).join(r);
}
function oU(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
let yT = /* @__PURE__ */ new Map();
function V8e(e) {
  let { locale: t } = Ud(), r = t + (e ? Object.entries(e).sort((a, s) => a[0] < s[0] ? -1 : 1).join() : "");
  if (yT.has(r)) return yT.get(r);
  let n = new Intl.Collator(t, e);
  return yT.set(r, n), n;
}
function G8e(e) {
  let t = V8e({
    usage: "search",
    ...e
  }), r = ci((s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), t.compare(s.slice(0, i.length), i) === 0), [
    t
  ]), n = ci((s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), t.compare(s.slice(-i.length), i) === 0), [
    t
  ]), a = ci((s, i) => {
    if (i.length === 0) return !0;
    s = s.normalize("NFC"), i = i.normalize("NFC");
    let o = 0, l = i.length;
    for (; o + l <= s.length; o++) {
      let u = s.slice(o, o + l);
      if (t.compare(i, u) === 0) return !0;
    }
    return !1;
  }, [
    t
  ]);
  return Or(() => ({
    startsWith: r,
    endsWith: n,
    contains: a
  }), [
    r,
    n,
    a
  ]);
}
function W8e(e, t, r) {
  let { direction: n } = Ud(), a = Or(() => CZ(t), [
    t
  ]), s = (l) => {
    if (l.currentTarget.contains(l.target) && (l.altKey && (l.key === "ArrowDown" || l.key === "ArrowUp") && "setOpen" in e && (l.preventDefault(), l.stopPropagation(), e.setOpen(!0)), !r))
      switch (l.key) {
        case "ArrowLeft":
          l.preventDefault(), l.stopPropagation(), n === "rtl" ? a.focusNext() : a.focusPrevious();
          break;
        case "ArrowRight":
          l.preventDefault(), l.stopPropagation(), n === "rtl" ? a.focusPrevious() : a.focusNext();
          break;
      }
  }, i = () => {
    var l;
    if (!t.current) return;
    let u = (l = window.event) === null || l === void 0 ? void 0 : l.target, c = Hf(t.current, {
      tabbable: !0
    });
    if (u && (c.currentNode = u, u = c.previousNode()), !u) {
      let d;
      do
        d = c.lastChild(), d && (u = d);
      while (d);
    }
    for (; u?.hasAttribute("data-placeholder"); ) {
      let d = c.previousNode();
      if (d && d.hasAttribute("data-placeholder")) u = d;
      else break;
    }
    u && u.focus();
  }, { pressProps: o } = o8e({
    preventFocusOnPress: !0,
    allowTextSelectionOnPress: !0,
    onPressStart(l) {
      l.pointerType === "mouse" && i();
    },
    onPress(l) {
      l.pointerType !== "mouse" && i();
    }
  });
  return Ou(o, {
    onKeyDown: s
  });
}
function K8e(e) {
  let { id: t, label: r, "aria-labelledby": n, "aria-label": a, labelElementType: s = "label" } = e;
  t = Jp(t);
  let i = Jp(), o = {};
  r ? (n = n ? `${i} ${n}` : i, o = {
    id: i,
    htmlFor: s === "label" ? t : void 0
  }) : !n && !a && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let l = hZ({
    id: t,
    "aria-label": a,
    "aria-labelledby": n
  });
  return {
    labelProps: o,
    fieldProps: l
  };
}
function Y8e(e) {
  let { description: t, errorMessage: r, isInvalid: n, validationState: a } = e, { labelProps: s, fieldProps: i } = K8e(e), o = H9([
    !!t,
    !!r,
    n,
    a
  ]), l = H9([
    !!t,
    !!r,
    n,
    a
  ]);
  return i = Ou(i, {
    "aria-describedby": [
      o,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      l,
      e["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  }), {
    labelProps: s,
    fieldProps: i,
    descriptionProps: {
      id: o
    },
    errorMessageProps: {
      id: l
    }
  };
}
function X8e(e, t, r) {
  let { validationBehavior: n, focus: a } = e;
  tl(() => {
    if (n === "native" && r?.current && !r.current.disabled) {
      let l = t.realtimeValidation.isInvalid ? t.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      r.current.setCustomValidity(l), r.current.hasAttribute("title") || (r.current.title = ""), t.realtimeValidation.isInvalid || t.updateValidation(J8e(r.current));
    }
  });
  let s = oa(() => {
    t.resetValidation();
  }), i = oa((l) => {
    var u;
    t.displayValidation.isInvalid || t.commitValidation();
    let c = r == null || (u = r.current) === null || u === void 0 ? void 0 : u.form;
    if (!l.defaultPrevented && r && c && Q8e(c) === r.current) {
      var d;
      a ? a() : (d = r.current) === null || d === void 0 || d.focus(), y8e("keyboard");
    }
    l.preventDefault();
  }), o = oa(() => {
    t.commitValidation();
  });
  Qn(() => {
    let l = r?.current;
    if (!l) return;
    let u = l.form;
    return l.addEventListener("invalid", i), l.addEventListener("change", o), u?.addEventListener("reset", s), () => {
      l.removeEventListener("invalid", i), l.removeEventListener("change", o), u?.removeEventListener("reset", s);
    };
  }, [
    r,
    i,
    o,
    s,
    n
  ]);
}
function Z8e(e) {
  let t = e.validity;
  return {
    badInput: t.badInput,
    customError: t.customError,
    patternMismatch: t.patternMismatch,
    rangeOverflow: t.rangeOverflow,
    rangeUnderflow: t.rangeUnderflow,
    stepMismatch: t.stepMismatch,
    tooLong: t.tooLong,
    tooShort: t.tooShort,
    typeMismatch: t.typeMismatch,
    valueMissing: t.valueMissing,
    valid: t.valid
  };
}
function J8e(e) {
  return {
    isInvalid: !e.validity.valid,
    validationDetails: Z8e(e),
    validationErrors: e.validationMessage ? [
      e.validationMessage
    ] : []
  };
}
function Q8e(e) {
  for (let t = 0; t < e.elements.length; t++) {
    let r = e.elements[t];
    if (!r.validity.valid) return r;
  }
  return null;
}
function eBe(e) {
  return e && e.__esModule ? e.default : e;
}
const OZ = /* @__PURE__ */ new WeakMap(), vT = "__role_" + Date.now(), tBe = "__focusManager_" + Date.now();
function rBe(e, t, r) {
  var n;
  let { isInvalid: a, validationErrors: s, validationDetails: i } = t.displayValidation, { labelProps: o, fieldProps: l, descriptionProps: u, errorMessageProps: c } = Y8e({
    ...e,
    labelElementType: "span",
    isInvalid: a,
    errorMessage: e.errorMessage || s
  }), d = Gr(null), { focusWithinProps: p } = v8e({
    ...e,
    onFocusWithin(B) {
      var U;
      d.current = t.value, (U = e.onFocus) === null || U === void 0 || U.call(e, B);
    },
    onBlurWithin: (B) => {
      var U;
      t.confirmPlaceholder(), t.value !== d.current && t.commitValidation(), (U = e.onBlur) === null || U === void 0 || U.call(e, B);
    },
    onFocusWithinChange: e.onFocusChange
  }), f = IZ(eBe(ZD), "@react-aria/datepicker"), h = t.maxGranularity === "hour" ? "selectedTimeDescription" : "selectedDateDescription", m = t.maxGranularity === "hour" ? "time" : "date", y = t.value ? f.format(h, {
    [m]: t.formatValue({
      month: "long"
    })
  }) : "", b = Z$e(y), v = e[vT] === "presentation" ? l["aria-describedby"] : [
    b["aria-describedby"],
    l["aria-describedby"]
  ].filter(Boolean).join(" ") || void 0, x = e[tBe], _ = Or(() => x || CZ(r), [
    x,
    r
  ]), E = W8e(t, r, e[vT] === "presentation");
  OZ.set(t, {
    ariaLabel: e["aria-label"],
    ariaLabelledBy: [
      o.id,
      e["aria-labelledby"]
    ].filter(Boolean).join(" ") || void 0,
    ariaDescribedBy: v,
    focusManager: _
  });
  let w = Gr(e.autoFocus), C;
  e[vT] === "presentation" ? C = {
    role: "presentation"
  } : C = Ou(l, {
    role: "group",
    "aria-disabled": e.isDisabled || void 0,
    "aria-describedby": v
  }), Qn(() => {
    w.current && _.focusFirst(), w.current = !1;
  }, [
    _
  ]), r8e(e.inputRef, t.value, t.setValue), X8e({
    ...e,
    focus() {
      _.focusFirst();
    }
  }, t, e.inputRef);
  let k = {
    type: "hidden",
    name: e.name,
    value: ((n = t.value) === null || n === void 0 ? void 0 : n.toString()) || "",
    disabled: e.isDisabled
  };
  e.validationBehavior === "native" && (k.type = "text", k.hidden = !0, k.required = e.isRequired, k.onChange = () => {
  });
  let S = B$e(e);
  return {
    labelProps: {
      ...o,
      onClick: () => {
        _.focusFirst();
      }
    },
    fieldProps: Ou(S, C, E, p, {
      onKeyDown(B) {
        e.onKeyDown && e.onKeyDown(B);
      },
      onKeyUp(B) {
        e.onKeyUp && e.onKeyUp(B);
      }
    }),
    inputProps: k,
    descriptionProps: u,
    errorMessageProps: c,
    isInvalid: a,
    validationErrors: s,
    validationDetails: i
  };
}
function nBe(e, t, r) {
  var n;
  let a = rBe(e, t, r);
  return a.inputProps.value = ((n = t.timeValue) === null || n === void 0 ? void 0 : n.toString()) || "", a;
}
const PZ = {
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valueMissing: !1,
  valid: !0
}, LZ = {
  ...PZ,
  customError: !0,
  valid: !1
}, Af = {
  isInvalid: !1,
  validationDetails: PZ,
  validationErrors: []
}, iBe = Ko({}), lU = "__formValidationState" + Date.now();
function aBe(e) {
  if (e[lU]) {
    let { realtimeValidation: t, displayValidation: r, updateValidation: n, resetValidation: a, commitValidation: s } = e[lU];
    return {
      realtimeValidation: t,
      displayValidation: r,
      updateValidation: n,
      resetValidation: a,
      commitValidation: s
    };
  }
  return sBe(e);
}
function sBe(e) {
  let { isInvalid: t, validationState: r, name: n, value: a, builtinValidation: s, validate: i, validationBehavior: o = "aria" } = e;
  r && (t || (t = r === "invalid"));
  let l = t !== void 0 ? {
    isInvalid: t,
    validationErrors: [],
    validationDetails: LZ
  } : null, u = Or(() => {
    if (!i || a == null) return null;
    let B = oBe(i, a);
    return uU(B);
  }, [
    i,
    a
  ]);
  s?.validationDetails.valid && (s = void 0);
  let c = Ta(iBe), d = Or(() => n ? Array.isArray(n) ? n.flatMap((B) => pI(c[B])) : pI(c[n]) : [], [
    c,
    n
  ]), [p, f] = Wn(c), [h, m] = Wn(!1);
  c !== p && (f(c), m(!1));
  let y = Or(() => uU(h ? [] : d), [
    h,
    d
  ]), b = Gr(Af), [v, x] = Wn(Af), _ = Gr(Af), E = () => {
    if (!w) return;
    C(!1);
    let B = u || s || b.current;
    wT(B, _.current) || (_.current = B, x(B));
  }, [w, C] = Wn(!1);
  return Qn(E), {
    realtimeValidation: l || y || u || s || Af,
    displayValidation: o === "native" ? l || y || v : l || y || u || s || v,
    updateValidation(B) {
      o === "aria" && !wT(v, B) ? x(B) : b.current = B;
    },
    resetValidation() {
      let B = Af;
      wT(B, _.current) || (_.current = B, x(B)), o === "native" && C(!1), m(!0);
    },
    commitValidation() {
      o === "native" && C(!0), m(!0);
    }
  };
}
function pI(e) {
  return e ? Array.isArray(e) ? e : [
    e
  ] : [];
}
function oBe(e, t) {
  if (typeof e == "function") {
    let r = e(t);
    if (r && typeof r != "boolean") return pI(r);
  }
  return [];
}
function uU(e) {
  return e.length ? {
    isInvalid: !0,
    validationErrors: e,
    validationDetails: LZ
  } : null;
}
function wT(e, t) {
  return e === t ? !0 : !!e && !!t && e.isInvalid === t.isInvalid && e.validationErrors.length === t.validationErrors.length && e.validationErrors.every((r, n) => r === t.validationErrors[n]) && Object.entries(e.validationDetails).every(([r, n]) => t.validationDetails[r] === n);
}
function lBe(e) {
  return e && e.__esModule ? e.default : e;
}
function uBe() {
  let { locale: e } = Ud(), t = RZ(lBe(ZD), "@react-aria/datepicker");
  return Or(() => {
    try {
      return new Intl.DisplayNames(e, {
        type: "dateTimeField"
      });
    } catch {
      return new cBe(e, t);
    }
  }, [
    e,
    t
  ]);
}
class cBe {
  of(t) {
    return this.dictionary.getStringForLocale(t, this.locale);
  }
  constructor(t, r) {
    this.locale = t, this.dictionary = r;
  }
}
var MZ = {};
MZ = {
  Empty: "فارغ"
};
var FZ = {};
FZ = {
  Empty: "Изпразни"
};
var $Z = {};
$Z = {
  Empty: "Prázdné"
};
var BZ = {};
BZ = {
  Empty: "Tom"
};
var UZ = {};
UZ = {
  Empty: "Leer"
};
var zZ = {};
zZ = {
  Empty: "Άδειο"
};
var qZ = {};
qZ = {
  Empty: "Empty"
};
var jZ = {};
jZ = {
  Empty: "Vacío"
};
var HZ = {};
HZ = {
  Empty: "Tühjenda"
};
var VZ = {};
VZ = {
  Empty: "Tyhjä"
};
var GZ = {};
GZ = {
  Empty: "Vide"
};
var WZ = {};
WZ = {
  Empty: "ריק"
};
var KZ = {};
KZ = {
  Empty: "Prazno"
};
var YZ = {};
YZ = {
  Empty: "Üres"
};
var XZ = {};
XZ = {
  Empty: "Vuoto"
};
var ZZ = {};
ZZ = {
  Empty: "空"
};
var JZ = {};
JZ = {
  Empty: "비어 있음"
};
var QZ = {};
QZ = {
  Empty: "Tuščias"
};
var eJ = {};
eJ = {
  Empty: "Tukšs"
};
var tJ = {};
tJ = {
  Empty: "Tom"
};
var rJ = {};
rJ = {
  Empty: "Leeg"
};
var nJ = {};
nJ = {
  Empty: "Pusty"
};
var iJ = {};
iJ = {
  Empty: "Vazio"
};
var aJ = {};
aJ = {
  Empty: "Vazio"
};
var sJ = {};
sJ = {
  Empty: "Gol"
};
var oJ = {};
oJ = {
  Empty: "Не заполнено"
};
var lJ = {};
lJ = {
  Empty: "Prázdne"
};
var uJ = {};
uJ = {
  Empty: "Prazen"
};
var cJ = {};
cJ = {
  Empty: "Prazno"
};
var dJ = {};
dJ = {
  Empty: "Tomt"
};
var fJ = {};
fJ = {
  Empty: "Boş"
};
var pJ = {};
pJ = {
  Empty: "Пусто"
};
var hJ = {};
hJ = {
  Empty: "空"
};
var mJ = {};
mJ = {
  Empty: "空白"
};
var gJ = {};
gJ = {
  "ar-AE": MZ,
  "bg-BG": FZ,
  "cs-CZ": $Z,
  "da-DK": BZ,
  "de-DE": UZ,
  "el-GR": zZ,
  "en-US": qZ,
  "es-ES": jZ,
  "et-EE": HZ,
  "fi-FI": VZ,
  "fr-FR": GZ,
  "he-IL": WZ,
  "hr-HR": KZ,
  "hu-HU": YZ,
  "it-IT": XZ,
  "ja-JP": ZZ,
  "ko-KR": JZ,
  "lt-LT": QZ,
  "lv-LV": eJ,
  "nb-NO": tJ,
  "nl-NL": rJ,
  "pl-PL": nJ,
  "pt-BR": iJ,
  "pt-PT": aJ,
  "ro-RO": sJ,
  "ru-RU": oJ,
  "sk-SK": lJ,
  "sl-SI": uJ,
  "sr-SP": cJ,
  "sv-SE": dJ,
  "tr-TR": fJ,
  "uk-UA": pJ,
  "zh-CN": hJ,
  "zh-TW": mJ
};
const bJ = 7e3;
let Qa = null;
function dBe(e, t = "assertive", r = bJ) {
  Qa ? Qa.announce(e, t, r) : (Qa = new pBe(), (typeof IS_REACT_ACT_ENVIRONMENT == "boolean" ? IS_REACT_ACT_ENVIRONMENT : typeof jest < "u") ? Qa.announce(e, t, r) : setTimeout(() => {
    Qa?.isAttached() && Qa?.announce(e, t, r);
  }, 100));
}
function fBe(e) {
  Qa && Qa.clear(e);
}
class pBe {
  isAttached() {
    var t;
    return (t = this.node) === null || t === void 0 ? void 0 : t.isConnected;
  }
  createLog(t) {
    let r = document.createElement("div");
    return r.setAttribute("role", "log"), r.setAttribute("aria-live", t), r.setAttribute("aria-relevant", "additions"), r;
  }
  destroy() {
    this.node && (document.body.removeChild(this.node), this.node = null);
  }
  announce(t, r = "assertive", n = bJ) {
    var a, s;
    if (!this.node) return;
    let i = document.createElement("div");
    typeof t == "object" ? (i.setAttribute("role", "img"), i.setAttribute("aria-labelledby", t["aria-labelledby"])) : i.textContent = t, r === "assertive" ? (a = this.assertiveLog) === null || a === void 0 || a.appendChild(i) : (s = this.politeLog) === null || s === void 0 || s.appendChild(i), t !== "" && setTimeout(() => {
      i.remove();
    }, n);
  }
  clear(t) {
    this.node && ((!t || t === "assertive") && this.assertiveLog && (this.assertiveLog.innerHTML = ""), (!t || t === "polite") && this.politeLog && (this.politeLog.innerHTML = ""));
  }
  constructor() {
    this.node = null, this.assertiveLog = null, this.politeLog = null, typeof document < "u" && (this.node = document.createElement("div"), this.node.dataset.liveAnnouncer = "true", Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    }), this.assertiveLog = this.createLog("assertive"), this.node.appendChild(this.assertiveLog), this.politeLog = this.createLog("polite"), this.node.appendChild(this.politeLog), document.body.prepend(this.node));
  }
}
function hBe(e) {
  return e && e.__esModule ? e.default : e;
}
function mBe(e) {
  const t = Gr(void 0);
  let { value: r, textValue: n, minValue: a, maxValue: s, isDisabled: i, isReadOnly: o, isRequired: l, onIncrement: u, onIncrementPage: c, onDecrement: d, onDecrementPage: p, onDecrementToMin: f, onIncrementToMax: h } = e;
  const m = IZ(hBe(gJ), "@react-aria/spinbutton"), y = () => clearTimeout(t.current);
  Qn(() => () => y(), []);
  let b = (U) => {
    if (!(U.ctrlKey || U.metaKey || U.shiftKey || U.altKey || o))
      switch (U.key) {
        case "PageUp":
          if (c) {
            U.preventDefault(), c?.();
            break;
          }
        // fallthrough!
        case "ArrowUp":
        case "Up":
          u && (U.preventDefault(), u?.());
          break;
        case "PageDown":
          if (p) {
            U.preventDefault(), p?.();
            break;
          }
        // fallthrough
        case "ArrowDown":
        case "Down":
          d && (U.preventDefault(), d?.());
          break;
        case "Home":
          f && (U.preventDefault(), f?.());
          break;
        case "End":
          h && (U.preventDefault(), h?.());
          break;
      }
  }, v = Gr(!1), x = () => {
    v.current = !0;
  }, _ = () => {
    v.current = !1;
  }, E = n === "" ? m.format("Empty") : (n || `${r}`).replace("-", "−");
  Qn(() => {
    v.current && (fBe("assertive"), dBe(E, "assertive"));
  }, [
    E
  ]);
  const w = oa((U) => {
    y(), u?.(), t.current = window.setTimeout(() => {
      (s === void 0 || isNaN(s) || r === void 0 || isNaN(r) || r < s) && w(60);
    }, U);
  }), C = oa((U) => {
    y(), d?.(), t.current = window.setTimeout(() => {
      (a === void 0 || isNaN(a) || r === void 0 || isNaN(r) || r > a) && C(60);
    }, U);
  });
  let k = (U) => {
    U.preventDefault();
  }, { addGlobalListener: S, removeAllGlobalListeners: B } = pZ();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": r !== void 0 && !isNaN(r) ? r : void 0,
      "aria-valuetext": E,
      "aria-valuemin": a,
      "aria-valuemax": s,
      "aria-disabled": i || void 0,
      "aria-readonly": o || void 0,
      "aria-required": l || void 0,
      onKeyDown: b,
      onFocus: x,
      onBlur: _
    },
    incrementButtonProps: {
      onPressStart: () => {
        w(400), S(window, "contextmenu", k);
      },
      onPressEnd: () => {
        y(), B();
      },
      onFocus: x,
      onBlur: _
    },
    decrementButtonProps: {
      onPressStart: () => {
        C(400), S(window, "contextmenu", k);
      },
      onPressEnd: () => {
        y(), B();
      },
      onFocus: x,
      onBlur: _
    }
  };
}
function gBe(e, t, r) {
  let n = Gr(""), { locale: a } = Ud(), s = uBe(), { ariaLabel: i, ariaLabelledBy: o, ariaDescribedBy: l, focusManager: u } = OZ.get(t), c = e.isPlaceholder ? "" : e.text, d = Or(() => t.dateFormatter.resolvedOptions(), [
    t.dateFormatter
  ]), p = tg({
    month: "long",
    timeZone: d.timeZone
  }), f = tg({
    hour: "numeric",
    hour12: d.hour12,
    timeZone: d.timeZone
  });
  if (e.type === "month" && !e.isPlaceholder) {
    let ne = p.format(t.dateValue);
    c = ne !== c ? `${c} – ${ne}` : ne;
  } else e.type === "hour" && !e.isPlaceholder && (c = f.format(t.dateValue));
  let { spinButtonProps: h } = mBe({
    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.
    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.
    // https://github.com/dequelabs/axe-core/issues/3505
    value: e.value,
    textValue: c,
    minValue: e.minValue,
    maxValue: e.maxValue,
    isDisabled: t.isDisabled,
    isReadOnly: t.isReadOnly || !e.isEditable,
    isRequired: t.isRequired,
    onIncrement: () => {
      n.current = "", t.increment(e.type);
    },
    onDecrement: () => {
      n.current = "", t.decrement(e.type);
    },
    onIncrementPage: () => {
      n.current = "", t.incrementPage(e.type);
    },
    onDecrementPage: () => {
      n.current = "", t.decrementPage(e.type);
    },
    onIncrementToMax: () => {
      n.current = "", e.maxValue !== void 0 && t.setSegment(e.type, e.maxValue);
    },
    onDecrementToMin: () => {
      n.current = "", e.minValue !== void 0 && t.setSegment(e.type, e.minValue);
    }
  }), m = Or(() => new DZ(a, {
    maximumFractionDigits: 0
  }), [
    a
  ]), y = () => {
    if (e.text === e.placeholder && u.focusPrevious(), m.isValidPartialNumber(e.text) && !t.isReadOnly && !e.isPlaceholder) {
      let ne = e.text.slice(0, -1), le = m.parse(ne);
      ne = le === 0 ? "" : ne, ne.length === 0 || le === 0 ? t.clearSegment(e.type) : t.setSegment(e.type, le), n.current = ne;
    } else e.type === "dayPeriod" && t.clearSegment(e.type);
  }, b = (ne) => {
    if (ne.key === "a" && (Ed() ? ne.metaKey : ne.ctrlKey) && ne.preventDefault(), !(ne.ctrlKey || ne.metaKey || ne.shiftKey || ne.altKey))
      switch (ne.key) {
        case "Backspace":
        case "Delete":
          ne.preventDefault(), ne.stopPropagation(), y();
          break;
      }
  }, { startsWith: v } = G8e({
    sensitivity: "base"
  }), x = tg({
    hour: "numeric",
    hour12: !0
  }), _ = Or(() => {
    let ne = /* @__PURE__ */ new Date();
    return ne.setHours(0), x.formatToParts(ne).find((le) => le.type === "dayPeriod").value;
  }, [
    x
  ]), E = Or(() => {
    let ne = /* @__PURE__ */ new Date();
    return ne.setHours(12), x.formatToParts(ne).find((le) => le.type === "dayPeriod").value;
  }, [
    x
  ]), w = tg({
    year: "numeric",
    era: "narrow",
    timeZone: "UTC"
  }), C = Or(() => {
    if (e.type !== "era") return [];
    let ne = la(new wd(1, 1, 1), t.calendar), le = t.calendar.getEras().map((X) => {
      let G = ne.set({
        year: 1,
        month: 1,
        day: 1,
        era: X
      }).toDate("UTC"), he = w.formatToParts(G).find((ye) => ye.type === "era").value;
      return {
        era: X,
        formatted: he
      };
    }), W = bBe(le.map((X) => X.formatted));
    if (W) for (let X of le) X.formatted = X.formatted.slice(W);
    return le;
  }, [
    w,
    t.calendar,
    e.type
  ]), k = (ne) => {
    if (t.isDisabled || t.isReadOnly) return;
    let le = n.current + ne;
    switch (e.type) {
      case "dayPeriod":
        if (v(_, ne)) t.setSegment("dayPeriod", 0);
        else if (v(E, ne)) t.setSegment("dayPeriod", 12);
        else break;
        u.focusNext();
        break;
      case "era": {
        let W = C.find((X) => v(X.formatted, ne));
        W && (t.setSegment("era", W.era), u.focusNext());
        break;
      }
      case "day":
      case "hour":
      case "minute":
      case "second":
      case "month":
      case "year": {
        if (!m.isValidPartialNumber(le)) return;
        let W = m.parse(le), X = W, G = e.minValue === 0;
        if (e.type === "hour" && t.dateFormatter.resolvedOptions().hour12) {
          switch (t.dateFormatter.resolvedOptions().hourCycle) {
            case "h11":
              W > 11 && (X = m.parse(ne));
              break;
            case "h12":
              G = !1, W > 12 && (X = m.parse(ne));
              break;
          }
          e.value !== void 0 && e.value >= 12 && W > 1 && (W += 12);
        } else e.maxValue !== void 0 && W > e.maxValue && (X = m.parse(ne));
        if (isNaN(W)) return;
        let P = X !== 0 || G;
        P && t.setSegment(e.type, X), e.maxValue !== void 0 && (+(W + "0") > e.maxValue || le.length >= String(e.maxValue).length) ? (n.current = "", P && u.focusNext()) : n.current = le;
        break;
      }
    }
  }, S = () => {
    n.current = "", r.current && Q$e(r.current, {
      containingElement: K$e(r.current)
    });
    let ne = window.getSelection();
    ne?.collapse(r.current);
  }, B = Gr(typeof document < "u" ? document : null);
  dT(B, "selectionchange", () => {
    var ne;
    let le = window.getSelection();
    le?.anchorNode && (!((ne = r.current) === null || ne === void 0) && ne.contains(le?.anchorNode)) && le.collapse(r.current);
  });
  let U = Gr("");
  dT(r, "beforeinput", (ne) => {
    if (r.current)
      switch (ne.preventDefault(), ne.inputType) {
        case "deleteContentBackward":
        case "deleteContentForward":
          m.isValidPartialNumber(e.text) && !t.isReadOnly && y();
          break;
        case "insertCompositionText":
          U.current = r.current.textContent, r.current.textContent = r.current.textContent;
          break;
        default:
          ne.data != null && k(ne.data);
          break;
      }
  }), dT(r, "input", (ne) => {
    let { inputType: le, data: W } = ne;
    switch (le) {
      case "insertCompositionText":
        r.current && (r.current.textContent = U.current), W != null && (v(_, W) || v(E, W)) && k(W);
        break;
    }
  }), tl(() => {
    let ne = r.current;
    return () => {
      document.activeElement === ne && (u.focusPrevious() || u.focusNext());
    };
  }, [
    r,
    u
  ]);
  let N = QD() || e.type === "timeZoneName" ? {
    role: "textbox",
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuetext": null,
    "aria-valuenow": null
  } : {}, O = Or(() => t.segments.find((ne) => ne.isEditable), [
    t.segments
  ]);
  e !== O && !t.isInvalid && (l = void 0);
  let I = Jp(), q = !t.isDisabled && !t.isReadOnly && e.isEditable, ae = e.type === "literal" ? "" : s.of(e.type), Q = hZ({
    "aria-label": `${ae}${i ? `, ${i}` : ""}${o ? ", " : ""}`,
    "aria-labelledby": o
  });
  return e.type === "literal" ? {
    segmentProps: {
      "aria-hidden": !0
    }
  } : {
    segmentProps: Ou(h, Q, {
      id: I,
      ...N,
      "aria-invalid": t.isInvalid ? "true" : void 0,
      "aria-describedby": l,
      "aria-readonly": t.isReadOnly || !e.isEditable ? "true" : void 0,
      "data-placeholder": e.isPlaceholder || void 0,
      contentEditable: q,
      suppressContentEditableWarning: q,
      spellCheck: q ? "false" : void 0,
      autoCorrect: q ? "off" : void 0,
      // Capitalization was changed in React 17...
      [parseInt(kt.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: q ? "next" : void 0,
      inputMode: t.isDisabled || e.type === "dayPeriod" || e.type === "era" || !q ? void 0 : "numeric",
      tabIndex: t.isDisabled ? void 0 : 0,
      onKeyDown: b,
      onFocus: S,
      style: {
        caretColor: "transparent"
      },
      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.
      onPointerDown(ne) {
        ne.stopPropagation();
      },
      onMouseDown(ne) {
        ne.stopPropagation();
      }
    })
  };
}
function bBe(e) {
  e.sort();
  let t = e[0], r = e[e.length - 1];
  for (let n = 0; n < t.length; n++)
    if (t[n] !== r[n]) return n;
  return 0;
}
var yJ = {};
yJ = {
  rangeOverflow: (e) => `يجب أن تكون القيمة ${e.maxValue} أو قبل ذلك.`,
  rangeReversed: "تاريخ البدء يجب أن يكون قبل تاريخ الانتهاء.",
  rangeUnderflow: (e) => `يجب أن تكون القيمة ${e.minValue} أو بعد ذلك.`,
  unavailableDate: "البيانات المحددة غير متاحة."
};
var vJ = {};
vJ = {
  rangeOverflow: (e) => `Стойността трябва да е ${e.maxValue} или по-ранна.`,
  rangeReversed: "Началната дата трябва да е преди крайната.",
  rangeUnderflow: (e) => `Стойността трябва да е ${e.minValue} или по-късно.`,
  unavailableDate: "Избраната дата не е налична."
};
var wJ = {};
wJ = {
  rangeOverflow: (e) => `Hodnota musí být ${e.maxValue} nebo dřívější.`,
  rangeReversed: "Datum zahájení musí předcházet datu ukončení.",
  rangeUnderflow: (e) => `Hodnota musí být ${e.minValue} nebo pozdější.`,
  unavailableDate: "Vybrané datum není k dispozici."
};
var xJ = {};
xJ = {
  rangeOverflow: (e) => `Værdien skal være ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen skal være før slutdatoen.",
  rangeUnderflow: (e) => `Værdien skal være ${e.minValue} eller nyere.`,
  unavailableDate: "Den valgte dato er ikke tilgængelig."
};
var EJ = {};
EJ = {
  rangeOverflow: (e) => `Der Wert muss ${e.maxValue} oder früher sein.`,
  rangeReversed: "Das Anfangsdatum muss vor dem Enddatum liegen.",
  rangeUnderflow: (e) => `Der Wert muss ${e.minValue} oder später sein.`,
  unavailableDate: "Das ausgewählte Datum ist nicht verfügbar."
};
var SJ = {};
SJ = {
  rangeOverflow: (e) => `Η τιμή πρέπει να είναι ${e.maxValue} ή παλαιότερη.`,
  rangeReversed: "Η ημερομηνία έναρξης πρέπει να είναι πριν από την ημερομηνία λήξης.",
  rangeUnderflow: (e) => `Η τιμή πρέπει να είναι ${e.minValue} ή μεταγενέστερη.`,
  unavailableDate: "Η επιλεγμένη ημερομηνία δεν είναι διαθέσιμη."
};
var _J = {};
_J = {
  rangeUnderflow: (e) => `Value must be ${e.minValue} or later.`,
  rangeOverflow: (e) => `Value must be ${e.maxValue} or earlier.`,
  rangeReversed: "Start date must be before end date.",
  unavailableDate: "Selected date unavailable."
};
var kJ = {};
kJ = {
  rangeOverflow: (e) => `El valor debe ser ${e.maxValue} o anterior.`,
  rangeReversed: "La fecha de inicio debe ser anterior a la fecha de finalización.",
  rangeUnderflow: (e) => `El valor debe ser ${e.minValue} o posterior.`,
  unavailableDate: "Fecha seleccionada no disponible."
};
var CJ = {};
CJ = {
  rangeOverflow: (e) => `Väärtus peab olema ${e.maxValue} või varasem.`,
  rangeReversed: "Alguskuupäev peab olema enne lõppkuupäeva.",
  rangeUnderflow: (e) => `Väärtus peab olema ${e.minValue} või hilisem.`,
  unavailableDate: "Valitud kuupäev pole saadaval."
};
var AJ = {};
AJ = {
  rangeOverflow: (e) => `Arvon on oltava ${e.maxValue} tai sitä aikaisempi.`,
  rangeReversed: "Aloituspäivän on oltava ennen lopetuspäivää.",
  rangeUnderflow: (e) => `Arvon on oltava ${e.minValue} tai sitä myöhäisempi.`,
  unavailableDate: "Valittu päivämäärä ei ole käytettävissä."
};
var TJ = {};
TJ = {
  rangeOverflow: (e) => `La valeur doit être ${e.maxValue} ou antérieure.`,
  rangeReversed: "La date de début doit être antérieure à la date de fin.",
  rangeUnderflow: (e) => `La valeur doit être ${e.minValue} ou ultérieure.`,
  unavailableDate: "La date sélectionnée n’est pas disponible."
};
var RJ = {};
RJ = {
  rangeOverflow: (e) => `הערך חייב להיות ${e.maxValue} או מוקדם יותר.`,
  rangeReversed: "תאריך ההתחלה חייב להיות לפני תאריך הסיום.",
  rangeUnderflow: (e) => `הערך חייב להיות ${e.minValue} או מאוחר יותר.`,
  unavailableDate: "התאריך הנבחר אינו זמין."
};
var IJ = {};
IJ = {
  rangeOverflow: (e) => `Vrijednost mora biti ${e.maxValue} ili ranije.`,
  rangeReversed: "Datum početka mora biti prije datuma završetka.",
  rangeUnderflow: (e) => `Vrijednost mora biti ${e.minValue} ili kasnije.`,
  unavailableDate: "Odabrani datum nije dostupan."
};
var NJ = {};
NJ = {
  rangeOverflow: (e) => `Az értéknek ${e.maxValue} vagy korábbinak kell lennie.`,
  rangeReversed: "A kezdő dátumnak a befejező dátumnál korábbinak kell lennie.",
  rangeUnderflow: (e) => `Az értéknek ${e.minValue} vagy későbbinek kell lennie.`,
  unavailableDate: "A kiválasztott dátum nem érhető el."
};
var DJ = {};
DJ = {
  rangeOverflow: (e) => `Il valore deve essere ${e.maxValue} o precedente.`,
  rangeReversed: "La data di inizio deve essere antecedente alla data di fine.",
  rangeUnderflow: (e) => `Il valore deve essere ${e.minValue} o successivo.`,
  unavailableDate: "Data selezionata non disponibile."
};
var OJ = {};
OJ = {
  rangeOverflow: (e) => `値は ${e.maxValue} 以下にする必要があります。`,
  rangeReversed: "開始日は終了日より前にする必要があります。",
  rangeUnderflow: (e) => `値は ${e.minValue} 以上にする必要があります。`,
  unavailableDate: "選択した日付は使用できません。"
};
var PJ = {};
PJ = {
  rangeOverflow: (e) => `값은 ${e.maxValue} 이전이어야 합니다.`,
  rangeReversed: "시작일은 종료일 이전이어야 합니다.",
  rangeUnderflow: (e) => `값은 ${e.minValue} 이상이어야 합니다.`,
  unavailableDate: "선택한 날짜를 사용할 수 없습니다."
};
var LJ = {};
LJ = {
  rangeOverflow: (e) => `Reikšmė turi būti ${e.maxValue} arba ankstesnė.`,
  rangeReversed: "Pradžios data turi būti ankstesnė nei pabaigos data.",
  rangeUnderflow: (e) => `Reikšmė turi būti ${e.minValue} arba naujesnė.`,
  unavailableDate: "Pasirinkta data nepasiekiama."
};
var MJ = {};
MJ = {
  rangeOverflow: (e) => `Vērtībai ir jābūt ${e.maxValue} vai agrākai.`,
  rangeReversed: "Sākuma datumam ir jābūt pirms beigu datuma.",
  rangeUnderflow: (e) => `Vērtībai ir jābūt ${e.minValue} vai vēlākai.`,
  unavailableDate: "Atlasītais datums nav pieejams."
};
var FJ = {};
FJ = {
  rangeOverflow: (e) => `Verdien må være ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen må være før sluttdatoen.",
  rangeUnderflow: (e) => `Verdien må være ${e.minValue} eller senere.`,
  unavailableDate: "Valgt dato utilgjengelig."
};
var $J = {};
$J = {
  rangeOverflow: (e) => `Waarde moet ${e.maxValue} of eerder zijn.`,
  rangeReversed: "De startdatum moet voor de einddatum liggen.",
  rangeUnderflow: (e) => `Waarde moet ${e.minValue} of later zijn.`,
  unavailableDate: "Geselecteerde datum niet beschikbaar."
};
var BJ = {};
BJ = {
  rangeOverflow: (e) => `Wartość musi mieć wartość ${e.maxValue} lub wcześniejszą.`,
  rangeReversed: "Data rozpoczęcia musi być wcześniejsza niż data zakończenia.",
  rangeUnderflow: (e) => `Wartość musi mieć wartość ${e.minValue} lub późniejszą.`,
  unavailableDate: "Wybrana data jest niedostępna."
};
var UJ = {};
UJ = {
  rangeOverflow: (e) => `O valor deve ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data inicial deve ser anterior à data final.",
  rangeUnderflow: (e) => `O valor deve ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponível."
};
var zJ = {};
zJ = {
  rangeOverflow: (e) => `O valor tem de ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data de início deve ser anterior à data de fim.",
  rangeUnderflow: (e) => `O valor tem de ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponível."
};
var qJ = {};
qJ = {
  rangeOverflow: (e) => `Valoarea trebuie să fie ${e.maxValue} sau anterioară.`,
  rangeReversed: "Data de început trebuie să fie anterioară datei de sfârșit.",
  rangeUnderflow: (e) => `Valoarea trebuie să fie ${e.minValue} sau ulterioară.`,
  unavailableDate: "Data selectată nu este disponibilă."
};
var jJ = {};
jJ = {
  rangeOverflow: (e) => `Значение должно быть не позже ${e.maxValue}.`,
  rangeReversed: "Дата начала должна предшествовать дате окончания.",
  rangeUnderflow: (e) => `Значение должно быть не раньше ${e.minValue}.`,
  unavailableDate: "Выбранная дата недоступна."
};
var HJ = {};
HJ = {
  rangeOverflow: (e) => `Hodnota musí byť ${e.maxValue} alebo skoršia.`,
  rangeReversed: "Dátum začiatku musí byť skorší ako dátum konca.",
  rangeUnderflow: (e) => `Hodnota musí byť ${e.minValue} alebo neskoršia.`,
  unavailableDate: "Vybratý dátum je nedostupný."
};
var VJ = {};
VJ = {
  rangeOverflow: (e) => `Vrednost mora biti ${e.maxValue} ali starejša.`,
  rangeReversed: "Začetni datum mora biti pred končnim datumom.",
  rangeUnderflow: (e) => `Vrednost mora biti ${e.minValue} ali novejša.`,
  unavailableDate: "Izbrani datum ni na voljo."
};
var GJ = {};
GJ = {
  rangeOverflow: (e) => `Vrednost mora da bude ${e.maxValue} ili starija.`,
  rangeReversed: "Datum početka mora biti pre datuma završetka.",
  rangeUnderflow: (e) => `Vrednost mora da bude ${e.minValue} ili novija.`,
  unavailableDate: "Izabrani datum nije dostupan."
};
var WJ = {};
WJ = {
  rangeOverflow: (e) => `Värdet måste vara ${e.maxValue} eller tidigare.`,
  rangeReversed: "Startdatumet måste vara före slutdatumet.",
  rangeUnderflow: (e) => `Värdet måste vara ${e.minValue} eller senare.`,
  unavailableDate: "Det valda datumet är inte tillgängligt."
};
var KJ = {};
KJ = {
  rangeOverflow: (e) => `Değer, ${e.maxValue} veya öncesi olmalıdır.`,
  rangeReversed: "Başlangıç tarihi bitiş tarihinden önce olmalıdır.",
  rangeUnderflow: (e) => `Değer, ${e.minValue} veya sonrası olmalıdır.`,
  unavailableDate: "Seçilen tarih kullanılamıyor."
};
var YJ = {};
YJ = {
  rangeOverflow: (e) => `Значення має бути не пізніше ${e.maxValue}.`,
  rangeReversed: "Дата початку має передувати даті завершення.",
  rangeUnderflow: (e) => `Значення має бути не раніше ${e.minValue}.`,
  unavailableDate: "Вибрана дата недоступна."
};
var XJ = {};
XJ = {
  rangeOverflow: (e) => `值必须是 ${e.maxValue} 或更早日期。`,
  rangeReversed: "开始日期必须早于结束日期。",
  rangeUnderflow: (e) => `值必须是 ${e.minValue} 或更晚日期。`,
  unavailableDate: "所选日期不可用。"
};
var ZJ = {};
ZJ = {
  rangeOverflow: (e) => `值必須是 ${e.maxValue} 或更早。`,
  rangeReversed: "開始日期必須在結束日期之前。",
  rangeUnderflow: (e) => `值必須是 ${e.minValue} 或更晚。`,
  unavailableDate: "所選日期無法使用。"
};
var JJ = {};
JJ = {
  "ar-AE": yJ,
  "bg-BG": vJ,
  "cs-CZ": wJ,
  "da-DK": xJ,
  "de-DE": EJ,
  "el-GR": SJ,
  "en-US": _J,
  "es-ES": kJ,
  "et-EE": CJ,
  "fi-FI": AJ,
  "fr-FR": TJ,
  "he-IL": RJ,
  "hr-HR": IJ,
  "hu-HU": NJ,
  "it-IT": DJ,
  "ja-JP": OJ,
  "ko-KR": PJ,
  "lt-LT": LJ,
  "lv-LV": MJ,
  "nb-NO": FJ,
  "nl-NL": $J,
  "pl-PL": BJ,
  "pt-BR": UJ,
  "pt-PT": zJ,
  "ro-RO": qJ,
  "ru-RU": jJ,
  "sk-SK": HJ,
  "sl-SI": VJ,
  "sr-SP": GJ,
  "sv-SE": WJ,
  "tr-TR": KJ,
  "uk-UA": YJ,
  "zh-CN": XJ,
  "zh-TW": ZJ
};
function yBe(e) {
  return e && e.__esModule ? e.default : e;
}
const vBe = new Ku(yBe(JJ));
function wBe() {
  return typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
}
function xBe(e, t, r, n, a) {
  let s = e != null && r != null && e.compare(r) > 0, i = e != null && t != null && e.compare(t) < 0, o = e != null && n?.(e) || !1, l = s || i || o, u = [];
  if (l) {
    let c = wBe(), d = Ku.getGlobalDictionaryForPackage("@react-stately/datepicker") || vBe, p = new TZ(c, d), f = new Bc(c, vg({}, a)), h = f.resolvedOptions().timeZone;
    i && t != null && u.push(p.format("rangeUnderflow", {
      minValue: f.format(t.toDate(h))
    })), s && r != null && u.push(p.format("rangeOverflow", {
      maxValue: f.format(r.toDate(h))
    })), o && u.push(p.format("unavailableDate"));
  }
  return {
    isInvalid: l,
    validationErrors: u,
    validationDetails: {
      badInput: o,
      customError: !1,
      patternMismatch: !1,
      rangeOverflow: s,
      rangeUnderflow: i,
      stepMismatch: !1,
      tooLong: !1,
      tooShort: !1,
      typeMismatch: !1,
      valueMissing: !1,
      valid: !l
    }
  };
}
const EBe = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  second: "2-digit"
}, SBe = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
};
function vg(e, t) {
  e = {
    ...t.shouldForceLeadingZeros ? SBe : EBe,
    ...e
  };
  let n = t.granularity || "minute", a = Object.keys(e);
  var s;
  let i = a.indexOf((s = t.maxGranularity) !== null && s !== void 0 ? s : "year");
  i < 0 && (i = 0);
  let o = a.indexOf(n);
  if (o < 0 && (o = 2), i > o) throw new Error("maxGranularity must be greater than granularity");
  let l = a.slice(i, o + 1).reduce((c, d) => (c[d] = e[d], c), {});
  return t.hourCycle != null && (l.hour12 = t.hourCycle === 12), l.timeZone = t.timeZone || "UTC", (n === "hour" || n === "minute" || n === "second") && t.timeZone && !t.hideTimeZone && (l.timeZoneName = "short"), t.showEra && i === 0 && (l.era = "short"), l;
}
function QJ(e, t) {
  if (e === null) return null;
  if (e)
    return la(e, t);
}
function Tf(e, t, r, n) {
  if (e) return QJ(e, r);
  let a = la(JY(n ?? Py()).set({
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }), r);
  return t === "year" || t === "month" || t === "day" ? iX(a) : n ? a : Vl(a);
}
function _Be(e, t) {
  let r = e && "timeZone" in e ? e.timeZone : void 0, n = e && "minute" in e ? "minute" : "day";
  if (e && t && !(t in e)) throw new Error("Invalid granularity " + t + " for value " + e.toString());
  let [a, s] = Wn([
    n,
    r
  ]);
  e && (a[0] !== n || a[1] !== r) && s([
    n,
    r
  ]), t || (t = e ? n : a[0]);
  let i = e ? r : a[1];
  return [
    t,
    i
  ];
}
const kBe = new Ku({
  ach: {
    year: "mwaka",
    month: "dwe",
    day: "nino"
  },
  af: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  am: {
    year: "ዓዓዓዓ",
    month: "ሚሜ",
    day: "ቀቀ"
  },
  an: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ar: {
    year: "سنة",
    month: "شهر",
    day: "يوم"
  },
  ast: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  az: {
    year: "iiii",
    month: "aa",
    day: "gg"
  },
  be: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  bg: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  bn: {
    year: "yyyy",
    month: "মিমি",
    day: "dd"
  },
  br: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  bs: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  ca: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  cak: {
    year: "jjjj",
    month: "ii",
    day: "q'q'"
  },
  ckb: {
    year: "ساڵ",
    month: "مانگ",
    day: "ڕۆژ"
  },
  cs: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  cy: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  da: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  de: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  dsb: {
    year: "llll",
    month: "mm",
    day: "źź"
  },
  el: {
    year: "εεεε",
    month: "μμ",
    day: "ηη"
  },
  en: {
    year: "yyyy",
    month: "mm",
    day: "dd"
  },
  eo: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  es: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  et: {
    year: "aaaa",
    month: "kk",
    day: "pp"
  },
  eu: {
    year: "uuuu",
    month: "hh",
    day: "ee"
  },
  fa: {
    year: "سال",
    month: "ماه",
    day: "روز"
  },
  ff: {
    year: "hhhh",
    month: "ll",
    day: "ññ"
  },
  fi: {
    year: "vvvv",
    month: "kk",
    day: "pp"
  },
  fr: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  fy: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  ga: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gd: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gl: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  he: {
    year: "שנה",
    month: "חודש",
    day: "יום"
  },
  hr: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  hsb: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  hu: {
    year: "éééé",
    month: "hh",
    day: "nn"
  },
  ia: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  id: {
    year: "tttt",
    month: "bb",
    day: "hh"
  },
  it: {
    year: "aaaa",
    month: "mm",
    day: "gg"
  },
  ja: {
    year: " 年 ",
    month: "月",
    day: "日"
  },
  ka: {
    year: "წწწწ",
    month: "თთ",
    day: "რრ"
  },
  kk: {
    year: "жжжж",
    month: "аа",
    day: "кк"
  },
  kn: {
    year: "ವವವವ",
    month: "ಮಿಮೀ",
    day: "ದಿದಿ"
  },
  ko: {
    year: "연도",
    month: "월",
    day: "일"
  },
  lb: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  lo: {
    year: "ປປປປ",
    month: "ດດ",
    day: "ວວ"
  },
  lt: {
    year: "mmmm",
    month: "mm",
    day: "dd"
  },
  lv: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  meh: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ml: {
    year: "വർഷം",
    month: "മാസം",
    day: "തീയതി"
  },
  ms: {
    year: "tttt",
    month: "mm",
    day: "hh"
  },
  nl: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  nn: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  no: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  oc: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  pl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  pt: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  rm: {
    year: "oooo",
    month: "mm",
    day: "dd"
  },
  ro: {
    year: "aaaa",
    month: "ll",
    day: "zz"
  },
  ru: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  sc: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  scn: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  sk: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  sl: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  sr: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  sv: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  szl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  tg: {
    year: "сссс",
    month: "мм",
    day: "рр"
  },
  th: {
    year: "ปปปป",
    month: "ดด",
    day: "วว"
  },
  tr: {
    year: "yyyy",
    month: "aa",
    day: "gg"
  },
  uk: {
    year: "рррр",
    month: "мм",
    day: "дд"
  },
  "zh-CN": {
    year: "年",
    month: "月",
    day: "日"
  },
  "zh-TW": {
    year: "年",
    month: "月",
    day: "日"
  }
}, "en");
function CBe(e, t, r) {
  return e === "era" || e === "dayPeriod" ? t : e === "year" || e === "month" || e === "day" ? kBe.getStringForLocale(e, r) : "––";
}
const ng = {
  year: !0,
  month: !0,
  day: !0,
  hour: !0,
  minute: !0,
  second: !0,
  dayPeriod: !0,
  era: !0
}, cU = {
  year: 5,
  month: 2,
  day: 7,
  hour: 2,
  minute: 15,
  second: 15
}, ABe = {
  dayperiod: "dayPeriod"
};
function TBe(e) {
  let { locale: t, createCalendar: r, hideTimeZone: n, isDisabled: a = !1, isReadOnly: s = !1, isRequired: i = !1, minValue: o, maxValue: l, isDateUnavailable: u } = e, c = e.value || e.defaultValue || e.placeholderValue || null, [d, p] = _Be(c, e.granularity), f = p || "UTC";
  if (c && !(d in c)) throw new Error("Invalid granularity " + d + " for value " + c.toString());
  let h = Or(() => new Bc(t), [
    t
  ]), m = Or(() => r(h.resolvedOptions().calendar), [
    r,
    h
  ]);
  var y;
  let [b, v] = mZ(e.value, (y = e.defaultValue) !== null && y !== void 0 ? y : null, e.onChange), x = Or(() => {
    var F;
    return (F = QJ(b, m)) !== null && F !== void 0 ? F : null;
  }, [
    b,
    m
  ]), [_, E] = Wn(() => Tf(e.placeholderValue, d, m, p)), w = x || _, C = m.identifier === "gregory" && w.era === "BC", k = Or(() => {
    var F;
    return {
      granularity: d,
      maxGranularity: (F = e.maxGranularity) !== null && F !== void 0 ? F : "year",
      timeZone: p,
      hideTimeZone: n,
      hourCycle: e.hourCycle,
      showEra: C,
      shouldForceLeadingZeros: e.shouldForceLeadingZeros
    };
  }, [
    e.maxGranularity,
    d,
    e.hourCycle,
    e.shouldForceLeadingZeros,
    p,
    n,
    C
  ]), S = Or(() => vg({}, k), [
    k
  ]), B = Or(() => new Bc(t, S), [
    t,
    S
  ]), U = Or(() => B.resolvedOptions(), [
    B
  ]), N = Or(() => B.formatToParts(/* @__PURE__ */ new Date()).filter((F) => ng[F.type]).reduce((F, ge) => (F[ge.type] = !0, F), {}), [
    B
  ]), [O, I] = Wn(() => e.value || e.defaultValue ? {
    ...N
  } : {}), q = Gr(null), ae = Gr(m.identifier);
  Qn(() => {
    m.identifier !== ae.current && (ae.current = m.identifier, E((F) => Object.keys(O).length > 0 ? la(F, m) : Tf(e.placeholderValue, d, m, p)));
  }, [
    m,
    d,
    O,
    p,
    e.placeholderValue
  ]), b && Object.keys(O).length < Object.keys(N).length && (O = {
    ...N
  }, I(O)), b == null && Object.keys(O).length === Object.keys(N).length && (O = {}, I(O), E(Tf(e.placeholderValue, d, m, p)));
  let Q = x && Object.keys(O).length >= Object.keys(N).length ? x : _, ne = (F) => {
    if (e.isDisabled || e.isReadOnly) return;
    let ge = Object.keys(O), ce = Object.keys(N);
    F == null ? (v(null), E(Tf(e.placeholderValue, d, m, p)), I({})) : ge.length >= ce.length || ge.length === ce.length - 1 && N.dayPeriod && !O.dayPeriod && q.current !== "dayPeriod" ? (F = la(F, c?.calendar || new Hl()), v(F)) : E(F), q.current = null;
  }, le = Or(() => Q.toDate(f), [
    Q,
    f
  ]), W = Or(() => B.formatToParts(le).map((F) => {
    let ge = ng[F.type];
    F.type === "era" && m.getEras().length === 1 && (ge = !1);
    let ce = ng[F.type] && !O[F.type], ie = ng[F.type] ? CBe(F.type, F.value, t) : null;
    return {
      type: ABe[F.type] || F.type,
      text: ce ? ie : F.value,
      ...RBe(Q, F.type, U),
      isPlaceholder: ce,
      placeholder: ie,
      isEditable: ge
    };
  }), [
    le,
    O,
    B,
    U,
    Q,
    m,
    t
  ]);
  N.era && O.year && !O.era ? (O.era = !0, I({
    ...O
  })) : !N.era && O.era && (delete O.era, I({
    ...O
  }));
  let X = (F) => {
    O[F] = !0, F === "year" && N.era && (O.era = !0), I({
      ...O
    });
  }, G = (F, ge) => {
    if (O[F])
      ne(IBe(Q, F, ge, U));
    else {
      X(F);
      let ce = Object.keys(O), ie = Object.keys(N);
      (ce.length >= ie.length || ce.length === ie.length - 1 && N.dayPeriod && !O.dayPeriod) && ne(Q);
    }
  }, P = Or(() => xBe(b, o, l, u, k), [
    b,
    o,
    l,
    u,
    k
  ]), he = aBe({
    ...e,
    value: b,
    builtinValidation: P
  }), ye = he.displayValidation.isInvalid, pe = e.validationState || (ye ? "invalid" : null);
  var $;
  return {
    ...he,
    value: x,
    dateValue: le,
    calendar: m,
    setValue: ne,
    segments: W,
    dateFormatter: B,
    validationState: pe,
    isInvalid: ye,
    granularity: d,
    maxGranularity: ($ = e.maxGranularity) !== null && $ !== void 0 ? $ : "year",
    isDisabled: a,
    isReadOnly: s,
    isRequired: i,
    increment(F) {
      G(F, 1);
    },
    decrement(F) {
      G(F, -1);
    },
    incrementPage(F) {
      G(F, cU[F] || 1);
    },
    decrementPage(F) {
      G(F, -(cU[F] || 1));
    },
    setSegment(F, ge) {
      X(F), ne(NBe(Q, F, ge, U));
    },
    confirmPlaceholder() {
      if (e.isDisabled || e.isReadOnly) return;
      let F = Object.keys(O), ge = Object.keys(N);
      F.length === ge.length - 1 && N.dayPeriod && !O.dayPeriod && (O = {
        ...N
      }, I(O), ne(Q.copy()));
    },
    clearSegment(F) {
      delete O[F], q.current = F, I({
        ...O
      });
      let ge = Tf(e.placeholderValue, d, m, p), ce = Q;
      if (F === "dayPeriod" && "hour" in Q && "hour" in ge) {
        let ie = Q.hour >= 12, re = ge.hour >= 12;
        ie && !re ? ce = Q.set({
          hour: Q.hour - 12
        }) : !ie && re && (ce = Q.set({
          hour: Q.hour + 12
        }));
      } else F in Q && (ce = Q.set({
        [F]: ge[F]
      }));
      v(null), ne(ce);
    },
    formatValue(F) {
      if (!x) return "";
      let ge = vg(F, k);
      return new Bc(t, ge).format(le);
    },
    getDateFormatter(F, ge) {
      let ce = {
        ...k,
        ...ge
      }, ie = vg({}, ce);
      return new Bc(F, ie);
    }
  };
}
function RBe(e, t, r) {
  switch (t) {
    case "era": {
      let n = e.calendar.getEras();
      return {
        value: n.indexOf(e.era),
        minValue: 0,
        maxValue: n.length - 1
      };
    }
    case "year":
      return {
        value: e.year,
        minValue: 1,
        maxValue: e.calendar.getYearsInEra(e)
      };
    case "month":
      return {
        value: e.month,
        minValue: q6e(e),
        maxValue: e.calendar.getMonthsInYear(e)
      };
    case "day":
      return {
        value: e.day,
        minValue: j6e(e),
        maxValue: e.calendar.getDaysInMonth(e)
      };
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod":
      return {
        value: e.hour >= 12 ? 12 : 0,
        minValue: 0,
        maxValue: 12
      };
    case "hour":
      if (r.hour12) {
        let n = e.hour >= 12;
        return {
          value: e.hour,
          minValue: n ? 12 : 0,
          maxValue: n ? 23 : 11
        };
      }
      return {
        value: e.hour,
        minValue: 0,
        maxValue: 23
      };
    case "minute":
      return {
        value: e.minute,
        minValue: 0,
        maxValue: 59
      };
    case "second":
      return {
        value: e.second,
        minValue: 0,
        maxValue: 59
      };
  }
  return {};
}
function IBe(e, t, r, n) {
  switch (t) {
    case "era":
    case "year":
    case "month":
    case "day":
      return e.cycle(t, r, {
        round: t === "year"
      });
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod": {
      let a = e.hour, s = a >= 12;
      return e.set({
        hour: s ? a - 12 : a + 12
      });
    }
    case "hour":
    case "minute":
    case "second":
      return e.cycle(t, r, {
        round: t !== "hour",
        hourCycle: n.hour12 ? 12 : 24
      });
  }
  throw new Error("Unknown segment: " + t);
}
function NBe(e, t, r, n) {
  switch (t) {
    case "day":
    case "month":
    case "year":
    case "era":
      return e.set({
        [t]: r
      });
  }
  if ("hour" in e && typeof r == "number") switch (t) {
    case "dayPeriod": {
      let a = e.hour, s = a >= 12;
      return r >= 12 === s ? e : e.set({
        hour: s ? a - 12 : a + 12
      });
    }
    case "hour":
      if (n.hour12) {
        let s = e.hour >= 12;
        !s && r === 12 && (r = 0), s && r < 12 && (r += 12);
      }
    // fallthrough
    case "minute":
    case "second":
      return e.set({
        [t]: r
      });
  }
  throw new Error("Unknown segment: " + t);
}
function DBe(e) {
  let { placeholderValue: t = new Tn(), minValue: r, maxValue: n, granularity: a, validate: s } = e;
  var i;
  let [o, l] = mZ(e.value, (i = e.defaultValue) !== null && i !== void 0 ? i : null, e.onChange), u = o || t, c = u && "day" in u ? u : void 0, d = e.defaultValue && "timeZone" in e.defaultValue ? e.defaultValue.timeZone : void 0, p = Or(() => {
    let x = u && "timeZone" in u ? u.timeZone : void 0;
    return (x || d) && t ? aX(Rf(t), x || d) : Rf(t);
  }, [
    t,
    u,
    d
  ]), f = Or(() => Rf(r, c), [
    r,
    c
  ]), h = Or(() => Rf(n, c), [
    n,
    c
  ]), m = Or(() => o && "day" in o ? j9(o) : o, [
    o
  ]), y = Or(() => o == null ? null : Rf(o), [
    o
  ]);
  return {
    ...TBe({
      ...e,
      value: y,
      defaultValue: void 0,
      minValue: f,
      maxValue: h,
      onChange: (x) => {
        l(c || d ? x : x && j9(x));
      },
      granularity: a || "minute",
      maxGranularity: "hour",
      placeholderValue: p ?? void 0,
      // Calendar should not matter for time fields.
      createCalendar: () => new Hl(),
      validate: ci(() => s?.(o), [
        s,
        o
      ])
    }),
    timeValue: m
  };
}
function Rf(e, t = z6e(Py())) {
  return e ? "day" in e ? e : Vl(t, e) : null;
}
function xn(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : /* @__PURE__ */ new Date(NaN);
}
function Va(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t);
}
function aa(e, t) {
  const r = xn(e);
  return isNaN(t) ? Va(e, NaN) : (t && r.setDate(r.getDate() + t), r);
}
function qs(e, t) {
  const r = xn(e);
  if (isNaN(t)) return Va(e, NaN);
  if (!t)
    return r;
  const n = r.getDate(), a = Va(e, r.getTime());
  a.setMonth(r.getMonth() + t + 1, 0);
  const s = a.getDate();
  return n >= s ? a : (r.setFullYear(
    a.getFullYear(),
    a.getMonth(),
    n
  ), r);
}
const n2 = 6048e5, OBe = 864e5;
let PBe = {};
function Ph() {
  return PBe;
}
function co(e, t) {
  const r = Ph(), n = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, a = xn(e), s = a.getDay(), i = (s < n ? 7 : 0) + s - n;
  return a.setDate(a.getDate() - i), a.setHours(0, 0, 0, 0), a;
}
function Lu(e) {
  return co(e, { weekStartsOn: 1 });
}
function eQ(e) {
  const t = xn(e), r = t.getFullYear(), n = Va(e, 0);
  n.setFullYear(r + 1, 0, 4), n.setHours(0, 0, 0, 0);
  const a = Lu(n), s = Va(e, 0);
  s.setFullYear(r, 0, 4), s.setHours(0, 0, 0, 0);
  const i = Lu(s);
  return t.getTime() >= a.getTime() ? r + 1 : t.getTime() >= i.getTime() ? r : r - 1;
}
function Sd(e) {
  const t = xn(e);
  return t.setHours(0, 0, 0, 0), t;
}
function bb(e) {
  const t = xn(e), r = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return r.setUTCFullYear(t.getFullYear()), +e - +r;
}
function io(e, t) {
  const r = Sd(e), n = Sd(t), a = +r - bb(r), s = +n - bb(n);
  return Math.round((a - s) / OBe);
}
function LBe(e) {
  const t = eQ(e), r = Va(e, 0);
  return r.setFullYear(t, 0, 4), r.setHours(0, 0, 0, 0), Lu(r);
}
function hI(e, t) {
  const r = t * 7;
  return aa(e, r);
}
function Gf(e, t) {
  return qs(e, t * 12);
}
function MBe(e) {
  let t;
  return e.forEach(function(r) {
    const n = xn(r);
    (t === void 0 || t < n || isNaN(Number(n))) && (t = n);
  }), t || /* @__PURE__ */ new Date(NaN);
}
function FBe(e) {
  let t;
  return e.forEach((r) => {
    const n = xn(r);
    (!t || t > n || isNaN(+n)) && (t = n);
  }), t || /* @__PURE__ */ new Date(NaN);
}
function Ca(e, t) {
  const r = Sd(e), n = Sd(t);
  return +r == +n;
}
function i2(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function $Be(e) {
  if (!i2(e) && typeof e != "number")
    return !1;
  const t = xn(e);
  return !isNaN(Number(t));
}
function eh(e, t) {
  const r = xn(e), n = xn(t), a = r.getFullYear() - n.getFullYear(), s = r.getMonth() - n.getMonth();
  return a * 12 + s;
}
function BBe(e, t, r) {
  const n = co(e, r), a = co(t, r), s = +n - bb(n), i = +a - bb(a);
  return Math.round((s - i) / n2);
}
function a2(e) {
  const t = xn(e), r = t.getMonth();
  return t.setFullYear(t.getFullYear(), r + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function Aa(e) {
  const t = xn(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function tQ(e) {
  const t = xn(e), r = Va(e, 0);
  return r.setFullYear(t.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r;
}
function s2(e, t) {
  const r = Ph(), n = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, a = xn(e), s = a.getDay(), i = (s < n ? -7 : 0) + 6 - (s - n);
  return a.setDate(a.getDate() + i), a.setHours(23, 59, 59, 999), a;
}
function rQ(e) {
  return s2(e, { weekStartsOn: 1 });
}
const UBe = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, zBe = (e, t, r) => {
  let n;
  const a = UBe[e];
  return typeof a == "string" ? n = a : t === 1 ? n = a.one : n = a.other.replace("{{count}}", t.toString()), r?.addSuffix ? r.comparison && r.comparison > 0 ? "in " + n : n + " ago" : n;
};
function xT(e) {
  return (t = {}) => {
    const r = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[r] || e.formats[e.defaultWidth];
  };
}
const qBe = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, jBe = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, HBe = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, VBe = {
  date: xT({
    formats: qBe,
    defaultWidth: "full"
  }),
  time: xT({
    formats: jBe,
    defaultWidth: "full"
  }),
  dateTime: xT({
    formats: HBe,
    defaultWidth: "full"
  })
}, GBe = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, WBe = (e, t, r, n) => GBe[e];
function If(e) {
  return (t, r) => {
    const n = r?.context ? String(r.context) : "standalone";
    let a;
    if (n === "formatting" && e.formattingValues) {
      const i = e.defaultFormattingWidth || e.defaultWidth, o = r?.width ? String(r.width) : i;
      a = e.formattingValues[o] || e.formattingValues[i];
    } else {
      const i = e.defaultWidth, o = r?.width ? String(r.width) : e.defaultWidth;
      a = e.values[o] || e.values[i];
    }
    const s = e.argumentCallback ? e.argumentCallback(t) : t;
    return a[s];
  };
}
const KBe = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, YBe = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, XBe = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, ZBe = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, JBe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, QBe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, e7e = (e, t) => {
  const r = Number(e), n = r % 100;
  if (n > 20 || n < 10)
    switch (n % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
}, t7e = {
  ordinalNumber: e7e,
  era: If({
    values: KBe,
    defaultWidth: "wide"
  }),
  quarter: If({
    values: YBe,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: If({
    values: XBe,
    defaultWidth: "wide"
  }),
  day: If({
    values: ZBe,
    defaultWidth: "wide"
  }),
  dayPeriod: If({
    values: JBe,
    defaultWidth: "wide",
    formattingValues: QBe,
    defaultFormattingWidth: "wide"
  })
};
function Nf(e) {
  return (t, r = {}) => {
    const n = r.width, a = n && e.matchPatterns[n] || e.matchPatterns[e.defaultMatchWidth], s = t.match(a);
    if (!s)
      return null;
    const i = s[0], o = n && e.parsePatterns[n] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(o) ? n7e(o, (d) => d.test(i)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      r7e(o, (d) => d.test(i))
    );
    let u;
    u = e.valueCallback ? e.valueCallback(l) : l, u = r.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      r.valueCallback(u)
    ) : u;
    const c = t.slice(i.length);
    return { value: u, rest: c };
  };
}
function r7e(e, t) {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r) && t(e[r]))
      return r;
}
function n7e(e, t) {
  for (let r = 0; r < e.length; r++)
    if (t(e[r]))
      return r;
}
function i7e(e) {
  return (t, r = {}) => {
    const n = t.match(e.matchPattern);
    if (!n) return null;
    const a = n[0], s = t.match(e.parsePattern);
    if (!s) return null;
    let i = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    i = r.valueCallback ? r.valueCallback(i) : i;
    const o = t.slice(a.length);
    return { value: i, rest: o };
  };
}
const a7e = /^(\d+)(th|st|nd|rd)?/i, s7e = /\d+/i, o7e = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, l7e = {
  any: [/^b/i, /^(a|c)/i]
}, u7e = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, c7e = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, d7e = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, f7e = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, p7e = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, h7e = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, m7e = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, g7e = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, b7e = {
  ordinalNumber: i7e({
    matchPattern: a7e,
    parsePattern: s7e,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: Nf({
    matchPatterns: o7e,
    defaultMatchWidth: "wide",
    parsePatterns: l7e,
    defaultParseWidth: "any"
  }),
  quarter: Nf({
    matchPatterns: u7e,
    defaultMatchWidth: "wide",
    parsePatterns: c7e,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: Nf({
    matchPatterns: d7e,
    defaultMatchWidth: "wide",
    parsePatterns: f7e,
    defaultParseWidth: "any"
  }),
  day: Nf({
    matchPatterns: p7e,
    defaultMatchWidth: "wide",
    parsePatterns: h7e,
    defaultParseWidth: "any"
  }),
  dayPeriod: Nf({
    matchPatterns: m7e,
    defaultMatchWidth: "any",
    parsePatterns: g7e,
    defaultParseWidth: "any"
  })
}, $y = {
  code: "en-US",
  formatDistance: zBe,
  formatLong: VBe,
  formatRelative: WBe,
  localize: t7e,
  match: b7e,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function y7e(e) {
  const t = xn(e);
  return io(t, tQ(t)) + 1;
}
function nQ(e) {
  const t = xn(e), r = +Lu(t) - +LBe(t);
  return Math.round(r / n2) + 1;
}
function iQ(e, t) {
  const r = xn(e), n = r.getFullYear(), a = Ph(), s = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? a.firstWeekContainsDate ?? a.locale?.options?.firstWeekContainsDate ?? 1, i = Va(e, 0);
  i.setFullYear(n + 1, 0, s), i.setHours(0, 0, 0, 0);
  const o = co(i, t), l = Va(e, 0);
  l.setFullYear(n, 0, s), l.setHours(0, 0, 0, 0);
  const u = co(l, t);
  return r.getTime() >= o.getTime() ? n + 1 : r.getTime() >= u.getTime() ? n : n - 1;
}
function v7e(e, t) {
  const r = Ph(), n = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1, a = iQ(e, t), s = Va(e, 0);
  return s.setFullYear(a, 0, n), s.setHours(0, 0, 0, 0), co(s, t);
}
function aQ(e, t) {
  const r = xn(e), n = +co(r, t) - +v7e(r, t);
  return Math.round(n / n2) + 1;
}
function Ln(e, t) {
  const r = e < 0 ? "-" : "", n = Math.abs(e).toString().padStart(t, "0");
  return r + n;
}
const xl = {
  // Year
  y(e, t) {
    const r = e.getFullYear(), n = r > 0 ? r : 1 - r;
    return Ln(t === "yy" ? n % 100 : n, t.length);
  },
  // Month
  M(e, t) {
    const r = e.getMonth();
    return t === "M" ? String(r + 1) : Ln(r + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return Ln(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const r = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return r.toUpperCase();
      case "aaa":
        return r;
      case "aaaaa":
        return r[0];
      case "aaaa":
      default:
        return r === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return Ln(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return Ln(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return Ln(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return Ln(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const r = t.length, n = e.getMilliseconds(), a = Math.trunc(
      n * Math.pow(10, r - 3)
    );
    return Ln(a, t.length);
  }
}, Sc = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, dU = {
  // Era
  G: function(e, t, r) {
    const n = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return r.era(n, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return r.era(n, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return r.era(n, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, r) {
    if (t === "yo") {
      const n = e.getFullYear(), a = n > 0 ? n : 1 - n;
      return r.ordinalNumber(a, { unit: "year" });
    }
    return xl.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, r, n) {
    const a = iQ(e, n), s = a > 0 ? a : 1 - a;
    if (t === "YY") {
      const i = s % 100;
      return Ln(i, 2);
    }
    return t === "Yo" ? r.ordinalNumber(s, { unit: "year" }) : Ln(s, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const r = eQ(e);
    return Ln(r, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const r = e.getFullYear();
    return Ln(r, t.length);
  },
  // Quarter
  Q: function(e, t, r) {
    const n = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "Q":
        return String(n);
      // 01, 02, 03, 04
      case "QQ":
        return Ln(n, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return r.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return r.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, r) {
    const n = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "q":
        return String(n);
      // 01, 02, 03, 04
      case "qq":
        return Ln(n, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return r.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return r.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, r) {
    const n = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return xl.M(e, t);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return r.ordinalNumber(n + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return r.month(n, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return r.month(n, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return r.month(n, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, r) {
    const n = e.getMonth();
    switch (t) {
      // 1, 2, ..., 12
      case "L":
        return String(n + 1);
      // 01, 02, ..., 12
      case "LL":
        return Ln(n + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return r.ordinalNumber(n + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return r.month(n, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return r.month(n, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return r.month(n, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, r, n) {
    const a = aQ(e, n);
    return t === "wo" ? r.ordinalNumber(a, { unit: "week" }) : Ln(a, t.length);
  },
  // ISO week of year
  I: function(e, t, r) {
    const n = nQ(e);
    return t === "Io" ? r.ordinalNumber(n, { unit: "week" }) : Ln(n, t.length);
  },
  // Day of the month
  d: function(e, t, r) {
    return t === "do" ? r.ordinalNumber(e.getDate(), { unit: "date" }) : xl.d(e, t);
  },
  // Day of year
  D: function(e, t, r) {
    const n = y7e(e);
    return t === "Do" ? r.ordinalNumber(n, { unit: "dayOfYear" }) : Ln(n, t.length);
  },
  // Day of week
  E: function(e, t, r) {
    const n = e.getDay();
    switch (t) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return r.day(n, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return r.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, r, n) {
    const a = e.getDay(), s = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(s);
      // Padded numerical value
      case "ee":
        return Ln(s, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return r.ordinalNumber(s, { unit: "day" });
      case "eee":
        return r.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return r.day(a, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return r.day(a, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return r.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, r, n) {
    const a = e.getDay(), s = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (same as in `e`)
      case "c":
        return String(s);
      // Padded numerical value
      case "cc":
        return Ln(s, t.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return r.ordinalNumber(s, { unit: "day" });
      case "ccc":
        return r.day(a, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return r.day(a, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return r.day(a, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return r.day(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, r) {
    const n = e.getDay(), a = n === 0 ? 7 : n;
    switch (t) {
      // 2
      case "i":
        return String(a);
      // 02
      case "ii":
        return Ln(a, t.length);
      // 2nd
      case "io":
        return r.ordinalNumber(a, { unit: "day" });
      // Tue
      case "iii":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return r.day(n, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return r.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, r) {
    const a = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, r) {
    const n = e.getHours();
    let a;
    switch (n === 12 ? a = Sc.noon : n === 0 ? a = Sc.midnight : a = n / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, r) {
    const n = e.getHours();
    let a;
    switch (n >= 17 ? a = Sc.evening : n >= 12 ? a = Sc.afternoon : n >= 4 ? a = Sc.morning : a = Sc.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, r) {
    if (t === "ho") {
      let n = e.getHours() % 12;
      return n === 0 && (n = 12), r.ordinalNumber(n, { unit: "hour" });
    }
    return xl.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, r) {
    return t === "Ho" ? r.ordinalNumber(e.getHours(), { unit: "hour" }) : xl.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, r) {
    const n = e.getHours() % 12;
    return t === "Ko" ? r.ordinalNumber(n, { unit: "hour" }) : Ln(n, t.length);
  },
  // Hour [1-24]
  k: function(e, t, r) {
    let n = e.getHours();
    return n === 0 && (n = 24), t === "ko" ? r.ordinalNumber(n, { unit: "hour" }) : Ln(n, t.length);
  },
  // Minute
  m: function(e, t, r) {
    return t === "mo" ? r.ordinalNumber(e.getMinutes(), { unit: "minute" }) : xl.m(e, t);
  },
  // Second
  s: function(e, t, r) {
    return t === "so" ? r.ordinalNumber(e.getSeconds(), { unit: "second" }) : xl.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return xl.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, r) {
    const n = e.getTimezoneOffset();
    if (n === 0)
      return "Z";
    switch (t) {
      // Hours and optional minutes
      case "X":
        return pU(n);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return pu(n);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return pu(n, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, r) {
    const n = e.getTimezoneOffset();
    switch (t) {
      // Hours and optional minutes
      case "x":
        return pU(n);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return pu(n);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return pu(n, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, r) {
    const n = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + fU(n, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + pu(n, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, r) {
    const n = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + fU(n, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + pu(n, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, r) {
    const n = Math.trunc(e.getTime() / 1e3);
    return Ln(n, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, r) {
    const n = e.getTime();
    return Ln(n, t.length);
  }
};
function fU(e, t = "") {
  const r = e > 0 ? "-" : "+", n = Math.abs(e), a = Math.trunc(n / 60), s = n % 60;
  return s === 0 ? r + String(a) : r + String(a) + t + Ln(s, 2);
}
function pU(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Ln(Math.abs(e) / 60, 2) : pu(e, t);
}
function pu(e, t = "") {
  const r = e > 0 ? "-" : "+", n = Math.abs(e), a = Ln(Math.trunc(n / 60), 2), s = Ln(n % 60, 2);
  return r + a + t + s;
}
const hU = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, sQ = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, w7e = (e, t) => {
  const r = e.match(/(P+)(p+)?/) || [], n = r[1], a = r[2];
  if (!a)
    return hU(e, t);
  let s;
  switch (n) {
    case "P":
      s = t.dateTime({ width: "short" });
      break;
    case "PP":
      s = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      s = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      s = t.dateTime({ width: "full" });
      break;
  }
  return s.replace("{{date}}", hU(n, t)).replace("{{time}}", sQ(a, t));
}, x7e = {
  p: sQ,
  P: w7e
}, E7e = /^D+$/, S7e = /^Y+$/, _7e = ["D", "DD", "YY", "YYYY"];
function k7e(e) {
  return E7e.test(e);
}
function C7e(e) {
  return S7e.test(e);
}
function A7e(e, t, r) {
  const n = T7e(e, t, r);
  if (console.warn(n), _7e.includes(e)) throw new RangeError(n);
}
function T7e(e, t, r) {
  const n = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${n} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const R7e = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, I7e = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, N7e = /^'([^]*?)'?$/, D7e = /''/g, O7e = /[a-zA-Z]/;
function zi(e, t, r) {
  const n = Ph(), a = r?.locale ?? n.locale ?? $y, s = r?.firstWeekContainsDate ?? r?.locale?.options?.firstWeekContainsDate ?? n.firstWeekContainsDate ?? n.locale?.options?.firstWeekContainsDate ?? 1, i = r?.weekStartsOn ?? r?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0, o = xn(e);
  if (!$Be(o))
    throw new RangeError("Invalid time value");
  let l = t.match(I7e).map((c) => {
    const d = c[0];
    if (d === "p" || d === "P") {
      const p = x7e[d];
      return p(c, a.formatLong);
    }
    return c;
  }).join("").match(R7e).map((c) => {
    if (c === "''")
      return { isToken: !1, value: "'" };
    const d = c[0];
    if (d === "'")
      return { isToken: !1, value: P7e(c) };
    if (dU[d])
      return { isToken: !0, value: c };
    if (d.match(O7e))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + d + "`"
      );
    return { isToken: !1, value: c };
  });
  a.localize.preprocessor && (l = a.localize.preprocessor(o, l));
  const u = {
    firstWeekContainsDate: s,
    weekStartsOn: i,
    locale: a
  };
  return l.map((c) => {
    if (!c.isToken) return c.value;
    const d = c.value;
    (!r?.useAdditionalWeekYearTokens && C7e(d) || !r?.useAdditionalDayOfYearTokens && k7e(d)) && A7e(d, t, String(e));
    const p = dU[d[0]];
    return p(o, d, a.localize, u);
  }).join("");
}
function P7e(e) {
  const t = e.match(N7e);
  return t ? t[1].replace(D7e, "'") : e;
}
function L7e(e) {
  const t = xn(e), r = t.getFullYear(), n = t.getMonth(), a = Va(e, 0);
  return a.setFullYear(r, n + 1, 0), a.setHours(0, 0, 0, 0), a.getDate();
}
function M7e(e) {
  return Math.trunc(+xn(e) / 1e3);
}
function F7e(e) {
  const t = xn(e), r = t.getMonth();
  return t.setFullYear(t.getFullYear(), r + 1, 0), t.setHours(0, 0, 0, 0), t;
}
function $7e(e, t) {
  return BBe(
    F7e(e),
    Aa(e),
    t
  ) + 1;
}
function mI(e, t) {
  const r = xn(e), n = xn(t);
  return r.getTime() > n.getTime();
}
function oQ(e, t) {
  const r = xn(e), n = xn(t);
  return +r < +n;
}
function By(e, t) {
  const r = xn(e), n = xn(t);
  return r.getFullYear() === n.getFullYear() && r.getMonth() === n.getMonth();
}
function B7e(e, t) {
  const r = xn(e), n = xn(t);
  return r.getFullYear() === n.getFullYear();
}
function ET(e, t) {
  return aa(e, -t);
}
function ST(e, t) {
  const r = xn(e), n = r.getFullYear(), a = r.getDate(), s = Va(e, 0);
  s.setFullYear(n, t, 15), s.setHours(0, 0, 0, 0);
  const i = L7e(s);
  return r.setMonth(t, Math.min(a, i)), r;
}
function mU(e, t) {
  const r = xn(e);
  return isNaN(+r) ? Va(e, NaN) : (r.setFullYear(t), r);
}
var Fr = function() {
  return Fr = Object.assign || function(t) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, Fr.apply(this, arguments);
};
function U7e(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, n = Object.getOwnPropertySymbols(e); a < n.length; a++)
      t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (r[n[a]] = e[n[a]]);
  return r;
}
function lQ(e, t, r) {
  for (var n = 0, a = t.length, s; n < a; n++)
    (s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
  return e.concat(s || Array.prototype.slice.call(t));
}
function Lh(e) {
  return e.mode === "multiple";
}
function Mh(e) {
  return e.mode === "range";
}
function Uy(e) {
  return e.mode === "single";
}
var z7e = {
  root: "rdp",
  multiple_months: "rdp-multiple_months",
  with_weeknumber: "rdp-with_weeknumber",
  vhidden: "rdp-vhidden",
  button_reset: "rdp-button_reset",
  button: "rdp-button",
  caption: "rdp-caption",
  caption_start: "rdp-caption_start",
  caption_end: "rdp-caption_end",
  caption_between: "rdp-caption_between",
  caption_label: "rdp-caption_label",
  caption_dropdowns: "rdp-caption_dropdowns",
  dropdown: "rdp-dropdown",
  dropdown_month: "rdp-dropdown_month",
  dropdown_year: "rdp-dropdown_year",
  dropdown_icon: "rdp-dropdown_icon",
  months: "rdp-months",
  month: "rdp-month",
  table: "rdp-table",
  tbody: "rdp-tbody",
  tfoot: "rdp-tfoot",
  head: "rdp-head",
  head_row: "rdp-head_row",
  head_cell: "rdp-head_cell",
  nav: "rdp-nav",
  nav_button: "rdp-nav_button",
  nav_button_previous: "rdp-nav_button_previous",
  nav_button_next: "rdp-nav_button_next",
  nav_icon: "rdp-nav_icon",
  row: "rdp-row",
  weeknumber: "rdp-weeknumber",
  cell: "rdp-cell",
  day: "rdp-day",
  day_today: "rdp-day_today",
  day_outside: "rdp-day_outside",
  day_selected: "rdp-day_selected",
  day_disabled: "rdp-day_disabled",
  day_hidden: "rdp-day_hidden",
  day_range_start: "rdp-day_range_start",
  day_range_end: "rdp-day_range_end",
  day_range_middle: "rdp-day_range_middle"
};
function q7e(e, t) {
  return zi(e, "LLLL y", t);
}
function j7e(e, t) {
  return zi(e, "d", t);
}
function H7e(e, t) {
  return zi(e, "LLLL", t);
}
function V7e(e) {
  return "".concat(e);
}
function G7e(e, t) {
  return zi(e, "cccccc", t);
}
function W7e(e, t) {
  return zi(e, "yyyy", t);
}
var K7e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  formatCaption: q7e,
  formatDay: j7e,
  formatMonthCaption: H7e,
  formatWeekNumber: V7e,
  formatWeekdayName: G7e,
  formatYearCaption: W7e
}), Y7e = function(e, t, r) {
  return zi(e, "do MMMM (EEEE)", r);
}, X7e = function() {
  return "Month: ";
}, Z7e = function() {
  return "Go to next month";
}, J7e = function() {
  return "Go to previous month";
}, Q7e = function(e, t) {
  return zi(e, "cccc", t);
}, e9e = function(e) {
  return "Week n. ".concat(e);
}, t9e = function() {
  return "Year: ";
}, r9e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  labelDay: Y7e,
  labelMonthDropdown: X7e,
  labelNext: Z7e,
  labelPrevious: J7e,
  labelWeekNumber: e9e,
  labelWeekday: Q7e,
  labelYearDropdown: t9e
});
function n9e() {
  var e = "buttons", t = z7e, r = $y, n = {}, a = {}, s = 1, i = {}, o = /* @__PURE__ */ new Date();
  return {
    captionLayout: e,
    classNames: t,
    formatters: K7e,
    labels: r9e,
    locale: r,
    modifiersClassNames: n,
    modifiers: a,
    numberOfMonths: s,
    styles: i,
    today: o,
    mode: "default"
  };
}
function i9e(e) {
  var t = e.fromYear, r = e.toYear, n = e.fromMonth, a = e.toMonth, s = e.fromDate, i = e.toDate;
  return n ? s = Aa(n) : t && (s = new Date(t, 0, 1)), a ? i = a2(a) : r && (i = new Date(r, 11, 31)), {
    fromDate: s ? Sd(s) : void 0,
    toDate: i ? Sd(i) : void 0
  };
}
var uQ = Ko(void 0);
function a9e(e) {
  var t, r = e.initialProps, n = n9e(), a = i9e(r), s = a.fromDate, i = a.toDate, o = (t = r.captionLayout) !== null && t !== void 0 ? t : n.captionLayout;
  o !== "buttons" && (!s || !i) && (o = "buttons");
  var l;
  (Uy(r) || Lh(r) || Mh(r)) && (l = r.onSelect);
  var u = Fr(Fr(Fr({}, n), r), { captionLayout: o, classNames: Fr(Fr({}, n.classNames), r.classNames), components: Fr({}, r.components), formatters: Fr(Fr({}, n.formatters), r.formatters), fromDate: s, labels: Fr(Fr({}, n.labels), r.labels), mode: r.mode || n.mode, modifiers: Fr(Fr({}, n.modifiers), r.modifiers), modifiersClassNames: Fr(Fr({}, n.modifiersClassNames), r.modifiersClassNames), onSelect: l, styles: Fr(Fr({}, n.styles), r.styles), toDate: i });
  return K(uQ.Provider, { value: u, children: e.children });
}
function zn() {
  var e = Ta(uQ);
  if (!e)
    throw new Error("useDayPicker must be used within a DayPickerProvider.");
  return e;
}
function cQ(e) {
  var t = zn(), r = t.locale, n = t.classNames, a = t.styles, s = t.formatters.formatCaption;
  return K("div", { className: n.caption_label, style: a.caption_label, "aria-live": "polite", role: "presentation", id: e.id, children: s(e.displayMonth, { locale: r }) });
}
function s9e(e) {
  return K("svg", Fr({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, e, { children: K("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function dQ(e) {
  var t, r, n = e.onChange, a = e.value, s = e.children, i = e.caption, o = e.className, l = e.style, u = zn(), c = (r = (t = u.components) === null || t === void 0 ? void 0 : t.IconDropdown) !== null && r !== void 0 ? r : s9e;
  return $t("div", { className: o, style: l, children: [K("span", { className: u.classNames.vhidden, children: e["aria-label"] }), K("select", { name: e.name, "aria-label": e["aria-label"], className: u.classNames.dropdown, style: u.styles.dropdown, value: a, onChange: n, children: s }), $t("div", { className: u.classNames.caption_label, style: u.styles.caption_label, "aria-hidden": "true", children: [i, K(c, { className: u.classNames.dropdown_icon, style: u.styles.dropdown_icon })] })] });
}
function o9e(e) {
  var t, r = zn(), n = r.fromDate, a = r.toDate, s = r.styles, i = r.locale, o = r.formatters.formatMonthCaption, l = r.classNames, u = r.components, c = r.labels.labelMonthDropdown;
  if (!n)
    return K(ln, {});
  if (!a)
    return K(ln, {});
  var d = [];
  if (B7e(n, a))
    for (var p = Aa(n), f = n.getMonth(); f <= a.getMonth(); f++)
      d.push(ST(p, f));
  else
    for (var p = Aa(/* @__PURE__ */ new Date()), f = 0; f <= 11; f++)
      d.push(ST(p, f));
  var h = function(y) {
    var b = Number(y.target.value), v = ST(Aa(e.displayMonth), b);
    e.onChange(v);
  }, m = (t = u?.Dropdown) !== null && t !== void 0 ? t : dQ;
  return K(m, { name: "months", "aria-label": c(), className: l.dropdown_month, style: s.dropdown_month, onChange: h, value: e.displayMonth.getMonth(), caption: o(e.displayMonth, { locale: i }), children: d.map(function(y) {
    return K("option", { value: y.getMonth(), children: o(y, { locale: i }) }, y.getMonth());
  }) });
}
function l9e(e) {
  var t, r = e.displayMonth, n = zn(), a = n.fromDate, s = n.toDate, i = n.locale, o = n.styles, l = n.classNames, u = n.components, c = n.formatters.formatYearCaption, d = n.labels.labelYearDropdown, p = [];
  if (!a)
    return K(ln, {});
  if (!s)
    return K(ln, {});
  for (var f = a.getFullYear(), h = s.getFullYear(), m = f; m <= h; m++)
    p.push(mU(tQ(/* @__PURE__ */ new Date()), m));
  var y = function(v) {
    var x = mU(Aa(r), Number(v.target.value));
    e.onChange(x);
  }, b = (t = u?.Dropdown) !== null && t !== void 0 ? t : dQ;
  return K(b, { name: "years", "aria-label": d(), className: l.dropdown_year, style: o.dropdown_year, onChange: y, value: r.getFullYear(), caption: c(r, { locale: i }), children: p.map(function(v) {
    return K("option", { value: v.getFullYear(), children: c(v, { locale: i }) }, v.getFullYear());
  }) });
}
function u9e(e, t) {
  var r = Wn(e), n = r[0], a = r[1], s = t === void 0 ? n : t;
  return [s, a];
}
function c9e(e) {
  var t = e.month, r = e.defaultMonth, n = e.today, a = t || r || n || /* @__PURE__ */ new Date(), s = e.toDate, i = e.fromDate, o = e.numberOfMonths, l = o === void 0 ? 1 : o;
  if (s && eh(s, a) < 0) {
    var u = -1 * (l - 1);
    a = qs(s, u);
  }
  return i && eh(a, i) < 0 && (a = i), Aa(a);
}
function d9e() {
  var e = zn(), t = c9e(e), r = u9e(t, e.month), n = r[0], a = r[1], s = function(i) {
    var o;
    if (!e.disableNavigation) {
      var l = Aa(i);
      a(l), (o = e.onMonthChange) === null || o === void 0 || o.call(e, l);
    }
  };
  return [n, s];
}
function f9e(e, t) {
  for (var r = t.reverseMonths, n = t.numberOfMonths, a = Aa(e), s = Aa(qs(a, n)), i = eh(s, a), o = [], l = 0; l < i; l++) {
    var u = qs(a, l);
    o.push(u);
  }
  return r && (o = o.reverse()), o;
}
function p9e(e, t) {
  if (!t.disableNavigation) {
    var r = t.toDate, n = t.pagedNavigation, a = t.numberOfMonths, s = a === void 0 ? 1 : a, i = n ? s : 1, o = Aa(e);
    if (!r)
      return qs(o, i);
    var l = eh(r, e);
    if (!(l < s))
      return qs(o, i);
  }
}
function h9e(e, t) {
  if (!t.disableNavigation) {
    var r = t.fromDate, n = t.pagedNavigation, a = t.numberOfMonths, s = a === void 0 ? 1 : a, i = n ? s : 1, o = Aa(e);
    if (!r)
      return qs(o, -i);
    var l = eh(o, r);
    if (!(l <= 0))
      return qs(o, -i);
  }
}
var fQ = Ko(void 0);
function m9e(e) {
  var t = zn(), r = d9e(), n = r[0], a = r[1], s = f9e(n, t), i = p9e(n, t), o = h9e(n, t), l = function(d) {
    return s.some(function(p) {
      return By(d, p);
    });
  }, u = function(d, p) {
    l(d) || (p && oQ(d, p) ? a(qs(d, 1 + t.numberOfMonths * -1)) : a(d));
  }, c = {
    currentMonth: n,
    displayMonths: s,
    goToMonth: a,
    goToDate: u,
    previousMonth: o,
    nextMonth: i,
    isDateDisplayed: l
  };
  return K(fQ.Provider, { value: c, children: e.children });
}
function zd() {
  var e = Ta(fQ);
  if (!e)
    throw new Error("useNavigation must be used within a NavigationProvider");
  return e;
}
function gU(e) {
  var t, r = zn(), n = r.classNames, a = r.styles, s = r.components, i = zd().goToMonth, o = function(c) {
    i(qs(c, e.displayIndex ? -e.displayIndex : 0));
  }, l = (t = s?.CaptionLabel) !== null && t !== void 0 ? t : cQ, u = K(l, { id: e.id, displayMonth: e.displayMonth });
  return $t("div", { className: n.caption_dropdowns, style: a.caption_dropdowns, children: [K("div", { className: n.vhidden, children: u }), K(o9e, { onChange: o, displayMonth: e.displayMonth }), K(l9e, { onChange: o, displayMonth: e.displayMonth })] });
}
function g9e(e) {
  return K("svg", Fr({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, e, { children: K("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function b9e(e) {
  return K("svg", Fr({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, e, { children: K("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) }));
}
var yb = Mu(function(e, t) {
  var r = zn(), n = r.classNames, a = r.styles, s = [n.button_reset, n.button];
  e.className && s.push(e.className);
  var i = s.join(" "), o = Fr(Fr({}, a.button_reset), a.button);
  return e.style && Object.assign(o, e.style), K("button", Fr({}, e, { ref: t, type: "button", className: i, style: o }));
});
function y9e(e) {
  var t, r, n = zn(), a = n.dir, s = n.locale, i = n.classNames, o = n.styles, l = n.labels, u = l.labelPrevious, c = l.labelNext, d = n.components;
  if (!e.nextMonth && !e.previousMonth)
    return K(ln, {});
  var p = u(e.previousMonth, { locale: s }), f = [
    i.nav_button,
    i.nav_button_previous
  ].join(" "), h = c(e.nextMonth, { locale: s }), m = [
    i.nav_button,
    i.nav_button_next
  ].join(" "), y = (t = d?.IconRight) !== null && t !== void 0 ? t : b9e, b = (r = d?.IconLeft) !== null && r !== void 0 ? r : g9e;
  return $t("div", { className: i.nav, style: o.nav, children: [!e.hidePrevious && K(yb, { name: "previous-month", "aria-label": p, className: f, style: o.nav_button_previous, disabled: !e.previousMonth, onClick: e.onPreviousClick, children: a === "rtl" ? K(y, { className: i.nav_icon, style: o.nav_icon }) : K(b, { className: i.nav_icon, style: o.nav_icon }) }), !e.hideNext && K(yb, { name: "next-month", "aria-label": h, className: m, style: o.nav_button_next, disabled: !e.nextMonth, onClick: e.onNextClick, children: a === "rtl" ? K(b, { className: i.nav_icon, style: o.nav_icon }) : K(y, { className: i.nav_icon, style: o.nav_icon }) })] });
}
function bU(e) {
  var t = zn().numberOfMonths, r = zd(), n = r.previousMonth, a = r.nextMonth, s = r.goToMonth, i = r.displayMonths, o = i.findIndex(function(h) {
    return By(e.displayMonth, h);
  }), l = o === 0, u = o === i.length - 1, c = t > 1 && (l || !u), d = t > 1 && (u || !l), p = function() {
    n && s(n);
  }, f = function() {
    a && s(a);
  };
  return K(y9e, { displayMonth: e.displayMonth, hideNext: c, hidePrevious: d, nextMonth: a, previousMonth: n, onPreviousClick: p, onNextClick: f });
}
function v9e(e) {
  var t, r = zn(), n = r.classNames, a = r.disableNavigation, s = r.styles, i = r.captionLayout, o = r.components, l = (t = o?.CaptionLabel) !== null && t !== void 0 ? t : cQ, u;
  return a ? u = K(l, { id: e.id, displayMonth: e.displayMonth }) : i === "dropdown" ? u = K(gU, { displayMonth: e.displayMonth, id: e.id }) : i === "dropdown-buttons" ? u = $t(ln, { children: [K(gU, { displayMonth: e.displayMonth, displayIndex: e.displayIndex, id: e.id }), K(bU, { displayMonth: e.displayMonth, displayIndex: e.displayIndex, id: e.id })] }) : u = $t(ln, { children: [K(l, { id: e.id, displayMonth: e.displayMonth, displayIndex: e.displayIndex }), K(bU, { displayMonth: e.displayMonth, id: e.id })] }), K("div", { className: n.caption, style: s.caption, children: u });
}
function w9e(e) {
  var t = zn(), r = t.footer, n = t.styles, a = t.classNames.tfoot;
  return r ? K("tfoot", { className: a, style: n.tfoot, children: K("tr", { children: K("td", { colSpan: 8, children: r }) }) }) : K(ln, {});
}
function x9e(e, t, r) {
  for (var n = r ? Lu(/* @__PURE__ */ new Date()) : co(/* @__PURE__ */ new Date(), { locale: e, weekStartsOn: t }), a = [], s = 0; s < 7; s++) {
    var i = aa(n, s);
    a.push(i);
  }
  return a;
}
function E9e() {
  var e = zn(), t = e.classNames, r = e.styles, n = e.showWeekNumber, a = e.locale, s = e.weekStartsOn, i = e.ISOWeek, o = e.formatters.formatWeekdayName, l = e.labels.labelWeekday, u = x9e(a, s, i);
  return $t("tr", { style: r.head_row, className: t.head_row, children: [n && K("td", { style: r.head_cell, className: t.head_cell }), u.map(function(c, d) {
    return K("th", { scope: "col", className: t.head_cell, style: r.head_cell, "aria-label": l(c, { locale: a }), children: o(c, { locale: a }) }, d);
  })] });
}
function S9e() {
  var e, t = zn(), r = t.classNames, n = t.styles, a = t.components, s = (e = a?.HeadRow) !== null && e !== void 0 ? e : E9e;
  return K("thead", { style: n.head, className: r.head, children: K(s, {}) });
}
function _9e(e) {
  var t = zn(), r = t.locale, n = t.formatters.formatDay;
  return K(ln, { children: n(e.date, { locale: r }) });
}
var o2 = Ko(void 0);
function k9e(e) {
  if (!Lh(e.initialProps)) {
    var t = {
      selected: void 0,
      modifiers: {
        disabled: []
      }
    };
    return K(o2.Provider, { value: t, children: e.children });
  }
  return K(C9e, { initialProps: e.initialProps, children: e.children });
}
function C9e(e) {
  var t = e.initialProps, r = e.children, n = t.selected, a = t.min, s = t.max, i = function(u, c, d) {
    var p, f;
    (p = t.onDayClick) === null || p === void 0 || p.call(t, u, c, d);
    var h = !!(c.selected && a && n?.length === a);
    if (!h) {
      var m = !!(!c.selected && s && n?.length === s);
      if (!m) {
        var y = n ? lQ([], n) : [];
        if (c.selected) {
          var b = y.findIndex(function(v) {
            return Ca(u, v);
          });
          y.splice(b, 1);
        } else
          y.push(u);
        (f = t.onSelect) === null || f === void 0 || f.call(t, y, u, c, d);
      }
    }
  }, o = {
    disabled: []
  };
  n && o.disabled.push(function(u) {
    var c = s && n.length > s - 1, d = n.some(function(p) {
      return Ca(p, u);
    });
    return !!(c && !d);
  });
  var l = {
    selected: n,
    onDayClick: i,
    modifiers: o
  };
  return K(o2.Provider, { value: l, children: r });
}
function l2() {
  var e = Ta(o2);
  if (!e)
    throw new Error("useSelectMultiple must be used within a SelectMultipleProvider");
  return e;
}
function A9e(e, t) {
  var r = t || {}, n = r.from, a = r.to;
  return n && a ? Ca(a, e) && Ca(n, e) ? void 0 : Ca(a, e) ? { from: a, to: void 0 } : Ca(n, e) ? void 0 : mI(n, e) ? { from: e, to: a } : { from: n, to: e } : a ? mI(e, a) ? { from: a, to: e } : { from: e, to: a } : n ? oQ(e, n) ? { from: e, to: n } : { from: n, to: e } : { from: e, to: void 0 };
}
var u2 = Ko(void 0);
function T9e(e) {
  if (!Mh(e.initialProps)) {
    var t = {
      selected: void 0,
      modifiers: {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
      }
    };
    return K(u2.Provider, { value: t, children: e.children });
  }
  return K(R9e, { initialProps: e.initialProps, children: e.children });
}
function R9e(e) {
  var t = e.initialProps, r = e.children, n = t.selected, a = n || {}, s = a.from, i = a.to, o = t.min, l = t.max, u = function(f, h, m) {
    var y, b;
    (y = t.onDayClick) === null || y === void 0 || y.call(t, f, h, m);
    var v = A9e(f, n);
    (b = t.onSelect) === null || b === void 0 || b.call(t, v, f, h, m);
  }, c = {
    range_start: [],
    range_end: [],
    range_middle: [],
    disabled: []
  };
  if (s ? (c.range_start = [s], i ? (c.range_end = [i], Ca(s, i) || (c.range_middle = [
    {
      after: s,
      before: i
    }
  ])) : c.range_end = [s]) : i && (c.range_start = [i], c.range_end = [i]), o && (s && !i && c.disabled.push({
    after: ET(s, o - 1),
    before: aa(s, o - 1)
  }), s && i && c.disabled.push({
    after: s,
    before: aa(s, o - 1)
  }), !s && i && c.disabled.push({
    after: ET(i, o - 1),
    before: aa(i, o - 1)
  })), l) {
    if (s && !i && (c.disabled.push({
      before: aa(s, -l + 1)
    }), c.disabled.push({
      after: aa(s, l - 1)
    })), s && i) {
      var d = io(i, s) + 1, p = l - d;
      c.disabled.push({
        before: ET(s, p)
      }), c.disabled.push({
        after: aa(i, p)
      });
    }
    !s && i && (c.disabled.push({
      before: aa(i, -l + 1)
    }), c.disabled.push({
      after: aa(i, l - 1)
    }));
  }
  return K(u2.Provider, { value: { selected: n, onDayClick: u, modifiers: c }, children: r });
}
function c2() {
  var e = Ta(u2);
  if (!e)
    throw new Error("useSelectRange must be used within a SelectRangeProvider");
  return e;
}
function wg(e) {
  return Array.isArray(e) ? lQ([], e) : e !== void 0 ? [e] : [];
}
function I9e(e) {
  var t = {};
  return Object.entries(e).forEach(function(r) {
    var n = r[0], a = r[1];
    t[n] = wg(a);
  }), t;
}
var js;
(function(e) {
  e.Outside = "outside", e.Disabled = "disabled", e.Selected = "selected", e.Hidden = "hidden", e.Today = "today", e.RangeStart = "range_start", e.RangeEnd = "range_end", e.RangeMiddle = "range_middle";
})(js || (js = {}));
var N9e = js.Selected, Ao = js.Disabled, D9e = js.Hidden, O9e = js.Today, _T = js.RangeEnd, kT = js.RangeMiddle, CT = js.RangeStart, P9e = js.Outside;
function L9e(e, t, r) {
  var n, a = (n = {}, n[N9e] = wg(e.selected), n[Ao] = wg(e.disabled), n[D9e] = wg(e.hidden), n[O9e] = [e.today], n[_T] = [], n[kT] = [], n[CT] = [], n[P9e] = [], n);
  return e.fromDate && a[Ao].push({ before: e.fromDate }), e.toDate && a[Ao].push({ after: e.toDate }), Lh(e) ? a[Ao] = a[Ao].concat(t.modifiers[Ao]) : Mh(e) && (a[Ao] = a[Ao].concat(r.modifiers[Ao]), a[CT] = r.modifiers[CT], a[kT] = r.modifiers[kT], a[_T] = r.modifiers[_T]), a;
}
var pQ = Ko(void 0);
function M9e(e) {
  var t = zn(), r = l2(), n = c2(), a = L9e(t, r, n), s = I9e(t.modifiers), i = Fr(Fr({}, a), s);
  return K(pQ.Provider, { value: i, children: e.children });
}
function hQ() {
  var e = Ta(pQ);
  if (!e)
    throw new Error("useModifiers must be used within a ModifiersProvider");
  return e;
}
function F9e(e) {
  return !!(e && typeof e == "object" && "before" in e && "after" in e);
}
function $9e(e) {
  return !!(e && typeof e == "object" && "from" in e);
}
function B9e(e) {
  return !!(e && typeof e == "object" && "after" in e);
}
function U9e(e) {
  return !!(e && typeof e == "object" && "before" in e);
}
function z9e(e) {
  return !!(e && typeof e == "object" && "dayOfWeek" in e);
}
function q9e(e, t) {
  var r, n = t.from, a = t.to;
  if (n && a) {
    var s = io(a, n) < 0;
    s && (r = [a, n], n = r[0], a = r[1]);
    var i = io(e, n) >= 0 && io(a, e) >= 0;
    return i;
  }
  return a ? Ca(a, e) : n ? Ca(n, e) : !1;
}
function j9e(e) {
  return i2(e);
}
function H9e(e) {
  return Array.isArray(e) && e.every(i2);
}
function V9e(e, t) {
  return t.some(function(r) {
    if (typeof r == "boolean")
      return r;
    if (j9e(r))
      return Ca(e, r);
    if (H9e(r))
      return r.includes(e);
    if ($9e(r))
      return q9e(e, r);
    if (z9e(r))
      return r.dayOfWeek.includes(e.getDay());
    if (F9e(r)) {
      var n = io(r.before, e), a = io(r.after, e), s = n > 0, i = a < 0, o = mI(r.before, r.after);
      return o ? i && s : s || i;
    }
    return B9e(r) ? io(e, r.after) > 0 : U9e(r) ? io(r.before, e) > 0 : typeof r == "function" ? r(e) : !1;
  });
}
function d2(e, t, r) {
  var n = Object.keys(t).reduce(function(s, i) {
    var o = t[i];
    return V9e(e, o) && s.push(i), s;
  }, []), a = {};
  return n.forEach(function(s) {
    return a[s] = !0;
  }), r && !By(e, r) && (a.outside = !0), a;
}
function G9e(e, t) {
  for (var r = Aa(e[0]), n = a2(e[e.length - 1]), a, s, i = r; i <= n; ) {
    var o = d2(i, t), l = !o.disabled && !o.hidden;
    if (!l) {
      i = aa(i, 1);
      continue;
    }
    if (o.selected)
      return i;
    o.today && !s && (s = i), a || (a = i), i = aa(i, 1);
  }
  return s || a;
}
var W9e = 365;
function mQ(e, t) {
  var r = t.moveBy, n = t.direction, a = t.context, s = t.modifiers, i = t.retry, o = i === void 0 ? { count: 0, lastFocused: e } : i, l = a.weekStartsOn, u = a.fromDate, c = a.toDate, d = a.locale, p = {
    day: aa,
    week: hI,
    month: qs,
    year: Gf,
    startOfWeek: function(y) {
      return a.ISOWeek ? Lu(y) : co(y, { locale: d, weekStartsOn: l });
    },
    endOfWeek: function(y) {
      return a.ISOWeek ? rQ(y) : s2(y, { locale: d, weekStartsOn: l });
    }
  }, f = p[r](e, n === "after" ? 1 : -1);
  n === "before" && u ? f = MBe([u, f]) : n === "after" && c && (f = FBe([c, f]));
  var h = !0;
  if (s) {
    var m = d2(f, s);
    h = !m.disabled && !m.hidden;
  }
  return h ? f : o.count > W9e ? o.lastFocused : mQ(f, {
    moveBy: r,
    direction: n,
    context: a,
    modifiers: s,
    retry: Fr(Fr({}, o), { count: o.count + 1 })
  });
}
var gQ = Ko(void 0);
function K9e(e) {
  var t = zd(), r = hQ(), n = Wn(), a = n[0], s = n[1], i = Wn(), o = i[0], l = i[1], u = G9e(t.displayMonths, r), c = a ?? (o && t.isDateDisplayed(o)) ? o : u, d = function() {
    l(a), s(void 0);
  }, p = function(y) {
    s(y);
  }, f = zn(), h = function(y, b) {
    if (a) {
      var v = mQ(a, {
        moveBy: y,
        direction: b,
        context: f,
        modifiers: r
      });
      Ca(a, v) || (t.goToDate(v, a), p(v));
    }
  }, m = {
    focusedDay: a,
    focusTarget: c,
    blur: d,
    focus: p,
    focusDayAfter: function() {
      return h("day", "after");
    },
    focusDayBefore: function() {
      return h("day", "before");
    },
    focusWeekAfter: function() {
      return h("week", "after");
    },
    focusWeekBefore: function() {
      return h("week", "before");
    },
    focusMonthBefore: function() {
      return h("month", "before");
    },
    focusMonthAfter: function() {
      return h("month", "after");
    },
    focusYearBefore: function() {
      return h("year", "before");
    },
    focusYearAfter: function() {
      return h("year", "after");
    },
    focusStartOfWeek: function() {
      return h("startOfWeek", "before");
    },
    focusEndOfWeek: function() {
      return h("endOfWeek", "after");
    }
  };
  return K(gQ.Provider, { value: m, children: e.children });
}
function f2() {
  var e = Ta(gQ);
  if (!e)
    throw new Error("useFocusContext must be used within a FocusProvider");
  return e;
}
function Y9e(e, t) {
  var r = hQ(), n = d2(e, r, t);
  return n;
}
var p2 = Ko(void 0);
function X9e(e) {
  if (!Uy(e.initialProps)) {
    var t = {
      selected: void 0
    };
    return K(p2.Provider, { value: t, children: e.children });
  }
  return K(Z9e, { initialProps: e.initialProps, children: e.children });
}
function Z9e(e) {
  var t = e.initialProps, r = e.children, n = function(s, i, o) {
    var l, u, c;
    if ((l = t.onDayClick) === null || l === void 0 || l.call(t, s, i, o), i.selected && !t.required) {
      (u = t.onSelect) === null || u === void 0 || u.call(t, void 0, s, i, o);
      return;
    }
    (c = t.onSelect) === null || c === void 0 || c.call(t, s, s, i, o);
  }, a = {
    selected: t.selected,
    onDayClick: n
  };
  return K(p2.Provider, { value: a, children: r });
}
function bQ() {
  var e = Ta(p2);
  if (!e)
    throw new Error("useSelectSingle must be used within a SelectSingleProvider");
  return e;
}
function J9e(e, t) {
  var r = zn(), n = bQ(), a = l2(), s = c2(), i = f2(), o = i.focusDayAfter, l = i.focusDayBefore, u = i.focusWeekAfter, c = i.focusWeekBefore, d = i.blur, p = i.focus, f = i.focusMonthBefore, h = i.focusMonthAfter, m = i.focusYearBefore, y = i.focusYearAfter, b = i.focusStartOfWeek, v = i.focusEndOfWeek, x = function(Q) {
    var ne, le, W, X;
    Uy(r) ? (ne = n.onDayClick) === null || ne === void 0 || ne.call(n, e, t, Q) : Lh(r) ? (le = a.onDayClick) === null || le === void 0 || le.call(a, e, t, Q) : Mh(r) ? (W = s.onDayClick) === null || W === void 0 || W.call(s, e, t, Q) : (X = r.onDayClick) === null || X === void 0 || X.call(r, e, t, Q);
  }, _ = function(Q) {
    var ne;
    p(e), (ne = r.onDayFocus) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, E = function(Q) {
    var ne;
    d(), (ne = r.onDayBlur) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, w = function(Q) {
    var ne;
    (ne = r.onDayMouseEnter) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, C = function(Q) {
    var ne;
    (ne = r.onDayMouseLeave) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, k = function(Q) {
    var ne;
    (ne = r.onDayPointerEnter) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, S = function(Q) {
    var ne;
    (ne = r.onDayPointerLeave) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, B = function(Q) {
    var ne;
    (ne = r.onDayTouchCancel) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, U = function(Q) {
    var ne;
    (ne = r.onDayTouchEnd) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, N = function(Q) {
    var ne;
    (ne = r.onDayTouchMove) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, O = function(Q) {
    var ne;
    (ne = r.onDayTouchStart) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, I = function(Q) {
    var ne;
    (ne = r.onDayKeyUp) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, q = function(Q) {
    var ne;
    switch (Q.key) {
      case "ArrowLeft":
        Q.preventDefault(), Q.stopPropagation(), r.dir === "rtl" ? o() : l();
        break;
      case "ArrowRight":
        Q.preventDefault(), Q.stopPropagation(), r.dir === "rtl" ? l() : o();
        break;
      case "ArrowDown":
        Q.preventDefault(), Q.stopPropagation(), u();
        break;
      case "ArrowUp":
        Q.preventDefault(), Q.stopPropagation(), c();
        break;
      case "PageUp":
        Q.preventDefault(), Q.stopPropagation(), Q.shiftKey ? m() : f();
        break;
      case "PageDown":
        Q.preventDefault(), Q.stopPropagation(), Q.shiftKey ? y() : h();
        break;
      case "Home":
        Q.preventDefault(), Q.stopPropagation(), b();
        break;
      case "End":
        Q.preventDefault(), Q.stopPropagation(), v();
        break;
    }
    (ne = r.onDayKeyDown) === null || ne === void 0 || ne.call(r, e, t, Q);
  }, ae = {
    onClick: x,
    onFocus: _,
    onBlur: E,
    onKeyDown: q,
    onKeyUp: I,
    onMouseEnter: w,
    onMouseLeave: C,
    onPointerEnter: k,
    onPointerLeave: S,
    onTouchCancel: B,
    onTouchEnd: U,
    onTouchMove: N,
    onTouchStart: O
  };
  return ae;
}
function Q9e() {
  var e = zn(), t = bQ(), r = l2(), n = c2(), a = Uy(e) ? t.selected : Lh(e) ? r.selected : Mh(e) ? n.selected : void 0;
  return a;
}
function eUe(e) {
  return Object.values(js).includes(e);
}
function tUe(e, t) {
  var r = [e.classNames.day];
  return Object.keys(t).forEach(function(n) {
    var a = e.modifiersClassNames[n];
    if (a)
      r.push(a);
    else if (eUe(n)) {
      var s = e.classNames["day_".concat(n)];
      s && r.push(s);
    }
  }), r;
}
function rUe(e, t) {
  var r = Fr({}, e.styles.day);
  return Object.keys(t).forEach(function(n) {
    var a;
    r = Fr(Fr({}, r), (a = e.modifiersStyles) === null || a === void 0 ? void 0 : a[n]);
  }), r;
}
function yQ(e, t, r) {
  var n, a, s, i = zn(), o = f2(), l = Y9e(e, t), u = J9e(e, l), c = Q9e(), d = !!(i.onDayClick || i.mode !== "default");
  Qn(function() {
    var w;
    l.outside || o.focusedDay && d && Ca(o.focusedDay, e) && ((w = r.current) === null || w === void 0 || w.focus());
  }, [
    o.focusedDay,
    e,
    r,
    d,
    l.outside
  ]);
  var p = tUe(i, l).join(" "), f = rUe(i, l), h = !!(l.outside && !i.showOutsideDays || l.hidden), m = (s = (a = i.components) === null || a === void 0 ? void 0 : a.DayContent) !== null && s !== void 0 ? s : _9e, y = K(m, { date: e, displayMonth: t, activeModifiers: l }), b = {
    style: f,
    className: p,
    children: y,
    role: "gridcell"
  }, v = o.focusTarget && Ca(o.focusTarget, e) && !l.outside, x = o.focusedDay && Ca(o.focusedDay, e), _ = Fr(Fr(Fr({}, b), (n = { disabled: l.disabled, role: "gridcell" }, n["aria-selected"] = l.selected, n.tabIndex = x || v ? 0 : -1, n)), u), E = {
    isButton: d,
    isHidden: h,
    activeModifiers: l,
    selectedDays: c,
    buttonProps: _,
    divProps: b
  };
  return E;
}
function nUe(e) {
  var t = Gr(null), r = yQ(e.date, e.displayMonth, t);
  return r.isHidden ? K("div", { role: "gridcell" }) : r.isButton ? K(yb, Fr({ name: "day", ref: t }, r.buttonProps)) : K("div", Fr({}, r.divProps));
}
function iUe(e) {
  var t = e.number, r = e.dates, n = zn(), a = n.onWeekNumberClick, s = n.styles, i = n.classNames, o = n.locale, l = n.labels.labelWeekNumber, u = n.formatters.formatWeekNumber, c = u(Number(t), { locale: o });
  if (!a)
    return K("span", { className: i.weeknumber, style: s.weeknumber, children: c });
  var d = l(Number(t), { locale: o }), p = function(f) {
    a(t, r, f);
  };
  return K(yb, { name: "week-number", "aria-label": d, className: i.weeknumber, style: s.weeknumber, onClick: p, children: c });
}
function aUe(e) {
  var t, r, n = zn(), a = n.styles, s = n.classNames, i = n.showWeekNumber, o = n.components, l = (t = o?.Day) !== null && t !== void 0 ? t : nUe, u = (r = o?.WeekNumber) !== null && r !== void 0 ? r : iUe, c;
  return i && (c = K("td", { className: s.cell, style: a.cell, children: K(u, { number: e.weekNumber, dates: e.dates }) })), $t("tr", { className: s.row, style: a.row, children: [c, e.dates.map(function(d) {
    return K("td", { className: s.cell, style: a.cell, role: "presentation", children: K(l, { displayMonth: e.displayMonth, date: d }) }, M7e(d));
  })] });
}
function yU(e, t, r) {
  for (var n = r?.ISOWeek ? rQ(t) : s2(t, r), a = r?.ISOWeek ? Lu(e) : co(e, r), s = io(n, a), i = [], o = 0; o <= s; o++)
    i.push(aa(a, o));
  var l = i.reduce(function(u, c) {
    var d = r?.ISOWeek ? nQ(c) : aQ(c, r), p = u.find(function(f) {
      return f.weekNumber === d;
    });
    return p ? (p.dates.push(c), u) : (u.push({
      weekNumber: d,
      dates: [c]
    }), u);
  }, []);
  return l;
}
function sUe(e, t) {
  var r = yU(Aa(e), a2(e), t);
  if (t?.useFixedWeeks) {
    var n = $7e(e, t);
    if (n < 6) {
      var a = r[r.length - 1], s = a.dates[a.dates.length - 1], i = hI(s, 6 - n), o = yU(hI(s, 1), i, t);
      r.push.apply(r, o);
    }
  }
  return r;
}
function oUe(e) {
  var t, r, n, a = zn(), s = a.locale, i = a.classNames, o = a.styles, l = a.hideHead, u = a.fixedWeeks, c = a.components, d = a.weekStartsOn, p = a.firstWeekContainsDate, f = a.ISOWeek, h = sUe(e.displayMonth, {
    useFixedWeeks: !!u,
    ISOWeek: f,
    locale: s,
    weekStartsOn: d,
    firstWeekContainsDate: p
  }), m = (t = c?.Head) !== null && t !== void 0 ? t : S9e, y = (r = c?.Row) !== null && r !== void 0 ? r : aUe, b = (n = c?.Footer) !== null && n !== void 0 ? n : w9e;
  return $t("table", { id: e.id, className: i.table, style: o.table, role: "grid", "aria-labelledby": e["aria-labelledby"], children: [!l && K(m, {}), K("tbody", { className: i.tbody, style: o.tbody, children: h.map(function(v) {
    return K(y, { displayMonth: e.displayMonth, dates: v.dates, weekNumber: v.weekNumber }, v.weekNumber);
  }) }), K(b, { displayMonth: e.displayMonth })] });
}
function lUe() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var uUe = lUe() ? Sb : Qn, AT = !1, cUe = 0;
function vU() {
  return "react-day-picker-".concat(++cUe);
}
function dUe(e) {
  var t, r = e ?? (AT ? vU() : null), n = Wn(r), a = n[0], s = n[1];
  return uUe(function() {
    a === null && s(vU());
  }, []), Qn(function() {
    AT === !1 && (AT = !0);
  }, []), (t = e ?? a) !== null && t !== void 0 ? t : void 0;
}
function fUe(e) {
  var t, r, n = zn(), a = n.dir, s = n.classNames, i = n.styles, o = n.components, l = zd().displayMonths, u = dUe(n.id ? "".concat(n.id, "-").concat(e.displayIndex) : void 0), c = n.id ? "".concat(n.id, "-grid-").concat(e.displayIndex) : void 0, d = [s.month], p = i.month, f = e.displayIndex === 0, h = e.displayIndex === l.length - 1, m = !f && !h;
  a === "rtl" && (t = [f, h], h = t[0], f = t[1]), f && (d.push(s.caption_start), p = Fr(Fr({}, p), i.caption_start)), h && (d.push(s.caption_end), p = Fr(Fr({}, p), i.caption_end)), m && (d.push(s.caption_between), p = Fr(Fr({}, p), i.caption_between));
  var y = (r = o?.Caption) !== null && r !== void 0 ? r : v9e;
  return $t("div", { className: d.join(" "), style: p, children: [K(y, { id: u, displayMonth: e.displayMonth, displayIndex: e.displayIndex }), K(oUe, { id: c, "aria-labelledby": u, displayMonth: e.displayMonth })] }, e.displayIndex);
}
function pUe(e) {
  var t = zn(), r = t.classNames, n = t.styles;
  return K("div", { className: r.months, style: n.months, children: e.children });
}
function hUe(e) {
  var t, r, n = e.initialProps, a = zn(), s = f2(), i = zd(), o = Wn(!1), l = o[0], u = o[1];
  Qn(function() {
    a.initialFocus && s.focusTarget && (l || (s.focus(s.focusTarget), u(!0)));
  }, [
    a.initialFocus,
    l,
    s.focus,
    s.focusTarget,
    s
  ]);
  var c = [a.classNames.root, a.className];
  a.numberOfMonths > 1 && c.push(a.classNames.multiple_months), a.showWeekNumber && c.push(a.classNames.with_weeknumber);
  var d = Fr(Fr({}, a.styles.root), a.style), p = Object.keys(n).filter(function(h) {
    return h.startsWith("data-");
  }).reduce(function(h, m) {
    var y;
    return Fr(Fr({}, h), (y = {}, y[m] = n[m], y));
  }, {}), f = (r = (t = n.components) === null || t === void 0 ? void 0 : t.Months) !== null && r !== void 0 ? r : pUe;
  return K("div", Fr({ className: c.join(" "), style: d, dir: a.dir, id: a.id, nonce: n.nonce, title: n.title, lang: n.lang }, p, { children: K(f, { children: i.displayMonths.map(function(h, m) {
    return K(fUe, { displayIndex: m, displayMonth: h }, m);
  }) }) }));
}
function mUe(e) {
  var t = e.children, r = U7e(e, ["children"]);
  return K(a9e, { initialProps: r, children: K(m9e, { children: K(X9e, { initialProps: r, children: K(k9e, { initialProps: r, children: K(T9e, { initialProps: r, children: K(M9e, { children: K(K9e, { children: t }) }) }) }) }) }) });
}
function gUe(e) {
  return K(mUe, Fr({}, e, { children: K(hUe, { initialProps: e }) }));
}
const Wf = D.forwardRef(
  ({ onClick: e, icon: t, disabled: r, ...n }, a) => {
    const s = t;
    return /* @__PURE__ */ K(
      "button",
      {
        ref: a,
        type: "button",
        disabled: r,
        className: gr(
          "flex size-8 shrink-0 select-none items-center justify-center rounded border p-1 outline-none transition sm:size-[30px]",
          // text color
          "text-gray-600 hover:text-gray-800",
          "dark:text-gray-400 hover:dark:text-gray-200",
          // border color
          "border-gray-300 dark:border-gray-800",
          // background color
          "hover:bg-gray-50 active:bg-gray-100",
          "hover:dark:bg-gray-900 active:dark:bg-gray-800",
          // disabled
          "disabled:pointer-events-none",
          "disabled:border-gray-200 disabled:dark:border-gray-800",
          "disabled:text-gray-400 disabled:dark:text-gray-600",
          dh
        ),
        onClick: e,
        ...n,
        children: /* @__PURE__ */ K(s, { className: "size-full shrink-0" })
      }
    );
  }
);
Wf.displayName = "NavigationButton";
const h2 = ({
  mode: e = "single",
  weekStartsOn: t = 1,
  numberOfMonths: r = 1,
  enableYearNavigation: n = !1,
  disableNavigation: a,
  locale: s,
  className: i,
  classNames: o,
  ...l
}) => /* @__PURE__ */ K(
  gUe,
  {
    mode: e,
    weekStartsOn: t,
    numberOfMonths: r,
    locale: s,
    showOutsideDays: r === 1,
    className: gr(i),
    classNames: {
      months: "flex space-y-0",
      month: "space-y-4 p-3",
      nav: "gap-1 flex items-center rounded-full size-full justify-between p-4",
      table: "w-full border-collapse space-y-1",
      head_cell: "w-9 font-medium text-sm sm:text-xs text-center text-gray-400 dark:text-gray-600 pb-2",
      row: "w-full mt-0.5",
      cell: gr(
        "relative p-0 text-center focus-within:relative",
        "text-gray-900 dark:text-gray-50"
      ),
      day: gr(
        "size-9 rounded text-sm focus:z-10",
        "text-gray-900 dark:text-gray-50",
        "hover:bg-gray-200 hover:dark:bg-gray-700",
        dh
      ),
      day_today: "font-semibold",
      day_selected: gr(
        "rounded",
        "aria-selected:bg-gray-900 aria-selected:text-white",
        "dark:aria-selected:bg-gray-100 dark:aria-selected:text-black"
      ),
      day_disabled: "!text-gray-300 dark:!text-gray-700 line-through disabled:hover:bg-transparent",
      day_outside: "text-gray-400 dark:text-gray-600",
      day_range_middle: gr(
        "!rounded-none",
        "aria-selected:!bg-gray-100 aria-selected:!text-gray-900",
        "dark:aria-selected:!bg-gray-900 dark:aria-selected:!text-gray-50"
      ),
      day_range_start: "rounded-r-none !rounded-l",
      day_range_end: "rounded-l-none !rounded-r",
      day_hidden: "invisible",
      ...o
    },
    components: {
      IconLeft: () => /* @__PURE__ */ K(MP, { "aria-hidden": "true", className: "size-4" }),
      IconRight: () => /* @__PURE__ */ K(WT, { "aria-hidden": "true", className: "size-4" }),
      Caption: ({ ...u }) => {
        const {
          goToMonth: c,
          nextMonth: d,
          previousMonth: p,
          currentMonth: f,
          displayMonths: h
        } = zd(), { numberOfMonths: m, fromDate: y, toDate: b } = zn(), v = h.findIndex(
          (S) => By(u.displayMonth, S)
        ), x = v === 0, _ = v === h.length - 1, E = m > 1 && (x || !_), w = m > 1 && (_ || !x), C = () => {
          const S = Gf(f, -1);
          p && (!y || S.getTime() >= y.getTime()) && c(S);
        }, k = () => {
          const S = Gf(f, 1);
          d && (!b || S.getTime() <= b.getTime()) && c(S);
        };
        return /* @__PURE__ */ $t("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ $t("div", { className: "flex items-center gap-1", children: [
            n && !w && /* @__PURE__ */ K(
              Wf,
              {
                disabled: a || !p || y && Gf(f, -1).getTime() < y.getTime(),
                "aria-label": "Go to previous year",
                onClick: C,
                icon: eue
              }
            ),
            !w && /* @__PURE__ */ K(
              Wf,
              {
                disabled: a || !p,
                "aria-label": "Go to previous month",
                onClick: () => p && c(p),
                icon: MP
              }
            )
          ] }),
          /* @__PURE__ */ K(
            "div",
            {
              role: "presentation",
              "aria-live": "polite",
              className: "text-sm font-medium capitalize tabular-nums text-gray-900 dark:text-gray-50",
              children: zi(u.displayMonth, "LLLL yyy", { locale: s })
            }
          ),
          /* @__PURE__ */ $t("div", { className: "flex items-center gap-1", children: [
            !E && /* @__PURE__ */ K(
              Wf,
              {
                disabled: a || !d,
                "aria-label": "Go to next month",
                onClick: () => d && c(d),
                icon: WT
              }
            ),
            n && !E && /* @__PURE__ */ K(
              Wf,
              {
                disabled: a || !d || b && Gf(f, 1).getTime() > b.getTime(),
                "aria-label": "Go to next year",
                onClick: k,
                icon: rue
              }
            )
          ] })
        ] });
      },
      Day: ({ date: u, displayMonth: c }) => {
        const d = D.useRef(null), { activeModifiers: p, buttonProps: f, divProps: h, isButton: m, isHidden: y } = yQ(u, c, d), { selected: b, today: v, disabled: x, range_middle: _ } = p;
        if (y)
          return /* @__PURE__ */ K(ln, {});
        if (!m)
          return /* @__PURE__ */ K(
            "div",
            {
              ...h,
              className: gr(
                "flex items-center justify-center",
                h.className
              )
            }
          );
        const {
          children: E,
          className: w,
          ...C
        } = f;
        return /* @__PURE__ */ $t(
          "button",
          {
            ref: d,
            ...C,
            type: "button",
            className: gr("relative", w),
            children: [
              E,
              v && /* @__PURE__ */ K(
                "span",
                {
                  className: gr(
                    "absolute inset-x-1/2 bottom-1.5 h-0.5 w-4 -translate-x-1/2 rounded-[2px]",
                    {
                      "bg-gray-900 dark:bg-gray-100": !b,
                      "!bg-white dark:!bg-gray-950": b,
                      "!bg-gray-400 dark:!bg-gray-600": b && _,
                      "bg-gray-400 text-gray-400 dark:bg-gray-400 dark:text-gray-600": x
                    }
                  )
                }
              )
            ]
          }
        );
      }
    },
    "tremor-id": "tremor-raw",
    ...l
  }
);
h2.displayName = "Calendar";
const bUe = () => {
  const e = typeof window < "u" ? window.navigator.language : "en-US", t = new Intl.DateTimeFormat(e, {
    hour: "numeric"
  }).format();
  return Number.isInteger(Number(t));
}, yUe = ({ segment: e, state: t }) => {
  const r = D.useRef(null), { segmentProps: n } = gBe(e, t, r), a = e.type === "literal" && e.text === ":", s = e.type === "literal" && e.text === " ";
  return /* @__PURE__ */ $t(
    "div",
    {
      ...n,
      ref: r,
      className: gr(
        // base
        "relative block w-full appearance-none rounded-md border px-2.5 py-1.5 text-left uppercase tabular-nums shadow-sm outline-none transition sm:text-sm",
        // border color
        "border-gray-300 dark:border-gray-800",
        // text color
        "text-gray-900 dark:text-gray-50",
        // background color
        "bg-white dark:bg-gray-950",
        // focus
        ch,
        // invalid (optional)
        "invalid:border-red-500 invalid:ring-2 invalid:ring-red-200 group-aria-[invalid=true]/time-input:border-red-500 group-aria-[invalid=true]/time-input:ring-2 group-aria-[invalid=true]/time-input:ring-red-200 group-aria-[invalid=true]/time-input:dark:ring-red-400/20",
        {
          "!w-fit border-none bg-transparent px-0 text-gray-400 shadow-none": a || s,
          hidden: s,
          "border-gray-300 bg-gray-100 text-gray-400 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-500": t.isDisabled,
          "!bg-transparent !text-gray-400": !e.isEditable
        }
      ),
      children: [
        /* @__PURE__ */ K(
          "span",
          {
            "aria-hidden": "true",
            className: gr(
              "pointer-events-none block w-full text-left text-gray-700 sm:text-sm",
              {
                hidden: !e.isPlaceholder,
                "h-0": !e.isPlaceholder
              }
            ),
            children: e.placeholder
          }
        ),
        e.isPlaceholder ? " " : e.text
      ]
    }
  );
}, vb = D.forwardRef(
  ({ hourCycle: e, ...t }, r) => {
    const n = D.useRef(null);
    D.useImperativeHandle(
      r,
      () => n?.current
    );
    const a = window !== void 0 ? window.navigator.language : "en-US", s = DBe({
      hourCycle: e,
      locale: a,
      shouldForceLeadingZeros: !0,
      autoFocus: !0,
      ...t
    }), { fieldProps: i } = nBe(
      {
        ...t,
        hourCycle: e,
        shouldForceLeadingZeros: !0
      },
      s,
      n
    );
    return /* @__PURE__ */ K(
      "div",
      {
        ...i,
        ref: n,
        className: "group/time-input inline-flex w-full gap-x-2",
        children: s.segments.map((o, l) => /* @__PURE__ */ K(yUe, { segment: o, state: s }, l))
      }
    );
  }
);
vb.displayName = "TimeInput";
const vUe = uh({
  base: [
    // base
    "peer flex w-full cursor-pointer appearance-none items-center gap-x-2 truncate rounded-md border px-3 py-2 shadow-sm outline-none transition-all sm:text-sm",
    // background color
    "bg-white dark:bg-gray-950",
    // border color
    "border-gray-300 dark:border-gray-800",
    // text color
    "text-gray-900 dark:text-gray-50",
    // placeholder color
    "placeholder-gray-400 dark:placeholder-gray-500",
    // hover
    "hover:bg-gray-50 hover:dark:bg-gray-950/50",
    // disabled
    "disabled:pointer-events-none",
    "disabled:bg-gray-100 disabled:text-gray-400",
    "disabled:dark:border-gray-800 disabled:dark:bg-gray-800 disabled:dark:text-gray-500",
    // focus
    ch
    // invalid (optional)
    // "aria-[invalid=true]:dark:ring-red-400/20 aria-[invalid=true]:ring-2 aria-[invalid=true]:ring-red-200 aria-[invalid=true]:border-red-500 invalid:ring-2 invalid:ring-red-200 invalid:border-red-500"
  ],
  variants: {
    hasError: {
      true: Fb
    }
  }
}), m2 = D.forwardRef(
  ({ className: e, children: t, placeholder: r, hasError: n, ...a }, s) => /* @__PURE__ */ K(w$e, { asChild: !0, children: /* @__PURE__ */ $t(
    "button",
    {
      ref: s,
      className: gr(vUe({ hasError: n }), e),
      ...a,
      children: [
        /* @__PURE__ */ K(Gle, { className: "size-5 shrink-0 text-gray-400 dark:text-gray-600" }),
        /* @__PURE__ */ K("span", { className: "flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-left text-gray-900 dark:text-gray-50", children: t || (r ? /* @__PURE__ */ K("span", { className: "text-gray-400 dark:text-gray-600", children: r }) : null) })
      ]
    }
  ) })
);
m2.displayName = "DatePicker.Trigger";
const g2 = D.forwardRef(({ align: e, className: t, children: r, ...n }, a) => /* @__PURE__ */ K(x$e, { children: /* @__PURE__ */ K(
  E$e,
  {
    ref: a,
    sideOffset: 10,
    side: "bottom",
    align: e,
    avoidCollisions: !0,
    onOpenAutoFocus: (s) => s.preventDefault(),
    className: gr(
      // base
      "relative z-50 w-fit rounded-md border text-sm shadow-xl shadow-black/[2.5%]",
      // widths
      "min-w-[calc(var(--radix-select-trigger-width)-2px)] max-w-[95vw]",
      // border color
      "border-gray-200 dark:border-gray-800",
      // background color
      "bg-white dark:bg-gray-950",
      // transition
      "will-change-[transform,opacity]",
      "data-[state=closed]:animate-hide",
      "data-[state=open]:data-[side=bottom]:animate-slideDownAndFade data-[state=open]:data-[side=left]:animate-slideLeftAndFade data-[state=open]:data-[side=right]:animate-slideRightAndFade data-[state=open]:data-[side=top]:animate-slideUpAndFade",
      t
    ),
    ...n,
    children: r
  }
) }));
g2.displayName = "DatePicker.CalendarPopover";
const b2 = ({
  // Available preset configurations
  presets: e,
  // Event handler when a preset is selected
  onSelect: t,
  // Currently selected preset
  currentValue: r
}) => {
  const n = (u) => "dateRange" in u, a = (u) => "date" in u, s = (u) => {
    n(u) ? t(u.dateRange) : a(u) && t(u.date);
  }, i = (u, c) => u.getDate() === c.getDate() && u.getMonth() === c.getMonth() && u.getFullYear() === c.getFullYear(), o = (u, c) => {
    const d = u.from, p = c.from;
    let f = !1;
    d && p && i(d, p) && (f = !0);
    const h = u.to, m = c.to;
    let y = !1;
    return h && m && i(h, m) && (y = !0), f && y;
  }, l = (u) => {
    if (n(u)) {
      const c = r;
      return c && o(c, u.dateRange);
    } else if (a(u)) {
      const c = r;
      return c && i(c, u.date);
    }
    return !1;
  };
  return /* @__PURE__ */ K("ul", { className: "flex items-start gap-x-2 sm:flex-col", children: e.map((u, c) => /* @__PURE__ */ K("li", { className: "sm:w-full sm:py-px", children: /* @__PURE__ */ K(
    "button",
    {
      title: u.label,
      className: gr(
        // base
        "relative w-full overflow-hidden text-ellipsis whitespace-nowrap rounded border px-2.5 py-1.5 text-left text-base shadow-sm outline-none transition-all sm:border-none sm:py-2 sm:text-sm sm:shadow-none",
        // text color
        "text-gray-700 dark:text-gray-300",
        // border color
        "border-gray-200 dark:border-gray-800",
        // focus
        dh,
        // background color
        "focus-visible:bg-gray-100 focus-visible:dark:bg-gray-900",
        "hover:bg-gray-100 hover:dark:bg-gray-900",
        {
          "bg-gray-100 dark:bg-gray-900": l(u)
        }
      ),
      onClick: () => s(u),
      "aria-label": `Select ${u.label}`,
      children: /* @__PURE__ */ K("span", { children: u.label })
    }
  ) }, c)) });
};
b2.displayName = "DatePicker.PresetContainer";
const gI = (e, t, r) => {
  const n = !bUe();
  let a;
  return r ? a = n ? zi(e, "dd MMM, yyyy h:mm a", { locale: t }) : zi(e, "dd MMM, yyyy HH:mm", { locale: t }) : a = zi(e, "dd MMM, yyyy", { locale: t }), a;
}, wUe = ({
  defaultValue: e,
  value: t,
  onChange: r,
  presets: n,
  disabled: a,
  disabledDays: s,
  disableNavigation: i,
  className: o,
  showTimePicker: l,
  placeholder: u = "Select date",
  hasError: c,
  translations: d,
  enableYearNavigation: p = !1,
  locale: f = $y,
  align: h = "center",
  ...m
}) => {
  const [y, b] = D.useState(!1), [v, x] = D.useState(
    t ?? e ?? void 0
  ), [_, E] = D.useState(v), [w, C] = D.useState(
    t ? new Tn(t.getHours(), t.getMinutes()) : e ? new Tn(e.getHours(), e.getMinutes()) : new Tn(0, 0)
  ), k = D.useMemo(() => v, [y]);
  D.useEffect(() => {
    x(t ?? e ?? void 0);
  }, [t, e]), D.useEffect(() => {
    v && E(v);
  }, [v]), D.useEffect(() => {
    y || E(v);
  }, [y]);
  const S = () => {
    x(k), C(
      k ? new Tn(k.getHours(), k.getMinutes()) : new Tn(0, 0)
    ), b(!1);
  }, B = (q) => {
    q || S(), b(q);
  }, U = (q) => {
    const ae = q;
    l && (ae && !w && C(new Tn(0, 0)), ae && w && (ae.setHours(w.hour), ae.setMinutes(w.minute))), x(ae);
  }, N = (q) => {
    if (C(q), !v)
      return;
    const ae = new Date(v.getTime());
    q ? (ae.setHours(q.hour), ae.setMinutes(q.minute)) : (ae.setHours(0), ae.setMinutes(0)), x(ae);
  }, O = D.useMemo(() => v ? gI(v, f, l) : null, [v, f, l]), I = () => {
    b(!1), r?.(v);
  };
  return D.useEffect(() => {
    x(t ?? e ?? void 0), C(
      t ? new Tn(t.getHours(), t.getMinutes()) : e ? new Tn(e.getHours(), e.getMinutes()) : new Tn(0, 0)
    );
  }, [t, e]), /* @__PURE__ */ $t(
    CX,
    {
      "tremor-id": "tremor-raw",
      open: y,
      onOpenChange: B,
      children: [
        /* @__PURE__ */ K(
          m2,
          {
            placeholder: u,
            disabled: a,
            className: o,
            hasError: c,
            "aria-required": m.required || m["aria-required"],
            "aria-invalid": m["aria-invalid"],
            "aria-label": m["aria-label"],
            "aria-labelledby": m["aria-labelledby"],
            children: O
          }
        ),
        /* @__PURE__ */ K(g2, { align: h, children: /* @__PURE__ */ K("div", { className: "flex", children: /* @__PURE__ */ $t("div", { className: "flex flex-col sm:flex-row sm:items-start", children: [
          n && n.length > 0 && /* @__PURE__ */ K(
            "div",
            {
              className: gr(
                "relative flex h-14 w-full items-center sm:h-full sm:w-40",
                "border-b border-gray-200 sm:border-b-0 sm:border-r dark:border-gray-800",
                "overflow-auto"
              ),
              children: /* @__PURE__ */ K("div", { className: "absolute px-2 pr-2 sm:inset-0 sm:left-0 sm:py-2", children: /* @__PURE__ */ K(
                b2,
                {
                  currentValue: v,
                  presets: n,
                  onSelect: U
                }
              ) })
            }
          ),
          /* @__PURE__ */ $t("div", { children: [
            /* @__PURE__ */ K(
              h2,
              {
                mode: "single",
                month: _,
                onMonthChange: E,
                selected: v,
                onSelect: U,
                disabled: s,
                locale: f,
                enableYearNavigation: p,
                disableNavigation: i,
                initialFocus: !0,
                ...m
              }
            ),
            l && /* @__PURE__ */ K("div", { className: "border-t border-gray-200 p-3 dark:border-gray-800", children: /* @__PURE__ */ K(
              vb,
              {
                "aria-label": "Time",
                onChange: N,
                isDisabled: !v,
                value: w,
                isRequired: m.required
              }
            ) }),
            /* @__PURE__ */ $t("div", { className: "flex items-center gap-x-2 border-t border-gray-200 p-3 dark:border-gray-800", children: [
              /* @__PURE__ */ K(
                ca,
                {
                  variant: "secondary",
                  className: "h-8 w-full",
                  type: "button",
                  onClick: S,
                  children: d?.cancel ?? "Cancel"
                }
              ),
              /* @__PURE__ */ K(
                ca,
                {
                  variant: "primary",
                  className: "h-8 w-full",
                  type: "button",
                  onClick: I,
                  children: d?.apply ?? "Apply"
                }
              )
            ] })
          ] })
        ] }) }) })
      ]
    }
  );
}, xUe = ({
  defaultValue: e,
  value: t,
  onChange: r,
  presets: n,
  disabled: a,
  disableNavigation: s,
  disabledDays: i,
  enableYearNavigation: o = !1,
  locale: l = $y,
  showTimePicker: u,
  placeholder: c = "Select date range",
  hasError: d,
  translations: p,
  align: f = "center",
  className: h,
  ...m
}) => {
  const [y, b] = D.useState(!1), [v, x] = D.useState(
    t ?? e ?? void 0
  ), [_, E] = D.useState(v?.from), [w, C] = D.useState(
    t?.from ? new Tn(t.from.getHours(), t.from.getMinutes()) : e?.from ? new Tn(e.from.getHours(), e.from.getMinutes()) : new Tn(0, 0)
  ), [k, S] = D.useState(
    t?.to ? new Tn(t.to.getHours(), t.to.getMinutes()) : e?.to ? new Tn(e.to.getHours(), e.to.getMinutes()) : new Tn(0, 0)
  ), B = D.useMemo(() => v, [y]);
  D.useEffect(() => {
    x(t ?? e ?? void 0);
  }, [t, e]), D.useEffect(() => {
    v && E(v.from);
  }, [v]), D.useEffect(() => {
    y || E(v?.from);
  }, [y]);
  const U = (Q) => {
    const ne = Q;
    u && (ne?.from && !w && C(new Tn(0, 0)), ne?.to && !k && S(new Tn(0, 0)), ne?.from && w && (ne.from.setHours(w.hour), ne.from.setMinutes(w.minute)), ne?.to && k && (ne.to.setHours(k.hour), ne.to.setMinutes(k.minute))), x(ne);
  }, N = () => {
    x(B), C(
      B?.from ? new Tn(B.from.getHours(), B.from.getMinutes()) : new Tn(0, 0)
    ), S(
      B?.to ? new Tn(B.to.getHours(), B.to.getMinutes()) : new Tn(0, 0)
    ), b(!1);
  }, O = (Q) => {
    Q || N(), b(Q);
  }, I = (Q, ne) => {
    switch (ne) {
      case "start":
        C(Q);
        break;
      case "end":
        S(Q);
        break;
    }
    if (v) {
      if (ne === "start") {
        if (!v.from)
          return;
        const le = new Date(v.from.getTime());
        Q ? (le.setHours(Q.hour), le.setMinutes(Q.minute)) : (le.setHours(0), le.setMinutes(0)), x({
          ...v,
          from: le
        });
      }
      if (ne === "end") {
        if (!v.to)
          return;
        const le = new Date(v.to.getTime());
        Q ? (le.setHours(Q.hour), le.setMinutes(Q.minute)) : (le.setHours(0), le.setMinutes(0)), x({
          ...v,
          to: le
        });
      }
    }
  };
  D.useEffect(() => {
    x(t ?? e ?? void 0), C(
      t?.from ? new Tn(t.from.getHours(), t.from.getMinutes()) : e?.from ? new Tn(e.from.getHours(), e.from.getMinutes()) : new Tn(0, 0)
    ), S(
      t?.to ? new Tn(t.to.getHours(), t.to.getMinutes()) : e?.to ? new Tn(e.to.getHours(), e.to.getMinutes()) : new Tn(0, 0)
    );
  }, [t, e]);
  const q = D.useMemo(() => v ? `${v.from ? gI(v.from, l, u) : ""} - ${v.to ? gI(v.to, l, u) : ""}` : null, [v, l, u]), ae = () => {
    b(!1), r?.(v);
  };
  return /* @__PURE__ */ $t(
    CX,
    {
      "tremor-id": "tremor-raw",
      open: y,
      onOpenChange: O,
      children: [
        /* @__PURE__ */ K(
          m2,
          {
            placeholder: c,
            disabled: a,
            className: h,
            hasError: d,
            "aria-required": m.required || m["aria-required"],
            "aria-invalid": m["aria-invalid"],
            "aria-label": m["aria-label"],
            "aria-labelledby": m["aria-labelledby"],
            children: q
          }
        ),
        /* @__PURE__ */ K(g2, { align: f, children: /* @__PURE__ */ K("div", { className: "flex", children: /* @__PURE__ */ $t("div", { className: "flex flex-col overflow-x-auto sm:flex-row sm:items-start", children: [
          n && n.length > 0 && /* @__PURE__ */ K(
            "div",
            {
              className: gr(
                "relative flex h-16 w-full items-center sm:h-full sm:w-40",
                "border-b border-gray-200 sm:border-b-0 sm:border-r dark:border-gray-800",
                "overflow-auto"
              ),
              children: /* @__PURE__ */ K("div", { className: "absolute px-3 sm:inset-0 sm:left-0 sm:p-2", children: /* @__PURE__ */ K(
                b2,
                {
                  currentValue: v,
                  presets: n,
                  onSelect: U
                }
              ) })
            }
          ),
          /* @__PURE__ */ $t("div", { className: "overflow-x-auto", children: [
            /* @__PURE__ */ K(
              h2,
              {
                mode: "range",
                selected: v,
                onSelect: U,
                month: _,
                onMonthChange: E,
                numberOfMonths: 2,
                disabled: i,
                disableNavigation: s,
                enableYearNavigation: o,
                locale: l,
                initialFocus: !0,
                classNames: {
                  months: "flex flex-row divide-x divide-gray-200 dark:divide-gray-800 overflow-x-auto"
                },
                ...m
              }
            ),
            u && /* @__PURE__ */ $t("div", { className: "flex items-center justify-evenly gap-x-3 border-t border-gray-200 p-3 dark:border-gray-800", children: [
              /* @__PURE__ */ $t("div", { className: "flex flex-1 items-center gap-x-2", children: [
                /* @__PURE__ */ $t("span", { className: "dark:text-gray-30 text-gray-700", children: [
                  p?.start ?? "Start",
                  ":"
                ] }),
                /* @__PURE__ */ K(
                  vb,
                  {
                    value: w,
                    onChange: (Q) => I(Q, "start"),
                    "aria-label": "Start date time",
                    isDisabled: !v?.from,
                    isRequired: m.required
                  }
                )
              ] }),
              /* @__PURE__ */ K(yue, { className: "size-4 shrink-0 text-gray-400" }),
              /* @__PURE__ */ $t("div", { className: "flex flex-1 items-center gap-x-2", children: [
                /* @__PURE__ */ $t("span", { className: "dark:text-gray-30 text-gray-700", children: [
                  p?.end ?? "End",
                  ":"
                ] }),
                /* @__PURE__ */ K(
                  vb,
                  {
                    value: k,
                    onChange: (Q) => I(Q, "end"),
                    "aria-label": "End date time",
                    isDisabled: !v?.to,
                    isRequired: m.required
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ $t("div", { className: "border-t border-gray-200 p-3 sm:flex sm:items-center sm:justify-between dark:border-gray-800", children: [
              /* @__PURE__ */ $t("p", { className: "tabular-nums text-gray-900 dark:text-gray-50", children: [
                /* @__PURE__ */ $t("span", { className: "text-gray-700 dark:text-gray-300", children: [
                  p?.range ?? "Range",
                  ":"
                ] }),
                " ",
                /* @__PURE__ */ K("span", { className: "font-medium", children: q })
              ] }),
              /* @__PURE__ */ $t("div", { className: "mt-2 flex items-center gap-x-2 sm:mt-0", children: [
                /* @__PURE__ */ K(
                  ca,
                  {
                    variant: "secondary",
                    className: "h-8 w-full sm:w-fit",
                    type: "button",
                    onClick: N,
                    children: p?.cancel ?? "Cancel"
                  }
                ),
                /* @__PURE__ */ K(
                  ca,
                  {
                    variant: "primary",
                    className: "h-8 w-full sm:w-fit",
                    type: "button",
                    onClick: ae,
                    children: p?.apply ?? "Apply"
                  }
                )
              ] })
            ] })
          ] })
        ] }) }) })
      ]
    }
  );
}, vQ = (e, t) => {
  const { toYear: r, fromYear: n, fromMonth: a, toMonth: s, fromDay: i, toDay: o } = t;
  if (e && e.length > 0) {
    const l = n, u = r;
    e.forEach((c) => {
      if ("date" in c) {
        const d = c.date.getFullYear();
        if (n && d < n)
          throw new Error(
            `Preset ${c.label} is before fromYear ${l}.`
          );
        if (r && d > r)
          throw new Error(
            `Preset ${c.label} is after toYear ${u}.`
          );
        if (a && c.date.getMonth() < a.getMonth())
          throw new Error(
            `Preset ${c.label} is before fromMonth ${a}.`
          );
        if (s && c.date.getMonth() > s.getMonth())
          throw new Error(
            `Preset ${c.label} is after toMonth ${s}.`
          );
        if (i && c.date.getDate() < i.getDate())
          throw new Error(
            `Preset ${c.label} is before fromDay ${i}.`
          );
        if (o && c.date.getDate() > o.getDate())
          throw new Error(
            `Preset ${c.label} is after toDay ${zi(
              o,
              "MMM dd, yyyy"
            )}.`
          );
      }
      if ("dateRange" in c) {
        const d = c.dateRange.from?.getFullYear(), p = c.dateRange.to?.getFullYear();
        if (d && n && d < n)
          throw new Error(
            `Preset ${c.label}'s 'from' is before fromYear ${l}.`
          );
        if (p && r && p > r)
          throw new Error(
            `Preset ${c.label}'s 'to' is after toYear ${u}.`
          );
        if (a) {
          const f = c.dateRange.from?.getMonth();
          if (f && f < a.getMonth())
            throw new Error(
              `Preset ${c.label}'s 'from' is before fromMonth ${zi(
                a,
                "MMM, yyyy"
              )}.`
            );
        }
        if (s) {
          const f = c.dateRange.to?.getMonth();
          if (f && f > s.getMonth())
            throw new Error(
              `Preset ${c.label}'s 'to' is after toMonth ${zi(
                s,
                "MMM, yyyy"
              )}.`
            );
        }
        if (i) {
          const f = c.dateRange.from?.getDate();
          if (f && f < i.getDate())
            throw new Error(
              `Preset ${c.dateRange.from}'s 'from' is before fromDay ${zi(i, "MMM dd, yyyy")}.`
            );
        }
        if (o) {
          const f = c.dateRange.to?.getDate();
          if (f && f > o.getDate())
            throw new Error(
              `Preset ${c.label}'s 'to' is after toDay ${zi(
                o,
                "MMM dd, yyyy"
              )}.`
            );
        }
      }
    });
  }
}, wQ = ({ presets: e, ...t }) => (e && vQ(e, t), /* @__PURE__ */ K(wUe, { presets: e, ...t }));
wQ.displayName = "DatePicker";
const xQ = ({ presets: e, ...t }) => (e && vQ(e, t), /* @__PURE__ */ K(xUe, { presets: e, ...t }));
xQ.displayName = "DateRangePicker";
const lqe = (e) => {
  const { state: t, ...r } = e;
  return /* @__PURE__ */ K(
    wQ,
    {
      ...r,
      value: t.value,
      onChange: (n) => t.update(n)
    }
  );
}, uqe = (e) => {
  const { state: t, ...r } = e;
  return /* @__PURE__ */ K(
    xQ,
    {
      ...r,
      value: {
        from: t[0].value,
        to: t[1].value
      },
      onChange: (n) => {
        t[0].update(n?.from), t[1].update(n?.to);
      }
    }
  );
};
function wU() {
  return (/* @__PURE__ */ new Date()).getTime().toString(16) + Math.floor(1e3 * Math.random()).toString(16);
}
function cqe({ state: e, children: t }) {
  const r = Gr(wU()), [n, a] = Wn(e.value);
  Qn(() => {
    a(e.value);
  }, [e, e.value]);
  const s = (u, c) => {
    const d = { ...n, [u]: c };
    a(d);
  }, i = (u) => {
    u.preventDefault(), e.update(n);
  }, o = () => {
    e.update({}), a({});
    const u = wU();
    r.current = u;
  }, l = (u) => kt.Children.map(u, (c) => {
    if (kt.isValidElement(c)) {
      if (c.props.name) {
        const d = c.props.name;
        return kt.cloneElement(
          c,
          {
            // value: localState[name] || undefined,
            onChange: (p) => s(d, p.target.value)
          }
        );
      }
      if (c.props.children)
        return kt.cloneElement(
          c,
          {
            children: l(c.props.children)
          }
        );
    }
    return c;
  });
  return /* @__PURE__ */ $t(ln, { children: [
    /* @__PURE__ */ K("form", { onSubmit: i, children: l(t) }, r.current),
    Object.keys(n).length > 0 && /* @__PURE__ */ K(ca, { className: "w-full", variant: "ghost", onClick: o, children: "Clear" })
  ] });
}
const EUe = (e, t) => {
  Qn(() => {
    const r = (n) => {
      !e.current || e.current.contains(n.target) || t(n);
    };
    return document.addEventListener("mousedown", r), document.addEventListener("touchstart", r), () => {
      document.removeEventListener("mousedown", r), document.removeEventListener("touchstart", r);
    };
  }, [e, t]);
}, dqe = ({
  children: e,
  className: t
}) => {
  const [r, n] = D.useState(!1), a = D.useRef(null);
  EUe(a, () => n(!1));
  const s = D.useCallback(() => {
    n((i) => !i);
  }, []);
  return /* @__PURE__ */ $t(ln, { children: [
    /* @__PURE__ */ $t("div", { className: `${r ? "visible" : "hidden"}`, children: [
      /* @__PURE__ */ K("div", { className: "fixed inset-0 bg-black/20 h-full w-full z-10" }),
      /* @__PURE__ */ K("div", { className: "fixed inset-8  grid place-items-center z-[100]", children: /* @__PURE__ */ $t(
        "div",
        {
          ref: a,
          className: "w-full h-full bg-white dark:bg-neutral-900 sm:rounded-xl overflow-hidden relative",
          children: [
            /* @__PURE__ */ $t("div", { className: "flex w-full items-end p-2 mb-[-1rem]", children: [
              /* @__PURE__ */ K("div", { className: "flex-1" }),
              /* @__PURE__ */ K(ca, { variant: "ghost", onClick: s, children: /* @__PURE__ */ K(gue, { size: 16 }) })
            ] }),
            /* @__PURE__ */ K("div", { className: "relative p-4", children: e })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ K(zu, { className: "p-0", children: /* @__PURE__ */ $t(
      "div",
      {
        onClick: s,
        className: ja([
          "p-4 hover:bg-neutral-50 dark:hover:bg-neutral-800 rounded-xl cursor-pointer relative group",
          t
        ]),
        children: [
          e,
          /* @__PURE__ */ $t("div", { className: "absolute top-2 right-2 invisible group-hover:visible", children: [
            /* @__PURE__ */ K("div", { className: "flex-1" }),
            /* @__PURE__ */ K(
              ca,
              {
                variant: "ghost",
                onClick: (i) => {
                  i.stopPropagation(), s();
                },
                children: /* @__PURE__ */ K(hue, { size: 16 })
              }
            )
          ] })
        ]
      }
    ) })
  ] });
};
var y2 = "Collapsible", [SUe, EQ] = ds(y2), [_Ue, v2] = SUe(y2), SQ = D.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: r,
      open: n,
      defaultOpen: a,
      disabled: s,
      onOpenChange: i,
      ...o
    } = e, [l = !1, u] = Bs({
      prop: n,
      defaultProp: a,
      onChange: i
    });
    return /* @__PURE__ */ K(
      _Ue,
      {
        scope: r,
        disabled: s,
        contentId: us(),
        open: l,
        onOpenToggle: D.useCallback(() => u((c) => !c), [u]),
        children: /* @__PURE__ */ K(
          Wr.div,
          {
            "data-state": x2(l),
            "data-disabled": s ? "" : void 0,
            ...o,
            ref: t
          }
        )
      }
    );
  }
);
SQ.displayName = y2;
var _Q = "CollapsibleTrigger", kQ = D.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: r, ...n } = e, a = v2(_Q, r);
    return /* @__PURE__ */ K(
      Wr.button,
      {
        type: "button",
        "aria-controls": a.contentId,
        "aria-expanded": a.open || !1,
        "data-state": x2(a.open),
        "data-disabled": a.disabled ? "" : void 0,
        disabled: a.disabled,
        ...n,
        ref: t,
        onClick: nr(e.onClick, a.onOpenToggle)
      }
    );
  }
);
kQ.displayName = _Q;
var w2 = "CollapsibleContent", CQ = D.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, a = v2(w2, e.__scopeCollapsible);
    return /* @__PURE__ */ K(Ra, { present: r || a.open, children: ({ present: s }) => /* @__PURE__ */ K(kUe, { ...n, ref: t, present: s }) });
  }
);
CQ.displayName = w2;
var kUe = D.forwardRef((e, t) => {
  const { __scopeCollapsible: r, present: n, children: a, ...s } = e, i = v2(w2, r), [o, l] = D.useState(n), u = D.useRef(null), c = sn(t, u), d = D.useRef(0), p = d.current, f = D.useRef(0), h = f.current, m = i.open || o, y = D.useRef(m), b = D.useRef(void 0);
  return D.useEffect(() => {
    const v = requestAnimationFrame(() => y.current = !1);
    return () => cancelAnimationFrame(v);
  }, []), Ti(() => {
    const v = u.current;
    if (v) {
      b.current = b.current || {
        transitionDuration: v.style.transitionDuration,
        animationName: v.style.animationName
      }, v.style.transitionDuration = "0s", v.style.animationName = "none";
      const x = v.getBoundingClientRect();
      d.current = x.height, f.current = x.width, y.current || (v.style.transitionDuration = b.current.transitionDuration, v.style.animationName = b.current.animationName), l(n);
    }
  }, [i.open, n]), /* @__PURE__ */ K(
    Wr.div,
    {
      "data-state": x2(i.open),
      "data-disabled": i.disabled ? "" : void 0,
      id: i.contentId,
      hidden: !m,
      ...s,
      ref: c,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": h ? `${h}px` : void 0,
        ...e.style
      },
      children: m && a
    }
  );
});
function x2(e) {
  return e ? "open" : "closed";
}
var CUe = SQ, AUe = kQ, TUe = CQ, rl = "Accordion", RUe = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [E2, IUe, NUe] = qb(rl), [zy, fqe] = ds(rl, [
  NUe,
  EQ
]), S2 = EQ(), AQ = kt.forwardRef(
  (e, t) => {
    const { type: r, ...n } = e, a = n, s = n;
    return /* @__PURE__ */ K(E2.Provider, { scope: e.__scopeAccordion, children: r === "multiple" ? /* @__PURE__ */ K(LUe, { ...s, ref: t }) : /* @__PURE__ */ K(PUe, { ...a, ref: t }) });
  }
);
AQ.displayName = rl;
var [TQ, DUe] = zy(rl), [RQ, OUe] = zy(
  rl,
  { collapsible: !1 }
), PUe = kt.forwardRef(
  (e, t) => {
    const {
      value: r,
      defaultValue: n,
      onValueChange: a = () => {
      },
      collapsible: s = !1,
      ...i
    } = e, [o, l] = Bs({
      prop: r,
      defaultProp: n,
      onChange: a
    });
    return /* @__PURE__ */ K(
      TQ,
      {
        scope: e.__scopeAccordion,
        value: o ? [o] : [],
        onItemOpen: l,
        onItemClose: kt.useCallback(() => s && l(""), [s, l]),
        children: /* @__PURE__ */ K(RQ, { scope: e.__scopeAccordion, collapsible: s, children: /* @__PURE__ */ K(IQ, { ...i, ref: t }) })
      }
    );
  }
), LUe = kt.forwardRef((e, t) => {
  const {
    value: r,
    defaultValue: n,
    onValueChange: a = () => {
    },
    ...s
  } = e, [i = [], o] = Bs({
    prop: r,
    defaultProp: n,
    onChange: a
  }), l = kt.useCallback(
    (c) => o((d = []) => [...d, c]),
    [o]
  ), u = kt.useCallback(
    (c) => o((d = []) => d.filter((p) => p !== c)),
    [o]
  );
  return /* @__PURE__ */ K(
    TQ,
    {
      scope: e.__scopeAccordion,
      value: i,
      onItemOpen: l,
      onItemClose: u,
      children: /* @__PURE__ */ K(RQ, { scope: e.__scopeAccordion, collapsible: !0, children: /* @__PURE__ */ K(IQ, { ...s, ref: t }) })
    }
  );
}), [MUe, qy] = zy(rl), IQ = kt.forwardRef(
  (e, t) => {
    const { __scopeAccordion: r, disabled: n, dir: a, orientation: s = "vertical", ...i } = e, o = kt.useRef(null), l = sn(o, t), u = IUe(r), d = hh(a) === "ltr", p = nr(e.onKeyDown, (f) => {
      if (!RUe.includes(f.key)) return;
      const h = f.target, m = u().filter((k) => !k.ref.current?.disabled), y = m.findIndex((k) => k.ref.current === h), b = m.length;
      if (y === -1) return;
      f.preventDefault();
      let v = y;
      const x = 0, _ = b - 1, E = () => {
        v = y + 1, v > _ && (v = x);
      }, w = () => {
        v = y - 1, v < x && (v = _);
      };
      switch (f.key) {
        case "Home":
          v = x;
          break;
        case "End":
          v = _;
          break;
        case "ArrowRight":
          s === "horizontal" && (d ? E() : w());
          break;
        case "ArrowDown":
          s === "vertical" && E();
          break;
        case "ArrowLeft":
          s === "horizontal" && (d ? w() : E());
          break;
        case "ArrowUp":
          s === "vertical" && w();
          break;
      }
      const C = v % b;
      m[C].ref.current?.focus();
    });
    return /* @__PURE__ */ K(
      MUe,
      {
        scope: r,
        disabled: n,
        direction: a,
        orientation: s,
        children: /* @__PURE__ */ K(E2.Slot, { scope: r, children: /* @__PURE__ */ K(
          Wr.div,
          {
            ...i,
            "data-orientation": s,
            ref: l,
            onKeyDown: n ? void 0 : p
          }
        ) })
      }
    );
  }
), wb = "AccordionItem", [FUe, _2] = zy(wb), NQ = kt.forwardRef(
  (e, t) => {
    const { __scopeAccordion: r, value: n, ...a } = e, s = qy(wb, r), i = DUe(wb, r), o = S2(r), l = us(), u = n && i.value.includes(n) || !1, c = s.disabled || e.disabled;
    return /* @__PURE__ */ K(
      FUe,
      {
        scope: r,
        open: u,
        disabled: c,
        triggerId: l,
        children: /* @__PURE__ */ K(
          CUe,
          {
            "data-orientation": s.orientation,
            "data-state": MQ(u),
            ...o,
            ...a,
            ref: t,
            disabled: c,
            open: u,
            onOpenChange: (d) => {
              d ? i.onItemOpen(n) : i.onItemClose(n);
            }
          }
        )
      }
    );
  }
);
NQ.displayName = wb;
var DQ = "AccordionHeader", $Ue = kt.forwardRef(
  (e, t) => {
    const { __scopeAccordion: r, ...n } = e, a = qy(rl, r), s = _2(DQ, r);
    return /* @__PURE__ */ K(
      Wr.h3,
      {
        "data-orientation": a.orientation,
        "data-state": MQ(s.open),
        "data-disabled": s.disabled ? "" : void 0,
        ...n,
        ref: t
      }
    );
  }
);
$Ue.displayName = DQ;
var bI = "AccordionTrigger", OQ = kt.forwardRef(
  (e, t) => {
    const { __scopeAccordion: r, ...n } = e, a = qy(rl, r), s = _2(bI, r), i = OUe(bI, r), o = S2(r);
    return /* @__PURE__ */ K(E2.ItemSlot, { scope: r, children: /* @__PURE__ */ K(
      AUe,
      {
        "aria-disabled": s.open && !i.collapsible || void 0,
        "data-orientation": a.orientation,
        id: s.triggerId,
        ...o,
        ...n,
        ref: t
      }
    ) });
  }
);
OQ.displayName = bI;
var PQ = "AccordionContent", LQ = kt.forwardRef(
  (e, t) => {
    const { __scopeAccordion: r, ...n } = e, a = qy(rl, r), s = _2(PQ, r), i = S2(r);
    return /* @__PURE__ */ K(
      TUe,
      {
        role: "region",
        "aria-labelledby": s.triggerId,
        "data-orientation": a.orientation,
        ...i,
        ...n,
        ref: t,
        style: {
          "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
          "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
          ...e.style
        }
      }
    );
  }
);
LQ.displayName = PQ;
function MQ(e) {
  return e ? "open" : "closed";
}
var BUe = AQ, UUe = NQ, zUe = OQ, qUe = LQ;
const FQ = BUe;
FQ.displayName = "AccordionItem";
const $Q = kt.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ K("div", { className: "flex", children: /* @__PURE__ */ $t(
  zUe,
  {
    className: gr(
      // base
      "group flex flex-1 cursor-pointer items-center justify-between py-3 text-left text-sm font-medium leading-none",
      // text color
      "text-gray-900 dark:text-gray-50",
      // disabled
      "data-[disabled]:cursor-default data-[disabled]:text-gray-400 dark:data-[disabled]:text-gray-600",
      //focus
      "focus-visible:z-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-blue-500",
      e
    ),
    ...r,
    ref: n,
    children: [
      t,
      /* @__PURE__ */ K(
        nq,
        {
          className: gr(
            // base
            "size-5 shrink-0 transition-transform duration-150 ease-[cubic-bezier(0.87,_0,_0.13,_1)] group-data-[state=open]:-rotate-45",
            // text color
            "text-gray-400 dark:text-gray-600",
            // disabled
            "group-data-[disabled]:text-gray-300 group-data-[disabled]:dark:text-gray-700"
          ),
          "aria-hidden": "true",
          focusable: "false"
        }
      )
    ]
  }
) }));
$Q.displayName = "AccordionTrigger";
const BQ = kt.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ K(
  qUe,
  {
    ref: n,
    className: gr(
      "transform-gpu data-[state=closed]:animate-accordionClose data-[state=open]:animate-accordionOpen"
    ),
    ...r,
    children: /* @__PURE__ */ K(
      "div",
      {
        className: gr(
          // base
          "overflow-hidden pb-4 text-sm",
          // text color
          "text-gray-700 dark:text-gray-200",
          e
        ),
        children: t
      }
    )
  }
));
BQ.displayName = "AccordionContent";
const UQ = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  UUe,
  {
    ref: r,
    className: gr(
      // base
      "overflow-hidden border-b first:mt-0",
      // border color
      "border-gray-200 dark:border-gray-800",
      e
    ),
    "tremor-id": "tremor-raw",
    ...t
  }
));
UQ.displayName = "AccordionItem";
const pqe = ({
  title: e,
  defaultOpen: t,
  children: r,
  className: n
}) => {
  const [a] = Wn(t ? "item-1" : void 0);
  return /* @__PURE__ */ K(
    FQ,
    {
      type: "single",
      collapsible: !0,
      defaultValue: a,
      className: ja(["border px-4 rounded-lg hover:bg-gray-700/5", n]),
      children: /* @__PURE__ */ $t(UQ, { value: "item-1", className: "border-none", children: [
        /* @__PURE__ */ K($Q, { className: "py-3", children: /* @__PURE__ */ K("div", { children: e }) }),
        /* @__PURE__ */ K(BQ, { children: r })
      ] })
    }
  );
}, jUe = uh({
  base: gr(
    "inline-flex items-center gap-x-1 whitespace-nowrap rounded-md px-2 py-1 text-xs font-medium ring-1 ring-inset"
  ),
  variants: {
    variant: {
      default: [
        "bg-blue-50 text-blue-900 ring-blue-500/30",
        "dark:bg-blue-400/10 dark:text-blue-400 dark:ring-blue-400/30"
      ],
      neutral: [
        "bg-gray-50 text-gray-900 ring-gray-500/30",
        "dark:bg-gray-400/10 dark:text-gray-400 dark:ring-gray-400/20"
      ],
      success: [
        "bg-emerald-50 text-emerald-900 ring-emerald-600/30",
        "dark:bg-emerald-400/10 dark:text-emerald-400 dark:ring-emerald-400/20"
      ],
      error: [
        "bg-red-50 text-red-900 ring-red-600/20",
        "dark:bg-red-400/10 dark:text-red-400 dark:ring-red-400/20"
      ],
      warning: [
        "bg-yellow-50 text-yellow-900 ring-yellow-600/30",
        "dark:bg-yellow-400/10 dark:text-yellow-500 dark:ring-yellow-400/20"
      ]
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), HUe = kt.forwardRef(
  ({ className: e, variant: t, ...r }, n) => /* @__PURE__ */ K(
    "span",
    {
      ref: n,
      className: gr(jUe({ variant: t }), e),
      "tremor-id": "tremor-raw",
      ...r
    }
  )
);
HUe.displayName = "Badge";
const VUe = kt.forwardRef(
  ({ className: e, hasError: t, ...r }, n) => /* @__PURE__ */ K(
    "textarea",
    {
      ref: n,
      className: gr(
        // base
        "flex min-h-[4rem] w-full rounded-md border px-3 py-1.5 shadow-sm outline-none transition-colors sm:text-sm",
        // text color
        "text-gray-900 dark:text-gray-50",
        // border color
        "border-gray-300 dark:border-gray-800",
        // background color
        "bg-white dark:bg-gray-950",
        // placeholder color
        "placeholder-gray-400 dark:placeholder-gray-500",
        // disabled
        "disabled:border-gray-300 disabled:bg-gray-100 disabled:text-gray-300",
        "disabled:dark:border-gray-700 disabled:dark:bg-gray-800 disabled:dark:text-gray-500",
        // focus
        ch,
        // error
        t ? Fb : "",
        // invalid (optional)
        // "aria-[invalid=true]:dark:ring-red-400/20 aria-[invalid=true]:ring-2 aria-[invalid=true]:ring-red-200 aria-[invalid=true]:border-red-500 invalid:ring-2 invalid:ring-red-200 invalid:border-red-500"
        e
      ),
      "tremor-id": "tremor-raw",
      ...r
    }
  )
);
VUe.displayName = "Textarea";
const GUe = kt.forwardRef(({ className: e, children: t, ...r }, n) => /* @__PURE__ */ K(
  "div",
  {
    ref: n,
    children: /* @__PURE__ */ K(
      "div",
      {
        className: gr("w-full overflow-auto whitespace-nowrap", e),
        ...r,
        children: t
      }
    )
  }
));
GUe.displayName = "TableRoot";
const WUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "table",
  {
    ref: r,
    "tremor-id": "tremor-raw",
    className: gr(
      // base
      "w-full caption-bottom border-b",
      // border color
      "border-gray-200 dark:border-gray-800",
      e
    ),
    ...t
  }
));
WUe.displayName = "Table";
const KUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K("thead", { ref: r, className: gr(e), ...t }));
KUe.displayName = "TableHead";
const YUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "th",
  {
    ref: r,
    className: gr(
      // base
      "border-b px-4 py-3.5 text-left text-sm font-semibold",
      // text color
      "text-gray-900 dark:text-gray-50",
      // border color
      "border-gray-200 dark:border-gray-800",
      e
    ),
    ...t
  }
));
YUe.displayName = "TableHeaderCell";
const XUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "tbody",
  {
    ref: r,
    className: gr(
      // base
      "divide-y",
      // divide color
      "divide-gray-200 dark:divide-gray-800",
      e
    ),
    ...t
  }
));
XUe.displayName = "TableBody";
const ZUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "tr",
  {
    ref: r,
    className: gr(
      "[&_td:last-child]:pr-4 [&_th:last-child]:pr-4",
      "[&_td:first-child]:pl-4 [&_th:first-child]:pl-4",
      e
    ),
    ...t
  }
));
ZUe.displayName = "TableRow";
const JUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "td",
  {
    ref: r,
    className: gr(
      // base
      "p-4 text-sm",
      // text color
      "text-gray-600 dark:text-gray-400",
      e
    ),
    ...t
  }
));
JUe.displayName = "TableCell";
const QUe = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "tfoot",
  {
    ref: r,
    className: gr(
      // base
      "border-t text-left font-medium",
      // text color
      "text-gray-900 dark:text-gray-50",
      // border color
      "border-gray-200 dark:border-gray-800",
      e
    ),
    ...t
  }
));
QUe.displayName = "TableFoot";
const eze = kt.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ K(
  "caption",
  {
    ref: r,
    className: gr(
      // base
      "mt-3 px-3 text-center text-sm",
      // text color
      "text-gray-500 dark:text-gray-500",
      e
    ),
    ...t
  }
));
eze.displayName = "TableCaption";
const hqe = ({ children: e }) => /* @__PURE__ */ K(aee, { children: eee.map(e, (t) => tee(t) && t.type === "link" && "rel" in t.props && t.props.rel === "icon" ? ree(t, {
  "head-key": "favicon"
}) : t) });
var tze = "DismissableLayer", yI = "dismissableLayer.update", rze = "dismissableLayer.pointerDownOutside", nze = "dismissableLayer.focusOutside", xU, zQ = D.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), qQ = D.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: n,
      onPointerDownOutside: a,
      onFocusOutside: s,
      onInteractOutside: i,
      onDismiss: o,
      ...l
    } = e, u = D.useContext(zQ), [c, d] = D.useState(null), p = c?.ownerDocument ?? globalThis?.document, [, f] = D.useState({}), h = sn(t, (C) => d(C)), m = Array.from(u.layers), [y] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), b = m.indexOf(y), v = c ? m.indexOf(c) : -1, x = u.layersWithOutsidePointerEventsDisabled.size > 0, _ = v >= b, E = sze((C) => {
      const k = C.target, S = [...u.branches].some((B) => B.contains(k));
      !_ || S || (a?.(C), i?.(C), C.defaultPrevented || o?.());
    }, p), w = oze((C) => {
      const k = C.target;
      [...u.branches].some((B) => B.contains(k)) || (s?.(C), i?.(C), C.defaultPrevented || o?.());
    }, p);
    return Jq((C) => {
      v === u.layers.size - 1 && (n?.(C), !C.defaultPrevented && o && (C.preventDefault(), o()));
    }, p), D.useEffect(() => {
      if (c)
        return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (xU = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), EU(), () => {
          r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = xU);
        };
    }, [c, p, r, u]), D.useEffect(() => () => {
      c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), EU());
    }, [c, u]), D.useEffect(() => {
      const C = () => f({});
      return document.addEventListener(yI, C), () => document.removeEventListener(yI, C);
    }, []), /* @__PURE__ */ K(
      Wr.div,
      {
        ...l,
        ref: h,
        style: {
          pointerEvents: x ? _ ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: nr(e.onFocusCapture, w.onFocusCapture),
        onBlurCapture: nr(e.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: nr(
          e.onPointerDownCapture,
          E.onPointerDownCapture
        )
      }
    );
  }
);
qQ.displayName = tze;
var ize = "DismissableLayerBranch", aze = D.forwardRef((e, t) => {
  const r = D.useContext(zQ), n = D.useRef(null), a = sn(t, n);
  return D.useEffect(() => {
    const s = n.current;
    if (s)
      return r.branches.add(s), () => {
        r.branches.delete(s);
      };
  }, [r.branches]), /* @__PURE__ */ K(Wr.div, { ...e, ref: a });
});
aze.displayName = ize;
function sze(e, t = globalThis?.document) {
  const r = si(e), n = D.useRef(!1), a = D.useRef(() => {
  });
  return D.useEffect(() => {
    const s = (o) => {
      if (o.target && !n.current) {
        let l = function() {
          jQ(
            rze,
            r,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: o };
        o.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = l, t.addEventListener("click", a.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", a.current);
      n.current = !1;
    }, i = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(i), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current);
    };
  }, [t, r]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n.current = !0
  };
}
function oze(e, t = globalThis?.document) {
  const r = si(e), n = D.useRef(!1);
  return D.useEffect(() => {
    const a = (s) => {
      s.target && !n.current && jQ(nze, r, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, r]), {
    onFocusCapture: () => n.current = !0,
    onBlurCapture: () => n.current = !1
  };
}
function EU() {
  const e = new CustomEvent(yI);
  document.dispatchEvent(e);
}
function jQ(e, t, r, { discrete: n }) {
  const a = r.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: r });
  t && a.addEventListener(e, t, { once: !0 }), n ? WI(a, s) : a.dispatchEvent(s);
}
var TT, k2 = "HoverCard", [HQ, mqe] = ds(k2, [
  Wl
]), jy = Wl(), [lze, C2] = HQ(k2), VQ = (e) => {
  const {
    __scopeHoverCard: t,
    children: r,
    open: n,
    defaultOpen: a,
    onOpenChange: s,
    openDelay: i = 700,
    closeDelay: o = 300
  } = e, l = jy(t), u = D.useRef(0), c = D.useRef(0), d = D.useRef(!1), p = D.useRef(!1), [f = !1, h] = Bs({
    prop: n,
    defaultProp: a,
    onChange: s
  }), m = D.useCallback(() => {
    clearTimeout(c.current), u.current = window.setTimeout(() => h(!0), i);
  }, [i, h]), y = D.useCallback(() => {
    clearTimeout(u.current), !d.current && !p.current && (c.current = window.setTimeout(() => h(!1), o));
  }, [o, h]), b = D.useCallback(() => h(!1), [h]);
  return D.useEffect(() => () => {
    clearTimeout(u.current), clearTimeout(c.current);
  }, []), /* @__PURE__ */ K(
    lze,
    {
      scope: t,
      open: f,
      onOpenChange: h,
      onOpen: m,
      onClose: y,
      onDismiss: b,
      hasSelectionRef: d,
      isPointerDownOnContentRef: p,
      children: /* @__PURE__ */ K(gh, { ...l, children: r })
    }
  );
};
VQ.displayName = k2;
var GQ = "HoverCardTrigger", WQ = D.forwardRef(
  (e, t) => {
    const { __scopeHoverCard: r, ...n } = e, a = C2(GQ, r), s = jy(r);
    return /* @__PURE__ */ K(bh, { asChild: !0, ...s, children: /* @__PURE__ */ K(
      Wr.a,
      {
        "data-state": a.open ? "open" : "closed",
        ...n,
        ref: t,
        onPointerEnter: nr(e.onPointerEnter, Eb(a.onOpen)),
        onPointerLeave: nr(e.onPointerLeave, Eb(a.onClose)),
        onFocus: nr(e.onFocus, a.onOpen),
        onBlur: nr(e.onBlur, a.onClose),
        onTouchStart: nr(e.onTouchStart, (i) => i.preventDefault())
      }
    ) });
  }
);
WQ.displayName = GQ;
var uze = "HoverCardPortal", [gqe, cze] = HQ(uze, {
  forceMount: void 0
}), xb = "HoverCardContent", A2 = D.forwardRef(
  (e, t) => {
    const r = cze(xb, e.__scopeHoverCard), { forceMount: n = r.forceMount, ...a } = e, s = C2(xb, e.__scopeHoverCard);
    return /* @__PURE__ */ K(Ra, { present: n || s.open, children: /* @__PURE__ */ K(
      dze,
      {
        "data-state": s.open ? "open" : "closed",
        ...a,
        onPointerEnter: nr(e.onPointerEnter, Eb(s.onOpen)),
        onPointerLeave: nr(e.onPointerLeave, Eb(s.onClose)),
        ref: t
      }
    ) });
  }
);
A2.displayName = xb;
var dze = D.forwardRef((e, t) => {
  const {
    __scopeHoverCard: r,
    onEscapeKeyDown: n,
    onPointerDownOutside: a,
    onFocusOutside: s,
    onInteractOutside: i,
    ...o
  } = e, l = C2(xb, r), u = jy(r), c = D.useRef(null), d = sn(t, c), [p, f] = D.useState(!1);
  return D.useEffect(() => {
    if (p) {
      const h = document.body;
      return TT = h.style.userSelect || h.style.webkitUserSelect, h.style.userSelect = "none", h.style.webkitUserSelect = "none", () => {
        h.style.userSelect = TT, h.style.webkitUserSelect = TT;
      };
    }
  }, [p]), D.useEffect(() => {
    if (c.current) {
      const h = () => {
        f(!1), l.isPointerDownOnContentRef.current = !1, setTimeout(() => {
          document.getSelection()?.toString() !== "" && (l.hasSelectionRef.current = !0);
        });
      };
      return document.addEventListener("pointerup", h), () => {
        document.removeEventListener("pointerup", h), l.hasSelectionRef.current = !1, l.isPointerDownOnContentRef.current = !1;
      };
    }
  }, [l.isPointerDownOnContentRef, l.hasSelectionRef]), D.useEffect(() => {
    c.current && hze(c.current).forEach((m) => m.setAttribute("tabindex", "-1"));
  }), /* @__PURE__ */ K(
    qQ,
    {
      asChild: !0,
      disableOutsidePointerEvents: !1,
      onInteractOutside: i,
      onEscapeKeyDown: n,
      onPointerDownOutside: a,
      onFocusOutside: nr(s, (h) => {
        h.preventDefault();
      }),
      onDismiss: l.onDismiss,
      children: /* @__PURE__ */ K(
        Kb,
        {
          ...u,
          ...o,
          onPointerDown: nr(o.onPointerDown, (h) => {
            h.currentTarget.contains(h.target) && f(!0), l.hasSelectionRef.current = !1, l.isPointerDownOnContentRef.current = !0;
          }),
          ref: d,
          style: {
            ...o.style,
            userSelect: p ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: p ? "text" : void 0,
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      )
    }
  );
}), fze = "HoverCardArrow", pze = D.forwardRef(
  (e, t) => {
    const { __scopeHoverCard: r, ...n } = e, a = jy(r);
    return /* @__PURE__ */ K(Yb, { ...a, ...n, ref: t });
  }
);
pze.displayName = fze;
function Eb(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function hze(e) {
  const t = [], r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; r.nextNode(); ) t.push(r.currentNode);
  return t;
}
var mze = VQ, gze = WQ, KQ = A2;
const bze = mze, yze = gze, vze = D.forwardRef(({ className: e, align: t = "center", sideOffset: r = 4, ...n }, a) => /* @__PURE__ */ K(
  KQ,
  {
    ref: a,
    align: t,
    sideOffset: r,
    className: ja(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...n
  }
));
vze.displayName = KQ.displayName;
const bqe = ({ toc: e, className: t }) => e ? /* @__PURE__ */ $t(ln, { children: [
  /* @__PURE__ */ K("div", { className: ja("toc text-sm w-full hidden lg:block", t), children: /* @__PURE__ */ K("div", { className: "grid gird-cols-1 gap-2.5 w-full", children: e.map((r) => /* @__PURE__ */ K("a", { className: "x-underline", href: `#${r.id}`, children: /* @__PURE__ */ K(
    "div",
    {
      className: "text-zinc-400 hover:text-zinc-900 cursor-pointer font-normal decoration-zinc-400 decoration-0 line-clamp-2",
      children: /* @__PURE__ */ K("span", { className: "", children: r.value })
    },
    r.id
  ) })) }) }),
  /* @__PURE__ */ K("div", { className: ja("toc text-sm w-full lg:hidden", t), children: /* @__PURE__ */ $t(bze, { openDelay: 300, children: [
    /* @__PURE__ */ K(yze, { asChild: !0, children: /* @__PURE__ */ K(ca, { variant: "ghost", children: /* @__PURE__ */ K(Sue, {}) }) }),
    /* @__PURE__ */ K(A2, { className: "w-[16rem]", children: /* @__PURE__ */ K(zu, { children: /* @__PURE__ */ K("div", { className: "grid gird-cols-1 gap-2.5 w-full", children: e.map((r) => /* @__PURE__ */ K("a", { className: "x-underline", href: `#${r.id}`, children: /* @__PURE__ */ K(
      "div",
      {
        className: "text-zinc-400 hover:text-zinc-900 cursor-pointer font-normal decoration-zinc-400 decoration-0 line-clamp-2",
        children: r.value
      },
      r.id
    ) })) }) }) })
  ] }) })
] }) : null, yqe = () => {
  const [, e] = nee((t) => t + 1, 0);
  Qn(() => {
    const t = (r) => {
      r.data === "morph-refresh" && e();
    };
    return window.addEventListener("message", t), () => {
      window.removeEventListener("message", t);
    };
  }, []);
};
export {
  th as $,
  pqe as A,
  ca as B,
  $se as C,
  Ize as D,
  Nze as E,
  rge as F,
  que as G,
  ege as H,
  Qze as I,
  tge as J,
  WUe as K,
  e6e as L,
  Dze as M,
  XUe as N,
  eze as O,
  dqe as P,
  JUe as Q,
  QUe as R,
  tqe as S,
  Vne as T,
  KUe as U,
  YUe as V,
  GUe as W,
  ZUe as X,
  hqe as Y,
  bqe as Z,
  HK as _,
  Oc as a,
  kze as a0,
  Cze as a1,
  Aze as a2,
  Tze as a3,
  yqe as a4,
  pre as b,
  Oze as c,
  rqe as d,
  nqe as e,
  iqe as f,
  aqe as g,
  sqe as h,
  Cc as i,
  lqe as j,
  uqe as k,
  cqe as l,
  Hne as m,
  zu as n,
  kd as o,
  HUe as p,
  VUe as q,
  wN as r,
  Ga as s,
  xN as t,
  Zme as u,
  Yme as v,
  Jme as w,
  Kme as x,
  EN as y,
  Jf as z
};
